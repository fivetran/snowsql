[load_proto_files=zetasql/testdata/test_schema.proto]
[load_proto_names=zetasql_test__.KitchenSinkExtension,zetasql_test__.KitchenSinkPB]

[prepare_database]
CREATE TABLE BasicTable AS
SELECT cast(10 as int64) as primary_key,
       cast(11 as int64) as int64_value,
       cast([12, 13, 14] as ARRAY<INT64>) as array_value
UNION ALL
SELECT 20, 21, [22, 23, 24]
UNION ALL
SELECT 30, 31, NULL
--
ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[
  {
    10,
    11,
    ARRAY<INT64>[12, 13, 14]
  },
  {
    20,
    21,
    ARRAY<INT64>[22, 23, 24]
  },
  {30, 31, ARRAY<INT64>(NULL)}
]
==

# Use a new table in case some engines don't support array-valued primary keys.
#
# We must annotate this [prepare_database] statement with
# [required_features=V_1_2_GROUP_BY_ARRAY] in order to pass the compliace test
# framework's validation that the first column can be thought of as a primary
# key. As a result, the table will only be created for drivers that support
# V_1_2_GROUP_BY_ARRAY, and it will only be visible to tests that require
# that feature.
[prepare_database]
[required_features=V_1_2_GROUP_BY_ARRAY]
CREATE TABLE TableWithArrayKey AS
SELECT cast([1, 2] as ARRAY<INT64>) as primary_key,
       cast(100 as int64) as int64_value
UNION ALL
SELECT [1, 2, 3], 200
UNION ALL
SELECT [1, 2, 4], 300
UNION ALL
SELECT [1, 2, 3, 4], 400
--
ARRAY<STRUCT<primary_key ARRAY<>, int64_value INT64>>[
  {ARRAY<INT64>[1, 2], 100},
  {
    ARRAY<INT64>[1, 2, 3],
    200
  },
  {
    ARRAY<INT64>[1, 2, 4],
    300
  },
  {
    ARRAY<INT64>[1, 2, 3, 4],
    400
  }
]
==

# Use a new table because some engines don't support protos.
[prepare_database]
CREATE TABLE ProtoTable AS
SELECT cast(1 as int64) as primary_key,
       cast('''int64_key_1: 11
               int64_key_2: 12'''
            as "zetasql_test__.KitchenSinkPB") as proto_value
UNION ALL
SELECT 2,
  '''
  int64_key_1: 21
  int64_key_2: 22
  repeated_int64_val: 100
  repeated_int64_val: 101
  nested_repeated_value: <
    [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 200
  >
  nested_repeated_value: <
    [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 201
  >
  [zetasql_test__.KitchenSinkExtension.repeated_extension]: <value: 'value1'>
  [zetasql_test__.KitchenSinkExtension.repeated_extension]: <value: 'value2'>
  '''
--
ARRAY<STRUCT<
        primary_key INT64,
        proto_value PROTO<zetasql_test__.KitchenSinkPB>
      >>
[{1,
  {
    int64_key_1: 11
    int64_key_2: 12
  }},
 {2,
  {
    int64_key_1: 21
    int64_key_2: 22
    repeated_int64_val: 100
    repeated_int64_val: 101
    nested_repeated_value {
      [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 200
    }
    nested_repeated_value {
      [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 201
    }
    [zetasql_test__.KitchenSinkExtension.repeated_extension] {
      value: "value1"
    }
    [zetasql_test__.KitchenSinkExtension.repeated_extension] {
      value: "value2"
    }
  }}]
==

# Use a new table because some engines don't support structs.
[prepare_database]
CREATE TABLE ArrayOfStructsTable AS
SELECT cast(1 as int64) as primary_key,
       [ STRUCT(110 as int64_value, [1100, 1101] as array_value2),
         (120, [1200, 1201]) ] as array_value
UNION ALL
SELECT 2,
       [ STRUCT(210 as int64_value, [200, 201] as array_value2),
         (220, [2200, 2201]) ]
--
ARRAY<STRUCT<primary_key INT64, array_value ARRAY<>>>[
  {1,
   ARRAY<STRUCT<int64_value INT64, array_value2 ARRAY<>>>[
     {
       110,
       ARRAY<INT64>[1100, 1101]
     },
     {
       120,
       ARRAY<INT64>[1200, 1201]
     }
   ]},
  {2,
   ARRAY<STRUCT<int64_value INT64, array_value2 ARRAY<>>>[
     {
       210,
       ARRAY<INT64>[200, 201]
     },
     {
       220,
       ARRAY<INT64>[2200, 2201]
     }
   ]}
]
==

# Nested DELETE.
[name=delete_everything_from_every_non_null_row]
UPDATE BasicTable
SET (DELETE array_value WHERE True)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {10, 11, ARRAY<INT64>[]},
    {20, 21, ARRAY<INT64>[]},
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=delete_everything_from_one_row]
UPDATE BasicTable SET (DELETE array_value WHERE True) WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {10, 11, ARRAY<INT64>[]},
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=delete_everything_from_null_row]
UPDATE BasicTable SET (DELETE array_value WHERE True) WHERE array_value IS NULL
--
ERROR: generic::out_of_range: Cannot execute a nested DELETE statement on a NULL array value
==

[name=delete_everything_from_no_rows]
UPDATE BasicTable SET (DELETE array_value WHERE True) WHERE False
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  0,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=delete_nothing_from_all_non_null_rows]
UPDATE BasicTable
SET (DELETE array_value WHERE False)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=delete_nothing_from_null_row]
UPDATE BasicTable SET (DELETE array_value WHERE False) WHERE array_value IS NULL
--
ERROR: generic::out_of_range: Cannot execute a nested DELETE statement on a NULL array value
==

[name=delete_one_value]
UPDATE BasicTable SET (DELETE array_value WHERE array_value = 13)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# Same as above, but with another column in the table.
[name=delete_using_other_column]
[required_features=V_1_2_CORRELATED_REFS_IN_NESTED_DML]
UPDATE BasicTable SET
  (DELETE array_value WHERE array_value = primary_key + 3)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# Same as above, but with parameters.
[name=delete_params]
[parameters=13 param1, 10 param2]
UPDATE BasicTable SET (DELETE array_value WHERE array_value = @param1)
WHERE primary_key = @param2
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=delete_with_offset]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET]
UPDATE BasicTable SET
  (DELETE array_value WITH OFFSET WHERE offset = 1)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=delete_with_nontrivial_offset]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET,V_1_2_CORRELATED_REFS_IN_NESTED_DML]
UPDATE BasicTable SET
  (DELETE array_value WITH OFFSET WHERE offset = (primary_key / 10) - 1)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=delete_with_null_offset]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET]
UPDATE BasicTable SET
  (DELETE array_value WITH OFFSET WHERE offset IS NULL)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=delete_with_out_of_range_offsets]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET]
UPDATE BasicTable SET
  (DELETE array_value WITH OFFSET WHERE offset < 0 OR offset > 1000)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=delete_from_primary_key]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY]
[forbidden_features=DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (DELETE primary_key WHERE primary_key = 1 ASSERT_ROWS_MODIFIED 1)
WHERE True
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{4,
  ARRAY<STRUCT<primary_key ARRAY<>, int64_value INT64>>[unknown order:
    {ARRAY<INT64>[2], 100},
    {
      ARRAY<INT64>[known order:2, 3],
      200
    },
    {
      ARRAY<INT64>[known order:2, 4],
      300
    },
    {
      ARRAY<INT64>[known order:2, 3, 4],
      400
    }
  ]}
==

[name=delete_from_primary_key_no_pk_updates]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY,DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (DELETE primary_key WHERE primary_key = 1 ASSERT_ROWS_MODIFIED 1)
WHERE True
--
ERROR: generic::out_of_range: Cannot modify a primary key column with UPDATE
==

[name=delete_causes_primary_key_collision]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY]
[forbidden_features=DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (DELETE primary_key WHERE primary_key = 4 ASSERT_ROWS_MODIFIED 1)
WHERE ARRAY_LENGTH(primary_key) = 4
--
ERROR: generic::out_of_range: Modification resulted in duplicate primary key ([1, 2, 3])
==

[name=delete_causes_primary_key_collision_no_pk_updates]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY,DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (DELETE primary_key WHERE primary_key = 4 ASSERT_ROWS_MODIFIED 1)
WHERE ARRAY_LENGTH(primary_key) = 4
--
ERROR: generic::out_of_range: Cannot modify a primary key column with UPDATE
==

[name=nested_delete_assert_rows_modified]
UPDATE BasicTable SET
  (DELETE array_value WHERE array_value <= 13 ASSERT_ROWS_MODIFIED 2)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {10, 11, ARRAY<INT64>[14]},
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=nested_delete_assert_rows_modified_with_outer]
UPDATE BasicTable SET
  (DELETE array_value WHERE array_value <= 13 ASSERT_ROWS_MODIFIED 2)
WHERE primary_key = 10
ASSERT_ROWS_MODIFIED 1
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {10, 11, ARRAY<INT64>[14]},
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=nested_no_op_delete_assert_rows_modified_with_outer]
UPDATE BasicTable SET
  (DELETE array_value WHERE array_value < 0 ASSERT_ROWS_MODIFIED 0)
WHERE primary_key = 10
ASSERT_ROWS_MODIFIED 1
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=nested_delete_assert_rows_modified_failure]
UPDATE BasicTable SET
  (DELETE array_value WHERE True ASSERT_ROWS_MODIFIED 0)
WHERE True
--
ERROR: generic::out_of_range: ASSERT_ROWS_MODIFIED expected 0 array elements modified, but found 3
==

[name=nested_delete_assert_with_null]
[parameters=NULL param]
UPDATE BasicTable SET
  (DELETE array_value WHERE True ASSERT_ROWS_MODIFIED @param)
WHERE True
--
ERROR: generic::out_of_range: ASSERT_ROWS_MODIFIED must have a non-NULL argument
==

[name=nested_delete_assert_with_negative]
[parameters=-1 param]
UPDATE BasicTable SET
  (DELETE array_value WHERE True ASSERT_ROWS_MODIFIED @param)
WHERE True
--
ERROR: generic::out_of_range: ASSERT_ROWS_MODIFIED expected -1 array elements modified, but found 3
==

# Just one simple test that nested deletes also work on repeated proto fields.
[name=nested_delete_repeated_proto_field]
UPDATE ProtoTable SET
  (DELETE proto_value.repeated_int64_val
   WHERE repeated_int64_val = 100)
WHERE True
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{2,
  ARRAY<STRUCT<
          primary_key INT64,
          proto_value PROTO<zetasql_test__.KitchenSinkPB>
        >>
  [unknown order:
    {1,
     {
       int64_key_1: 11
       int64_key_2: 12
     }},
    {2,
     {
       int64_key_1: 21
       int64_key_2: 22
       repeated_int64_val: 101
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 200
       }
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 201
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "value1"
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "value2"
       }
     }}
  ]}
==

# Same as above, but with an extension field.
[name=nested_delete_repeated_extension_proto_field]
[required_features=V_1_2_PROTO_EXTENSIONS_WITH_SET]
UPDATE ProtoTable SET
  (DELETE proto_value.(zetasql_test__.KitchenSinkExtension.repeated_extension) x
   WHERE x.value = "value1")
WHERE True
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{2,
  ARRAY<STRUCT<
          primary_key INT64,
          proto_value PROTO<zetasql_test__.KitchenSinkPB>
        >>
  [unknown order:
    {1,
     {
       int64_key_1: 11
       int64_key_2: 12
     }},
    {2,
     {
       int64_key_1: 21
       int64_key_2: 22
       repeated_int64_val: 100
       repeated_int64_val: 101
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 200
       }
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 201
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "value2"
       }
     }}
  ]}
==

[name=two_nested_deletes]
UPDATE BasicTable SET
  (DELETE array_value WHERE array_value = 12 ASSERT_ROWS_MODIFIED 1),
  (DELETE array_value WHERE array_value = 14 ASSERT_ROWS_MODIFIED 1)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {10, 11, ARRAY<INT64>[13]},
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=two_overlapping_deletes]
UPDATE BasicTable SET
  (DELETE array_value WHERE array_value = 12 ASSERT_ROWS_MODIFIED 1),
  (DELETE array_value WHERE array_value = 12 ASSERT_ROWS_MODIFIED 0)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=deletes_with_different_offsets]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET]
UPDATE BasicTable SET
  (DELETE array_value WITH OFFSET WHERE offset = 0 ASSERT_ROWS_MODIFIED 1),
  (DELETE array_value WITH OFFSET WHERE offset = 2 ASSERT_ROWS_MODIFIED 1)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {10, 11, ARRAY<INT64>[13]},
    {20, 21, ARRAY<INT64>[23]},
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=deletes_with_same_offset_twice]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET]
UPDATE BasicTable SET
  (DELETE array_value WITH OFFSET WHERE offset = 0 ASSERT_ROWS_MODIFIED 1),
  (DELETE array_value WITH OFFSET WHERE offset = 0 ASSERT_ROWS_MODIFIED 0)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# Nested UPDATE.
[name=update_everything_in_every_non_null_row]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = array_value + 1 WHERE True)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:13, 14, 15]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:23, 24, 25]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=update_everything_from_one_row]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = array_value + 1 WHERE True)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:13, 14, 15]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=update_everything_from_one_null_row]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = array_value + 1 WHERE True)
WHERE array_value IS NULL
--
ERROR: generic::out_of_range: Cannot execute a nested UPDATE statement on a NULL array value
==

[name=update_everything_in_no_rows]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = array_value + 1 WHERE True)
WHERE False
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  0,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=update_nothing_in_all_non_null_rows]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = array_value + 1 WHERE False)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=update_nothing_in_null_row]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = array_value + 1 WHERE False)
WHERE array_value IS NULL
--
ERROR: generic::out_of_range: Cannot execute a nested UPDATE statement on a NULL array value
==

[name=update_one_value]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = 100 WHERE array_value = 12)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:100, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# Same as above, but with another column in the table.
[name=update_from_other_column]
[required_features=V_1_2_CORRELATED_REFS_IN_NESTED_DML]
UPDATE BasicTable SET
  (UPDATE array_value
   SET array_value = primary_key * 10
   WHERE array_value = primary_key + 3)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 100, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# Same as above, but with parameters.
[name=update_params]
[parameters=100 param1, 10 param2]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = @param1 WHERE array_value = 12)
WHERE primary_key = @param2
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:100, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=update_with_offset]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET]
UPDATE BasicTable SET
  (UPDATE array_value WITH OFFSET
   SET array_value = array_value + 1
   WHERE offset = 1)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 14, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 24, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=update_with_offset_using_offset]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET]
UPDATE BasicTable SET
  (UPDATE array_value WITH OFFSET
   SET array_value = array_value + offset
   WHERE offset = 1)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 14, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 24, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=update_with_nontrivial_offset]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET,V_1_2_CORRELATED_REFS_IN_NESTED_DML]
UPDATE BasicTable SET
  (UPDATE array_value WITH OFFSET
   SET array_value = array_value + 1
   WHERE offset = (primary_key / 10) - 1)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:13, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 24, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=update_with_null_offset]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET]
UPDATE BasicTable SET
  (UPDATE array_value WITH OFFSET
   SET array_value = array_value + 1
   WHERE offset IS NULL)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=update_with_out_of_range_offsets]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET]
UPDATE BasicTable SET
  (UPDATE array_value WITH OFFSET
   SET array_value = array_value + 1
   WHERE offset < 0 OR offset > 1000)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# An intermediate state has a primary key collision, but the spec says that is
# ok.
[name=update_primary_key]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY]
[forbidden_features=DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (UPDATE primary_key SET primary_key = 4 WHERE primary_key = 3),
  (UPDATE primary_key SET primary_key = 5 WHERE primary_key = 4)
WHERE True
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{4,
  ARRAY<STRUCT<primary_key ARRAY<>, int64_value INT64>>[unknown order:
    {
      ARRAY<INT64>[known order:1, 2],
      100
    },
    {
      ARRAY<INT64>[known order:1, 2, 4],
      200
    },
    {
      ARRAY<INT64>[known order:1, 2, 5],
      300
    },
    {
      ARRAY<INT64>[known order:1, 2, 4, 5],
      400
    }
  ]}
==

# An intermediate state has a primary key collision, but the spec says that is
# ok.
[name=update_primary_key_no_pk_updates]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY,DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (UPDATE primary_key SET primary_key = 4 WHERE primary_key = 3),
  (UPDATE primary_key SET primary_key = 5 WHERE primary_key = 4)
WHERE True
--
ERROR: generic::out_of_range: Cannot modify a primary key column with UPDATE
==

[name=update_causes_primary_key_collision]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY]
[forbidden_features=DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (UPDATE primary_key SET primary_key = 4 WHERE primary_key = 3)
WHERE int64_value = 200
--
ERROR: generic::out_of_range: Modification resulted in duplicate primary key ([1, 2, 4])
==

[name=update_causes_primary_key_collision_no_pk_updates]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY,DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (UPDATE primary_key SET primary_key = 4 WHERE primary_key = 3)
WHERE int64_value = 200
--
ERROR: generic::out_of_range: Cannot modify a primary key column with UPDATE
==

[name=nested_update_assert_rows_modified]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = 100 WHERE array_value <= 13
   ASSERT_ROWS_MODIFIED 2)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:100, 100, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=nested_update_assert_rows_modified_with_outer]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = 100 WHERE array_value <= 13
   ASSERT_ROWS_MODIFIED 2)
WHERE primary_key = 10
ASSERT_ROWS_MODIFIED 1
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:100, 100, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=nested_no_op_update_assert_rows_modified_with_outer]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = 10 WHERE array_value < 0
   ASSERT_ROWS_MODIFIED 0)
WHERE primary_key = 10
ASSERT_ROWS_MODIFIED 1
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=nested_update_assert_rows_modified_failure]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = 100 WHERE True ASSERT_ROWS_MODIFIED 0)
WHERE True
--
ERROR: generic::out_of_range: ASSERT_ROWS_MODIFIED expected 0 array elements modified, but found 3
==

[name=nested_update_assert_with_null]
[parameters=NULL param]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = 100 WHERE True
   ASSERT_ROWS_MODIFIED @param)
WHERE True
--
ERROR: generic::out_of_range: ASSERT_ROWS_MODIFIED must have a non-NULL argument
==

[name=nested_update_assert_with_negative]
[parameters=-1 param]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = 100 WHERE True
   ASSERT_ROWS_MODIFIED @param)
WHERE True
--
ERROR: generic::out_of_range: ASSERT_ROWS_MODIFIED expected -1 array elements modified, but found 3
==

# Just one simple test that nested updates also work on repeated proto fields.
[name=nested_update_repeated_proto_field]
UPDATE ProtoTable SET
  (UPDATE proto_value.repeated_int64_val
   SET repeated_int64_val = 500
   WHERE repeated_int64_val = 100)
WHERE True
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{2,
  ARRAY<STRUCT<
          primary_key INT64,
          proto_value PROTO<zetasql_test__.KitchenSinkPB>
        >>
  [unknown order:
    {1,
     {
       int64_key_1: 11
       int64_key_2: 12
     }},
    {2,
     {
       int64_key_1: 21
       int64_key_2: 22
       repeated_int64_val: 500
       repeated_int64_val: 101
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 200
       }
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 201
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "value1"
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "value2"
       }
     }}
  ]}
==

# Same as above, but with an extension field.
[name=nested_update_repeated_extension_proto_field]
[required_features=V_1_2_PROTO_EXTENSIONS_WITH_SET]
UPDATE ProtoTable SET
  (UPDATE proto_value.(zetasql_test__.KitchenSinkExtension.repeated_extension) x
   SET x = CAST('value: "new_value"' AS zetasql_test__.KitchenSinkExtension)
   WHERE x.value = "value1")
WHERE True
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{2,
  ARRAY<STRUCT<
          primary_key INT64,
          proto_value PROTO<zetasql_test__.KitchenSinkPB>
        >>
  [unknown order:
    {1,
     {
       int64_key_1: 11
       int64_key_2: 12
     }},
    {2,
     {
       int64_key_1: 21
       int64_key_2: 22
       repeated_int64_val: 100
       repeated_int64_val: 101
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 200
       }
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 201
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "new_value"
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "value2"
       }
     }}
  ]}
==

[name=nested_update_extension_subfield_of_repeated_proto_field]
[required_features=V_1_2_PROTO_EXTENSIONS_WITH_SET]
UPDATE ProtoTable SET
  (UPDATE proto_value.nested_repeated_value
   SET nested_repeated_value.
         (zetasql_test__.KitchenSinkPB.nested_extension_int64) = 1000
   WHERE nested_repeated_value.
           (zetasql_test__.KitchenSinkPB.nested_extension_int64) = 200)
WHERE True
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{2,
  ARRAY<STRUCT<
          primary_key INT64,
          proto_value PROTO<zetasql_test__.KitchenSinkPB>
        >>
  [unknown order:
    {1,
     {
       int64_key_1: 11
       int64_key_2: 12
     }},
    {2,
     {
       int64_key_1: 21
       int64_key_2: 22
       repeated_int64_val: 100
       repeated_int64_val: 101
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 1000
       }
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 201
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "value1"
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "value2"
       }
     }}
  ]}
==

[name=nested_update_containing_array_element_set]
[required_features=V_1_2_ARRAY_ELEMENTS_WITH_SET]
UPDATE ArrayOfStructsTable SET
  (UPDATE array_value
   SET array_value.array_value2[OFFSET(0)] = 10000
   WHERE True)
WHERE True
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{2,
  ARRAY<STRUCT<primary_key INT64, array_value ARRAY<>>>[unknown order:
    {1,
     ARRAY<STRUCT<int64_value INT64, array_value2 ARRAY<>>>[known order:
       {
         110,
         ARRAY<INT64>[known order:10000, 1101]
       },
       {
         120,
         ARRAY<INT64>[known order:10000, 1201]
       }
     ]},
    {2,
     ARRAY<STRUCT<int64_value INT64, array_value2 ARRAY<>>>[known order:
       {
         210,
         ARRAY<INT64>[known order:10000, 201]
       },
       {
         220,
         ARRAY<INT64>[known order:10000, 2201]
       }
     ]}
  ]}
==

[name=two_nested_updates]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = 100 WHERE array_value = 12
   ASSERT_ROWS_MODIFIED 1),
  (UPDATE array_value SET array_value = 200 WHERE array_value = 13
   ASSERT_ROWS_MODIFIED 1)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:100, 200, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=two_overlapping_updates]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = 1 WHERE array_value = 12
   ASSERT_ROWS_MODIFIED 1),
  (UPDATE array_value SET array_value = 1 WHERE array_value = 12
   ASSERT_ROWS_MODIFIED 1)
WHERE primary_key = 10
--
ERROR: generic::out_of_range: Attempted to modify an array element with multiple nested UPDATE statements
==

# Tests that the WHERE clause of a nested UPDATE sees the unmodified row.
[name=two_nested_updates_no_interference]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = 100 WHERE array_value = 12
   ASSERT_ROWS_MODIFIED 1),
  (UPDATE array_value SET array_value = 200 WHERE array_value = 100
   ASSERT_ROWS_MODIFIED 0)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:100, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=updates_with_different_offsets]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET]
UPDATE BasicTable SET
  (UPDATE array_value WITH OFFSET
   SET array_value = 500
   WHERE offset = 0
   ASSERT_ROWS_MODIFIED 1),
  (UPDATE array_value WITH OFFSET
   SET array_value = 501
   WHERE offset = 2
   ASSERT_ROWS_MODIFIED 1)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:500, 13, 501]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:500, 23, 501]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=updates_with_same_offset_twice]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET]
UPDATE BasicTable SET
  (UPDATE array_value WITH OFFSET
   SET array_value = 500
   WHERE offset = 0),
  (UPDATE array_value WITH OFFSET
   SET array_value = 501
   WHERE offset = 0)
WHERE array_value IS NOT NULL
--
ERROR: generic::out_of_range: Attempted to modify an array element with multiple nested UPDATE statements
==

# Nested INSERT.
[name=insert_into_every_non_null_row]
UPDATE BasicTable SET (INSERT array_value VALUES (100), (200), (300))
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 100, 200, 300]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24, 100, 200, 300]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=insert_into_no_rows]
UPDATE BasicTable SET (INSERT array_value VALUES (100), (200), (300))
WHERE False
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  0,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=insert_into_one_row]
UPDATE BasicTable SET (INSERT array_value VALUES (100), (200), (300))
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 100, 200, 300]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=insert_into_null_row]
UPDATE BasicTable SET (INSERT array_value VALUES (100), (200), (300))
WHERE array_value IS NULL
--
ERROR: generic::out_of_range: Cannot execute a nested INSERT statement on a NULL array value
==

# Note that by default, no columns are visible inside VALUES.
[name=insert_value_with_nontrivial_expression]
UPDATE BasicTable SET
  (INSERT array_value VALUES
    (100),
    ((SELECT primary_key * 20 FROM BasicTable WHERE primary_key = 10)),
    (300))
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 100, 200, 300]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# Same as above, but with another column in the table.
[name=insert_using_other_column]
[required_features=V_1_2_CORRELATED_REFS_IN_NESTED_DML]
UPDATE BasicTable T SET
  (INSERT array_value VALUES
    (100),
    ((SELECT primary_key * 20
      FROM BasicTable
      WHERE primary_key = T.primary_key)),
    (primary_key))
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 100, 200, 10]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# Same as above, but with query parameters.
[name=insert_params]
[parameters=100 param1, 10 param2]
UPDATE BasicTable SET
  (INSERT array_value VALUES
    (@param1),
    ((SELECT primary_key * 20 FROM BasicTable WHERE primary_key = 10)),
    (300))
WHERE primary_key = @param2
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 100, 200, 300]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# An intermediate state has a primary key collision, but the spec says that is
# ok.
[name=insert_into_primary_key]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY]
[forbidden_features=DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (INSERT primary_key VALUES (4))
WHERE True
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{4,
  ARRAY<STRUCT<primary_key ARRAY<>, int64_value INT64>>[unknown order:
    {
      ARRAY<INT64>[known order:1, 2, 4],
      100
    },
    {
      ARRAY<INT64>[known order:1, 2, 3, 4],
      200
    },
    {
      ARRAY<INT64>[known order:1, 2, 4, 4],
      300
    },
    {
      ARRAY<INT64>[known order:1, 2, 3, 4, 4],
      400
    }
  ]}
==

# An intermediate state has a primary key collision, but the spec says that is
# ok.
[name=insert_into_primary_key_no_pk_updates]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY,DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (INSERT primary_key VALUES (4))
WHERE True
--
ERROR: generic::out_of_range: Cannot modify a primary key column with UPDATE
==

[name=insert_causes_primary_key_collision]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY]
[forbidden_features=DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (INSERT primary_key VALUES (4))
WHERE ARRAY_LENGTH(primary_key) = 3
--
ERROR: generic::out_of_range: Modification resulted in duplicate primary key ([1, 2, 3, 4])
==

[name=insert_causes_primary_key_collision_no_pk_updates]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY,DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (INSERT primary_key VALUES (4))
WHERE ARRAY_LENGTH(primary_key) = 3
--
ERROR: generic::out_of_range: Cannot modify a primary key column with UPDATE
==

[name=nested_insert_assert_rows_modified]
UPDATE BasicTable SET
  (INSERT array_value VALUES (100), (200) ASSERT_ROWS_MODIFIED 2)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 100, 200]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=nested_insert_assert_rows_modified_with_outer]
UPDATE BasicTable SET
  (INSERT array_value VALUES (100), (200) ASSERT_ROWS_MODIFIED 2)
WHERE primary_key = 10
ASSERT_ROWS_MODIFIED 1
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 100, 200]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=nested_insert_assert_rows_modified_with_null]
[parameters=NULL param]
UPDATE BasicTable SET
  (INSERT array_value VALUES (100), (200) ASSERT_ROWS_MODIFIED @param)
WHERE True
--
ERROR: generic::out_of_range: ASSERT_ROWS_MODIFIED must have a non-NULL argument
==

[name=nested_insert_assert_rows_modified_with_negative]
[parameters=-1 param]
UPDATE BasicTable SET
  (INSERT array_value VALUES (100), (200) ASSERT_ROWS_MODIFIED @param)
WHERE True
--
ERROR: generic::out_of_range: ASSERT_ROWS_MODIFIED expected -1 array elements modified, but found 2
==

[name=insert_query]
UPDATE BasicTable SET (INSERT array_value (SELECT 20)) WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 20]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24, 20]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# Test that a nested INSERT ... SELECT ... ORDERY BY honors the ORDER BY.
#
# The query is designed so that an engine that ignores the ORDER BY is unlikely
# to accidentally choose the correct order.
[name=insert_query_multiple_rows]
UPDATE BasicTable SET
  (INSERT array_value
    (SELECT value FROM UNNEST([200, 100, 300]) value ORDER BY value))
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 100, 200, 300]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24, 100, 200, 300]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=insert_query_using_other_column]
[required_features=V_1_2_CORRELATED_REFS_IN_NESTED_DML]
UPDATE BasicTable T SET
  (INSERT array_value SELECT int64_value)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 11]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=insert_query_using_same_array_column]
[required_features=V_1_2_CORRELATED_REFS_IN_NESTED_DML]
UPDATE BasicTable T SET
  (INSERT array_value SELECT * FROM T.array_value)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 12, 13, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=insert_query_using_nested_reference]
[required_features=V_1_2_CORRELATED_REFS_IN_NESTED_DML]
UPDATE ArrayOfStructsTable T SET
  (UPDATE array_value x SET
     (INSERT array_value2 SELECT T.primary_key + x.int64_value)
   WHERE true)
WHERE primary_key = 1
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{1,
  ARRAY<STRUCT<primary_key INT64, array_value ARRAY<>>>[unknown order:
    {1,
     ARRAY<STRUCT<int64_value INT64, array_value2 ARRAY<>>>[known order:
       {
         110,
         ARRAY<INT64>[known order:1100, 1101, 111]
       },
       {
         120,
         ARRAY<INT64>[known order:1200, 1201, 121]
       }
     ]},
    {2,
     ARRAY<STRUCT<int64_value INT64, array_value2 ARRAY<>>>[known order:
       {
         210,
         ARRAY<INT64>[known order:200, 201]
       },
       {
         220,
         ARRAY<INT64>[known order:2200, 2201]
       }
     ]}
  ]}
==

[name=insert_query_causes_primary_key_collision]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY]
[forbidden_features=DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (INSERT primary_key (SELECT 4))
WHERE ARRAY_LENGTH(primary_key) = 3
--
ERROR: generic::out_of_range: Modification resulted in duplicate primary key ([1, 2, 3, 4])
==

[name=insert_query_causes_primary_key_collision_no_pk_updates]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY,DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (INSERT primary_key (SELECT 4))
WHERE ARRAY_LENGTH(primary_key) = 3
--
ERROR: generic::out_of_range: Cannot modify a primary key column with UPDATE
==

[name=nested_insert_query_assert_rows_modified]
UPDATE BasicTable SET
  (INSERT array_value (SELECT 100) ASSERT_ROWS_MODIFIED 1)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 100]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=nested_insert_query_assert_rows_modified_with_outer]
UPDATE BasicTable SET
  (INSERT array_value (SELECT 100) ASSERT_ROWS_MODIFIED 1)
WHERE array_value IS NOT NULL
ASSERT_ROWS_MODIFIED 2
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 100]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24, 100]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

[name=nested_insert_query_assert_rows_modified_with_null]
[parameters=NULL param]
UPDATE BasicTable SET
  (INSERT array_value (SELECT 100) ASSERT_ROWS_MODIFIED @param)
WHERE True
--
ERROR: generic::out_of_range: ASSERT_ROWS_MODIFIED must have a non-NULL argument
==

[name=nested_insert_query_assert_rows_modified_with_negative]
[parameters=-1 param]
UPDATE BasicTable SET
  (INSERT array_value (SELECT 100) ASSERT_ROWS_MODIFIED @param)
WHERE True
--
ERROR: generic::out_of_range: ASSERT_ROWS_MODIFIED expected -1 array elements modified, but found 1
==

# Just one simple test that nested inserts also work on repeated proto fields.
[name=nested_insert_repeated_proto_field]
UPDATE ProtoTable SET
  (INSERT proto_value.repeated_int64_val VALUES (500), (600), (700))
WHERE True
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{2,
  ARRAY<STRUCT<
          primary_key INT64,
          proto_value PROTO<zetasql_test__.KitchenSinkPB>
        >>
  [unknown order:
    {1,
     {
       int64_key_1: 11
       int64_key_2: 12
       repeated_int64_val: 500
       repeated_int64_val: 600
       repeated_int64_val: 700
     }},
    {2,
     {
       int64_key_1: 21
       int64_key_2: 22
       repeated_int64_val: 100
       repeated_int64_val: 101
       repeated_int64_val: 500
       repeated_int64_val: 600
       repeated_int64_val: 700
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 200
       }
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 201
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "value1"
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "value2"
       }
     }}
  ]}
==

# Same as above, but with an extension field.
[name=nested_insert_repeated_extension_proto_field]
[required_features=V_1_2_PROTO_EXTENSIONS_WITH_SET]
UPDATE ProtoTable SET
  (INSERT proto_value.(zetasql_test__.KitchenSinkExtension.repeated_extension)
   VALUES (CAST('value: "new_value1"' AS zetasql_test__.KitchenSinkExtension)),
          (CAST('value: "new_value2"' AS zetasql_test__.KitchenSinkExtension)),
          (CAST('value: "new_value3"' AS zetasql_test__.KitchenSinkExtension)))
WHERE True
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{2,
  ARRAY<STRUCT<
          primary_key INT64,
          proto_value PROTO<zetasql_test__.KitchenSinkPB>
        >>
  [unknown order:
    {1,
     {
       int64_key_1: 11
       int64_key_2: 12
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "new_value1"
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "new_value2"
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "new_value3"
       }
     }},
    {2,
     {
       int64_key_1: 21
       int64_key_2: 22
       repeated_int64_val: 100
       repeated_int64_val: 101
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 200
       }
       nested_repeated_value {
         [zetasql_test__.KitchenSinkPB.nested_extension_int64]: 201
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "value1"
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "value2"
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "new_value1"
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "new_value2"
       }
       [zetasql_test__.KitchenSinkExtension.repeated_extension] {
         value: "new_value3"
       }
     }}
  ]}
==

[name=two_nested_inserts]
UPDATE BasicTable SET
  (INSERT array_value VALUES (100) ASSERT_ROWS_MODIFIED 1),
  (INSERT array_value VALUES (100), (200), (300) ASSERT_ROWS_MODIFIED 3)
WHERE array_value IS NOT NULL
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  2,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:12, 13, 14, 100, 100, 200, 300]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24, 100, 100, 200, 300]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# Test mixing nested DELETE and UPDATE. The deleted element matches the WHERE
# clause for the UPDATE, but the UPDATE doesn't see it.
[name=nested_delete_and_update]
UPDATE BasicTable SET
  (DELETE array_value WHERE array_value = 12 ASSERT_ROWS_MODIFIED 1),
  (UPDATE array_value SET array_value = 100 WHERE array_value <= 13
   ASSERT_ROWS_MODIFIED 1)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:100, 14]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# The offset for the nested UPDATE is relative to the original array (before the
# nested DELETE).
[name=nested_delete_and_update_with_offset]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET]
UPDATE BasicTable SET
  (DELETE array_value WITH OFFSET
   WHERE offset = 0
   ASSERT_ROWS_MODIFIED 1),
  (UPDATE array_value WITH OFFSET
   SET array_value = 100
   WHERE offset = 1
   ASSERT_ROWS_MODIFIED 1),
  (INSERT array_value VALUES (1000))
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:100, 14, 1000]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# The offset for the nested UPDATE is relative to the original array (before the
# nested DELETE). It is not an error if the WHERE clause for the nested
# UPDATE matches an element that has already been deleted, and in that case
# the nested UPDATE does not count as an element modification.
[name=nested_delete_and_update_with_same_offset_twice]
[required_features=V_1_2_NESTED_UPDATE_DELETE_WITH_OFFSET]
UPDATE BasicTable SET
  (DELETE array_value WITH OFFSET
   WHERE offset = 0
   ASSERT_ROWS_MODIFIED 1),
  (UPDATE array_value WITH OFFSET
   SET array_value = 100
   WHERE offset = 0
   ASSERT_ROWS_MODIFIED 0),
  (INSERT array_value VALUES (1000))
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:13, 14, 1000]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# An intermediate state has a primary key collision, but the spec says that is
# ok.
[name=nested_delete_and_update_intermediate_primary_key_collision]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY]
[forbidden_features=DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (DELETE primary_key WHERE primary_key = 4 ASSERT_ROWS_MODIFIED 1),
  (UPDATE primary_key SET primary_key = 5 WHERE primary_key = 3
   ASSERT_ROWS_MODIFIED 1)
WHERE ARRAY_LENGTH(primary_key) = 4
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{1,
  ARRAY<STRUCT<primary_key ARRAY<>, int64_value INT64>>[unknown order:
    {
      ARRAY<INT64>[known order:1, 2],
      100
    },
    {
      ARRAY<INT64>[known order:1, 2, 3],
      200
    },
    {
      ARRAY<INT64>[known order:1, 2, 4],
      300
    },
    {
      ARRAY<INT64>[known order:1, 2, 5],
      400
    }
  ]}
==

# An intermediate state has a primary key collision, but the spec says that is
# ok.
[name=nested_delete_and_update_intermediate_primary_key_collision_no_pk_updates]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY,DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (DELETE primary_key WHERE primary_key = 4 ASSERT_ROWS_MODIFIED 1),
  (UPDATE primary_key SET primary_key = 5 WHERE primary_key = 3
   ASSERT_ROWS_MODIFIED 1)
WHERE ARRAY_LENGTH(primary_key) = 4
--
ERROR: generic::out_of_range: Cannot modify a primary key column with UPDATE
==

# Test mixing nested DELETE and INSERT.
[name=nested_delete_and_insert]
UPDATE BasicTable SET
  (DELETE array_value WHERE array_value IN (12, 14) ASSERT_ROWS_MODIFIED 2),
  (INSERT array_value VALUES (12), (14), (15) ASSERT_ROWS_MODIFIED 3)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:13, 12, 14, 15]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# An intermediate state has a primary key collision, but the spec says that is
# ok.
[name=nested_delete_and_insert_intermediate_primary_key_collision]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY]
[forbidden_features=DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (DELETE primary_key WHERE primary_key = 4 ASSERT_ROWS_MODIFIED 1),
  (INSERT primary_key VALUES (4) ASSERT_ROWS_MODIFIED 1)
WHERE ARRAY_LENGTH(primary_key) = 4
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{1,
  ARRAY<STRUCT<primary_key ARRAY<>, int64_value INT64>>[unknown order:
    {
      ARRAY<INT64>[known order:1, 2],
      100
    },
    {
      ARRAY<INT64>[known order:1, 2, 3],
      200
    },
    {
      ARRAY<INT64>[known order:1, 2, 4],
      300
    },
    {
      ARRAY<INT64>[known order:1, 2, 3, 4],
      400
    }
  ]}
==

# An intermediate state has a primary key collision, but the spec says that is
# ok.
[name=nested_delete_and_insert_intermediate_primary_key_collision_no_pk_updates]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY,DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (DELETE primary_key WHERE primary_key = 4 ASSERT_ROWS_MODIFIED 1),
  (INSERT primary_key VALUES (4) ASSERT_ROWS_MODIFIED 1)
WHERE ARRAY_LENGTH(primary_key) = 4
--
ERROR: generic::out_of_range: Cannot modify a primary key column with UPDATE
==

# Test mixing nested UPDATE and INSERT.
[name=nested_update_and_insert]
UPDATE BasicTable SET
  (UPDATE array_value SET array_value = 100 WHERE array_value <= 13
   ASSERT_ROWS_MODIFIED 2),
  (INSERT array_value VALUES (12), (13) ASSERT_ROWS_MODIFIED 2)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:100, 100, 14, 12, 13]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
==

# An intermediate state has a primary key collision, but the spec says that is
# ok.
[name=nested_update_and_insert_intermediate_primary_key_collision]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY]
[forbidden_features=DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (UPDATE primary_key SET primary_key = 3 WHERE primary_key = 4
   ASSERT_ROWS_MODIFIED 1),
  (INSERT primary_key VALUES (5) ASSERT_ROWS_MODIFIED 1)
WHERE int64_value = 300
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{1,
  ARRAY<STRUCT<primary_key ARRAY<>, int64_value INT64>>[unknown order:
    {
      ARRAY<INT64>[known order:1, 2],
      100
    },
    {
      ARRAY<INT64>[known order:1, 2, 3],
      200
    },
    {
      ARRAY<INT64>[known order:1, 2, 3, 5],
      300
    },
    {
      ARRAY<INT64>[known order:1, 2, 3, 4],
      400
    }
  ]}
==

# An intermediate state has a primary key collision, but the spec says that is
# ok.
[name=nested_update_and_insert_intermediate_primary_key_collision_no_pk_updates]
[primary_key_mode=first_column_is_primary_key]
[required_features=V_1_2_GROUP_BY_ARRAY,DISALLOW_PRIMARY_KEY_UPDATES]
UPDATE TableWithArrayKey SET
  (UPDATE primary_key SET primary_key = 3 WHERE primary_key = 4
   ASSERT_ROWS_MODIFIED 1),
  (INSERT primary_key VALUES (5) ASSERT_ROWS_MODIFIED 1)
WHERE int64_value = 300
--
ERROR: generic::out_of_range: Cannot modify a primary key column with UPDATE
==

# Test mixing nested DELETE, UPDATE, and INSERT.
[name=nested_deleted_update_insert]
UPDATE BasicTable SET
  (DELETE array_value WHERE array_value = 12 ASSERT_ROWS_MODIFIED 1),
  (UPDATE array_value SET array_value = 100 WHERE array_value <= 13
   ASSERT_ROWS_MODIFIED 1),
  (INSERT array_value VALUES (12), (13) ASSERT_ROWS_MODIFIED 2)
WHERE primary_key = 10
--
STRUCT<
  num_rows_modified INT64,
  all_rows ARRAY<>
>{
  1,
  ARRAY<STRUCT<primary_key INT64, int64_value INT64, array_value ARRAY<>>>[unknown order:
    {
      10,
      11,
      ARRAY<INT64>[known order:100, 14, 12, 13]
    },
    {
      20,
      21,
      ARRAY<INT64>[known order:22, 23, 24]
    },
    {30, 31, ARRAY<INT64>(NULL)}
  ]
}
