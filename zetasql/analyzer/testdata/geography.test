[default also_show_signature_mismatch_details]
[default language_features=GEOGRAPHY]

select * from GeographyTable
--
QueryStmt
+-output_column_list=
| +-GeographyTable.key#1 AS key [INT64]
| +-GeographyTable.text#2 AS text [STRING]
| +-GeographyTable.geo1#3 AS geo1 [GEOGRAPHY]
| +-GeographyTable.geo2#4 AS geo2 [GEOGRAPHY]
+-query=
  +-ProjectScan
    +-column_list=GeographyTable.[key#1, text#2, geo1#3, geo2#4]
    +-input_scan=
      +-TableScan(column_list=GeographyTable.[key#1, text#2, geo1#3, geo2#4], table=GeographyTable, column_index_list=[0, 1, 2, 3])
==

# Auto-coercion int64->double
select st_geogpoint(double, int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS "$col1" [GEOGRAPHY]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-FunctionCall(ZetaSQL:st_geogpoint(DOUBLE, DOUBLE) -> GEOGRAPHY)
    |     +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
    |     +-Cast(INT64 -> DOUBLE)
    |       +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    +-input_scan=
      +-TableScan(column_list=SimpleTypes.[int64#2, double#9], table=SimpleTypes, column_index_list=[1, 8])
==

# Constructors
select
  st_geogpoint(1.2, 9e100),
  st_makeline(geo1, geo2),
  st_makeline(null, null),
  st_makeline([]),
  st_makeline([cast(null as geography)]),
  st_makeline([geo1, geo2, geo1]),
  st_makepolygon(geo1),
  st_makepolygon(geo1, [geo2]),
  st_makepolygonoriented([geo1, geo2])
from GeographyTable
--

QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [GEOGRAPHY]
| +-$query.$col2#6 AS "$col2" [GEOGRAPHY]
| +-$query.$col3#7 AS "$col3" [GEOGRAPHY]
| +-$query.$col4#8 AS "$col4" [GEOGRAPHY]
| +-$query.$col5#9 AS "$col5" [GEOGRAPHY]
| +-$query.$col6#10 AS "$col6" [GEOGRAPHY]
| +-$query.$col7#11 AS "$col7" [GEOGRAPHY]
| +-$query.$col8#12 AS "$col8" [GEOGRAPHY]
| +-$query.$col9#13 AS "$col9" [GEOGRAPHY]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8, $col5#9, $col6#10, $col7#11, $col8#12, $col9#13]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:st_geogpoint(DOUBLE, DOUBLE) -> GEOGRAPHY)
    | |   +-Literal(type=DOUBLE, value=1.2)
    | |   +-Literal(type=DOUBLE, value=9e+100)
    | +-$col2#6 :=
    | | +-FunctionCall(ZetaSQL:st_makeline(GEOGRAPHY, GEOGRAPHY) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col3#7 :=
    | | +-FunctionCall(ZetaSQL:st_makeline(GEOGRAPHY, GEOGRAPHY) -> GEOGRAPHY)
    | |   +-Literal(type=GEOGRAPHY, value=NULL)
    | |   +-Literal(type=GEOGRAPHY, value=NULL)
    | +-$col4#8 :=
    | | +-FunctionCall(ZetaSQL:st_makeline(ARRAY<GEOGRAPHY>) -> GEOGRAPHY)
    | |   +-Literal(type=ARRAY<GEOGRAPHY>, value=[])
    | +-$col5#9 :=
    | | +-FunctionCall(ZetaSQL:st_makeline(ARRAY<GEOGRAPHY>) -> GEOGRAPHY)
    | |   +-Literal(type=ARRAY<GEOGRAPHY>, value=[NULL], has_explicit_type=TRUE)
    | +-$col6#10 :=
    | | +-FunctionCall(ZetaSQL:st_makeline(ARRAY<GEOGRAPHY>) -> GEOGRAPHY)
    | |   +-FunctionCall(ZetaSQL:$make_array(repeated(3) GEOGRAPHY) -> ARRAY<GEOGRAPHY>)
    | |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col7#11 :=
    | | +-FunctionCall(ZetaSQL:st_makepolygon(GEOGRAPHY, optional(0) ARRAY<GEOGRAPHY>) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col8#12 :=
    | | +-FunctionCall(ZetaSQL:st_makepolygon(GEOGRAPHY, optional(1) ARRAY<GEOGRAPHY>) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-FunctionCall(ZetaSQL:$make_array(repeated(1) GEOGRAPHY) -> ARRAY<GEOGRAPHY>)
    | |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col9#13 :=
    |   +-FunctionCall(ZetaSQL:st_makepolygonoriented(ARRAY<GEOGRAPHY>) -> GEOGRAPHY)
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(2) GEOGRAPHY) -> ARRAY<GEOGRAPHY>)
    |       +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    |       +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    +-input_scan=
      +-TableScan(column_list=GeographyTable.[geo1#3, geo2#4], table=GeographyTable, column_index_list=[2, 3])
==

select st_makeline(st_geogpoint(0, 0), [st_geogpoint(1, 1)])
--
ERROR: No matching signature for function ST_MAKELINE for argument types: GEOGRAPHY, ARRAY<GEOGRAPHY>. Supported signatures: ST_MAKELINE(GEOGRAPHY, GEOGRAPHY); ST_MAKELINE(ARRAY<GEOGRAPHY>) [at 1:8]
select st_makeline(st_geogpoint(0, 0), [st_geogpoint(1, 1)])
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function ST_MAKELINE
  Argument types: GEOGRAPHY, ARRAY<GEOGRAPHY>
  Signature: ST_MAKELINE(GEOGRAPHY, GEOGRAPHY)
    Argument 2: Unable to coerce type ARRAY<GEOGRAPHY> to expected type GEOGRAPHY
  Signature: ST_MAKELINE(ARRAY<GEOGRAPHY>)
    Signature accepts at most 1 argument, found 2 arguments [at 1:8]
select st_makeline(st_geogpoint(0, 0), [st_geogpoint(1, 1)])
       ^
==

select st_makeline([1,2])
--

ERROR: No matching signature for function ST_MAKELINE for argument types: ARRAY<INT64>. Supported signatures: ST_MAKELINE(GEOGRAPHY, GEOGRAPHY); ST_MAKELINE(ARRAY<GEOGRAPHY>) [at 1:8]
select st_makeline([1,2])
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function ST_MAKELINE
  Argument types: ARRAY<INT64>
  Signature: ST_MAKELINE(GEOGRAPHY, GEOGRAPHY)
    Signature requires at least 2 arguments, found 1 argument
  Signature: ST_MAKELINE(ARRAY<GEOGRAPHY>)
    Argument 1: Unable to coerce type ARRAY<INT64> to expected type ARRAY<GEOGRAPHY> [at 1:8]
select st_makeline([1,2])
       ^
==

# No automatic coercion to array
select st_makepolygonoriented(geo1) from GeographyTable
--
ERROR: No matching signature for function ST_MAKEPOLYGONORIENTED for argument types: GEOGRAPHY. Supported signature: ST_MAKEPOLYGONORIENTED(ARRAY<GEOGRAPHY>) [at 1:8]
select st_makepolygonoriented(geo1) from GeographyTable
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function ST_MAKEPOLYGONORIENTED
  Argument types: GEOGRAPHY
  Signature: ST_MAKEPOLYGONORIENTED(ARRAY<GEOGRAPHY>)
    Argument 1: Unable to coerce type GEOGRAPHY to expected type ARRAY<GEOGRAPHY> [at 1:8]
select st_makepolygonoriented(geo1) from GeographyTable
       ^
==

select
  st_union(geo1, geo2),
  st_union([geo1, geo1, geo2, geo2]),
  st_intersection(geo1, geo2),
  st_union(geo1, geo2),
  st_difference(geo1, geo2),
  st_unaryunion(geo1),
  st_centroid(geo1),
  st_simplify(geo1, 2.3),
  st_snaptogrid(geo1, 3e-3),
  st_closestpoint(geo1, geo2),
  st_closestpoint(geo1, geo2, false),
  st_boundary(geo1),
  st_x(geo1),
  st_y(geo1)
from GeographyTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [GEOGRAPHY]
| +-$query.$col2#6 AS "$col2" [GEOGRAPHY]
| +-$query.$col3#7 AS "$col3" [GEOGRAPHY]
| +-$query.$col4#8 AS "$col4" [GEOGRAPHY]
| +-$query.$col5#9 AS "$col5" [GEOGRAPHY]
| +-$query.$col6#10 AS "$col6" [GEOGRAPHY]
| +-$query.$col7#11 AS "$col7" [GEOGRAPHY]
| +-$query.$col8#12 AS "$col8" [GEOGRAPHY]
| +-$query.$col9#13 AS "$col9" [GEOGRAPHY]
| +-$query.$col10#14 AS "$col10" [GEOGRAPHY]
| +-$query.$col11#15 AS "$col11" [GEOGRAPHY]
| +-$query.$col12#16 AS "$col12" [GEOGRAPHY]
| +-$query.$col13#17 AS "$col13" [DOUBLE]
| +-$query.$col14#18 AS "$col14" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8, $col5#9, $col6#10, $col7#11, $col8#12, $col9#13, $col10#14, $col11#15, $col12#16, $col13#17, $col14#18]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:st_union(GEOGRAPHY, GEOGRAPHY) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col2#6 :=
    | | +-FunctionCall(ZetaSQL:st_union(ARRAY<GEOGRAPHY>) -> GEOGRAPHY)
    | |   +-FunctionCall(ZetaSQL:$make_array(repeated(4) GEOGRAPHY) -> ARRAY<GEOGRAPHY>)
    | |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col3#7 :=
    | | +-FunctionCall(ZetaSQL:st_intersection(GEOGRAPHY, GEOGRAPHY) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col4#8 :=
    | | +-FunctionCall(ZetaSQL:st_union(GEOGRAPHY, GEOGRAPHY) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col5#9 :=
    | | +-FunctionCall(ZetaSQL:st_difference(GEOGRAPHY, GEOGRAPHY) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col6#10 :=
    | | +-FunctionCall(ZetaSQL:st_unaryunion(GEOGRAPHY) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col7#11 :=
    | | +-FunctionCall(ZetaSQL:st_centroid(GEOGRAPHY) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col8#12 :=
    | | +-FunctionCall(ZetaSQL:st_simplify(GEOGRAPHY, DOUBLE) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=DOUBLE, value=2.3)
    | +-$col9#13 :=
    | | +-FunctionCall(ZetaSQL:st_snaptogrid(GEOGRAPHY, DOUBLE) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=DOUBLE, value=0.003)
    | +-$col10#14 :=
    | | +-FunctionCall(ZetaSQL:st_closestpoint(GEOGRAPHY, GEOGRAPHY, optional(0) BOOL) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col11#15 :=
    | | +-FunctionCall(ZetaSQL:st_closestpoint(GEOGRAPHY, GEOGRAPHY, optional(1) BOOL) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | |   +-Literal(type=BOOL, value=false)
    | +-$col12#16 :=
    | | +-FunctionCall(ZetaSQL:st_boundary(GEOGRAPHY) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col13#17 :=
    | | +-FunctionCall(ZetaSQL:st_x(GEOGRAPHY) -> DOUBLE)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col14#18 :=
    |   +-FunctionCall(ZetaSQL:st_y(GEOGRAPHY) -> DOUBLE)
    |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    +-input_scan=
      +-TableScan(column_list=GeographyTable.[geo1#3, geo2#4], table=GeographyTable, column_index_list=[2, 3])
==

# Predicates
select
  st_equals(geo1, geo2),
  st_intersects(geo1, geo2),
  st_contains(geo1, geo2),
  st_within(geo1, geo2),
  st_covers(geo1, geo2),
  st_coveredby(geo1, geo2),
  st_disjoint(geo1, geo2),
  st_touches(geo1, geo2),
  st_intersectsbox(geo1, 1, 1, 2, 2),
  st_dwithin(geo1, geo2, 12.03),
  st_dwithin(geo2, geo1, 0.1, false)
from GeographyTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [BOOL]
| +-$query.$col2#6 AS "$col2" [BOOL]
| +-$query.$col3#7 AS "$col3" [BOOL]
| +-$query.$col4#8 AS "$col4" [BOOL]
| +-$query.$col5#9 AS "$col5" [BOOL]
| +-$query.$col6#10 AS "$col6" [BOOL]
| +-$query.$col7#11 AS "$col7" [BOOL]
| +-$query.$col8#12 AS "$col8" [BOOL]
| +-$query.$col9#13 AS "$col9" [BOOL]
| +-$query.$col10#14 AS "$col10" [BOOL]
| +-$query.$col11#15 AS "$col11" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8, $col5#9, $col6#10, $col7#11, $col8#12, $col9#13, $col10#14, $col11#15]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:st_equals(GEOGRAPHY, GEOGRAPHY) -> BOOL)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col2#6 :=
    | | +-FunctionCall(ZetaSQL:st_intersects(GEOGRAPHY, GEOGRAPHY) -> BOOL)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col3#7 :=
    | | +-FunctionCall(ZetaSQL:st_contains(GEOGRAPHY, GEOGRAPHY) -> BOOL)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col4#8 :=
    | | +-FunctionCall(ZetaSQL:st_within(GEOGRAPHY, GEOGRAPHY) -> BOOL)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col5#9 :=
    | | +-FunctionCall(ZetaSQL:st_covers(GEOGRAPHY, GEOGRAPHY) -> BOOL)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col6#10 :=
    | | +-FunctionCall(ZetaSQL:st_coveredby(GEOGRAPHY, GEOGRAPHY) -> BOOL)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col7#11 :=
    | | +-FunctionCall(ZetaSQL:st_disjoint(GEOGRAPHY, GEOGRAPHY) -> BOOL)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col8#12 :=
    | | +-FunctionCall(ZetaSQL:st_touches(GEOGRAPHY, GEOGRAPHY) -> BOOL)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col9#13 :=
    | | +-FunctionCall(ZetaSQL:st_intersectsbox(GEOGRAPHY, DOUBLE, DOUBLE, DOUBLE, DOUBLE) -> BOOL)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=DOUBLE, value=1)
    | |   +-Literal(type=DOUBLE, value=1)
    | |   +-Literal(type=DOUBLE, value=2)
    | |   +-Literal(type=DOUBLE, value=2)
    | +-$col10#14 :=
    | | +-FunctionCall(ZetaSQL:st_dwithin(GEOGRAPHY, GEOGRAPHY, DOUBLE, optional(0) BOOL) -> BOOL)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | |   +-Literal(type=DOUBLE, value=12.03)
    | +-$col11#15 :=
    |   +-FunctionCall(ZetaSQL:st_dwithin(GEOGRAPHY, GEOGRAPHY, DOUBLE, optional(1) BOOL) -> BOOL)
    |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    |     +-Literal(type=DOUBLE, value=0.1)
    |     +-Literal(type=BOOL, value=false)
    +-input_scan=
      +-TableScan(column_list=GeographyTable.[geo1#3, geo2#4], table=GeographyTable, column_index_list=[2, 3])
==

# Accessors
select
  st_isempty(geo1),
  st_iscollection(geo1),
  st_dimension(geo1),
  st_numpoints(geo1)
from GeographyTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [BOOL]
| +-$query.$col2#6 AS "$col2" [BOOL]
| +-$query.$col3#7 AS "$col3" [INT64]
| +-$query.$col4#8 AS "$col4" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:st_isempty(GEOGRAPHY) -> BOOL)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col2#6 :=
    | | +-FunctionCall(ZetaSQL:st_iscollection(GEOGRAPHY) -> BOOL)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col3#7 :=
    | | +-FunctionCall(ZetaSQL:st_dimension(GEOGRAPHY) -> INT64)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col4#8 :=
    |   +-FunctionCall(ZetaSQL:st_numpoints(GEOGRAPHY) -> INT64)
    |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    +-input_scan=
      +-TableScan(column_list=[GeographyTable.geo1#3], table=GeographyTable, column_index_list=[2])
==

# Measures
select
  st_length(geo1),
  st_perimeter(geo1),
  st_area(geo1),
  st_distance(geo1, geo2),
  st_maxdistance(geo1, geo2)
from GeographyTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [DOUBLE]
| +-$query.$col2#6 AS "$col2" [DOUBLE]
| +-$query.$col3#7 AS "$col3" [DOUBLE]
| +-$query.$col4#8 AS "$col4" [DOUBLE]
| +-$query.$col5#9 AS "$col5" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8, $col5#9]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:st_length(GEOGRAPHY, optional(0) BOOL) -> DOUBLE)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col2#6 :=
    | | +-FunctionCall(ZetaSQL:st_perimeter(GEOGRAPHY, optional(0) BOOL) -> DOUBLE)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col3#7 :=
    | | +-FunctionCall(ZetaSQL:st_area(GEOGRAPHY, optional(0) BOOL) -> DOUBLE)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col4#8 :=
    | | +-FunctionCall(ZetaSQL:st_distance(GEOGRAPHY, GEOGRAPHY, optional(0) BOOL) -> DOUBLE)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | +-$col5#9 :=
    |   +-FunctionCall(ZetaSQL:st_maxdistance(GEOGRAPHY, GEOGRAPHY, optional(0) BOOL) -> DOUBLE)
    |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    +-input_scan=
      +-TableScan(column_list=GeographyTable.[geo1#3, geo2#4], table=GeographyTable, column_index_list=[2, 3])
==

select
  st_length(geo1, false),
  st_perimeter(geo1, false),
  st_area(geo1, false),
  st_distance(geo1, null, false),
  st_maxdistance(geo1, null, false)
from GeographyTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [DOUBLE]
| +-$query.$col2#6 AS "$col2" [DOUBLE]
| +-$query.$col3#7 AS "$col3" [DOUBLE]
| +-$query.$col4#8 AS "$col4" [DOUBLE]
| +-$query.$col5#9 AS "$col5" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8, $col5#9]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:st_length(GEOGRAPHY, optional(1) BOOL) -> DOUBLE)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=BOOL, value=false)
    | +-$col2#6 :=
    | | +-FunctionCall(ZetaSQL:st_perimeter(GEOGRAPHY, optional(1) BOOL) -> DOUBLE)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=BOOL, value=false)
    | +-$col3#7 :=
    | | +-FunctionCall(ZetaSQL:st_area(GEOGRAPHY, optional(1) BOOL) -> DOUBLE)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=BOOL, value=false)
    | +-$col4#8 :=
    | | +-FunctionCall(ZetaSQL:st_distance(GEOGRAPHY, GEOGRAPHY, optional(1) BOOL) -> DOUBLE)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=GEOGRAPHY, value=NULL)
    | |   +-Literal(type=BOOL, value=false)
    | +-$col5#9 :=
    |   +-FunctionCall(ZetaSQL:st_maxdistance(GEOGRAPHY, GEOGRAPHY, optional(1) BOOL) -> DOUBLE)
    |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    |     +-Literal(type=GEOGRAPHY, value=NULL)
    |     +-Literal(type=BOOL, value=false)
    +-input_scan=
      +-TableScan(column_list=[GeographyTable.geo1#3], table=GeographyTable, column_index_list=[2])
==

select st_distance(geo2) from GeographyTable
--
ERROR: Number of arguments does not match for function ST_DISTANCE. Supported signature: ST_DISTANCE(GEOGRAPHY, GEOGRAPHY, [BOOL]) [at 1:8]
select st_distance(geo2) from GeographyTable
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function ST_DISTANCE
  Argument types: GEOGRAPHY
  Signature: ST_DISTANCE(GEOGRAPHY, GEOGRAPHY, [BOOL])
    Signature requires at least 2 arguments, found 1 argument [at 1:8]
select st_distance(geo2) from GeographyTable
       ^
==

# Parsers
select
  st_geogfromtext(text),
  st_geogfromtext(text, TRUE),
  st_geogfromtext(text, FALSE),
  st_geogfromtext(text, NULL),
  st_geogfromtext(text, CAST('true' AS BOOLEAN)),
  st_geogfromtext(text, @test_param_bool),
  st_geogfromkml(text),
  st_geogfromgeojson(text),
  st_geogfromwkb(cast(text as bytes)),
  st_geogpointfromgeohash(text)
from GeographyTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [GEOGRAPHY]
| +-$query.$col2#6 AS "$col2" [GEOGRAPHY]
| +-$query.$col3#7 AS "$col3" [GEOGRAPHY]
| +-$query.$col4#8 AS "$col4" [GEOGRAPHY]
| +-$query.$col5#9 AS "$col5" [GEOGRAPHY]
| +-$query.$col6#10 AS "$col6" [GEOGRAPHY]
| +-$query.$col7#11 AS "$col7" [GEOGRAPHY]
| +-$query.$col8#12 AS "$col8" [GEOGRAPHY]
| +-$query.$col9#13 AS "$col9" [GEOGRAPHY]
| +-$query.$col10#14 AS "$col10" [GEOGRAPHY]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8, $col5#9, $col6#10, $col7#11, $col8#12, $col9#13, $col10#14]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromtext(STRING, optional(0) BOOL) -> GEOGRAPHY)
    | |   +-ColumnRef(type=STRING, column=GeographyTable.text#2)
    | +-$col2#6 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromtext(STRING, optional(1) BOOL) -> GEOGRAPHY)
    | |   +-ColumnRef(type=STRING, column=GeographyTable.text#2)
    | |   +-Literal(type=BOOL, value=true)
    | +-$col3#7 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromtext(STRING, optional(1) BOOL) -> GEOGRAPHY)
    | |   +-ColumnRef(type=STRING, column=GeographyTable.text#2)
    | |   +-Literal(type=BOOL, value=false)
    | +-$col4#8 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromtext(STRING, optional(1) BOOL) -> GEOGRAPHY)
    | |   +-ColumnRef(type=STRING, column=GeographyTable.text#2)
    | |   +-Literal(type=BOOL, value=NULL)
    | +-$col5#9 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromtext(STRING, optional(1) BOOL) -> GEOGRAPHY)
    | |   +-ColumnRef(type=STRING, column=GeographyTable.text#2)
    | |   +-Literal(type=BOOL, value=true, has_explicit_type=TRUE)
    | +-$col6#10 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromtext(STRING, optional(1) BOOL) -> GEOGRAPHY)
    | |   +-ColumnRef(type=STRING, column=GeographyTable.text#2)
    | |   +-Parameter(type=BOOL, name="test_param_bool")
    | +-$col7#11 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromkml(STRING) -> GEOGRAPHY)
    | |   +-ColumnRef(type=STRING, column=GeographyTable.text#2)
    | +-$col8#12 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromgeojson(STRING) -> GEOGRAPHY)
    | |   +-ColumnRef(type=STRING, column=GeographyTable.text#2)
    | +-$col9#13 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromwkb(BYTES) -> GEOGRAPHY)
    | |   +-Cast(STRING -> BYTES)
    | |     +-ColumnRef(type=STRING, column=GeographyTable.text#2)
    | +-$col10#14 :=
    |   +-FunctionCall(ZetaSQL:st_geogpointfromgeohash(STRING) -> GEOGRAPHY)
    |     +-ColumnRef(type=STRING, column=GeographyTable.text#2)
    +-input_scan=
      +-TableScan(column_list=[GeographyTable.text#2], table=GeographyTable, column_index_list=[1])
==

# Parser errors
select st_geogfromtext(text, TRUE AND FALSE) from GeographyTable
--
ERROR: Argument 2 to ST_GEOGFROMTEXT must be a literal or query parameter [at 1:30]
select st_geogfromtext(text, TRUE AND FALSE) from GeographyTable
                             ^
==

# Parser errors
select st_geogfromtext(text, NOT TRUE) from GeographyTable
--
ERROR: Argument 2 to ST_GEOGFROMTEXT must be a literal or query parameter [at 1:30]
select st_geogfromtext(text, NOT TRUE) from GeographyTable
                             ^
==

# Formatters
select
  st_astext(geo1),
  st_askml(geo1),
  st_asgeojson(geo1),
  st_asgeojson(geo1, 10),
  st_asbinary(geo1),
  st_geohash(geo1),
  st_geohash(geo1, 5)
from GeographyTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [STRING]
| +-$query.$col2#6 AS "$col2" [STRING]
| +-$query.$col3#7 AS "$col3" [STRING]
| +-$query.$col4#8 AS "$col4" [STRING]
| +-$query.$col5#9 AS "$col5" [BYTES]
| +-$query.$col6#10 AS "$col6" [STRING]
| +-$query.$col7#11 AS "$col7" [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8, $col5#9, $col6#10, $col7#11]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:st_astext(GEOGRAPHY) -> STRING)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col2#6 :=
    | | +-FunctionCall(ZetaSQL:st_askml(GEOGRAPHY) -> STRING)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col3#7 :=
    | | +-FunctionCall(ZetaSQL:st_asgeojson(GEOGRAPHY, optional(0) INT64) -> STRING)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col4#8 :=
    | | +-FunctionCall(ZetaSQL:st_asgeojson(GEOGRAPHY, optional(1) INT64) -> STRING)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=INT64, value=10)
    | +-$col5#9 :=
    | | +-FunctionCall(ZetaSQL:st_asbinary(GEOGRAPHY) -> BYTES)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col6#10 :=
    | | +-FunctionCall(ZetaSQL:st_geohash(GEOGRAPHY, optional(0) INT64) -> STRING)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | +-$col7#11 :=
    |   +-FunctionCall(ZetaSQL:st_geohash(GEOGRAPHY, optional(1) INT64) -> STRING)
    |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    |     +-Literal(type=INT64, value=5)
    +-input_scan=
      +-TableScan(column_list=[GeographyTable.geo1#3], table=GeographyTable, column_index_list=[2])
==

# Aggregate functions
select
  key,
  st_union_agg(geo1),
  st_union_agg(geo2),
  st_accum(geo1)
from GeographyTable
group by key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#8 AS key [INT64]
| +-$aggregate.$agg1#5 AS "$col2" [GEOGRAPHY]
| +-$aggregate.$agg2#6 AS "$col3" [GEOGRAPHY]
| +-$aggregate.$agg3#7 AS "$col4" [ARRAY<GEOGRAPHY>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#8, $aggregate.$agg1#5, $aggregate.$agg2#6, $aggregate.$agg3#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#8, $aggregate.$agg1#5, $aggregate.$agg2#6, $aggregate.$agg3#7]
        +-input_scan=
        | +-TableScan(column_list=GeographyTable.[key#1, geo1#3, geo2#4], table=GeographyTable, column_index_list=[0, 2, 3])
        +-group_by_list=
        | +-key#8 := ColumnRef(type=INT64, column=GeographyTable.key#1)
        +-aggregate_list=
          +-$agg1#5 :=
          | +-AggregateFunctionCall(ZetaSQL:st_union_agg(GEOGRAPHY) -> GEOGRAPHY)
          |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
          +-$agg2#6 :=
          | +-AggregateFunctionCall(ZetaSQL:st_union_agg(GEOGRAPHY) -> GEOGRAPHY)
          |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
          +-$agg3#7 :=
            +-AggregateFunctionCall(ZetaSQL:st_accum(GEOGRAPHY) -> ARRAY<GEOGRAPHY>)
              +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
==

# Not supported operators and functions
select st_geogpoint(1, 1) > st_geogpoint(0, 0)
--
ERROR: Greater than is not defined for arguments of type GEOGRAPHY [at 1:8]
select st_geogpoint(1, 1) > st_geogpoint(0, 0)
       ^
==

select cast(st_geogpoint(0, 0) as string)
--
ERROR: Invalid cast from GEOGRAPHY to STRING [at 1:13]
select cast(st_geogpoint(0, 0) as string)
            ^
==

select cast('foo' as geography)
--
ERROR: Invalid cast from STRING to GEOGRAPHY [at 1:13]
select cast('foo' as geography)
            ^
==

select geo1, count(*) from GeographyTable group by geo1
--
ERROR: Grouping by expressions of type GEOGRAPHY is not allowed [at 1:52]
select geo1, count(*) from GeographyTable group by geo1
                                                   ^
==

select * from GeographyTable order by geo1
--
ERROR: ORDER BY does not support expressions of type GEOGRAPHY [at 1:39]
select * from GeographyTable order by geo1
                                      ^
==

[language_features=ANALYTIC_FUNCTIONS]
select count(*) over(partition by geo1) from GeographyTable
--
ERROR: Partitioning by expressions of type GEOGRAPHY is not allowed [at 1:35]
select count(*) over(partition by geo1) from GeographyTable
                                  ^
==

[language_features=ANALYTIC_FUNCTIONS]
select count(*) over(order by geo1) from GeographyTable
--
ERROR: Ordering by expressions of type GEOGRAPHY is not allowed [at 1:31]
select count(*) over(order by geo1) from GeographyTable
                              ^
==

# Function signature errors
select st_geogpoint(1.1, 2.2, 3)
--
ERROR: Number of arguments does not match for function ST_GEOGPOINT. Supported signature: ST_GEOGPOINT(DOUBLE, DOUBLE) [at 1:8]
select st_geogpoint(1.1, 2.2, 3)
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function ST_GEOGPOINT
  Argument types: DOUBLE, DOUBLE, INT64
  Signature: ST_GEOGPOINT(DOUBLE, DOUBLE)
    Signature accepts at most 2 arguments, found 3 arguments [at 1:8]
select st_geogpoint(1.1, 2.2, 3)
       ^
==

[language_features=GEOGRAPHY,NAMED_ARGUMENTS{{,V_1_3_EXTENDED_GEOGRAPHY_PARSERS|}}]
select st_geogfromtext('point(0 0)', planar => TRUE)
--
ALTERNATION GROUP: ,V_1_3_EXTENDED_GEOGRAPHY_PARSERS
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [GEOGRAPHY]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:st_geogfromtext(STRING, optional(1) BOOL oriented, optional(1) BOOL planar, optional(1) BOOL make_valid) -> GEOGRAPHY)
    |     +-Literal(type=STRING, value="point(0 0)")
    |     +-Literal(type=BOOL, value=false)
    |     +-Literal(type=BOOL, value=true)
    |     +-Literal(type=BOOL, value=false)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for function ST_GEOGFROMTEXT for argument types: STRING, planar => BOOL. Supported signature: ST_GEOGFROMTEXT(STRING, [BOOL]) [at 1:8]
select st_geogfromtext('point(0 0)', planar => TRUE)
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function ST_GEOGFROMTEXT
  Argument types: STRING, planar => BOOL
  Signature: ST_GEOGFROMTEXT(STRING, [BOOL])
    Named argument "planar" does not exist in signature [at 1:8]
select st_geogfromtext('point(0 0)', planar => TRUE)
       ^
==

[language_features=GEOGRAPHY,NAMED_ARGUMENTS,V_1_3_EXTENDED_GEOGRAPHY_PARSERS]
select
  # Permutation of named arguments produce same resolved AST.
  st_geogfromtext('point(0 0)', planar => true, make_valid => false, oriented => true),
  st_geogfromtext('point(0 0)', oriented => true, planar => true, make_valid => false),
  st_geogfromtext('point(0 0)', make_valid => false, oriented => true, planar => true),
  # Some named arguments are missing - become NULLs in resolved AST.
  # Note: this might change when (broken link) is implemented.
  st_geogfromtext('point(0 0)', oriented => false, planar => true),
  st_geogfromtext('point(0 0)', planar => true),
  st_geogfromtext('point(0 0)', make_valid => true, oriented => true)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [GEOGRAPHY]
| +-$query.$col2#2 AS "$col2" [GEOGRAPHY]
| +-$query.$col3#3 AS "$col3" [GEOGRAPHY]
| +-$query.$col4#4 AS "$col4" [GEOGRAPHY]
| +-$query.$col5#5 AS "$col5" [GEOGRAPHY]
| +-$query.$col6#6 AS "$col6" [GEOGRAPHY]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromtext(STRING, optional(1) BOOL oriented, optional(1) BOOL planar, optional(1) BOOL make_valid) -> GEOGRAPHY)
    | |   +-Literal(type=STRING, value="point(0 0)")
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BOOL, value=false)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromtext(STRING, optional(1) BOOL oriented, optional(1) BOOL planar, optional(1) BOOL make_valid) -> GEOGRAPHY)
    | |   +-Literal(type=STRING, value="point(0 0)")
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BOOL, value=false)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromtext(STRING, optional(1) BOOL oriented, optional(1) BOOL planar, optional(1) BOOL make_valid) -> GEOGRAPHY)
    | |   +-Literal(type=STRING, value="point(0 0)")
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BOOL, value=false)
    | +-$col4#4 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromtext(STRING, optional(1) BOOL oriented, optional(1) BOOL planar, optional(1) BOOL make_valid) -> GEOGRAPHY)
    | |   +-Literal(type=STRING, value="point(0 0)")
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BOOL, value=false)
    | +-$col5#5 :=
    | | +-FunctionCall(ZetaSQL:st_geogfromtext(STRING, optional(1) BOOL oriented, optional(1) BOOL planar, optional(1) BOOL make_valid) -> GEOGRAPHY)
    | |   +-Literal(type=STRING, value="point(0 0)")
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BOOL, value=false)
    | +-$col6#6 :=
    |   +-FunctionCall(ZetaSQL:st_geogfromtext(STRING, optional(1) BOOL oriented, optional(1) BOOL planar, optional(1) BOOL make_valid) -> GEOGRAPHY)
    |     +-Literal(type=STRING, value="point(0 0)")
    |     +-Literal(type=BOOL, value=true)
    |     +-Literal(type=BOOL, value=false)
    |     +-Literal(type=BOOL, value=true)
    +-input_scan=
      +-SingleRowScan

==

[language_features=GEOGRAPHY,NAMED_ARGUMENTS,V_1_3_EXTENDED_GEOGRAPHY_PARSERS]
select st_geogfromtext('point(0 0)', planar => x) from unnest([true, false]) x
--
ERROR: Argument 'planar' to ST_GEOGFROMTEXT must be a literal or query parameter [at 1:38]
select st_geogfromtext('point(0 0)', planar => x) from unnest([true, false]) x
                                     ^
==

# Invalid signature: omitted required argument
[language_features=GEOGRAPHY,NAMED_ARGUMENTS,V_1_3_EXTENDED_GEOGRAPHY_PARSERS]
select st_bufferwithtolerance(st_geogpoint(1,2),
  tolerance_meters => 100, endcap => "flat", side => "left");
--
ERROR: Call to function ZetaSQL:st_bufferwithtolerance does not include required positional argument number 2 [at 1:8]
select st_bufferwithtolerance(st_geogpoint(1,2),
       ^
--
Signature Mismatch Details:
ERROR: No matching signature for function ST_BUFFERWITHTOLERANCE
  Argument types: GEOGRAPHY, tolerance_meters => INT64, endcap => STRING, side => STRING
  Signature: ST_BUFFERWITHTOLERANCE(GEOGRAPHY, DOUBLE, [tolerance_meters=>]DOUBLE, [[use_spheroid=>]BOOL], [endcap => STRING], [side => STRING])
    Required positional argument number 2 is not provided [at 1:8]
select st_bufferwithtolerance(st_geogpoint(1,2),
       ^
==

[language_features=GEOGRAPHY,NAMED_ARGUMENTS]
select
  # Permutation of named arguments produce same resolved AST.
  st_buffer(geo1, 100.1, num_seg_quarter_circle => 8, use_spheroid => false, endcap => 'flat', side => 'left'),
  st_buffer(geo2, 5.2, 8, use_spheroid => false, endcap => 'flat', side => 'left'),
  st_buffer(geo1, 200.5, 8, false, side => 'left', endcap => 'flat'),
  st_bufferwithtolerance(geo1, 100.1, tolerance_meters => 10.01, use_spheroid => false, endcap => 'flat', side => 'left'),
  st_bufferwithtolerance(geo2, 5.2, 0.052, use_spheroid => false, endcap => 'flat', side => 'left'),
  st_bufferwithtolerance(geo1, 200.5, 4.01, false, side => 'left', endcap => 'flat'),
  # Some named arguments are missing - test that defaults are set correctly.
  st_buffer(geo2, 0.0),
  st_buffer(geo1, 10, num_seg_quarter_circle => 10),
  st_buffer(geo2, 0.0, use_spheroid => false),
  st_buffer(geo1, 100.2, endcap => 'flat'),
  st_buffer(geo1, 100.2, side => 'right'),
  st_bufferwithtolerance(geo1, 10, tolerance_meters => 5),
  st_bufferwithtolerance(geo2, 0.0, 5),
  st_bufferwithtolerance(geo2, 0.0, 10, use_spheroid => false),
  st_bufferwithtolerance(geo1, 100.2, 10, endcap => 'round'),
  st_bufferwithtolerance(geo1, 100.2, 10, side => 'right')
from GeographyTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [GEOGRAPHY]
| +-$query.$col2#6 AS "$col2" [GEOGRAPHY]
| +-$query.$col3#7 AS "$col3" [GEOGRAPHY]
| +-$query.$col4#8 AS "$col4" [GEOGRAPHY]
| +-$query.$col5#9 AS "$col5" [GEOGRAPHY]
| +-$query.$col6#10 AS "$col6" [GEOGRAPHY]
| +-$query.$col7#11 AS "$col7" [GEOGRAPHY]
| +-$query.$col8#12 AS "$col8" [GEOGRAPHY]
| +-$query.$col9#13 AS "$col9" [GEOGRAPHY]
| +-$query.$col10#14 AS "$col10" [GEOGRAPHY]
| +-$query.$col11#15 AS "$col11" [GEOGRAPHY]
| +-$query.$col12#16 AS "$col12" [GEOGRAPHY]
| +-$query.$col13#17 AS "$col13" [GEOGRAPHY]
| +-$query.$col14#18 AS "$col14" [GEOGRAPHY]
| +-$query.$col15#19 AS "$col15" [GEOGRAPHY]
| +-$query.$col16#20 AS "$col16" [GEOGRAPHY]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8, $col5#9, $col6#10, $col7#11, $col8#12, $col9#13, $col10#14, $col11#15, $col12#16, $col13#17, $col14#18, $col15#19, $col16#20]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:st_buffer(GEOGRAPHY, DOUBLE, optional(1) DOUBLE num_seg_quarter_circle, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=DOUBLE, value=100.1)
    | |   +-Literal(type=DOUBLE, value=8)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="flat")
    | |   +-Literal(type=STRING, value="left")
    | +-$col2#6 :=
    | | +-FunctionCall(ZetaSQL:st_buffer(GEOGRAPHY, DOUBLE, optional(1) DOUBLE num_seg_quarter_circle, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | |   +-Literal(type=DOUBLE, value=5.2)
    | |   +-Literal(type=DOUBLE, value=8)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="flat")
    | |   +-Literal(type=STRING, value="left")
    | +-$col3#7 :=
    | | +-FunctionCall(ZetaSQL:st_buffer(GEOGRAPHY, DOUBLE, optional(1) DOUBLE num_seg_quarter_circle, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=DOUBLE, value=200.5)
    | |   +-Literal(type=DOUBLE, value=8)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="flat")
    | |   +-Literal(type=STRING, value="left")
    | +-$col4#8 :=
    | | +-FunctionCall(ZetaSQL:st_bufferwithtolerance(GEOGRAPHY, DOUBLE, DOUBLE tolerance_meters, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=DOUBLE, value=100.1)
    | |   +-Literal(type=DOUBLE, value=10.01)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="flat")
    | |   +-Literal(type=STRING, value="left")
    | +-$col5#9 :=
    | | +-FunctionCall(ZetaSQL:st_bufferwithtolerance(GEOGRAPHY, DOUBLE, DOUBLE tolerance_meters, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | |   +-Literal(type=DOUBLE, value=5.2)
    | |   +-Literal(type=DOUBLE, value=0.052)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="flat")
    | |   +-Literal(type=STRING, value="left")
    | +-$col6#10 :=
    | | +-FunctionCall(ZetaSQL:st_bufferwithtolerance(GEOGRAPHY, DOUBLE, DOUBLE tolerance_meters, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=DOUBLE, value=200.5)
    | |   +-Literal(type=DOUBLE, value=4.01)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="flat")
    | |   +-Literal(type=STRING, value="left")
    | +-$col7#11 :=
    | | +-FunctionCall(ZetaSQL:st_buffer(GEOGRAPHY, DOUBLE, optional(1) DOUBLE num_seg_quarter_circle, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | |   +-Literal(type=DOUBLE, value=0)
    | |   +-Literal(type=DOUBLE, value=8)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="ROUND")
    | |   +-Literal(type=STRING, value="BOTH")
    | +-$col8#12 :=
    | | +-FunctionCall(ZetaSQL:st_buffer(GEOGRAPHY, DOUBLE, optional(1) DOUBLE num_seg_quarter_circle, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=DOUBLE, value=10)
    | |   +-Literal(type=DOUBLE, value=10)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="ROUND")
    | |   +-Literal(type=STRING, value="BOTH")
    | +-$col9#13 :=
    | | +-FunctionCall(ZetaSQL:st_buffer(GEOGRAPHY, DOUBLE, optional(1) DOUBLE num_seg_quarter_circle, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | |   +-Literal(type=DOUBLE, value=0)
    | |   +-Literal(type=DOUBLE, value=8)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="ROUND")
    | |   +-Literal(type=STRING, value="BOTH")
    | +-$col10#14 :=
    | | +-FunctionCall(ZetaSQL:st_buffer(GEOGRAPHY, DOUBLE, optional(1) DOUBLE num_seg_quarter_circle, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=DOUBLE, value=100.2)
    | |   +-Literal(type=DOUBLE, value=8)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="flat")
    | |   +-Literal(type=STRING, value="BOTH")
    | +-$col11#15 :=
    | | +-FunctionCall(ZetaSQL:st_buffer(GEOGRAPHY, DOUBLE, optional(1) DOUBLE num_seg_quarter_circle, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=DOUBLE, value=100.2)
    | |   +-Literal(type=DOUBLE, value=8)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="ROUND")
    | |   +-Literal(type=STRING, value="right")
    | +-$col12#16 :=
    | | +-FunctionCall(ZetaSQL:st_bufferwithtolerance(GEOGRAPHY, DOUBLE, DOUBLE tolerance_meters, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=DOUBLE, value=10)
    | |   +-Literal(type=DOUBLE, value=5)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="ROUND")
    | |   +-Literal(type=STRING, value="BOTH")
    | +-$col13#17 :=
    | | +-FunctionCall(ZetaSQL:st_bufferwithtolerance(GEOGRAPHY, DOUBLE, DOUBLE tolerance_meters, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | |   +-Literal(type=DOUBLE, value=0)
    | |   +-Literal(type=DOUBLE, value=5)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="ROUND")
    | |   +-Literal(type=STRING, value="BOTH")
    | +-$col14#18 :=
    | | +-FunctionCall(ZetaSQL:st_bufferwithtolerance(GEOGRAPHY, DOUBLE, DOUBLE tolerance_meters, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo2#4)
    | |   +-Literal(type=DOUBLE, value=0)
    | |   +-Literal(type=DOUBLE, value=10)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="ROUND")
    | |   +-Literal(type=STRING, value="BOTH")
    | +-$col15#19 :=
    | | +-FunctionCall(ZetaSQL:st_bufferwithtolerance(GEOGRAPHY, DOUBLE, DOUBLE tolerance_meters, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    | |   +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    | |   +-Literal(type=DOUBLE, value=100.2)
    | |   +-Literal(type=DOUBLE, value=10)
    | |   +-Literal(type=BOOL, value=false)
    | |   +-Literal(type=STRING, value="round")
    | |   +-Literal(type=STRING, value="BOTH")
    | +-$col16#20 :=
    |   +-FunctionCall(ZetaSQL:st_bufferwithtolerance(GEOGRAPHY, DOUBLE, DOUBLE tolerance_meters, optional(1) BOOL use_spheroid, optional(1) STRING endcap, optional(1) STRING side) -> GEOGRAPHY)
    |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    |     +-Literal(type=DOUBLE, value=100.2)
    |     +-Literal(type=DOUBLE, value=10)
    |     +-Literal(type=BOOL, value=false)
    |     +-Literal(type=STRING, value="ROUND")
    |     +-Literal(type=STRING, value="right")
    +-input_scan=
      +-TableScan(column_list=GeographyTable.[geo1#3, geo2#4], table=GeographyTable, column_index_list=[2, 3])

==

[language_features=GEOGRAPHY,NAMED_ARGUMENTS]
select s2_coveringcellids(geo1) from GeographyTable;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:s2_coveringcellids(GEOGRAPHY, optional(1) INT64 min_level, optional(1) INT64 max_level, optional(1) INT64 max_cells, optional(1) DOUBLE buffer) -> ARRAY<INT64>)
    |     +-ColumnRef(type=GEOGRAPHY, column=GeographyTable.geo1#3)
    |     +-Literal(type=INT64, value=0)
    |     +-Literal(type=INT64, value=30)
    |     +-Literal(type=INT64, value=8)
    |     +-Literal(type=DOUBLE, value=0)
    +-input_scan=
      +-TableScan(column_list=[GeographyTable.geo1#3], table=GeographyTable, column_index_list=[2])
