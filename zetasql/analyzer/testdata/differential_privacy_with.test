# Table with UID in the WITH clause, differential privacy in the outer SELECT
[default language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,V_1_1_WITH_ON_SUBQUERY,V_1_3_WITH_RECURSIVE]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
WITH t as (select *
           from SimpleTypesWithAnonymizationUid)
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count from t;
--
QueryStmt
+-output_column_list=
| +-$aggregate.count#25 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#25]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#25]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#25]
            +-input_scan=
            | +-WithRefScan(column_list=t.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t")
            +-aggregate_list=
              +-count#25 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.count#25 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#25]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#25]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#25]
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$aggregate.count_partial#27, $group_by.$uid#28]
            |   +-input_scan=
            |   | +-WithRefScan(column_list=t.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t")
            |   +-group_by_list=
            |   | +-$uid#28 := ColumnRef(type=INT64, column=t.uid#23)
            |   +-aggregate_list=
            |     +-count_partial#27 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-aggregate_list=
            | +-count#25 :=
            | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#27)
            | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
            | +-$group_selection_threshold_col#31 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-Literal(type=INT64, value=1)
            |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#31)
==

# Reject WithRefScan without UID table
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
with with_scan as (select 1)
select with differential_privacy count(*, contribution_bounds_per_group => (0, 100))
from with_scan;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-parse_location=0-128
    +-column_list=[$aggregate.$agg1#3]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='with_scan'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-parse_location=19-27
    |       +-column_list=[with_scan.$col1#1]
    |       +-expr_list=
    |       | +-$col1#1 := Literal(parse_location=26-27, type=INT64, value=1)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-WithRefScan(column_list=[with_scan.$col1#2], with_query_name="with_scan")
            +-aggregate_list=
              +-$agg1#3 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-parse_location=62-67
                  +-Literal(parse_location=104-112, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
with with_scan as (select @_p0_INT64)
select with differential_privacy count(*, contribution_bounds_per_group => @_p1_STRUCT)
from with_scan;

Rewrite ERROR: A SELECT WITH DIFFERENTIAL_PRIVACY query must query data with a specified privacy unit column
==

# Require explicit uid projection
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
with t1 as (select 1 from SimpleTypesWithAnonymizationUid)
select with differential_privacy count(*, contribution_bounds_per_group => (0, 100))
from (select * from t1);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-parse_location=0-167
    +-column_list=[$aggregate.$agg1#15]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-parse_location=12-57
    |       +-column_list=[t1.$col1#13]
    |       +-expr_list=
    |       | +-$col1#13 := Literal(parse_location=19-20, type=INT64, value=1)
    |       +-input_scan=
    |         +-TableScan(parse_location=26-57, table=SimpleTypesWithAnonymizationUid)
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.$agg1#15]
            +-input_scan=
            | +-ProjectScan
            |   +-parse_location=150-166
            |   +-column_list=[t1.$col1#14]
            |   +-input_scan=
            |     +-WithRefScan(column_list=[t1.$col1#14], with_query_name="t1")
            +-aggregate_list=
              +-$agg1#15 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-parse_location=92-97
                  +-Literal(parse_location=134-142, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
with t1 as (select @_p0_INT64 from SimpleTypesWithAnonymizationUid)
select with differential_privacy count(*, contribution_bounds_per_group => @_p1_STRUCT)
from (select * from t1);

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid' [at 1:13]
with t1 as (select 1 from SimpleTypesWithAnonymizationUid)
            ^
==

# Require explicit uid projection
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
with t1 as (select uid from SimpleTypesWithAnonymizationUid)
select with differential_privacy count(*, contribution_bounds_per_group => (0, 100))
from (select * from t1);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#14 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.$agg1#14]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[SimpleTypesWithAnonymizationUid.uid#11]
    |       +-input_scan=
    |         +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#14]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.$agg1#14]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[t1.uid#13]
            |   +-input_scan=
            |     +-WithRefScan(column_list=[t1.uid#13], with_query_name="t1")
            +-aggregate_list=
              +-$agg1#14 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#14 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.$agg1#14]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[SimpleTypesWithAnonymizationUid.uid#11]
    |       +-input_scan=
    |         +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#14]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.$agg1#14]
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
            |   +-input_scan=
            |   | +-ProjectScan
            |   |   +-column_list=[t1.uid#13]
            |   |   +-input_scan=
            |   |     +-WithRefScan(column_list=[t1.uid#13], with_query_name="t1")
            |   +-group_by_list=
            |   | +-$uid#17 := ColumnRef(type=INT64, column=t1.uid#13)
            |   +-aggregate_list=
            |     +-$agg1_partial#16 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-aggregate_list=
            | +-$agg1#14 :=
            | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
            | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
            | +-$group_selection_threshold_col#20 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-Literal(type=INT64, value=1)
            |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

# Extraneous with clauses
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
with t1 as (select * from SimpleTypesWithAnonymizationUid),
     t2 as (select * from SimpleTypesWithAnonymizationUid),
     t3 as (select * from SimpleTypes)
select with differential_privacy count(*, contribution_bounds_per_group => (0, 100))
from (select * from t1);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#55 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.$agg1#55]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    | | +-with_query_name='t2'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t3'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypes.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, timestamp_seconds#35, timestamp_millis#36, timestamp_micros#37, timestamp_nanos#38, timestamp#39, numeric#40, bignumeric#41, json#42]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypes.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, timestamp_seconds#35, timestamp_millis#36, timestamp_micros#37, timestamp_nanos#38, timestamp#39, numeric#40, bignumeric#41, json#42], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#55]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.$agg1#55]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=t1.[int32#43, int64#44, uint32#45, uint64#46, string#47, bytes#48, bool#49, float#50, double#51, date#52, uid#53, numeric#54]
            |   +-input_scan=
            |     +-WithRefScan(column_list=t1.[int32#43, int64#44, uint32#45, uint64#46, string#47, bytes#48, bool#49, float#50, double#51, date#52, uid#53, numeric#54], with_query_name="t1")
            +-aggregate_list=
              +-$agg1#55 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#55 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.$agg1#55]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    | | +-with_query_name='t2'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t3'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypes.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, timestamp_seconds#35, timestamp_millis#36, timestamp_micros#37, timestamp_nanos#38, timestamp#39, numeric#40, bignumeric#41, json#42]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypes.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, timestamp_seconds#35, timestamp_millis#36, timestamp_micros#37, timestamp_nanos#38, timestamp#39, numeric#40, bignumeric#41, json#42], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#55]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.$agg1#55]
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$aggregate.$agg1_partial#57, $group_by.$uid#58]
            |   +-input_scan=
            |   | +-ProjectScan
            |   |   +-column_list=t1.[int32#43, int64#44, uint32#45, uint64#46, string#47, bytes#48, bool#49, float#50, double#51, date#52, uid#53, numeric#54]
            |   |   +-input_scan=
            |   |     +-WithRefScan(column_list=t1.[int32#43, int64#44, uint32#45, uint64#46, string#47, bytes#48, bool#49, float#50, double#51, date#52, uid#53, numeric#54], with_query_name="t1")
            |   +-group_by_list=
            |   | +-$uid#58 := ColumnRef(type=INT64, column=t1.uid#53)
            |   +-aggregate_list=
            |     +-$agg1_partial#57 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-aggregate_list=
            | +-$agg1#55 :=
            | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#57)
            | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
            | +-$group_selection_threshold_col#61 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-Literal(type=INT64, value=1)
            |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#61)
==

# Reject recursive with clauses referenced from within the anonymization clause
# This is waiting on support for set operations
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
with recursive t1 as (
  (select int64, uid from SimpleTypesWithAnonymizationUid)
  union all
  (select int64+1, uid from t1 where true))
select with differential_privacy count(*) from t1;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-parse_location=0-187
    +-column_list=[$aggregate.$agg1#20]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=$union_all.[int64#13, uid#14]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-parse_location=26-80
    |       |   |   +-column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11]
    |       |   |   +-input_scan=
    |       |   |     +-TableScan(parse_location=49-80, column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
    |       |   +-output_column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-parse_location=97-135
    |           |   +-column_list=[$union_all2.$col1#17, t1.uid#16]
    |           |   +-expr_list=
    |           |   | +-$col1#17 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(parse_location=104-109, type=INT64, column=t1.int64#15)
    |           |   |     +-Literal(parse_location=110-111, type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=t1.[int64#15, uid#16]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=t1.[int64#15, uid#16])
    |           |       +-filter_expr=
    |           |         +-Literal(parse_location=131-135, type=BOOL, value=true)
    |           +-output_column_list=[$union_all2.$col1#17, t1.uid#16]
    +-query=
    | +-ProjectScan
    |   +-column_list=[$aggregate.$agg1#20]
    |   +-input_scan=
    |     +-DifferentialPrivacyAggregateScan
    |       +-column_list=[$aggregate.$agg1#20]
    |       +-input_scan=
    |       | +-WithRefScan(column_list=t1.[int64#18, uid#19], with_query_name="t1")
    |       +-aggregate_list=
    |         +-$agg1#20 :=
    |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    |             +-parse_location=171-176
    |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
    +-recursive=TRUE
[REPLACED_LITERALS]
with recursive t1 as (
  (select int64, uid from SimpleTypesWithAnonymizationUid)
  union all
  (select int64+@_p0_INT64, uid from t1 where @_p1_BOOL))
select with differential_privacy count(*) from t1;

Rewrite ERROR: Unsupported scan type inside of SELECT WITH DIFFERENTIAL_PRIVACY from clause: ResolvedRecursiveScan
==

# Recursive with clauses with differential_privacy inside the WITH entry
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
with recursive t1 as (
  (select with differential_privacy count(*) as c
    from SimpleTypesWithAnonymizationUid)
  union all
  (select c+1 from t1 where true))
select * from t1;
--
QueryStmt
+-output_column_list=
| +-t1.c#17 AS c [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.c#17]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.c#14]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$aggregate.c#13]
    |       |   |   +-input_scan=
    |       |   |     +-DifferentialPrivacyAggregateScan
    |       |   |       +-column_list=[$aggregate.c#13]
    |       |   |       +-input_scan=
    |       |   |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
    |       |   |       +-aggregate_list=
    |       |   |         +-c#13 :=
    |       |   |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    |       |   |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
    |       |   +-output_column_list=[$aggregate.c#13]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#16]
    |           |   +-expr_list=
    |           |   | +-$col1#16 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=t1.c#15)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=[t1.c#15]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=[t1.c#15])
    |           |       +-filter_expr=
    |           |         +-Literal(type=BOOL, value=true)
    |           +-output_column_list=[$union_all2.$col1#16]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.c#17]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.c#17], with_query_name="t1")
    +-recursive=TRUE

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-t1.c#17 AS c [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.c#17]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.c#14]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$aggregate.c#13]
    |       |   |   +-input_scan=
    |       |   |     +-DifferentialPrivacyAggregateScan
    |       |   |       +-column_list=[$aggregate.c#13]
    |       |   |       +-input_scan=
    |       |   |       | +-AggregateScan
    |       |   |       |   +-column_list=[$aggregate.c_partial#20, $group_by.$uid#21]
    |       |   |       |   +-input_scan=
    |       |   |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#18], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
    |       |   |       |   +-group_by_list=
    |       |   |       |   | +-$uid#21 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#18)
    |       |   |       |   +-aggregate_list=
    |       |   |       |     +-c_partial#20 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    |       |   |       +-aggregate_list=
    |       |   |       | +-c#13 :=
    |       |   |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    |       |   |       | |   +-ColumnRef(type=INT64, column=$aggregate.c_partial#20)
    |       |   |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
    |       |   |       | +-$group_selection_threshold_col#24 :=
    |       |   |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    |       |   |       |     +-Literal(type=INT64, value=1)
    |       |   |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
    |       |   |       +-group_selection_threshold_expr=
    |       |   |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#24)
    |       |   +-output_column_list=[$aggregate.c#13]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#16]
    |           |   +-expr_list=
    |           |   | +-$col1#16 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=t1.c#15)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=[t1.c#15]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=[t1.c#15])
    |           |       +-filter_expr=
    |           |         +-Literal(type=BOOL, value=true)
    |           +-output_column_list=[$union_all2.$col1#16]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.c#17]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.c#17], with_query_name="t1")
    +-recursive=TRUE
==

# Reject recursive with clauses with differential_privacy inside the recursive term
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
with recursive t1 as (
  (select int64, uid from SimpleTypesWithAnonymizationUid)
  union all
  (select with differential_privacy SUM(int64) as int64, 1 as uid from t1 where true))
select * from t1;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-t1.int64#19 AS int64 [INT64]
| +-t1.uid#20 AS uid [INT64]
+-query=
  +-WithScan
    +-parse_location=0-197
    +-column_list=t1.[int64#19, uid#20]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=$union_all.[int64#13, uid#14]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-parse_location=26-80
    |       |   |   +-column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11]
    |       |   |   +-input_scan=
    |       |   |     +-TableScan(parse_location=49-80, column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
    |       |   +-output_column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-parse_location=97-178
    |           |   +-column_list=[$aggregate.int64#17, $union_all2.uid#18]
    |           |   +-expr_list=
    |           |   | +-uid#18 := Literal(parse_location=151-152, type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-DifferentialPrivacyAggregateScan
    |           |       +-column_list=[$aggregate.int64#17]
    |           |       +-input_scan=
    |           |       | +-FilterScan
    |           |       |   +-column_list=t1.[int64#15, uid#16]
    |           |       |   +-input_scan=
    |           |       |   | +-RecursiveRefScan(column_list=t1.[int64#15, uid#16])
    |           |       |   +-filter_expr=
    |           |       |     +-Literal(parse_location=174-178, type=BOOL, value=true)
    |           |       +-aggregate_list=
    |           |         +-int64#17 :=
    |           |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    |           |             +-parse_location=130-133
    |           |             +-ColumnRef(parse_location=134-139, type=INT64, column=t1.int64#15)
    |           |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
    |           +-output_column_list=[$aggregate.int64#17, $union_all2.uid#18]
    +-query=
    | +-ProjectScan
    |   +-column_list=t1.[int64#19, uid#20]
    |   +-input_scan=
    |     +-WithRefScan(column_list=t1.[int64#19, uid#20], with_query_name="t1")
    +-recursive=TRUE
[REPLACED_LITERALS]
with recursive t1 as (
  (select int64, uid from SimpleTypesWithAnonymizationUid)
  union all
  (select with differential_privacy SUM(int64) as int64, @_p0_INT64 as uid from t1 where @_p1_BOOL))
select * from t1;

Rewrite ERROR: Unsupported scan type inside of SELECT WITH DIFFERENTIAL_PRIVACY from clause: ResolvedRecursiveRefScan [at 4:4]
  (select with differential_privacy SUM(int64) as int64, 1 as uid from t1 whe...
   ^
==

# Reject uid projection via anonymization in WITH entry
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
with t as (select with differential_privacy uid, count(*)
                  from SimpleTypesWithAnonymizationUid
                  group by uid)
select with differential_privacy count(*)
from t;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#17 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-parse_location=0-193
    +-column_list=[$aggregate.$agg1#17]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-parse_location=11-143
    |       +-column_list=[$groupby.uid#14, $aggregate.$agg1#13]
    |       +-input_scan=
    |         +-DifferentialPrivacyAggregateScan
    |           +-column_list=[$groupby.uid#14, $aggregate.$agg1#13]
    |           +-input_scan=
    |           | +-TableScan(parse_location=81-112, column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
    |           +-group_by_list=
    |           | +-uid#14 := ColumnRef(parse_location=44-47, type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
    |           +-aggregate_list=
    |             +-$agg1#13 :=
    |               +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    |                 +-parse_location=49-54
    |                 +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#17]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.$agg1#17]
            +-input_scan=
            | +-WithRefScan(column_list=t.[uid#15, $col2#16], with_query_name="t")
            +-aggregate_list=
              +-$agg1#17 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-parse_location=178-183
                  +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
[REPLACED_LITERALS]
with t as (select with differential_privacy uid, count(*)
                  from SimpleTypesWithAnonymizationUid
                  group by uid)
select with differential_privacy count(*)
from t;

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid' [at 1:12]
with t as (select with differential_privacy uid, count(*)
           ^
==

# Extraneous with clauses
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
with t1 as (select * from SimpleTypesWithAnonymizationUid),
     t2 as (select * from SimpleTypes)
select 1 from t2;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#49 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-column_list=[$query.$col1#49]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypes.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, timestamp_seconds#23, timestamp_millis#24, timestamp_micros#25, timestamp_nanos#26, timestamp#27, numeric#28, bignumeric#29, json#30]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypes.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, timestamp_seconds#23, timestamp_millis#24, timestamp_micros#25, timestamp_nanos#26, timestamp#27, numeric#28, bignumeric#29, json#30], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
    +-query=
      +-ProjectScan
        +-column_list=[$query.$col1#49]
        +-expr_list=
        | +-$col1#49 := Literal(type=INT64, value=1)
        +-input_scan=
          +-WithRefScan(column_list=t2.[int32#31, int64#32, uint32#33, uint64#34, string#35, bytes#36, bool#37, float#38, double#39, date#40, timestamp_seconds#41, timestamp_millis#42, timestamp_micros#43, timestamp_nanos#44, timestamp#45, numeric#46, bignumeric#47, json#48], with_query_name="t2")
==

# Extraneous with clauses
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
with t1 as (select with differential_privacy count(*) from SimpleTypesWithAnonymizationUid),
     t2 as (select * from SimpleTypes)
select 1 from t2;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#50 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-column_list=[$query.$col1#50]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$aggregate.$agg1#13]
    | |     +-input_scan=
    | |       +-DifferentialPrivacyAggregateScan
    | |         +-column_list=[$aggregate.$agg1#13]
    | |         +-input_scan=
    | |         | +-TableScan(table=SimpleTypesWithAnonymizationUid)
    | |         +-aggregate_list=
    | |           +-$agg1#13 :=
    | |             +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    | |               +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypes.[int32#14, int64#15, uint32#16, uint64#17, string#18, bytes#19, bool#20, float#21, double#22, date#23, timestamp_seconds#24, timestamp_millis#25, timestamp_micros#26, timestamp_nanos#27, timestamp#28, numeric#29, bignumeric#30, json#31]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypes.[int32#14, int64#15, uint32#16, uint64#17, string#18, bytes#19, bool#20, float#21, double#22, date#23, timestamp_seconds#24, timestamp_millis#25, timestamp_micros#26, timestamp_nanos#27, timestamp#28, numeric#29, bignumeric#30, json#31], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
    +-query=
      +-ProjectScan
        +-column_list=[$query.$col1#50]
        +-expr_list=
        | +-$col1#50 := Literal(type=INT64, value=1)
        +-input_scan=
          +-WithRefScan(column_list=t2.[int32#32, int64#33, uint32#34, uint64#35, string#36, bytes#37, bool#38, float#39, double#40, date#41, timestamp_seconds#42, timestamp_millis#43, timestamp_micros#44, timestamp_nanos#45, timestamp#46, numeric#47, bignumeric#48, json#49], with_query_name="t2")

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#50 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-column_list=[$query.$col1#50]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$aggregate.$agg1#13]
    | |     +-input_scan=
    | |       +-DifferentialPrivacyAggregateScan
    | |         +-column_list=[$aggregate.$agg1#13]
    | |         +-input_scan=
    | |         | +-AggregateScan
    | |         |   +-column_list=[$aggregate.$agg1_partial#53, $group_by.$uid#54]
    | |         |   +-input_scan=
    | |         |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#51], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
    | |         |   +-group_by_list=
    | |         |   | +-$uid#54 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#51)
    | |         |   +-aggregate_list=
    | |         |     +-$agg1_partial#53 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    | |         +-aggregate_list=
    | |         | +-$agg1#13 :=
    | |         | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    | |         | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#53)
    | |         | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
    | |         | +-$group_selection_threshold_col#57 :=
    | |         |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    | |         |     +-Literal(type=INT64, value=1)
    | |         |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
    | |         +-group_selection_threshold_expr=
    | |           +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#57)
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypes.[int32#14, int64#15, uint32#16, uint64#17, string#18, bytes#19, bool#20, float#21, double#22, date#23, timestamp_seconds#24, timestamp_millis#25, timestamp_micros#26, timestamp_nanos#27, timestamp#28, numeric#29, bignumeric#30, json#31]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypes.[int32#14, int64#15, uint32#16, uint64#17, string#18, bytes#19, bool#20, float#21, double#22, date#23, timestamp_seconds#24, timestamp_millis#25, timestamp_micros#26, timestamp_nanos#27, timestamp#28, numeric#29, bignumeric#30, json#31], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
    +-query=
      +-ProjectScan
        +-column_list=[$query.$col1#50]
        +-expr_list=
        | +-$col1#50 := Literal(type=INT64, value=1)
        +-input_scan=
          +-WithRefScan(column_list=t2.[int32#32, int64#33, uint32#34, uint64#35, string#36, bytes#37, bool#38, float#39, double#40, date#41, timestamp_seconds#42, timestamp_millis#43, timestamp_micros#44, timestamp_nanos#45, timestamp#46, numeric#47, bignumeric#48, json#49], with_query_name="t2")
==


# Extraneous with clauses
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
with t1 as (select * from SimpleTypesWithAnonymizationUid),
     t2 as (select * from SimpleTypes)
select with differential_privacy count(*, contribution_bounds_per_group => (0, 100))
from (select * from t1)
union all
SELECT count(*) from t2;
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#63 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-column_list=[$union_all.$col1#63]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypes.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, timestamp_seconds#23, timestamp_millis#24, timestamp_micros#25, timestamp_nanos#26, timestamp#27, numeric#28, bignumeric#29, json#30]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypes.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, timestamp_seconds#23, timestamp_millis#24, timestamp_micros#25, timestamp_nanos#26, timestamp#27, numeric#28, bignumeric#29, json#30], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
    +-query=
      +-SetOperationScan
        +-column_list=[$union_all.$col1#63]
        +-op_type=UNION_ALL
        +-input_item_list=
          +-SetOperationItem
          | +-scan=
          | | +-ProjectScan
          | |   +-column_list=[$aggregate.$agg1#43]
          | |   +-input_scan=
          | |     +-DifferentialPrivacyAggregateScan
          | |       +-column_list=[$aggregate.$agg1#43]
          | |       +-input_scan=
          | |       | +-ProjectScan
          | |       |   +-column_list=t1.[int32#31, int64#32, uint32#33, uint64#34, string#35, bytes#36, bool#37, float#38, double#39, date#40, uid#41, numeric#42]
          | |       |   +-input_scan=
          | |       |     +-WithRefScan(column_list=t1.[int32#31, int64#32, uint32#33, uint64#34, string#35, bytes#36, bool#37, float#38, double#39, date#40, uid#41, numeric#42], with_query_name="t1")
          | |       +-aggregate_list=
          | |         +-$agg1#43 :=
          | |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          | |             +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
          | +-output_column_list=[$aggregate.$agg1#43]
          +-SetOperationItem
            +-scan=
            | +-ProjectScan
            |   +-column_list=[$aggregate.$agg1#62]
            |   +-input_scan=
            |     +-AggregateScan
            |       +-column_list=[$aggregate.$agg1#62]
            |       +-input_scan=
            |       | +-WithRefScan(column_list=t2.[int32#44, int64#45, uint32#46, uint64#47, string#48, bytes#49, bool#50, float#51, double#52, date#53, timestamp_seconds#54, timestamp_millis#55, timestamp_micros#56, timestamp_nanos#57, timestamp#58, numeric#59, bignumeric#60, json#61], with_query_name="t2")
            |       +-aggregate_list=
            |         +-$agg1#62 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-output_column_list=[$aggregate.$agg1#62]

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$union_all.$col1#63 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-column_list=[$union_all.$col1#63]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypes.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, timestamp_seconds#23, timestamp_millis#24, timestamp_micros#25, timestamp_nanos#26, timestamp#27, numeric#28, bignumeric#29, json#30]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypes.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, timestamp_seconds#23, timestamp_millis#24, timestamp_micros#25, timestamp_nanos#26, timestamp#27, numeric#28, bignumeric#29, json#30], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
    +-query=
      +-SetOperationScan
        +-column_list=[$union_all.$col1#63]
        +-op_type=UNION_ALL
        +-input_item_list=
          +-SetOperationItem
          | +-scan=
          | | +-ProjectScan
          | |   +-column_list=[$aggregate.$agg1#43]
          | |   +-input_scan=
          | |     +-DifferentialPrivacyAggregateScan
          | |       +-column_list=[$aggregate.$agg1#43]
          | |       +-input_scan=
          | |       | +-AggregateScan
          | |       |   +-column_list=[$aggregate.$agg1_partial#65, $group_by.$uid#66]
          | |       |   +-input_scan=
          | |       |   | +-ProjectScan
          | |       |   |   +-column_list=t1.[int32#31, int64#32, uint32#33, uint64#34, string#35, bytes#36, bool#37, float#38, double#39, date#40, uid#41, numeric#42]
          | |       |   |   +-input_scan=
          | |       |   |     +-WithRefScan(column_list=t1.[int32#31, int64#32, uint32#33, uint64#34, string#35, bytes#36, bool#37, float#38, double#39, date#40, uid#41, numeric#42], with_query_name="t1")
          | |       |   +-group_by_list=
          | |       |   | +-$uid#66 := ColumnRef(type=INT64, column=t1.uid#41)
          | |       |   +-aggregate_list=
          | |       |     +-$agg1_partial#65 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
          | |       +-aggregate_list=
          | |       | +-$agg1#43 :=
          | |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          | |       | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#65)
          | |       | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
          | |       | +-$group_selection_threshold_col#69 :=
          | |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          | |       |     +-Literal(type=INT64, value=1)
          | |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
          | |       +-group_selection_threshold_expr=
          | |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#69)
          | +-output_column_list=[$aggregate.$agg1#43]
          +-SetOperationItem
            +-scan=
            | +-ProjectScan
            |   +-column_list=[$aggregate.$agg1#62]
            |   +-input_scan=
            |     +-AggregateScan
            |       +-column_list=[$aggregate.$agg1#62]
            |       +-input_scan=
            |       | +-WithRefScan(column_list=t2.[int32#44, int64#45, uint32#46, uint64#47, string#48, bytes#49, bool#50, float#51, double#52, date#53, timestamp_seconds#54, timestamp_millis#55, timestamp_micros#56, timestamp_nanos#57, timestamp#58, numeric#59, bignumeric#60, json#61], with_query_name="t2")
            |       +-aggregate_list=
            |         +-$agg1#62 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-output_column_list=[$aggregate.$agg1#62]
==


# Nested with clauses
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
WITH t1 as (select * from SimpleTypesWithAnonymizationUid),
     t2 as (select * from t1)
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count from t2;
--
QueryStmt
+-output_column_list=
| +-$aggregate.count#37 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#37]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
    |       +-input_scan=
    |         +-WithRefScan(column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t1")
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#37]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#37]
            +-input_scan=
            | +-WithRefScan(column_list=t2.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36], with_query_name="t2")
            +-aggregate_list=
              +-count#37 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.count#37 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#37]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
    |       +-input_scan=
    |         +-WithRefScan(column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t1")
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#37]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#37]
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$aggregate.count_partial#39, $group_by.$uid#40]
            |   +-input_scan=
            |   | +-WithRefScan(column_list=t2.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36], with_query_name="t2")
            |   +-group_by_list=
            |   | +-$uid#40 := ColumnRef(type=INT64, column=t2.uid#35)
            |   +-aggregate_list=
            |     +-count_partial#39 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-aggregate_list=
            | +-count#37 :=
            | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#39)
            | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
            | +-$group_selection_threshold_col#43 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-Literal(type=INT64, value=1)
            |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#43)
==

# Join user data with and user data table
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
WITH t1 as (select * from SimpleTypesWithAnonymizationUid)
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from t1
inner join SimpleTypesWithAnonymizationUid t2 on t1.uid = t2.uid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.count#37 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#37]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#37]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#37]
            +-input_scan=
            | +-JoinScan
            |   +-column_list=[t1.int32#13, t1.int64#14, t1.uint32#15, t1.uint64#16, t1.string#17, t1.bytes#18, t1.bool#19, t1.float#20, t1.double#21, t1.date#22, t1.uid#23, t1.numeric#24, SimpleTypesWithAnonymizationUid.uid#35]
            |   +-left_scan=
            |   | +-WithRefScan(column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t1")
            |   +-right_scan=
            |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#35], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias='t2')
            |   +-join_expr=
            |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |       +-ColumnRef(type=INT64, column=t1.uid#23)
            |       +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#35)
            +-aggregate_list=
              +-count#37 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.count#37 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#37]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#37]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#37]
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$aggregate.count_partial#39, $group_by.$uid#40]
            |   +-input_scan=
            |   | +-JoinScan
            |   |   +-column_list=[t1.int32#13, t1.int64#14, t1.uint32#15, t1.uint64#16, t1.string#17, t1.bytes#18, t1.bool#19, t1.float#20, t1.double#21, t1.date#22, t1.uid#23, t1.numeric#24, SimpleTypesWithAnonymizationUid.uid#35]
            |   |   +-left_scan=
            |   |   | +-WithRefScan(column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t1")
            |   |   +-right_scan=
            |   |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#35], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias='t2')
            |   |   +-join_expr=
            |   |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |   |       +-ColumnRef(type=INT64, column=t1.uid#23)
            |   |       +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#35)
            |   +-group_by_list=
            |   | +-$uid#40 := ColumnRef(type=INT64, column=t1.uid#23)
            |   +-aggregate_list=
            |     +-count_partial#39 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-aggregate_list=
            | +-count#37 :=
            | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#39)
            | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
            | +-$group_selection_threshold_col#43 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-Literal(type=INT64, value=1)
            |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#43)
==

# Require join clause for join user data with and user data table
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
WITH t1 as (select * from SimpleTypesWithAnonymizationUid)
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from t1
cross join SimpleTypesWithAnonymizationUid t2;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.count#37 AS count [INT64]
+-query=
  +-WithScan
    +-parse_location=0-163
    +-column_list=[$aggregate.count#37]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-parse_location=12-57
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    |       +-input_scan=
    |         +-TableScan(parse_location=26-57, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#37]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#37]
            +-input_scan=
            | +-JoinScan
            |   +-parse_location=118-128
            |   +-column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
            |   +-left_scan=
            |   | +-WithRefScan(column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t1")
            |   +-right_scan=
            |     +-TableScan(parse_location=129-160, table=SimpleTypesWithAnonymizationUid, alias='t2')
            +-aggregate_list=
              +-count#37 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-parse_location=92-97
                  +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
[REPLACED_LITERALS]
WITH t1 as (select * from SimpleTypesWithAnonymizationUid)
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from t1
cross join SimpleTypesWithAnonymizationUid t2;

Rewrite ERROR: Joins between tables containing private data must explicitly join on the user id column in each table, add 'ON t1.uid=t2.uid' [at 4:1]
cross join SimpleTypesWithAnonymizationUid t2;
^
==

# Join user data with and non-user data table
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
WITH t1 as (select * from SimpleTypesWithAnonymizationUid)
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from t1
cross join SimpleTypes;
--
QueryStmt
+-output_column_list=
| +-$aggregate.count#43 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#43]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#43]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#43]
            +-input_scan=
            | +-JoinScan
            |   +-column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
            |   +-left_scan=
            |   | +-WithRefScan(column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t1")
            |   +-right_scan=
            |     +-TableScan(table=SimpleTypes)
            +-aggregate_list=
              +-count#43 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.count#43 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#43]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#43]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#43]
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$aggregate.count_partial#45, $group_by.$uid#46]
            |   +-input_scan=
            |   | +-JoinScan
            |   |   +-column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
            |   |   +-left_scan=
            |   |   | +-WithRefScan(column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t1")
            |   |   +-right_scan=
            |   |     +-TableScan(table=SimpleTypes)
            |   +-group_by_list=
            |   | +-$uid#46 := ColumnRef(type=INT64, column=t1.uid#23)
            |   +-aggregate_list=
            |     +-count_partial#45 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-aggregate_list=
            | +-count#43 :=
            | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#45)
            | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
            | +-$group_selection_threshold_col#49 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-Literal(type=INT64, value=1)
            |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#49)
==

# Join non-user data with and user data table
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
WITH t1 as (select 1)
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from t1
cross join SimpleTypesWithAnonymizationUid t2;
--
QueryStmt
+-output_column_list=
| +-$aggregate.count#15 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#15]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t1.$col1#1]
    |       +-expr_list=
    |       | +-$col1#1 := Literal(type=INT64, value=1)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#15]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#15]
            +-input_scan=
            | +-JoinScan
            |   +-column_list=[t1.$col1#2]
            |   +-left_scan=
            |   | +-WithRefScan(column_list=[t1.$col1#2], with_query_name="t1")
            |   +-right_scan=
            |     +-TableScan(table=SimpleTypesWithAnonymizationUid, alias='t2')
            +-aggregate_list=
              +-count#15 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.count#15 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#15]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t1.$col1#1]
    |       +-expr_list=
    |       | +-$col1#1 := Literal(type=INT64, value=1)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#15]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#15]
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$aggregate.count_partial#18, $group_by.$uid#19]
            |   +-input_scan=
            |   | +-JoinScan
            |   |   +-column_list=[t1.$col1#2, SimpleTypesWithAnonymizationUid.uid#16]
            |   |   +-left_scan=
            |   |   | +-WithRefScan(column_list=[t1.$col1#2], with_query_name="t1")
            |   |   +-right_scan=
            |   |     +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#16], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias='t2')
            |   +-group_by_list=
            |   | +-$uid#19 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#16)
            |   +-aggregate_list=
            |     +-count_partial#18 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-aggregate_list=
            | +-count#15 :=
            | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#18)
            | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
            | +-$group_selection_threshold_col#22 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-Literal(type=INT64, value=1)
            |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#22)
==

# Join user data with and user data with
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
WITH t1 as (select * from SimpleTypesWithAnonymizationUid),
     t2 as (select * from SimpleTypesWithAnonymizationUid)
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from t1
inner join t2 on t1.uid = t2.uid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.count#49 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#49]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#49]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#49]
            +-input_scan=
            | +-JoinScan
            |   +-column_list=[t1.int32#25, t1.int64#26, t1.uint32#27, t1.uint64#28, t1.string#29, t1.bytes#30, t1.bool#31, t1.float#32, t1.double#33, t1.date#34, t1.uid#35, t1.numeric#36, t2.int32#37, t2.int64#38, t2.uint32#39, t2.uint64#40, t2.string#41, t2.bytes#42, t2.bool#43, t2.float#44, t2.double#45, t2.date#46, t2.uid#47, t2.numeric#48]
            |   +-left_scan=
            |   | +-WithRefScan(column_list=t1.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36], with_query_name="t1")
            |   +-right_scan=
            |   | +-WithRefScan(column_list=t2.[int32#37, int64#38, uint32#39, uint64#40, string#41, bytes#42, bool#43, float#44, double#45, date#46, uid#47, numeric#48], with_query_name="t2")
            |   +-join_expr=
            |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |       +-ColumnRef(type=INT64, column=t1.uid#35)
            |       +-ColumnRef(type=INT64, column=t2.uid#47)
            +-aggregate_list=
              +-count#49 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.count#49 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#49]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#49]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#49]
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$aggregate.count_partial#51, $group_by.$uid#52]
            |   +-input_scan=
            |   | +-JoinScan
            |   |   +-column_list=[t1.int32#25, t1.int64#26, t1.uint32#27, t1.uint64#28, t1.string#29, t1.bytes#30, t1.bool#31, t1.float#32, t1.double#33, t1.date#34, t1.uid#35, t1.numeric#36, t2.int32#37, t2.int64#38, t2.uint32#39, t2.uint64#40, t2.string#41, t2.bytes#42, t2.bool#43, t2.float#44, t2.double#45, t2.date#46, t2.uid#47, t2.numeric#48]
            |   |   +-left_scan=
            |   |   | +-WithRefScan(column_list=t1.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36], with_query_name="t1")
            |   |   +-right_scan=
            |   |   | +-WithRefScan(column_list=t2.[int32#37, int64#38, uint32#39, uint64#40, string#41, bytes#42, bool#43, float#44, double#45, date#46, uid#47, numeric#48], with_query_name="t2")
            |   |   +-join_expr=
            |   |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |   |       +-ColumnRef(type=INT64, column=t1.uid#35)
            |   |       +-ColumnRef(type=INT64, column=t2.uid#47)
            |   +-group_by_list=
            |   | +-$uid#52 := ColumnRef(type=INT64, column=t1.uid#35)
            |   +-aggregate_list=
            |     +-count_partial#51 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-aggregate_list=
            | +-count#49 :=
            | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#51)
            | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
            | +-$group_selection_threshold_col#55 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-Literal(type=INT64, value=1)
            |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#55)
==

# Require join clause for join user data with and user data with
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
WITH t1 as (select * from SimpleTypesWithAnonymizationUid),
     t2 as (select * from SimpleTypesWithAnonymizationUid)
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from t1
cross join t2;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.count#49 AS count [INT64]
+-query=
  +-WithScan
    +-parse_location=0-191
    +-column_list=[$aggregate.count#49]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-parse_location=12-57
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(parse_location=26-57, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-parse_location=72-117
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
    |       +-input_scan=
    |         +-TableScan(parse_location=86-117, column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#49]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#49]
            +-input_scan=
            | +-JoinScan
            |   +-parse_location=178-188
            |   +-column_list=[t1.int32#25, t1.int64#26, t1.uint32#27, t1.uint64#28, t1.string#29, t1.bytes#30, t1.bool#31, t1.float#32, t1.double#33, t1.date#34, t1.uid#35, t1.numeric#36, t2.int32#37, t2.int64#38, t2.uint32#39, t2.uint64#40, t2.string#41, t2.bytes#42, t2.bool#43, t2.float#44, t2.double#45, t2.date#46, t2.uid#47, t2.numeric#48]
            |   +-left_scan=
            |   | +-WithRefScan(column_list=t1.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36], with_query_name="t1")
            |   +-right_scan=
            |     +-WithRefScan(column_list=t2.[int32#37, int64#38, uint32#39, uint64#40, string#41, bytes#42, bool#43, float#44, double#45, date#46, uid#47, numeric#48], with_query_name="t2")
            +-aggregate_list=
              +-count#49 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-parse_location=152-157
                  +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
[REPLACED_LITERALS]
WITH t1 as (select * from SimpleTypesWithAnonymizationUid),
     t2 as (select * from SimpleTypesWithAnonymizationUid)
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from t1
cross join t2;

Rewrite ERROR: Joins between tables containing private data must explicitly join on the user id column in each table, add 'ON t1.uid=t2.uid' [at 5:1]
cross join t2;
^
==

# Join user data with and non-user data with
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
WITH t1 as (select * from SimpleTypesWithAnonymizationUid),
     t2 as (select 1)
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from t1
cross join t2;
--
QueryStmt
+-output_column_list=
| +-$aggregate.count#27 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#27]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t2.$col1#13]
    |       +-expr_list=
    |       | +-$col1#13 := Literal(type=INT64, value=1)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#27]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#27]
            +-input_scan=
            | +-JoinScan
            |   +-column_list=[t1.int32#14, t1.int64#15, t1.uint32#16, t1.uint64#17, t1.string#18, t1.bytes#19, t1.bool#20, t1.float#21, t1.double#22, t1.date#23, t1.uid#24, t1.numeric#25, t2.$col1#26]
            |   +-left_scan=
            |   | +-WithRefScan(column_list=t1.[int32#14, int64#15, uint32#16, uint64#17, string#18, bytes#19, bool#20, float#21, double#22, date#23, uid#24, numeric#25], with_query_name="t1")
            |   +-right_scan=
            |     +-WithRefScan(column_list=[t2.$col1#26], with_query_name="t2")
            +-aggregate_list=
              +-count#27 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.count#27 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#27]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t2.$col1#13]
    |       +-expr_list=
    |       | +-$col1#13 := Literal(type=INT64, value=1)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#27]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#27]
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$aggregate.count_partial#29, $group_by.$uid#30]
            |   +-input_scan=
            |   | +-JoinScan
            |   |   +-column_list=[t1.int32#14, t1.int64#15, t1.uint32#16, t1.uint64#17, t1.string#18, t1.bytes#19, t1.bool#20, t1.float#21, t1.double#22, t1.date#23, t1.uid#24, t1.numeric#25, t2.$col1#26]
            |   |   +-left_scan=
            |   |   | +-WithRefScan(column_list=t1.[int32#14, int64#15, uint32#16, uint64#17, string#18, bytes#19, bool#20, float#21, double#22, date#23, uid#24, numeric#25], with_query_name="t1")
            |   |   +-right_scan=
            |   |     +-WithRefScan(column_list=[t2.$col1#26], with_query_name="t2")
            |   +-group_by_list=
            |   | +-$uid#30 := ColumnRef(type=INT64, column=t1.uid#24)
            |   +-aggregate_list=
            |     +-count_partial#29 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-aggregate_list=
            | +-count#27 :=
            | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#29)
            | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
            | +-$group_selection_threshold_col#33 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-Literal(type=INT64, value=1)
            |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#33)
==

# Repeated joins of user data withs and non-user data withs
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
WITH t1 as (select * from SimpleTypesWithAnonymizationUid),
     t2 as (select 1)
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from t1 as t1
cross join t2 as t2
inner join t1 as t3 on t1.uid = t3.uid
cross join t2 as t4
--
QueryStmt
+-output_column_list=
| +-$aggregate.count#40 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#40]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t2.$col1#13]
    |       +-expr_list=
    |       | +-$col1#13 := Literal(type=INT64, value=1)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#40]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#40]
            +-input_scan=
            | +-JoinScan
            |   +-column_list=[t1.int32#14, t1.int64#15, t1.uint32#16, t1.uint64#17, t1.string#18, t1.bytes#19, t1.bool#20, t1.float#21, t1.double#22, t1.date#23, t1.uid#24, t1.numeric#25, t2.$col1#26, t1.int32#27, t1.int64#28, t1.uint32#29, t1.uint64#30, t1.string#31, t1.bytes#32, t1.bool#33, t1.float#34, t1.double#35, t1.date#36, t1.uid#37, t1.numeric#38, t2.$col1#39]
            |   +-left_scan=
            |   | +-JoinScan
            |   |   +-column_list=[t1.int32#14, t1.int64#15, t1.uint32#16, t1.uint64#17, t1.string#18, t1.bytes#19, t1.bool#20, t1.float#21, t1.double#22, t1.date#23, t1.uid#24, t1.numeric#25, t2.$col1#26, t1.int32#27, t1.int64#28, t1.uint32#29, t1.uint64#30, t1.string#31, t1.bytes#32, t1.bool#33, t1.float#34, t1.double#35, t1.date#36, t1.uid#37, t1.numeric#38]
            |   |   +-left_scan=
            |   |   | +-JoinScan
            |   |   |   +-column_list=[t1.int32#14, t1.int64#15, t1.uint32#16, t1.uint64#17, t1.string#18, t1.bytes#19, t1.bool#20, t1.float#21, t1.double#22, t1.date#23, t1.uid#24, t1.numeric#25, t2.$col1#26]
            |   |   |   +-left_scan=
            |   |   |   | +-WithRefScan(column_list=t1.[int32#14, int64#15, uint32#16, uint64#17, string#18, bytes#19, bool#20, float#21, double#22, date#23, uid#24, numeric#25], with_query_name="t1")
            |   |   |   +-right_scan=
            |   |   |     +-WithRefScan(column_list=[t2.$col1#26], with_query_name="t2")
            |   |   +-right_scan=
            |   |   | +-WithRefScan(column_list=t1.[int32#27, int64#28, uint32#29, uint64#30, string#31, bytes#32, bool#33, float#34, double#35, date#36, uid#37, numeric#38], with_query_name="t1")
            |   |   +-join_expr=
            |   |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |   |       +-ColumnRef(type=INT64, column=t1.uid#24)
            |   |       +-ColumnRef(type=INT64, column=t1.uid#37)
            |   +-right_scan=
            |     +-WithRefScan(column_list=[t2.$col1#39], with_query_name="t2")
            +-aggregate_list=
              +-count#40 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.count#40 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#40]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t2.$col1#13]
    |       +-expr_list=
    |       | +-$col1#13 := Literal(type=INT64, value=1)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#40]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.count#40]
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$aggregate.count_partial#42, $group_by.$uid#43]
            |   +-input_scan=
            |   | +-JoinScan
            |   |   +-column_list=[t1.int32#14, t1.int64#15, t1.uint32#16, t1.uint64#17, t1.string#18, t1.bytes#19, t1.bool#20, t1.float#21, t1.double#22, t1.date#23, t1.uid#24, t1.numeric#25, t2.$col1#26, t1.int32#27, t1.int64#28, t1.uint32#29, t1.uint64#30, t1.string#31, t1.bytes#32, t1.bool#33, t1.float#34, t1.double#35, t1.date#36, t1.uid#37, t1.numeric#38, t2.$col1#39]
            |   |   +-left_scan=
            |   |   | +-JoinScan
            |   |   |   +-column_list=[t1.int32#14, t1.int64#15, t1.uint32#16, t1.uint64#17, t1.string#18, t1.bytes#19, t1.bool#20, t1.float#21, t1.double#22, t1.date#23, t1.uid#24, t1.numeric#25, t2.$col1#26, t1.int32#27, t1.int64#28, t1.uint32#29, t1.uint64#30, t1.string#31, t1.bytes#32, t1.bool#33, t1.float#34, t1.double#35, t1.date#36, t1.uid#37, t1.numeric#38]
            |   |   |   +-left_scan=
            |   |   |   | +-JoinScan
            |   |   |   |   +-column_list=[t1.int32#14, t1.int64#15, t1.uint32#16, t1.uint64#17, t1.string#18, t1.bytes#19, t1.bool#20, t1.float#21, t1.double#22, t1.date#23, t1.uid#24, t1.numeric#25, t2.$col1#26]
            |   |   |   |   +-left_scan=
            |   |   |   |   | +-WithRefScan(column_list=t1.[int32#14, int64#15, uint32#16, uint64#17, string#18, bytes#19, bool#20, float#21, double#22, date#23, uid#24, numeric#25], with_query_name="t1")
            |   |   |   |   +-right_scan=
            |   |   |   |     +-WithRefScan(column_list=[t2.$col1#26], with_query_name="t2")
            |   |   |   +-right_scan=
            |   |   |   | +-WithRefScan(column_list=t1.[int32#27, int64#28, uint32#29, uint64#30, string#31, bytes#32, bool#33, float#34, double#35, date#36, uid#37, numeric#38], with_query_name="t1")
            |   |   |   +-join_expr=
            |   |   |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |   |   |       +-ColumnRef(type=INT64, column=t1.uid#24)
            |   |   |       +-ColumnRef(type=INT64, column=t1.uid#37)
            |   |   +-right_scan=
            |   |     +-WithRefScan(column_list=[t2.$col1#39], with_query_name="t2")
            |   +-group_by_list=
            |   | +-$uid#43 := ColumnRef(type=INT64, column=t1.uid#24)
            |   +-aggregate_list=
            |     +-count_partial#42 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-aggregate_list=
            | +-count#40 :=
            | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#42)
            | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
            | +-$group_selection_threshold_col#46 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-Literal(type=INT64, value=1)
            |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#46)
==

# Nested with entires in subqueries outside of WITH DIFFERENTIAL_PRIVACY subquery
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
WITH t1 as (select * from SimpleTypesWithAnonymizationUid)
SELECT * FROM (
  WITH t2 as (select * from t1)
  SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
  from t2)
--
QueryStmt
+-output_column_list=
| +-$aggregate.count#37 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#37]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#37]
        +-input_scan=
          +-WithScan
            +-column_list=[$aggregate.count#37]
            +-with_entry_list=
            | +-WithEntry
            |   +-with_query_name='t2'
            |   +-with_subquery=
            |     +-ProjectScan
            |       +-column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
            |       +-input_scan=
            |         +-WithRefScan(column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t1")
            +-query=
              +-ProjectScan
                +-column_list=[$aggregate.count#37]
                +-input_scan=
                  +-DifferentialPrivacyAggregateScan
                    +-column_list=[$aggregate.count#37]
                    +-input_scan=
                    | +-WithRefScan(column_list=t2.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36], with_query_name="t2")
                    +-aggregate_list=
                      +-count#37 :=
                        +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                          +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.count#37 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.count#37]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.count#37]
        +-input_scan=
          +-WithScan
            +-column_list=[$aggregate.count#37]
            +-with_entry_list=
            | +-WithEntry
            |   +-with_query_name='t2'
            |   +-with_subquery=
            |     +-ProjectScan
            |       +-column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
            |       +-input_scan=
            |         +-WithRefScan(column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t1")
            +-query=
              +-ProjectScan
                +-column_list=[$aggregate.count#37]
                +-input_scan=
                  +-DifferentialPrivacyAggregateScan
                    +-column_list=[$aggregate.count#37]
                    +-input_scan=
                    | +-AggregateScan
                    |   +-column_list=[$aggregate.count_partial#39, $group_by.$uid#40]
                    |   +-input_scan=
                    |   | +-WithRefScan(column_list=t2.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36], with_query_name="t2")
                    |   +-group_by_list=
                    |   | +-$uid#40 := ColumnRef(type=INT64, column=t2.uid#35)
                    |   +-aggregate_list=
                    |     +-count_partial#39 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
                    +-aggregate_list=
                    | +-count#37 :=
                    | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                    | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#39)
                    | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
                    | +-$group_selection_threshold_col#43 :=
                    |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                    |     +-Literal(type=INT64, value=1)
                    |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
                    +-group_selection_threshold_expr=
                      +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#43)
==


# WithScan inside SELECT WITH DIFFERENTIAL_PRIVACY
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*, contribution_bounds_per_group => (0, 100))
from (
  with t1 as (select * from SimpleTypesWithAnonymizationUid)
  select * from t1);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#25 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#25]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#25]
        +-input_scan=
        | +-WithScan
        |   +-column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
        |   +-with_entry_list=
        |   | +-WithEntry
        |   |   +-with_query_name='t1'
        |   |   +-with_subquery=
        |   |     +-ProjectScan
        |   |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |   +-query=
        |     +-ProjectScan
        |       +-column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
        |       +-input_scan=
        |         +-WithRefScan(column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t1")
        +-aggregate_list=
          +-$agg1#25 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#25 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#25]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#25]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#27, $group_by.$uid#28]
        |   +-input_scan=
        |   | +-WithScan
        |   |   +-column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
        |   |   +-with_entry_list=
        |   |   | +-WithEntry
        |   |   |   +-with_query_name='t1'
        |   |   |   +-with_subquery=
        |   |   |     +-ProjectScan
        |   |   |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |   |   |       +-input_scan=
        |   |   |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |   |   +-query=
        |   |     +-ProjectScan
        |   |       +-column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
        |   |       +-input_scan=
        |   |         +-WithRefScan(column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t1")
        |   +-group_by_list=
        |   | +-$uid#28 := ColumnRef(type=INT64, column=t1.uid#23)
        |   +-aggregate_list=
        |     +-$agg1_partial#27 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#25 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#27)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$group_selection_threshold_col#31 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#31)
==

# Nested WithScan inside SELECT WITH DIFFERENTIAL_PRIVACY
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
with t1 as (select * from SimpleTypesWithAnonymizationUid)
select with differential_privacy count(*, contribution_bounds_per_group => (0, 100))
from (
  with t2 as (select * from t1)
  select * from t2);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#37 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.$agg1#37]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#37]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.$agg1#37]
            +-input_scan=
            | +-WithScan
            |   +-column_list=t2.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36]
            |   +-with_entry_list=
            |   | +-WithEntry
            |   |   +-with_query_name='t2'
            |   |   +-with_subquery=
            |   |     +-ProjectScan
            |   |       +-column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
            |   |       +-input_scan=
            |   |         +-WithRefScan(column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t1")
            |   +-query=
            |     +-ProjectScan
            |       +-column_list=t2.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36]
            |       +-input_scan=
            |         +-WithRefScan(column_list=t2.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36], with_query_name="t2")
            +-aggregate_list=
              +-$agg1#37 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#37 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-column_list=[$aggregate.$agg1#37]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#37]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.$agg1#37]
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$aggregate.$agg1_partial#39, $group_by.$uid#40]
            |   +-input_scan=
            |   | +-WithScan
            |   |   +-column_list=t2.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36]
            |   |   +-with_entry_list=
            |   |   | +-WithEntry
            |   |   |   +-with_query_name='t2'
            |   |   |   +-with_subquery=
            |   |   |     +-ProjectScan
            |   |   |       +-column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
            |   |   |       +-input_scan=
            |   |   |         +-WithRefScan(column_list=t1.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t1")
            |   |   +-query=
            |   |     +-ProjectScan
            |   |       +-column_list=t2.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36]
            |   |       +-input_scan=
            |   |         +-WithRefScan(column_list=t2.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36], with_query_name="t2")
            |   +-group_by_list=
            |   | +-$uid#40 := ColumnRef(type=INT64, column=t2.uid#35)
            |   +-aggregate_list=
            |     +-$agg1_partial#39 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-aggregate_list=
            | +-$agg1#37 :=
            | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#39)
            | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
            | +-$group_selection_threshold_col#43 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-Literal(type=INT64, value=1)
            |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#43)
==

# SELECT WITH DIFFERENTIAL_PRIVACY inside WITH entry
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
with t1 as (
  select with differential_privacy count(*)
  from SimpleTypesWithAnonymizationUid)
select * from t1;
--
QueryStmt
+-output_column_list=
| +-t1.$col1#14 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.$col1#14]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[$aggregate.$agg1#13]
    |       +-input_scan=
    |         +-DifferentialPrivacyAggregateScan
    |           +-column_list=[$aggregate.$agg1#13]
    |           +-input_scan=
    |           | +-TableScan(table=SimpleTypesWithAnonymizationUid)
    |           +-aggregate_list=
    |             +-$agg1#13 :=
    |               +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    |                 +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
    +-query=
      +-ProjectScan
        +-column_list=[t1.$col1#14]
        +-input_scan=
          +-WithRefScan(column_list=[t1.$col1#14], with_query_name="t1")

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-t1.$col1#14 AS "$col1" [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.$col1#14]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[$aggregate.$agg1#13]
    |       +-input_scan=
    |         +-DifferentialPrivacyAggregateScan
    |           +-column_list=[$aggregate.$agg1#13]
    |           +-input_scan=
    |           | +-AggregateScan
    |           |   +-column_list=[$aggregate.$agg1_partial#17, $group_by.$uid#18]
    |           |   +-input_scan=
    |           |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
    |           |   +-group_by_list=
    |           |   | +-$uid#18 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
    |           |   +-aggregate_list=
    |           |     +-$agg1_partial#17 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    |           +-aggregate_list=
    |           | +-$agg1#13 :=
    |           | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    |           | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#17)
    |           | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
    |           | +-$group_selection_threshold_col#21 :=
    |           |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    |           |     +-Literal(type=INT64, value=1)
    |           |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
    |           +-group_selection_threshold_expr=
    |             +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#21)
    +-query=
      +-ProjectScan
        +-column_list=[t1.$col1#14]
        +-input_scan=
          +-WithRefScan(column_list=[t1.$col1#14], with_query_name="t1")
==

# Extraneous WithScan inside SELECT WITH DIFFERENTIAL_PRIVACY
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*, contribution_bounds_per_group => (0, 100))
from (
  with t1 as (select * from SimpleTypesWithAnonymizationUid),
       t2 as (select * from SimpleTypesWithAnonymizationUid),
       t3 as (select * from SimpleTypes)
  select * from t1);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#55 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#55]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#55]
        +-input_scan=
        | +-WithScan
        |   +-column_list=t1.[int32#43, int64#44, uint32#45, uint64#46, string#47, bytes#48, bool#49, float#50, double#51, date#52, uid#53, numeric#54]
        |   +-with_entry_list=
        |   | +-WithEntry
        |   | | +-with_query_name='t1'
        |   | | +-with_subquery=
        |   | |   +-ProjectScan
        |   | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |   | |     +-input_scan=
        |   | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |   | +-WithEntry
        |   | | +-with_query_name='t2'
        |   | | +-with_subquery=
        |   | |   +-ProjectScan
        |   | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
        |   | |     +-input_scan=
        |   | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |   | +-WithEntry
        |   |   +-with_query_name='t3'
        |   |   +-with_subquery=
        |   |     +-ProjectScan
        |   |       +-column_list=SimpleTypes.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, timestamp_seconds#35, timestamp_millis#36, timestamp_micros#37, timestamp_nanos#38, timestamp#39, numeric#40, bignumeric#41, json#42]
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=SimpleTypes.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, timestamp_seconds#35, timestamp_millis#36, timestamp_micros#37, timestamp_nanos#38, timestamp#39, numeric#40, bignumeric#41, json#42], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
        |   +-query=
        |     +-ProjectScan
        |       +-column_list=t1.[int32#43, int64#44, uint32#45, uint64#46, string#47, bytes#48, bool#49, float#50, double#51, date#52, uid#53, numeric#54]
        |       +-input_scan=
        |         +-WithRefScan(column_list=t1.[int32#43, int64#44, uint32#45, uint64#46, string#47, bytes#48, bool#49, float#50, double#51, date#52, uid#53, numeric#54], with_query_name="t1")
        +-aggregate_list=
          +-$agg1#55 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#55 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#55]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#55]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#57, $group_by.$uid#58]
        |   +-input_scan=
        |   | +-WithScan
        |   |   +-column_list=t1.[int32#43, int64#44, uint32#45, uint64#46, string#47, bytes#48, bool#49, float#50, double#51, date#52, uid#53, numeric#54]
        |   |   +-with_entry_list=
        |   |   | +-WithEntry
        |   |   | | +-with_query_name='t1'
        |   |   | | +-with_subquery=
        |   |   | |   +-ProjectScan
        |   |   | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |   |   | |     +-input_scan=
        |   |   | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |   |   | +-WithEntry
        |   |   | | +-with_query_name='t2'
        |   |   | | +-with_subquery=
        |   |   | |   +-ProjectScan
        |   |   | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24]
        |   |   | |     +-input_scan=
        |   |   | |       +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |   |   | +-WithEntry
        |   |   |   +-with_query_name='t3'
        |   |   |   +-with_subquery=
        |   |   |     +-ProjectScan
        |   |   |       +-column_list=SimpleTypes.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, timestamp_seconds#35, timestamp_millis#36, timestamp_micros#37, timestamp_nanos#38, timestamp#39, numeric#40, bignumeric#41, json#42]
        |   |   |       +-input_scan=
        |   |   |         +-TableScan(column_list=SimpleTypes.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, timestamp_seconds#35, timestamp_millis#36, timestamp_micros#37, timestamp_nanos#38, timestamp#39, numeric#40, bignumeric#41, json#42], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
        |   |   +-query=
        |   |     +-ProjectScan
        |   |       +-column_list=t1.[int32#43, int64#44, uint32#45, uint64#46, string#47, bytes#48, bool#49, float#50, double#51, date#52, uid#53, numeric#54]
        |   |       +-input_scan=
        |   |         +-WithRefScan(column_list=t1.[int32#43, int64#44, uint32#45, uint64#46, string#47, bytes#48, bool#49, float#50, double#51, date#52, uid#53, numeric#54], with_query_name="t1")
        |   +-group_by_list=
        |   | +-$uid#58 := ColumnRef(type=INT64, column=t1.uid#53)
        |   +-aggregate_list=
        |     +-$agg1_partial#57 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#55 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#57)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$group_selection_threshold_col#61 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#61)
==

# Extraneous WithScan inside SELECT WITH DIFFERENTIAL_PRIVACY trigger validation
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0, 100))
from (
  with t1 as (select * from SimpleTypesWithAnonymizationUid),
       t2 as (select 1 from SimpleTypesWithAnonymizationUid)
  select * from t1);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#38 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-234
    +-column_list=[$aggregate.$agg1#38]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#38]
        +-input_scan=
        | +-WithScan
        |   +-parse_location=94-233
        |   +-column_list=t1.[int32#26, int64#27, uint32#28, uint64#29, string#30, bytes#31, bool#32, float#33, double#34, date#35, uid#36, numeric#37]
        |   +-with_entry_list=
        |   | +-WithEntry
        |   | | +-with_query_name='t1'
        |   | | +-with_subquery=
        |   | |   +-ProjectScan
        |   | |     +-parse_location=106-151
        |   | |     +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |   | |     +-input_scan=
        |   | |       +-TableScan(parse_location=120-151, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |   | +-WithEntry
        |   |   +-with_query_name='t2'
        |   |   +-with_subquery=
        |   |     +-ProjectScan
        |   |       +-parse_location=168-213
        |   |       +-column_list=[t2.$col1#25]
        |   |       +-expr_list=
        |   |       | +-$col1#25 := Literal(parse_location=175-176, type=INT64, value=1)
        |   |       +-input_scan=
        |   |         +-TableScan(parse_location=182-213, table=SimpleTypesWithAnonymizationUid)
        |   +-query=
        |     +-ProjectScan
        |       +-column_list=t1.[int32#26, int64#27, uint32#28, uint64#29, string#30, bytes#31, bool#32, float#33, double#34, date#35, uid#36, numeric#37]
        |       +-input_scan=
        |         +-WithRefScan(column_list=t1.[int32#26, int64#27, uint32#28, uint64#29, string#30, bytes#31, bool#32, float#33, double#34, date#35, uid#36, numeric#37], with_query_name="t1")
        +-aggregate_list=
          +-$agg1#38 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (
  with t1 as (select * from SimpleTypesWithAnonymizationUid),
       t2 as (select @_p1_INT64 from SimpleTypesWithAnonymizationUid)
  select * from t1);

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid' [at 4:15]
       t2 as (select 1 from SimpleTypesWithAnonymizationUid)
              ^
==

# WITH clause was crashed, see b/413760889.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
WITH t AS (
  SELECT int64
    FROM SimpleTypesWithAnonymizationUid
    ORDER BY RAND()
) SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS (epsilon=100000000, delta=1e-5)
  COUNT(*) as aggregation_count
  FROM t;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.aggregation_count#15 AS aggregation_count [INT64]
+-query=
  +-WithScan
    +-parse_location=0-203
    +-column_list=[$aggregate.aggregation_count#15]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-OrderByScan
    |       +-parse_location=14-87
    |       +-column_list=[SimpleTypesWithAnonymizationUid.int64#2]
    |       +-is_ordered=TRUE
    |       +-input_scan=
    |       | +-ProjectScan
    |       |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2, $orderby.$orderbycol1#13]
    |       |   +-expr_list=
    |       |   | +-$orderbycol1#13 := FunctionCall(ZetaSQL:rand() -> DOUBLE)(parse_location=81-85)
    |       |   +-input_scan=
    |       |     +-TableScan(parse_location=36-67, column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
    |       +-order_by_item_list=
    |         +-OrderByItem
    |           +-column_ref=
    |             +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#13)
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.aggregation_count#15]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.aggregation_count#15]
            +-input_scan=
            | +-WithRefScan(column_list=[t.int64#14], with_query_name="t")
            +-aggregate_list=
            | +-aggregation_count#15 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-parse_location=165-170
            |     +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
            +-option_list=
              +-epsilon=
              | +-parse_location=132-149
              | +-Literal(parse_location=140-149, type=DOUBLE, value=100000000)
              +-delta=
                +-parse_location=151-161
                +-Literal(parse_location=157-161, type=DOUBLE, value=1e-05)
[REPLACED_LITERALS]
WITH t AS (
  SELECT int64
    FROM SimpleTypesWithAnonymizationUid
    ORDER BY RAND()
) SELECT WITH DIFFERENTIAL_PRIVACY OPTIONS (epsilon=@_p0_DOUBLE, delta=@_p1_DOUBLE)
  COUNT(*) as aggregation_count
  FROM t;

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid'
==

# Count (*) counting unique users.
# DIFFERENTIAL_PRIVACY_THRESHOLDING feature is enabled, therefore we should use this
# count for k_threshold.
[default language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,TABLE_VALUED_FUNCTIONS,DIFFERENTIAL_PRIVACY_THRESHOLDING]
[default enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
WITH t as (select *
           from SimpleTypesWithAnonymizationUid)
SELECT WITH DIFFERENTIAL_PRIVACY count(*, contribution_bounds_per_group => (0, 1)) as anon_count from t;
--
QueryStmt
+-output_column_list=
| +-$aggregate.anon_count#25 AS anon_count [INT64]
+-query=
  +-WithScan
    +-parse_location=0-172
    +-column_list=[$aggregate.anon_count#25]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-parse_location=11-67
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    |       +-input_scan=
    |         +-TableScan(parse_location=36-67, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.anon_count#25]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.anon_count#25]
            +-input_scan=
            | +-WithRefScan(column_list=t.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t")
            +-aggregate_list=
              +-anon_count#25 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-parse_location=102-107
                  +-Literal(parse_location=144-150, type=STRUCT<INT64, INT64>, value={0, 1})
[REPLACED_LITERALS]
WITH t as (select *
           from SimpleTypesWithAnonymizationUid)
SELECT WITH DIFFERENTIAL_PRIVACY count(*, contribution_bounds_per_group => @_p0_STRUCT) as anon_count from t;

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.anon_count#25 AS anon_count [INT64]
+-query=
  +-WithScan
    +-parse_location=0-172
    +-column_list=[$aggregate.anon_count#25]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-parse_location=11-67
    |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
    |       +-input_scan=
    |         +-TableScan(parse_location=36-67, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
    +-query=
      +-ProjectScan
        +-column_list=[$aggregate.anon_count#25]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.anon_count#25]
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$aggregate.anon_count_partial#27, $group_by.$uid#28]
            |   +-input_scan=
            |   | +-WithRefScan(column_list=t.[int32#13, int64#14, uint32#15, uint64#16, string#17, bytes#18, bool#19, float#20, double#21, date#22, uid#23, numeric#24], with_query_name="t")
            |   +-group_by_list=
            |   | +-$uid#28 := ColumnRef(type=INT64, column=t.uid#23)
            |   +-aggregate_list=
            |     +-anon_count_partial#27 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
            +-aggregate_list=
            | +-anon_count#25 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-ColumnRef(type=INT64, column=$aggregate.anon_count_partial#27)
            |     +-Literal(parse_location=144-150, type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$aggregate.anon_count#25)

