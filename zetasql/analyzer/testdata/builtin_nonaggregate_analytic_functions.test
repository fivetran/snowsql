# This file tests the analytic support for non-aggregate analytic functions.

# For RANK and DENSE_RANK, ORDER BY is required and PARTITION BY is optional.
[default language_features=ANALYTIC_FUNCTIONS]
select rank() over w1,
       dense_rank() over w1,
       rank() over w2,
       dense_rank() over w2
from keyvalue
window w1 as (partition by value order by key),
       w2 as (order by key)
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#7 AS `$col1` [INT64]
| +-$analytic.$analytic2#8 AS `$col2` [INT64]
| +-$analytic.$analytic3#9 AS `$col3` [INT64]
| +-$analytic.$analytic4#10 AS `$col4` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#7, $analytic2#8, $analytic3#9, $analytic4#10]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#7, $analytic.$analytic2#8, $analytic.$analytic3#9, $analytic.$analytic4#10]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-partition_by=
          | | +-WindowPartitioning
          | |   +-partition_by_list=
          | |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          | +-analytic_function_list=
          |   +-$analytic1#7 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
          |   +-$analytic2#8 := AnalyticFunctionCall(ZetaSQL:dense_rank() -> INT64)
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-analytic_function_list=
              +-$analytic3#9 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
              +-$analytic4#10 := AnalyticFunctionCall(ZetaSQL:dense_rank() -> INT64)
==

# ORDER BY is required in RANK and DENSE_RANK.
select {{rank()|dense_rank()}} over () from keyvalue
--
ALTERNATION GROUP: rank()
--
ERROR: Window ORDER BY is required for analytic function rank [at 1:20]
select rank() over () from keyvalue
                   ^
--
ALTERNATION GROUP: dense_rank()
--
ERROR: Window ORDER BY is required for analytic function dense_rank [at 1:26]
select dense_rank() over () from keyvalue
                         ^
==

# Window frame is not allowed in RANK and DENSE_RANK.
select {{rank()|dense_rank()}} over (order by key rows 2 preceding)
from keyvalue
--
ALTERNATION GROUP: rank()
--
ERROR: Window framing clause is not allowed for analytic function rank [at 1:34]
select rank() over (order by key rows 2 preceding)
                                 ^
--
ALTERNATION GROUP: dense_rank()
--
ERROR: Window framing clause is not allowed for analytic function dense_rank [at 1:40]
select dense_rank() over (order by key rows 2 preceding)
                                       ^
==

# For ROW_NUMBER, PARTITION BY and ORDER BY are optional.
select row_number() over (partition by key order by value),
       row_number() over (partition by key),
       row_number() over (order by value),
       row_number() over ()
from keyvalue
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#7 AS `$col1` [INT64]
| +-$analytic.$analytic2#8 AS `$col2` [INT64]
| +-$analytic.$analytic3#9 AS `$col3` [INT64]
| +-$analytic.$analytic4#10 AS `$col4` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#7, $analytic2#8, $analytic3#9, $analytic4#10]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#7, $analytic.$analytic2#8, $analytic.$analytic3#9, $analytic.$analytic4#10]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-partition_by=
          | | +-WindowPartitioning
          | |   +-partition_by_list=
          | |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
          | +-analytic_function_list=
          |   +-$analytic1#7 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
          +-AnalyticFunctionGroup
          | +-partition_by=
          | | +-WindowPartitioning
          | |   +-partition_by_list=
          | |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          | +-analytic_function_list=
          |   +-$analytic2#8 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
          +-AnalyticFunctionGroup
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
          | +-analytic_function_list=
          |   +-$analytic3#9 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic4#10 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
==

# Window frame is not allowed in ROW_NUMBER.
select row_number() over (rows 2 preceding)
from keyvalue
--
ERROR: Window framing clause is not allowed for analytic function row_number [at 1:27]
select row_number() over (rows 2 preceding)
                          ^
==

# PERCENT_RANK, CUME_DIST, and NTILE allow partition by, ORDER BY is required,
# and the window frame clause is disallowed.  So most tests only test one
# of those functions for a particular OVER clause.

# An OVER clause is required.
select {{percent_rank()|cume_dist()|ntile(2)}} from KeyValue;
--
ALTERNATION GROUP: percent_rank()
--
ERROR: Analytic function PERCENT_RANK cannot be called without an OVER clause [at 1:8]
select percent_rank() from KeyValue;
       ^
--
ALTERNATION GROUP: cume_dist()
--
ERROR: Analytic function CUME_DIST cannot be called without an OVER clause [at 1:8]
select cume_dist() from KeyValue;
       ^
--
ALTERNATION GROUP: ntile(2)
--
ERROR: Analytic function NTILE cannot be called without an OVER clause [at 1:8]
select ntile(2) from KeyValue;
       ^
==

# ORDER BY is required.
select percent_rank() over () from KeyValue
--
ERROR: Window ORDER BY is required for analytic function percent_rank [at 1:28]
select percent_rank() over () from KeyValue
                           ^
==

# FROM clause is required;
select percent_rank() over (ORDER BY (select @test_param_int64))
--
ERROR: SELECT without FROM clause cannot use analytic functions [at 1:1]
select percent_rank() over (ORDER BY (select @test_param_int64))
^
==

select cume_dist() over (order by key)
from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-analytic_function_list=
              +-$analytic1#4 := AnalyticFunctionCall(ZetaSQL:cume_dist() -> DOUBLE)
==

select ntile(2) over (partition by value order BY key)
from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:ntile(INT64) -> INT64)
                  +-Literal(type=INT64, value=2)
==

# Window frame not allowed.
select percent_rank() over
  (order BY key rows between unbounded preceding and unbounded following)
from keyvalue;
--
ERROR: Window framing clause is not allowed for analytic function percent_rank [at 2:17]
  (order BY key rows between unbounded preceding and unbounded following)
                ^
==

# NTILE requires a non-NULL integer literal, or parameter.
select ntile(@test_param_int64) over (order by value),
       ntile(1) over (order by value),
       ntile(0) over (order by value)
from keyvalue;
--
ERROR: The argument to NTILE must be at least 1 [at 3:14]
       ntile(0) over (order by value)
             ^
==

select ntile(-1) over (order by value)
from keyvalue;
--
ERROR: The argument to NTILE must be at least 1 [at 1:14]
select ntile(-1) over (order by value)
             ^
==

# UINT64 literals are not allowed as NTILE arguments.
select ntile(99999999999999999999) over (order by value)
from keyvalue
--
ERROR: Invalid integer literal: 99999999999999999999 [at 1:14]
select ntile(99999999999999999999) over (order by value)
             ^
==

select ntile(null) over (order by value) from keyvalue;
--
ERROR: The argument to NTILE must be non-NULL [at 1:14]
select ntile(null) over (order by value) from keyvalue;
             ^
==

select ntile("1") over (order by value) from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:ntile(INT64) -> INT64)
                  +-Literal(type=INT64, value=1)
==

select ntile(true) over (order by value) from keyvalue;
--
ERROR: No matching signature for analytic function NTILE for argument types: BOOL. Supported signature: NTILE(INT64) [at 1:8]
select ntile(true) over (order by value) from keyvalue;
       ^
==

select ntile(coalesce(1)) over (order by value) from keyvalue;
--
ERROR: The argument to NTILE must be a literal or query parameter [at 1:14]
select ntile(coalesce(1)) over (order by value) from keyvalue;
             ^
==

select ntile(cast(1 as int32)) over (order by value) from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:ntile(INT64) -> INT64)
                  +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
==

select ntile(key) over (order by value) from keyvalue;
--
ERROR: The argument to NTILE must be a literal or query parameter [at 1:14]
select ntile(key) over (order by value) from keyvalue;
             ^
==

# For lead and lag, ORDER BY is required and window frames are not allowed.
# The argument must be a non-NULL constant integer expression.  The second
# two arguments are optional.

# One argument is required.
select {{lead()|lag()}} over (order by key) from keyvalue
--
ALTERNATION GROUP: lead()
--
ERROR: Number of arguments does not match for analytic function LEAD. Supported signature: LEAD(ANY, [INT64], [ANY]) [at 1:8]
select lead() over (order by key) from keyvalue
       ^
--
ALTERNATION GROUP: lag()
--
ERROR: Number of arguments does not match for analytic function LAG. Supported signature: LAG(ANY, [INT64], [ANY]) [at 1:8]
select lag() over (order by key) from keyvalue
       ^
==

# NULL not allowed for offset
select lead(value, NULL) over (order by value)
from keyvalue
--
ERROR: Argument 2 to LEAD must be non-NULL [at 1:20]
select lead(value, NULL) over (order by value)
                   ^
==

# Non-constant not allowed for offset.
select lead(value, key) over (order by value)
from keyvalue
--
ERROR: Argument 2 to LEAD must be a literal or query parameter [at 1:20]
select lead(value, key) over (order by value)
                   ^
==

# TODO: We should populate all of the optional arguments in the
# resolved tree.
select lead(value) over window1,
       lead(value, 1) over window1,
       lag(value, @test_param_int32) over window1,
       lead(value, -1, NULL) over window1,
       lag(value, 0, "string_constant") over window1,
       lag(key, 5000, key+1) over window1
from keyvalue
window window1 as (partition by key+1 order by value)
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#9 AS `$col1` [STRING]
| +-$analytic.$analytic2#10 AS `$col2` [STRING]
| +-$analytic.$analytic3#11 AS `$col3` [STRING]
| +-$analytic.$analytic4#12 AS `$col4` [STRING]
| +-$analytic.$analytic5#13 AS `$col5` [STRING]
| +-$analytic.$analytic6#14 AS `$col6` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#9, $analytic2#10, $analytic3#11, $analytic4#12, $analytic5#13, $analytic6#14]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#9, $analytic.$analytic2#10, $analytic.$analytic3#11, $analytic.$analytic4#12, $analytic.$analytic5#13, $analytic.$analytic6#14]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $partitionby.$partitionbycol1#15]
        |   +-expr_list=
        |   | +-$partitionbycol1#15 :=
        |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |     +-Literal(type=INT64, value=1)
        |   +-input_scan=
        |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=$partitionby.$partitionbycol1#15)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-analytic_function_list=
              +-$analytic1#9 :=
              | +-AnalyticFunctionCall(ZetaSQL:lead(STRING, optional(0) INT64, optional(0) STRING) -> STRING)
              |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              +-$analytic2#10 :=
              | +-AnalyticFunctionCall(ZetaSQL:lead(STRING, optional(1) INT64, optional(0) STRING) -> STRING)
              |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              |   +-Literal(type=INT64, value=1)
              +-$analytic3#11 :=
              | +-AnalyticFunctionCall(ZetaSQL:lag(STRING, optional(1) INT64, optional(0) STRING) -> STRING)
              |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              |   +-Cast(INT32 -> INT64)
              |     +-Parameter(type=INT32, name="test_param_int32")
              +-$analytic4#12 :=
              | +-AnalyticFunctionCall(ZetaSQL:lead(STRING, optional(1) INT64, optional(1) STRING) -> STRING)
              |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              |   +-Literal(type=INT64, value=-1)
              |   +-Literal(type=STRING, value=NULL)
              +-$analytic5#13 :=
              | +-AnalyticFunctionCall(ZetaSQL:lag(STRING, optional(1) INT64, optional(1) STRING) -> STRING)
              |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              |   +-Literal(type=INT64, value=0)
              |   +-Literal(type=STRING, value="string_constant")
              +-$analytic6#14 :=
                +-AnalyticFunctionCall(ZetaSQL:lag(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=INT64, value=5000)
                  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                    +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                    +-Literal(type=INT64, value=1)
==

# The result type of the lead/lag expression is the supertype of the
# first and third (default) expressions.
select lead(uint32, 1, int32) over (order by int64) from simpletypes;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#20 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#20]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int32#1, SimpleTypes.int64#2, SimpleTypes.uint32#3, $analytic.$analytic1#20]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3], table=SimpleTypes, column_index_list=[0, 1, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            +-analytic_function_list=
              +-$analytic1#20 :=
                +-AnalyticFunctionCall(ZetaSQL:lead(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
                  +-Cast(UINT32 -> INT64)
                  | +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
                  +-Literal(type=INT64, value=1)
                  +-Cast(INT32 -> INT64)
                    +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
==

# FIRST_VALUE and LAST_VALUE requires one argument.  ORDER BY is required.
# PARTITION BY and window frame are optional.

select {{first_value|last_value}}() over (order by int64)
from simpletypes;
--
ALTERNATION GROUP: first_value
--
ERROR: Number of arguments does not match for analytic function FIRST_VALUE. Supported signature: FIRST_VALUE(ANY) [at 1:8]
select first_value() over (order by int64)
       ^
--
ALTERNATION GROUP: last_value
--
ERROR: Number of arguments does not match for analytic function LAST_VALUE. Supported signature: LAST_VALUE(ANY) [at 1:8]
select last_value() over (order by int64)
       ^
==

# Their argument must not be NULL.
select first_value(NULL) over (order by int64)
from simpletypes;
--
ERROR: The argument to FIRST_VALUE must be non-NULL [at 1:20]
select first_value(NULL) over (order by int64)
                   ^
==

# ORDER BY is required.
select last_value(int32) over (partition by int64)
from simpletypes;
--
ERROR: Window ORDER BY is required for analytic function last_value [at 1:31]
select last_value(int32) over (partition by int64)
                              ^
==

# The argument can be any general expression or literal.
select first_value(uint32) over w1,
       first_value(1) over w1,
       first_value(@test_param_int32) over w1
from simpletypes
window w1 as (order by int64);
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#22 AS `$col1` [UINT32]
| +-$analytic.$analytic2#23 AS `$col2` [INT64]
| +-$analytic.$analytic3#24 AS `$col3` [INT32]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#22, $analytic2#23, $analytic3#24]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int64#2, SimpleTypes.uint32#3, $analytic.$analytic1#22, $analytic.$analytic2#23, $analytic.$analytic3#24]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, uint32#3], table=SimpleTypes, column_index_list=[1, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            +-analytic_function_list=
              +-$analytic1#22 :=
              | +-AnalyticFunctionCall(ZetaSQL:first_value(UINT32) -> UINT32)
              |   +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
              |   +-window_frame=
              |     +-WindowFrame(frame_unit=RANGE)
              |       +-start_expr=
              |       | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
              |       +-end_expr=
              |         +-WindowFrameExpr(boundary_type=CURRENT ROW)
              +-$analytic2#23 :=
              | +-AnalyticFunctionCall(ZetaSQL:first_value(INT64) -> INT64)
              |   +-Literal(type=INT64, value=1)
              |   +-window_frame=
              |     +-WindowFrame(frame_unit=RANGE)
              |       +-start_expr=
              |       | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
              |       +-end_expr=
              |         +-WindowFrameExpr(boundary_type=CURRENT ROW)
              +-$analytic3#24 :=
                +-AnalyticFunctionCall(ZetaSQL:first_value(INT32) -> INT32)
                  +-Parameter(type=INT32, name="test_param_int32")
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

select first_value(sum(uint32)) over (order by int64)
from simpletypes
group by int64;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#22 AS `$col1` [UINT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#22]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$groupby.int64#21, $aggregate.$agg1#19, $analytic.$analytic1#22]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.int64#21, $aggregate.$agg1#19]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypes.[int64#2, uint32#3], table=SimpleTypes, column_index_list=[1, 2])
        |   +-group_by_list=
        |   | +-int64#21 := ColumnRef(type=INT64, column=SimpleTypes.int64#2)
        |   +-aggregate_list=
        |     +-$agg1#19 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(UINT64) -> UINT64)
        |         +-Cast(UINT32 -> UINT64)
        |           +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=$groupby.int64#21)
            +-analytic_function_list=
              +-$analytic1#22 :=
                +-AnalyticFunctionCall(ZetaSQL:first_value(UINT64) -> UINT64)
                  +-ColumnRef(type=UINT64, column=$aggregate.$agg1#19)
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

# Only one argument is allowed.
select first_value(uint32, 1) over (order by int64)
from simpletypes;
--
ERROR: Number of arguments does not match for analytic function FIRST_VALUE. Supported signature: FIRST_VALUE(ANY) [at 1:8]
select first_value(uint32, 1) over (order by int64)
       ^
==

# Partition by and window frame are allowed.
select last_value(uint32) over w1
from simpletypes
window w1 as (partition by int32 order by int64
              rows between 1 preceding and 1 following)
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#20 AS `$col1` [UINT32]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#20]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int32#1, SimpleTypes.int64#2, SimpleTypes.uint32#3, $analytic.$analytic1#20]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3], table=SimpleTypes, column_index_list=[0, 1, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            +-analytic_function_list=
              +-$analytic1#20 :=
                +-AnalyticFunctionCall(ZetaSQL:last_value(UINT32) -> UINT32)
                  +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=OFFSET PRECEDING)
                      |   +-Literal(type=INT64, value=1)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=OFFSET FOLLOWING)
                          +-Literal(type=INT64, value=1)
==

# Nth value requires two arguments, the second must be a non-null constant
# integer value.  ORDER BY is required.  PARTITION BY and window frame
# are optional.

select nth_value() over (order by int32) from simpletypes;
--
ERROR: Number of arguments does not match for analytic function NTH_VALUE. Supported signature: NTH_VALUE(ANY, INT64) [at 1:8]
select nth_value() over (order by int32) from simpletypes;
       ^
==

select nth_value(uint32) over (order by int32) from simpletypes;
--
ERROR: Number of arguments does not match for analytic function NTH_VALUE. Supported signature: NTH_VALUE(ANY, INT64) [at 1:8]
select nth_value(uint32) over (order by int32) from simpletypes;
       ^
==

select nth_value(uint32, NULL) over (order by int32) from simpletypes;
--
ERROR: Argument 2 to NTH_VALUE must be non-NULL [at 1:26]
select nth_value(uint32, NULL) over (order by int32) from simpletypes;
                         ^
==

select nth_value(uint32, int64) over (order by int32) from simpletypes;
--
ERROR: Argument 2 to NTH_VALUE must be a literal or query parameter [at 1:26]
select nth_value(uint32, int64) over (order by int32) from simpletypes;
                         ^
==

select nth_value(uint32, @test_param_int64) over (order by int32)
from simpletypes;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#20 AS `$col1` [UINT32]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#20]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int32#1, SimpleTypes.uint32#3, $analytic.$analytic1#20]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, uint32#3], table=SimpleTypes, column_index_list=[0, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            +-analytic_function_list=
              +-$analytic1#20 :=
                +-AnalyticFunctionCall(ZetaSQL:nth_value(UINT32, INT64) -> UINT32)
                  +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
                  +-Parameter(type=INT64, name="test_param_int64")
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

select nth_value(uint32, 5)
         over (partition by int64 order by int32
               rows between 1 preceding and unbounded following)
from simpletypes;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#20 AS `$col1` [UINT32]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#20]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int32#1, SimpleTypes.int64#2, SimpleTypes.uint32#3, $analytic.$analytic1#20]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3], table=SimpleTypes, column_index_list=[0, 1, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            +-analytic_function_list=
              +-$analytic1#20 :=
                +-AnalyticFunctionCall(ZetaSQL:nth_value(UINT32, INT64) -> UINT32)
                  +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
                  +-Literal(type=INT64, value=5)
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=OFFSET PRECEDING)
                      |   +-Literal(type=INT64, value=1)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

# IGNORE NULLS are allowed.
[language_features=ANALYTIC_FUNCTIONS{{,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC|}}]
select
  first_value(uint32 ignore nulls) over (order by int32),
  last_value(uint32 ignore nulls) over (order by int32),
  nth_value(uint32, @test_param_int64 ignore nulls) over (order by int32)
from simpletypes;
--
ALTERNATION GROUP: ,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#22 AS `$col1` [UINT32]
| +-$analytic.$analytic2#23 AS `$col2` [UINT32]
| +-$analytic.$analytic3#24 AS `$col3` [UINT32]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#22, $analytic2#23, $analytic3#24]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int32#1, SimpleTypes.uint32#3, $analytic.$analytic1#22, $analytic.$analytic2#23, $analytic.$analytic3#24]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, uint32#3], table=SimpleTypes, column_index_list=[0, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
          | +-analytic_function_list=
          |   +-$analytic1#22 :=
          |     +-AnalyticFunctionCall(ZetaSQL:first_value(UINT32) -> UINT32)
          |       +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
          |       +-null_handling_modifier=IGNORE_NULLS
          |       +-window_frame=
          |         +-WindowFrame(frame_unit=RANGE)
          |           +-start_expr=
          |           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
          |           +-end_expr=
          |             +-WindowFrameExpr(boundary_type=CURRENT ROW)
          +-AnalyticFunctionGroup
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
          | +-analytic_function_list=
          |   +-$analytic2#23 :=
          |     +-AnalyticFunctionCall(ZetaSQL:last_value(UINT32) -> UINT32)
          |       +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
          |       +-null_handling_modifier=IGNORE_NULLS
          |       +-window_frame=
          |         +-WindowFrame(frame_unit=RANGE)
          |           +-start_expr=
          |           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
          |           +-end_expr=
          |             +-WindowFrameExpr(boundary_type=CURRENT ROW)
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            +-analytic_function_list=
              +-$analytic3#24 :=
                +-AnalyticFunctionCall(ZetaSQL:nth_value(UINT32, INT64) -> UINT32)
                  +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
                  +-Parameter(type=INT64, name="test_param_int64")
                  +-null_handling_modifier=IGNORE_NULLS
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 2:3]
  first_value(uint32 ignore nulls) over (order by int32),
  ^
==

# RESPECT NULLS are allowed.
[language_features=ANALYTIC_FUNCTIONS{{,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC|}}]
select
  nth_value(uint32, @test_param_int64 respect nulls) over (order by int32),
  last_value(uint32 respect nulls) over (order by int32),
  first_value(uint32 respect nulls) over (order by int32)
from simpletypes;
--
ALTERNATION GROUP: ,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#22 AS `$col1` [UINT32]
| +-$analytic.$analytic2#23 AS `$col2` [UINT32]
| +-$analytic.$analytic3#24 AS `$col3` [UINT32]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#22, $analytic2#23, $analytic3#24]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int32#1, SimpleTypes.uint32#3, $analytic.$analytic1#22, $analytic.$analytic2#23, $analytic.$analytic3#24]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, uint32#3], table=SimpleTypes, column_index_list=[0, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
          | +-analytic_function_list=
          |   +-$analytic1#22 :=
          |     +-AnalyticFunctionCall(ZetaSQL:nth_value(UINT32, INT64) -> UINT32)
          |       +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
          |       +-Parameter(type=INT64, name="test_param_int64")
          |       +-null_handling_modifier=RESPECT_NULLS
          |       +-window_frame=
          |         +-WindowFrame(frame_unit=RANGE)
          |           +-start_expr=
          |           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
          |           +-end_expr=
          |             +-WindowFrameExpr(boundary_type=CURRENT ROW)
          +-AnalyticFunctionGroup
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
          | +-analytic_function_list=
          |   +-$analytic2#23 :=
          |     +-AnalyticFunctionCall(ZetaSQL:last_value(UINT32) -> UINT32)
          |       +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
          |       +-null_handling_modifier=RESPECT_NULLS
          |       +-window_frame=
          |         +-WindowFrame(frame_unit=RANGE)
          |           +-start_expr=
          |           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
          |           +-end_expr=
          |             +-WindowFrameExpr(boundary_type=CURRENT ROW)
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            +-analytic_function_list=
              +-$analytic3#24 :=
                +-AnalyticFunctionCall(ZetaSQL:first_value(UINT32) -> UINT32)
                  +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
                  +-null_handling_modifier=RESPECT_NULLS
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 2:3]
  nth_value(uint32, @test_param_int64 respect nulls) over (order by int32),
  ^
==

select percentile_cont(key, 0.5) over () from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
                  +-Cast(INT64 -> DOUBLE)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=0.5)
==

# Both arguments are NUMERIC.
[language_features=ANALYTIC_FUNCTIONS{{|,NUMERIC_TYPE}}]
select percentile_cont(cast(key as numeric), numeric "0.5") over () from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: numeric [at 1:36]
select percentile_cont(cast(key as numeric), numeric "0.5") over () from keyv...
                                   ^
--
ALTERNATION GROUP: ,NUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(NUMERIC, NUMERIC) -> NUMERIC)
                  +-Cast(INT64 -> NUMERIC)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=NUMERIC, value=0.5, has_explicit_type=TRUE)
==

# Only one argument is NUMERIC and the other is DOUBLE/INT64;
# should not use the NUMERIC signature.
[language_features=ANALYTIC_FUNCTIONS{{|,NUMERIC_TYPE}}]
select
  percentile_cont(cast(key as numeric), 0.5) over (),
  percentile_cont(cast(key as numeric), 1) over (),
  percentile_cont(key, numeric "0.5") over()
from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: numeric [at 2:31]
  percentile_cont(cast(key as numeric), 0.5) over (),
                              ^
--
ALTERNATION GROUP: ,NUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#6 AS `$col1` [DOUBLE]
| +-$analytic.$analytic2#7 AS `$col2` [DOUBLE]
| +-$analytic.$analytic3#8 AS `$col3` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#6, $analytic2#7, $analytic3#8]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#6, $analytic.$analytic2#7, $analytic.$analytic3#8]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#6 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
              |   +-Cast(NUMERIC -> DOUBLE)
              |   | +-Cast(INT64 -> NUMERIC)
              |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=0.5, float_literal_id=2)
              +-$analytic2#7 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
              |   +-Cast(NUMERIC -> DOUBLE)
              |   | +-Cast(INT64 -> NUMERIC)
              |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=1)
              +-$analytic3#8 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
                  +-Cast(INT64 -> DOUBLE)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=0.5, has_explicit_type=TRUE)
==

# Both arguments are BIGNUMERIC.
[language_features=ANALYTIC_FUNCTIONS{{|,BIGNUMERIC_TYPE}}]
select percentile_cont(cast(key as bignumeric), bignumeric "0.5") over () from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: bignumeric [at 1:36]
select percentile_cont(cast(key as bignumeric), bignumeric "0.5") over () fro...
                                   ^
--
ALTERNATION GROUP: ,BIGNUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
                  +-Cast(INT64 -> BIGNUMERIC)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=BIGNUMERIC, value=0.5, has_explicit_type=TRUE)
==

# Only one argument is BIGNUMERIC and the other is DOUBLE/INT64;
# should not use the BIGNUMERIC signature.
[language_features=ANALYTIC_FUNCTIONS{{|,BIGNUMERIC_TYPE}}]
select
  percentile_cont(cast(key as bignumeric), 0.5) over (),
  percentile_cont(cast(key as bignumeric), 1) over (),
  percentile_cont(key, bignumeric "0.5") over()
from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: bignumeric [at 2:31]
  percentile_cont(cast(key as bignumeric), 0.5) over (),
                              ^
--
ALTERNATION GROUP: ,BIGNUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#6 AS `$col1` [DOUBLE]
| +-$analytic.$analytic2#7 AS `$col2` [DOUBLE]
| +-$analytic.$analytic3#8 AS `$col3` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#6, $analytic2#7, $analytic3#8]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#6, $analytic.$analytic2#7, $analytic.$analytic3#8]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#6 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
              |   +-Cast(BIGNUMERIC -> DOUBLE)
              |   | +-Cast(INT64 -> BIGNUMERIC)
              |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=0.5, float_literal_id=2)
              +-$analytic2#7 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
              |   +-Cast(BIGNUMERIC -> DOUBLE)
              |   | +-Cast(INT64 -> BIGNUMERIC)
              |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=1)
              +-$analytic3#8 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
                  +-Cast(INT64 -> DOUBLE)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=0.5, has_explicit_type=TRUE)
==

# One argument is BIGNUMERIC and the other is NUMERIC;
# should use the BIGNUMERIC signature.
[language_features=ANALYTIC_FUNCTIONS,NUMERIC_TYPE,BIGNUMERIC_TYPE]
select
  percentile_cont(cast(key as bignumeric), numeric "0.5") over (),
  percentile_cont(cast(key as numeric), bignumeric "0.5") over ()
from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [BIGNUMERIC]
| +-$analytic.$analytic2#6 AS `$col2` [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_cont(BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
              |   +-Cast(INT64 -> BIGNUMERIC)
              |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=BIGNUMERIC, value=0.5, has_explicit_type=TRUE)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
                  +-Cast(NUMERIC -> BIGNUMERIC)
                  | +-Cast(INT64 -> NUMERIC)
                  |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=BIGNUMERIC, value=0.5, has_explicit_type=TRUE)
==

# PARTITION BY is allowed for percentile_cont.
select percentile_cont(key, 0) over (partition by value) from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
                  +-Cast(INT64 -> DOUBLE)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=0)
==

select
  percentile_disc(key, 0.5) over (),
  percentile_disc(value, 0.5) over ()
from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [INT64]
| +-$analytic.$analytic2#6 AS `$col2` [STRING]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_disc(INT64, DOUBLE) -> INT64)
              |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=0.5)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(STRING, DOUBLE) -> STRING)
                  +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-Literal(type=DOUBLE, value=0.5)
==

# Only first argument is NUMERIC.
[language_features=ANALYTIC_FUNCTIONS{{|,NUMERIC_TYPE}}]
select
  percentile_disc(cast(key as numeric), 0.5) over (),
  percentile_disc(cast(key as numeric), 1) over ()
from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: numeric [at 2:31]
  percentile_disc(cast(key as numeric), 0.5) over (),
                              ^
--
ALTERNATION GROUP: ,NUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [NUMERIC]
| +-$analytic.$analytic2#6 AS `$col2` [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_disc(NUMERIC, DOUBLE) -> NUMERIC)
              |   +-Cast(INT64 -> NUMERIC)
              |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=0.5, float_literal_id=2)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(NUMERIC, DOUBLE) -> NUMERIC)
                  +-Cast(INT64 -> NUMERIC)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=1)
==

# Only second argument is NUMERIC.
[language_features=ANALYTIC_FUNCTIONS{{|,NUMERIC_TYPE}}]
select
  percentile_disc(key, NUMERIC "0.5") over (),
  percentile_disc(value, NUMERIC "0.5") over ()
from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: NUMERIC literals are not supported [at 2:24]
  percentile_disc(key, NUMERIC "0.5") over (),
                       ^
--
ALTERNATION GROUP: ,NUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [INT64]
| +-$analytic.$analytic2#6 AS `$col2` [STRING]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_disc(INT64, NUMERIC) -> INT64)
              |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=NUMERIC, value=0.5, has_explicit_type=TRUE)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(STRING, NUMERIC) -> STRING)
                  +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-Literal(type=NUMERIC, value=0.5, has_explicit_type=TRUE)
==

# Only first argument is BIGNUMERIC.
[language_features=ANALYTIC_FUNCTIONS{{|,BIGNUMERIC_TYPE}}]
select
  percentile_disc(cast(key as bignumeric), 0.5) over (),
  percentile_disc(cast(key as bignumeric), 1) over ()
from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: bignumeric [at 2:31]
  percentile_disc(cast(key as bignumeric), 0.5) over (),
                              ^
--
ALTERNATION GROUP: ,BIGNUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [BIGNUMERIC]
| +-$analytic.$analytic2#6 AS `$col2` [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_disc(BIGNUMERIC, DOUBLE) -> BIGNUMERIC)
              |   +-Cast(INT64 -> BIGNUMERIC)
              |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=0.5, float_literal_id=2)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(BIGNUMERIC, DOUBLE) -> BIGNUMERIC)
                  +-Cast(INT64 -> BIGNUMERIC)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=1)
==

# Only second argument is BIGNUMERIC.
[language_features=ANALYTIC_FUNCTIONS{{|,BIGNUMERIC_TYPE}}]
select
  percentile_disc(key, BIGNUMERIC "0.5") over (),
  percentile_disc(value, BIGNUMERIC "0.5") over ()
from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: BIGNUMERIC literals are not supported [at 2:24]
  percentile_disc(key, BIGNUMERIC "0.5") over (),
                       ^
--
ALTERNATION GROUP: ,BIGNUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [INT64]
| +-$analytic.$analytic2#6 AS `$col2` [STRING]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_disc(INT64, BIGNUMERIC) -> INT64)
              |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=BIGNUMERIC, value=0.5, has_explicit_type=TRUE)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(STRING, BIGNUMERIC) -> STRING)
                  +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-Literal(type=BIGNUMERIC, value=0.5, has_explicit_type=TRUE)
==

# Mix of NUMERIC and BIGNUMERIC.
[language_features=ANALYTIC_FUNCTIONS,NUMERIC_TYPE,BIGNUMERIC_TYPE]
select
  percentile_disc(CAST(key AS NUMERIC), BIGNUMERIC "0.5") over (),
  percentile_disc(CAST(key AS BIGNUMERIC), NUMERIC "0.5") over ()
from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [NUMERIC]
| +-$analytic.$analytic2#6 AS `$col2` [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_disc(NUMERIC, BIGNUMERIC) -> NUMERIC)
              |   +-Cast(INT64 -> NUMERIC)
              |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=BIGNUMERIC, value=0.5, has_explicit_type=TRUE)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(BIGNUMERIC, NUMERIC) -> BIGNUMERIC)
                  +-Cast(INT64 -> BIGNUMERIC)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=NUMERIC, value=0.5, has_explicit_type=TRUE)
==

# PARTITION BY is allowed for percentile_disc.

select
  percentile_disc(key, 0.5) over (partition by value),
  percentile_disc(value, 0.5) over (partition by key)
from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [INT64]
| +-$analytic.$analytic2#6 AS `$col2` [STRING]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-partition_by=
          | | +-WindowPartitioning
          | |   +-partition_by_list=
          | |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
          | +-analytic_function_list=
          |   +-$analytic1#5 :=
          |     +-AnalyticFunctionCall(ZetaSQL:percentile_disc(INT64, DOUBLE) -> INT64)
          |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          |       +-Literal(type=DOUBLE, value=0.5)
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-analytic_function_list=
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(STRING, DOUBLE) -> STRING)
                  +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-Literal(type=DOUBLE, value=0.5)
==

# ORDER BY is disallowed for percentile_cont and percentile_disc.
select percentile_{{cont|disc}}(key, 0) over (order by key) from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Window ORDER BY is not allowed for analytic function percentile_cont [at 1:38]
select percentile_cont(key, 0) over (order by key) from keyvalue;
                                     ^
--
ALTERNATION GROUP: disc
--
ERROR: Window ORDER BY is not allowed for analytic function percentile_disc [at 1:38]
select percentile_disc(key, 0) over (order by key) from keyvalue;
                                     ^
==

# Window frame is disallowed for percentile_cont and percentile_disc.
select percentile_{{cont|disc}}(key, 0) over (rows 2 preceding) from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Window framing clause is not allowed for analytic function percentile_cont [at 1:38]
select percentile_cont(key, 0) over (rows 2 preceding) from keyvalue;
                                     ^
--
ALTERNATION GROUP: disc
--
ERROR: Window framing clause is not allowed for analytic function percentile_disc [at 1:38]
select percentile_disc(key, 0) over (rows 2 preceding) from keyvalue;
                                     ^
==

# DISTINCT is disallowed for percentile_cont and percentile_disc.
select percentile_{{cont|disc}}(distinct key, 0) over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: DISTINCT is not allowed for analytic function percentile_cont [at 1:8]
select percentile_cont(distinct key, 0) over () from keyvalue;
       ^
--
ALTERNATION GROUP: disc
--
ERROR: DISTINCT is not allowed for analytic function percentile_disc [at 1:8]
select percentile_disc(distinct key, 0) over () from keyvalue;
       ^
==

# IGNORE NULLS and percentile=-0.0 are allowed for percentile_cont and percentile_disc.
[language_features=ANALYTIC_FUNCTIONS{{,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC|}}]
select percentile_{{cont|disc}}(key, -0.0 ignore nulls) over () from keyvalue;
--
ALTERNATION GROUP: ,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC,cont
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
                  +-Cast(INT64 -> DOUBLE)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=-0)
                  +-null_handling_modifier=IGNORE_NULLS
--
ALTERNATION GROUP: ,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC,disc
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(INT64, DOUBLE) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=-0)
                  +-null_handling_modifier=IGNORE_NULLS
--
ALTERNATION GROUP: cont
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 1:8]
select percentile_cont(key, -0.0 ignore nulls) over () from keyvalue;
       ^
--
ALTERNATION GROUP: disc
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 1:8]
select percentile_disc(key, -0.0 ignore nulls) over () from keyvalue;
       ^
==

# RESPECT NULLS is allowed for percentile_cont.
[language_features=ANALYTIC_FUNCTIONS{{,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC|}}]
select percentile_{{cont|disc}}(key, 1 respect nulls) over () from keyvalue;
--
ALTERNATION GROUP: ,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC,cont
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
                  +-Cast(INT64 -> DOUBLE)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=1)
                  +-null_handling_modifier=RESPECT_NULLS
--
ALTERNATION GROUP: ,V_1_1_NULL_HANDLING_MODIFIER_IN_ANALYTIC,disc
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(INT64, DOUBLE) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=1)
                  +-null_handling_modifier=RESPECT_NULLS
--
ALTERNATION GROUP: cont
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 1:8]
select percentile_cont(key, 1 respect nulls) over () from keyvalue;
       ^
--
ALTERNATION GROUP: disc
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 1:8]
select percentile_disc(key, 1 respect nulls) over () from keyvalue;
       ^
==

# Second argument cannot be negative DOUBLE.
select percentile_{{cont|disc}}(key, -0.1) over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:29]
select percentile_cont(key, -0.1) over () from keyvalue;
                            ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 1:29]
select percentile_disc(key, -0.1) over () from keyvalue;
                            ^
==

# Second argument cannot be NaN.
select percentile_{{cont|disc}}(key, cast("nan" as double)) over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:29]
select percentile_cont(key, cast("nan" as double)) over () from keyvalue;
                            ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 1:29]
select percentile_disc(key, cast("nan" as double)) over () from keyvalue;
                            ^
==

# Second argument cannot be infinity.
select percentile_{{cont|disc}}(key, cast("inf" as double)) over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:29]
select percentile_cont(key, cast("inf" as double)) over () from keyvalue;
                            ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 1:29]
select percentile_disc(key, cast("inf" as double)) over () from keyvalue;
                            ^
==

# Second argument cannot be > 1 (NUMERIC type).
[language_features=ANALYTIC_FUNCTIONS,NUMERIC_TYPE]
select percentile_{{cont|disc}}(cast(key as numeric), numeric "1.000000001") over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:46]
select percentile_cont(cast(key as numeric), numeric "1.000000001") over () f...
                                             ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 1:46]
select percentile_disc(cast(key as numeric), numeric "1.000000001") over () f...
                                             ^

==

# Second argument cannot be negative NUMERIC.
[language_features=ANALYTIC_FUNCTIONS,NUMERIC_TYPE]
select percentile_{{cont|disc}}(cast(key as numeric), numeric "-1e-9") over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:46]
select percentile_cont(cast(key as numeric), numeric "-1e-9") over () from ke...
                                             ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 1:46]
select percentile_disc(cast(key as numeric), numeric "-1e-9") over () from ke...
                                             ^
==

# Second argument cannot be > 1 (BIGNUMERIC type).
[language_features=ANALYTIC_FUNCTIONS,BIGNUMERIC_TYPE]
select
  percentile_{{cont|disc}}(cast(key as bignumeric),
                           bignumeric "1.00000000000000000000000000000000000001")
  over ()
from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 3:28]
                           bignumeric "1.000000000000000000000000000000000000...
                           ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 3:28]
                           bignumeric "1.000000000000000000000000000000000000...
                           ^

==

# Second argument cannot be negative BIGNUMERIC.
[language_features=ANALYTIC_FUNCTIONS,BIGNUMERIC_TYPE]
select percentile_{{cont|disc}}(cast(key as bignumeric), bignumeric "-1e-38") over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:49]
select percentile_cont(cast(key as bignumeric), bignumeric "-1e-38") over () ...
                                                ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 1:49]
select percentile_disc(cast(key as bignumeric), bignumeric "-1e-38") over () ...
                                                ^
