# This file includes tests for standalone expressions, outside of queries.
# Two expression columns ("column_int32" and "column_KitchenSink") are
# created in run_analyzer_test.cc.
[default parse_location_record_type=PARSE_LOCATION_RECORD_FULL_NODE_SCOPE]
[default mode=expression]

123
--
Literal(parse_location=0-3, type=INT64, value=123)
==

0x123
--
Literal(parse_location=0-5, type=INT64, value=291)
==

'abc'
--
Literal(parse_location=0-5, type=STRING, value='abc')
==

column_KitchenSink
--
ExpressionColumn(parse_location=0-18, type=PROTO<zetasql_test__.KitchenSinkPB>, name='column_kitchensink')
==

# The columns are only visible in AnalyzeStatement mode, not AnalyzeQuery.
[mode=statement]
select column_int32 from KeyValue
--
ERROR: Unrecognized name: column_int32 [at 1:8]
select column_int32 from KeyValue
       ^
==

coLUMN_int32 = 10
--
FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
+-parse_location=0-17
+-ExpressionColumn(parse_location=0-12, type=INT32, name='column_int32')
+-Literal(parse_location=15-17, type=INT32, value=10)
==

some_catalog.column_int32
--
ERROR: Unrecognized name: some_catalog [at 1:1]
some_catalog.column_int32
^
==

column_int32.xyz
--
ERROR: Cannot access field xyz on a value with type INT32 [at 1:14]
column_int32.xyz
             ^
==

column_int32 = 5 and COLUMN_kitchensink.float_val >= 0.0
--
FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
+-parse_location=0-56
+-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
| +-parse_location=0-16
| +-ExpressionColumn(parse_location=0-12, type=INT32, name='column_int32')
| +-Literal(parse_location=15-16, type=INT32, value=5)
+-FunctionCall(ZetaSQL:$greater_or_equal(FLOAT, FLOAT) -> BOOL)
  +-parse_location=21-56
  +-GetProtoField
  | +-parse_location=21-49
  | +-type=FLOAT
  | +-expr=
  | | +-ExpressionColumn(parse_location=21-49, type=PROTO<zetasql_test__.KitchenSinkPB>, name='column_kitchensink')
  | +-field_descriptor=float_val
  | +-default_value=0
  +-Literal(parse_location=53-56, type=FLOAT, value=0)
==

1 + 2 * @test_param_int32
--
FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
+-parse_location=0-25
+-Literal(parse_location=0-1, type=INT64, value=1)
+-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
  +-parse_location=4-25
  +-Literal(parse_location=4-5, type=INT64, value=2)
  +-Cast(INT32 -> INT64)
    +-Parameter(parse_location=8-25, type=INT32, name='test_param_int32')
==

[parameter_mode=positional]
[positional_parameter_types=int32]

1 + 2 * ?
--
FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
+-parse_location=0-9
+-Literal(parse_location=0-1, type=INT64, value=1)
+-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
  +-parse_location=4-9
  +-Literal(parse_location=4-5, type=INT64, value=2)
  +-Cast(INT32 -> INT64)
    +-Parameter(parse_location=8-9, type=INT32, position=1)
==

[parameter_mode=positional]
[positional_parameter_types=int64,int32,double]

? + ? - 5 / ?
--
FunctionCall(ZetaSQL:$subtract(DOUBLE, DOUBLE) -> DOUBLE)
+-parse_location=0-13
+-Cast(INT64 -> DOUBLE)
| +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
|   +-parse_location=0-5
|   +-Parameter(parse_location=0-1, type=INT64, position=1)
|   +-Cast(INT32 -> INT64)
|     +-Parameter(parse_location=4-5, type=INT32, position=2)
+-FunctionCall(ZetaSQL:$divide(DOUBLE, DOUBLE) -> DOUBLE)
  +-parse_location=8-13
  +-Literal(parse_location=8-9, type=DOUBLE, value=5)
  +-Parameter(parse_location=12-13, type=DOUBLE, position=3)
==

column_int32 = @test_param_int32
--
FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
+-parse_location=0-32
+-ExpressionColumn(parse_location=0-12, type=INT32, name='column_int32')
+-Parameter(parse_location=15-32, type=INT32, name='test_param_int32')
==

[parameter_mode=positional]
[positional_parameter_types=int32]

column_int32 = ?
--
FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
+-parse_location=0-16
+-ExpressionColumn(parse_location=0-12, type=INT32, name='column_int32')
+-Parameter(parse_location=15-16, type=INT32, position=1)
==

[parameter_mode=positional]
[allow_undeclared_parameters]

column_int32 = ?
--
FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
+-parse_location=0-16
+-ExpressionColumn(parse_location=0-12, type=INT32, name='column_int32')
+-Parameter(parse_location=15-16, type=INT32, position=1)
[UNDECLARED_PARAMETERS]
INT32
==

@xyz
--
ERROR: Query parameter 'xyz' not found [at 1:1]
@xyz
^
==

[parameter_mode=positional]

?
--
ERROR: Query parameter number 1 is not defined (0 provided) [at 1:1]
?
^
==

[parameter_mode=none]

? = 5
--
ERROR: Parameters are not supported [at 1:1]
? = 5
^
==

[parameter_mode=none]

@test_param_int32 = 5
--
ERROR: Parameters are not supported [at 1:1]
@test_param_int32 = 5
^
==

select 123
--
ERROR: Syntax error: Unexpected keyword SELECT [at 1:1]
select 123
^
==

sqrt(123)
--
FunctionCall(ZetaSQL:sqrt(DOUBLE) -> DOUBLE)
+-parse_location=0-9
+-Literal(parse_location=5-8, type=DOUBLE, value=123)
==

sum(123)
--
ERROR: Aggregate function SUM not allowed in standalone expression [at 1:1]
sum(123)
^
==

1 + count(*)
--
ERROR: Aggregate function COUNT(*) not allowed in standalone expression [at 1:5]
1 + count(*)
    ^
==

# Subquery to construct a struct
(select AS STRUCT 1, 'abc')
--
SubqueryExpr
+-parse_location=0-27
+-type=STRUCT<INT64, STRING>
+-subquery_type=SCALAR
+-subquery=
  +-ProjectScan
    +-parse_location=1-26
    +-column_list=[$make_struct.$struct#3]
    +-expr_list=
    | +-$struct#3 :=
    |   +-MakeStruct
    |     +-type=STRUCT<INT64, STRING>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=$expr_subquery.$col1#1)
    |       +-ColumnRef(type=STRING, column=$expr_subquery.$col2#2)
    +-input_scan=
      +-ProjectScan
        +-column_list=$expr_subquery.[$col1#1, $col2#2]
        +-expr_list=
        | +-$col1#1 := Literal(parse_location=18-19, type=INT64, value=1)
        | +-$col2#2 := Literal(parse_location=21-26, type=STRING, value='abc')
        +-input_scan=
          +-SingleRowScan
==

# Subqueries, including one with aggregation.
(select AS STRUCT 1 x, 2 y).x + (select count(*) from (select 1 union all select 2))
--
FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
+-parse_location=0-84
+-GetStructField
| +-parse_location=0-29
| +-type=INT64
| +-expr=
| | +-SubqueryExpr
| |   +-parse_location=0-27
| |   +-type=STRUCT<x INT64, y INT64>
| |   +-subquery_type=SCALAR
| |   +-subquery=
| |     +-ProjectScan
| |       +-parse_location=1-26
| |       +-column_list=[$make_struct.$struct#3]
| |       +-expr_list=
| |       | +-$struct#3 :=
| |       |   +-MakeStruct
| |       |     +-type=STRUCT<x INT64, y INT64>
| |       |     +-field_list=
| |       |       +-ColumnRef(type=INT64, column=$expr_subquery.x#1)
| |       |       +-ColumnRef(type=INT64, column=$expr_subquery.y#2)
| |       +-input_scan=
| |         +-ProjectScan
| |           +-column_list=$expr_subquery.[x#1, y#2]
| |           +-expr_list=
| |           | +-x#1 := Literal(parse_location=18-19, type=INT64, value=1)
| |           | +-y#2 := Literal(parse_location=23-24, type=INT64, value=2)
| |           +-input_scan=
| |             +-SingleRowScan
| +-field_idx=0
+-SubqueryExpr
  +-parse_location=32-84
  +-type=INT64
  +-subquery_type=SCALAR
  +-subquery=
    +-ProjectScan
      +-parse_location=33-83
      +-column_list=[$aggregate.$agg1#7]
      +-input_scan=
        +-AggregateScan
          +-column_list=[$aggregate.$agg1#7]
          +-input_scan=
          | +-SetOperationScan
          |   +-parse_location=55-82
          |   +-column_list=[$union_all.$col1#6]
          |   +-op_type=UNION_ALL
          |   +-input_item_list=
          |     +-SetOperationItem
          |     | +-scan=
          |     | | +-ProjectScan
          |     | |   +-column_list=[$union_all1.$col1#4]
          |     | |   +-expr_list=
          |     | |   | +-$col1#4 := Literal(parse_location=62-63, type=INT64, value=1)
          |     | |   +-input_scan=
          |     | |     +-SingleRowScan
          |     | +-output_column_list=[$union_all1.$col1#4]
          |     +-SetOperationItem
          |       +-scan=
          |       | +-ProjectScan
          |       |   +-column_list=[$union_all2.$col1#5]
          |       |   +-expr_list=
          |       |   | +-$col1#5 := Literal(parse_location=81-82, type=INT64, value=2)
          |       |   +-input_scan=
          |       |     +-SingleRowScan
          |       +-output_column_list=[$union_all2.$col1#5]
          +-aggregate_list=
            +-$agg1#7 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=40-48)
==

# Subquery over a repeated field in an expression column.
# The extra subquery is required to generate an ArrayScan without UNNEST.
(select count(*) from (select column_KitchenSink as ks) s1, s1.ks.repeated_date)
--
SubqueryExpr
+-parse_location=0-80
+-type=INT64
+-subquery_type=SCALAR
+-subquery=
  +-ProjectScan
    +-parse_location=1-79
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[s1.ks#1]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-parse_location=23-54
        |   |   +-column_list=[s1.ks#1]
        |   |   +-expr_list=
        |   |   | +-ks#1 := ExpressionColumn(parse_location=30-48, type=PROTO<zetasql_test__.KitchenSinkPB>, name='column_kitchensink')
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-array_expr=
        |   | +-GetProtoField
        |   |   +-parse_location=60-79
        |   |   +-type=ARRAY<DATE>
        |   |   +-expr=
        |   |   | +-ColumnRef(parse_location=60-79, type=PROTO<zetasql_test__.KitchenSinkPB>, column=s1.ks#1)
        |   |   +-field_descriptor=repeated_date
        |   |   +-default_value=[]
        |   |   +-format=DATE
        |   +-element_column=$array.repeated_date#2
        +-aggregate_list=
          +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=8-16)
==

# Same thing with UNNEST.
(select count(*) from UNNEST(column_KitchenSink.repeated_date))
--
SubqueryExpr
+-parse_location=0-63
+-type=INT64
+-subquery_type=SCALAR
+-subquery=
  +-ProjectScan
    +-parse_location=1-62
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-ArrayScan
        |   +-array_expr=
        |   | +-GetProtoField
        |   |   +-parse_location=29-61
        |   |   +-type=ARRAY<DATE>
        |   |   +-expr=
        |   |   | +-ExpressionColumn(parse_location=29-61, type=PROTO<zetasql_test__.KitchenSinkPB>, name='column_kitchensink')
        |   |   +-field_descriptor=repeated_date
        |   |   +-default_value=[]
        |   |   +-format=DATE
        |   +-element_column=$array.$unnest1#1
        +-aggregate_list=
          +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=8-16)
==

# A subquery can reference a table that shows up in the catalog.
ARRAY(select Key from KeyValue)
--
SubqueryExpr
+-parse_location=0-31
+-type=ARRAY<INT64>
+-subquery_type=ARRAY
+-subquery=
  +-ProjectScan
    +-parse_location=6-30
    +-column_list=[KeyValue.Key#1]
    +-input_scan=
      +-TableScan(parse_location=22-30, column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
==

# Referencing an identifier that doesn't exist anywhere.
key
--
ERROR: Unrecognized name: key [at 1:1]
key
^
==

# Referencing a table.column isn't allowed.
KeyValue.Key
--
ERROR: Unrecognized name: KeyValue [at 1:1]
KeyValue.Key
^
==

# Star isn't allowed because it isn't really expression syntax (it's part
# of the SELECT list itself) and because it outputs multiple columns.
(select 1 x).*
--
ERROR: Syntax error: Expected end of input but got "." [at 1:13]
(select 1 x).*
            ^
==

@test_param_proto.*
--
ERROR: Syntax error: Expected end of input but got "." [at 1:18]
@test_param_proto.*
                 ^
==

[parameter_mode=positional]
[positional_parameter_types=struct<x int64>]

?.*
--
ERROR: Syntax error: Expected end of input but got "." [at 1:2]
?.*
 ^
==

*
--
ERROR: Syntax error: Unexpected "*" [at 1:1]
*
^
==

xx yy
--
ERROR: Syntax error: Expected end of input but got identifier "yy" [at 1:4]
xx yy
   ^
==

/* comment */ []
--
Literal(parse_location=14-16, type=ARRAY<INT64>, value=[])
==

ARRAY[]
--
Literal(parse_location=0-7, type=ARRAY<INT64>, value=[])
==

ARRAY<int64>[]
--
Literal(parse_location=0-14, type=ARRAY<INT64>, value=[], has_explicit_type=TRUE)
==

/* comment */ [1]
--
Literal(parse_location=14-17, type=ARRAY<INT64>, value=[1])
==

/* comment */ [cast(1 as uint32)]
--
Literal(parse_location=14-33, type=ARRAY<UINT32>, value=[1], has_explicit_type=TRUE)
==

ARRAY[cast(1 as uint32)]
--
Literal(parse_location=0-24, type=ARRAY<UINT32>, value=[1], has_explicit_type=TRUE)
==

ARRAY<uint64>[cast(1 as uint32)]
--
Literal(parse_location=0-32, type=ARRAY<UINT64>, value=[1], has_explicit_type=TRUE)
==

ARRAY[(select key from KeyValue), @test_param_int32]
--
FunctionCall(ZetaSQL:$make_array(repeated(2) INT64) -> ARRAY<INT64>)
+-parse_location=0-52
+-SubqueryExpr
| +-parse_location=6-32
| +-type=INT64
| +-subquery_type=SCALAR
| +-subquery=
|   +-ProjectScan
|     +-parse_location=7-31
|     +-column_list=[KeyValue.Key#1]
|     +-input_scan=
|       +-TableScan(parse_location=23-31, column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-Cast(INT32 -> INT64)
  +-Parameter(parse_location=34-51, type=INT32, name='test_param_int32')
==

[parameter_mode=positional]
[positional_parameter_types=int32]

ARRAY[(select key from KeyValue), ?]
--
FunctionCall(ZetaSQL:$make_array(repeated(2) INT64) -> ARRAY<INT64>)
+-parse_location=0-36
+-SubqueryExpr
| +-parse_location=6-32
| +-type=INT64
| +-subquery_type=SCALAR
| +-subquery=
|   +-ProjectScan
|     +-parse_location=7-31
|     +-column_list=[KeyValue.Key#1]
|     +-input_scan=
|       +-TableScan(parse_location=23-31, column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-Cast(INT32 -> INT64)
  +-Parameter(parse_location=34-35, type=INT32, position=1)
==

current_date
--
FunctionCall(ZetaSQL:current_date(optional(0) STRING) -> DATE)(parse_location=0-12)
==

current_timestamp()
--
FunctionCall(ZetaSQL:current_timestamp() -> TIMESTAMP)(parse_location=0-19)
==

current_date('UTC')
--
FunctionCall(ZetaSQL:current_date(optional(1) STRING) -> DATE)
+-parse_location=0-19
+-Literal(parse_location=13-18, type=STRING, value='UTC')

==

date '2001-01-01'
--
Literal(parse_location=0-17, type=DATE, value=2001-01-01, has_explicit_type=TRUE)
==

cast(date '2001-01-01' as DATE)
--

Literal(parse_location=0-31, type=DATE, value=2001-01-01, has_explicit_type=TRUE)
==

timestamp '2011-01-01 12:34:56 America/Los_Angeles'
--
Literal(parse_location=0-51, type=TIMESTAMP, value=2011-01-01 20:34:56+00, has_explicit_type=TRUE)
==

cast(timestamp '2011-01-01 12:34:56 UTC' as TIMESTAMP)
--
Literal(parse_location=0-54, type=TIMESTAMP, value=2011-01-01 12:34:56+00, has_explicit_type=TRUE)
==

# Show the effect of the default timezone.
[default_timezone=America/Los_Angeles]
cast(timestamp '2011-01-01 12:34:56' as TIMESTAMP)
--
Literal(parse_location=0-50, type=TIMESTAMP, value=2011-01-01 20:34:56+00, has_explicit_type=TRUE)
==

[default_timezone=UTC]
cast(timestamp '2011-01-01 12:34:56' as TIMESTAMP)
--
Literal(parse_location=0-50, type=TIMESTAMP, value=2011-01-01 12:34:56+00, has_explicit_type=TRUE)
==

[language_features={{V_1_2_CIVIL_TIME|}}]
time '01:02:03.123456'
--
ALTERNATION GROUP: V_1_2_CIVIL_TIME
--
Literal(parse_location=0-22, type=TIME, value=01:02:03.123456, has_explicit_type=TRUE)
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: TIME [at 1:1]
time '01:02:03.123456'
^
==

[language_features={{V_1_2_CIVIL_TIME|}}]
time 'abc'
--
ALTERNATION GROUP: V_1_2_CIVIL_TIME
--
ERROR: Invalid TIME literal [at 1:1]
time 'abc'
^
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: TIME [at 1:1]
time 'abc'
^
==

[language_features={{V_1_2_CIVIL_TIME|}}]
time '01:02:03.123456abc'
--
ALTERNATION GROUP: V_1_2_CIVIL_TIME
--
ERROR: Invalid TIME literal [at 1:1]
time '01:02:03.123456abc'
^
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: TIME [at 1:1]
time '01:02:03.123456abc'
^
==

[language_features={{V_1_2_CIVIL_TIME|}}]
time '24:00:00'
--
ALTERNATION GROUP: V_1_2_CIVIL_TIME
--
ERROR: Invalid TIME literal [at 1:1]
time '24:00:00'
^
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: TIME [at 1:1]
time '24:00:00'
^
==

[language_features={{V_1_2_CIVIL_TIME|}}]
datetime '2006-01-02 03:04:05.123456'
--
ALTERNATION GROUP: V_1_2_CIVIL_TIME
--
Literal(parse_location=0-37, type=DATETIME, value=2006-01-02 03:04:05.123456, has_explicit_type=TRUE)
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: DATETIME [at 1:1]
datetime '2006-01-02 03:04:05.123456'
^
==

[language_features={{V_1_2_CIVIL_TIME|}}]
datetime 'abc'
--
ALTERNATION GROUP: V_1_2_CIVIL_TIME
--
ERROR: Invalid DATETIME literal [at 1:1]
datetime 'abc'
^
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: DATETIME [at 1:1]
datetime 'abc'
^
==

[language_features={{V_1_2_CIVIL_TIME|}}]
datetime '2006-01-02 03:04:05.123456abc'
--
ALTERNATION GROUP: V_1_2_CIVIL_TIME
--
ERROR: Invalid DATETIME literal [at 1:1]
datetime '2006-01-02 03:04:05.123456abc'
^
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: DATETIME [at 1:1]
datetime '2006-01-02 03:04:05.123456abc'
^
==

[language_features={{V_1_2_CIVIL_TIME|}}]
datetime '2006-13-02 03:04:05.123456'
--
ALTERNATION GROUP: V_1_2_CIVIL_TIME
--
ERROR: Invalid DATETIME literal [at 1:1]
datetime '2006-13-02 03:04:05.123456'
^
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: DATETIME [at 1:1]
datetime '2006-13-02 03:04:05.123456'
^
==

[language_features={{V_1_2_CIVIL_TIME|}}]
datetime '2006-13-02 03:04:05.123456 UTC'
--
ALTERNATION GROUP: V_1_2_CIVIL_TIME
--
ERROR: Invalid DATETIME literal [at 1:1]
datetime '2006-13-02 03:04:05.123456 UTC'
^
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: DATETIME [at 1:1]
datetime '2006-13-02 03:04:05.123456 UTC'
^
==

# Using an expression value column, we can get the full value by name.
[in_scope_expression_column_name=value]
value
--
ExpressionColumn(parse_location=0-5, type=PROTO<zetasql_test__.KitchenSinkPB>, name='value')
==

# Setting the [in_scope_expression_column_name] switches us to have one
# in_scope_expression_column rather than two named expression_columns.
[in_scope_expression_column_name=value]
int64_key_1
--
GetProtoField
+-parse_location=0-11
+-type=INT64
+-expr=
| +-ExpressionColumn(type=PROTO<zetasql_test__.KitchenSinkPB>, name='value')
+-field_descriptor=int64_key_1
==

[in_scope_expression_column_name=value]
has_int64_key_1
--
GetProtoField
+-parse_location=0-15
+-type=BOOL
+-expr=
| +-ExpressionColumn(type=PROTO<zetasql_test__.KitchenSinkPB>, name='value')
+-field_descriptor=int64_key_1
+-get_has_bit=TRUE
==

[in_scope_expression_column_name=value]
nested_value.nested_int64 +
value.nested_repeated_group[DEFAULT_OFFSET(0)].nestedrepeatedgroupnested[ORDINAL(2)].id
--
FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
+-parse_location=0-115
+-GetProtoField
| +-parse_location=0-25
| +-type=INT64
| +-expr=
| | +-GetProtoField
| |   +-parse_location=0-12
| |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
| |   +-expr=
| |   | +-ExpressionColumn(type=PROTO<zetasql_test__.KitchenSinkPB>, name='value')
| |   +-field_descriptor=nested_value
| |   +-default_value=NULL
| +-field_descriptor=nested_int64
| +-default_value=88
+-GetProtoField
  +-parse_location=28-115
  +-type=INT64
  +-expr=
  | +-FunctionCall(ZetaSQL:$array_at_ordinal(ARRAY<PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup.NestedRepeatedGroupNested>>, INT64) -> PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup.NestedRepeatedGroupNested>)
  |   +-parse_location=28-112
  |   +-GetProtoField
  |   | +-parse_location=28-100
  |   | +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup.NestedRepeatedGroupNested>>
  |   | +-expr=
  |   | | +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup>>, INT64) -> PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup>)
  |   | |   +-parse_location=28-74
  |   | |   +-GetProtoField
  |   | |   | +-parse_location=28-55
  |   | |   | +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.NestedRepeatedGroup>>
  |   | |   | +-expr=
  |   | |   | | +-ExpressionColumn(parse_location=28-55, type=PROTO<zetasql_test__.KitchenSinkPB>, name='value')
  |   | |   | +-field_descriptor=nested_repeated_group
  |   | |   | +-default_value=[]
  |   | |   +-Literal(parse_location=71-72, type=INT64, value=0)
  |   | +-field_descriptor=nestedrepeatedgroupnested
  |   | +-default_value=[]
  |   +-Literal(parse_location=109-110, type=INT64, value=2)
  +-field_descriptor=id
==

# We can get to fields directly or by using the name 'sink', and
# can access has_ fields either way.
[in_scope_expression_column_name=sink]
(sink.int64_key_1 + int64_key_2,
 has_int32_val,
 repeated_date,
 sink.has_timestamp_micros,
 MIXed_CAse,
 sink.has_MixED_cASe,
 sink)
--
MakeStruct
+-type=STRUCT<INT64, BOOL, ARRAY<DATE>, BOOL, STRING, BOOL, PROTO<zetasql_test__.KitchenSinkPB>>
+-field_list=
  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
  | +-parse_location=1-31
  | +-GetProtoField
  | | +-parse_location=1-17
  | | +-type=INT64
  | | +-expr=
  | | | +-ExpressionColumn(parse_location=1-17, type=PROTO<zetasql_test__.KitchenSinkPB>, name='sink')
  | | +-field_descriptor=int64_key_1
  | +-GetProtoField
  |   +-parse_location=20-31
  |   +-type=INT64
  |   +-expr=
  |   | +-ExpressionColumn(type=PROTO<zetasql_test__.KitchenSinkPB>, name='sink')
  |   +-field_descriptor=int64_key_2
  +-GetProtoField
  | +-parse_location=34-47
  | +-type=BOOL
  | +-expr=
  | | +-ExpressionColumn(type=PROTO<zetasql_test__.KitchenSinkPB>, name='sink')
  | +-field_descriptor=int32_val
  | +-get_has_bit=TRUE
  +-GetProtoField
  | +-parse_location=50-63
  | +-type=ARRAY<DATE>
  | +-expr=
  | | +-ExpressionColumn(type=PROTO<zetasql_test__.KitchenSinkPB>, name='sink')
  | +-field_descriptor=repeated_date
  | +-default_value=[]
  | +-format=DATE
  +-GetProtoField
  | +-parse_location=66-91
  | +-type=BOOL
  | +-expr=
  | | +-ExpressionColumn(parse_location=66-91, type=PROTO<zetasql_test__.KitchenSinkPB>, name='sink')
  | +-field_descriptor=timestamp_micros
  | +-get_has_bit=TRUE
  +-GetProtoField
  | +-parse_location=94-104
  | +-type=STRING
  | +-expr=
  | | +-ExpressionColumn(type=PROTO<zetasql_test__.KitchenSinkPB>, name='sink')
  | +-field_descriptor=MIXED_case
  | +-default_value=''
  +-GetProtoField
  | +-parse_location=107-126
  | +-type=BOOL
  | +-expr=
  | | +-ExpressionColumn(parse_location=107-126, type=PROTO<zetasql_test__.KitchenSinkPB>, name='sink')
  | +-field_descriptor=MIXED_case
  | +-get_has_bit=TRUE
  +-ExpressionColumn(parse_location=129-133, type=PROTO<zetasql_test__.KitchenSinkPB>, name='sink')
==

# We can use UNNEST to scan an array field of the value column.
[in_scope_expression_column_name=sink]
(select count(*) from UNNEST(repeated_date))
--
SubqueryExpr
+-parse_location=0-44
+-type=INT64
+-subquery_type=SCALAR
+-subquery=
  +-ProjectScan
    +-parse_location=1-43
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-ArrayScan
        |   +-array_expr=
        |   | +-GetProtoField
        |   |   +-parse_location=29-42
        |   |   +-type=ARRAY<DATE>
        |   |   +-expr=
        |   |   | +-ExpressionColumn(type=PROTO<zetasql_test__.KitchenSinkPB>, name='sink')
        |   |   +-field_descriptor=repeated_date
        |   |   +-default_value=[]
        |   |   +-format=DATE
        |   +-element_column=$array.$unnest1#1
        +-aggregate_list=
          +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=8-16)
==

# We can't use field names directly in the FROM clause, even with qualifiers.
[in_scope_expression_column_name=sink]
(select count(*) from {{repeated_date|sink.repeated_date}})
--
ALTERNATION GROUP: repeated_date
--
ERROR: Table not found: repeated_date [at 1:23]
(select count(*) from repeated_date)
                      ^
--
ALTERNATION GROUP: sink.repeated_date
--
ERROR: Table not found: sink.repeated_date [at 1:23]
(select count(*) from sink.repeated_date)
                      ^
==

# With an unnamed expression value column, we can still get fields
# by name.
[in_scope_expression_column_name=]
(int64_key_1, has_date)
--
MakeStruct
+-type=STRUCT<INT64, BOOL>
+-field_list=
  +-GetProtoField
  | +-parse_location=1-12
  | +-type=INT64
  | +-expr=
  | | +-ExpressionColumn(type=PROTO<zetasql_test__.KitchenSinkPB>, name='')
  | +-field_descriptor=int64_key_1
  +-GetProtoField
    +-parse_location=14-22
    +-type=BOOL
    +-expr=
    | +-ExpressionColumn(type=PROTO<zetasql_test__.KitchenSinkPB>, name='')
    +-field_descriptor=date
    +-get_has_bit=TRUE
==

# Bad field names when we have an anonymous expression value column.
[in_scope_expression_column_name=]
{{bad_field_name|has_bad_field_name}}
--
ALTERNATION GROUP: bad_field_name
--
ERROR: Unrecognized name: bad_field_name [at 1:1]
bad_field_name
^
--
ALTERNATION GROUP: has_bad_field_name
--
ERROR: Unrecognized name: has_bad_field_name [at 1:1]
has_bad_field_name
^
==

# Bad field names when we have a named expression value column.
[in_scope_expression_column_name=value]
{{bad_name|has_bad_name|value.bad_name|value.has_bad_name}}
--
ALTERNATION GROUP: bad_name
--
ERROR: Unrecognized name: bad_name [at 1:1]
bad_name
^
--
ALTERNATION GROUP: has_bad_name
--
ERROR: Unrecognized name: has_bad_name [at 1:1]
has_bad_name
^
--
ALTERNATION GROUP: value.bad_name
--
ERROR: Protocol buffer zetasql_test__.KitchenSinkPB does not have a field called bad_name [at 1:7]
value.bad_name
      ^
--
ALTERNATION GROUP: value.has_bad_name
--
ERROR: Protocol buffer zetasql_test__.KitchenSinkPB does not have a field called has_bad_name [at 1:7]
value.has_bad_name
      ^
==

[in_scope_expression_column_name=value]
[in_scope_expression_column_type=INT32]
value
--
ExpressionColumn(parse_location=0-5, type=INT32, name='value')
==

[in_scope_expression_column_name=value]
[in_scope_expression_column_type=INT32]
value.xyz
--
ERROR: Cannot access field xyz on a value with type INT32 [at 1:7]
value.xyz
      ^
==

# This includes case insensitive value and struct field lookups.
[in_scope_expression_column_name=VALue]
[in_scope_expression_column_type=struct<xxxXXX int32, double, s string>]
(value,
 valUE.xXxXxX,
 s)
--
MakeStruct
+-type=STRUCT<STRUCT<xxxXXX INT32, DOUBLE, s STRING>, INT32, STRING>
+-field_list=
  +-ExpressionColumn(parse_location=1-6, type=STRUCT<xxxXXX INT32, DOUBLE, s STRING>, name='value')
  +-GetStructField
  | +-parse_location=9-21
  | +-type=INT32
  | +-expr=
  | | +-ExpressionColumn(parse_location=9-21, type=STRUCT<xxxXXX INT32, DOUBLE, s STRING>, name='value')
  | +-field_idx=0
  +-GetStructField
    +-parse_location=24-25
    +-type=STRING
    +-expr=
    | +-ExpressionColumn(type=STRUCT<xxxXXX INT32, DOUBLE, s STRING>, name='value')
    +-field_idx=2
==

[in_scope_expression_column_name=]
[in_scope_expression_column_type=struct<x int32, double, s string>]
(x, s)
--
MakeStruct
+-type=STRUCT<INT32, STRING>
+-field_list=
  +-GetStructField
  | +-parse_location=1-2
  | +-type=INT32
  | +-expr=
  | | +-ExpressionColumn(type=STRUCT<x INT32, DOUBLE, s STRING>, name='')
  | +-field_idx=0
  +-GetStructField
    +-parse_location=4-5
    +-type=STRING
    +-expr=
    | +-ExpressionColumn(type=STRUCT<x INT32, DOUBLE, s STRING>, name='')
    +-field_idx=2
==

# Bad names with a struct expression value column.
[in_scope_expression_column_name=]
[in_scope_expression_column_type=struct<x int32, double, s string>]
bad
--
ERROR: Unrecognized name: bad [at 1:1]
bad
^
==

# Bad names with a named struct expression value column.
[in_scope_expression_column_name=value]
[in_scope_expression_column_type=struct<x int32, double, s string>]
{{bad|value.bad}}
--
ALTERNATION GROUP: bad
--
ERROR: Unrecognized name: bad [at 1:1]
bad
^
--
ALTERNATION GROUP: value.bad
--
ERROR: Field name bad does not exist in STRUCT<x INT32, DOUBLE, s STRING> [at 1:7]
value.bad
      ^
==

[in_scope_expression_column_name=value]
[in_scope_expression_column_type=array<date>]
value
--
ExpressionColumn(parse_location=0-5, type=ARRAY<DATE>, name='value')
==

[in_scope_expression_column_name=value]
[in_scope_expression_column_type=array<date>]
value.x
--
ERROR: Cannot access field x on a value with type ARRAY<DATE> [at 1:7]
value.x
      ^
==

# Use both the in-scope expression column and a named expression column.
[in_scope_expression_column_name=value]
column_KitchenSink.int64_key_1 + value.int64_key_2 + int32_val
--
FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
+-parse_location=0-62
+-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
| +-parse_location=0-50
| +-GetProtoField
| | +-parse_location=0-30
| | +-type=INT64
| | +-expr=
| | | +-ExpressionColumn(parse_location=0-30, type=PROTO<zetasql_test__.KitchenSinkPB>, name='column_kitchensink')
| | +-field_descriptor=int64_key_1
| +-GetProtoField
|   +-parse_location=33-50
|   +-type=INT64
|   +-expr=
|   | +-ExpressionColumn(parse_location=33-50, type=PROTO<zetasql_test__.KitchenSinkPB>, name='value')
|   +-field_descriptor=int64_key_2
+-Cast(INT32 -> INT64)
  +-GetProtoField
    +-parse_location=53-62
    +-type=INT32
    +-expr=
    | +-ExpressionColumn(type=PROTO<zetasql_test__.KitchenSinkPB>, name='value')
    +-field_descriptor=int32_val
    +-default_value=77
==

# If we have a conflict between an expression column name and an in-scope
# expression column's field, the column name takes precedence.
# Here, "int32_val" is used as a column name with type KitchenSinkPB.
[in_scope_expression_column_name=int32_val]
(int32_val, int32_val.int32_val)
--
MakeStruct
+-type=STRUCT<PROTO<zetasql_test__.KitchenSinkPB>, INT32>
+-field_list=
  +-ExpressionColumn(parse_location=1-10, type=PROTO<zetasql_test__.KitchenSinkPB>, name='int32_val')
  +-GetProtoField
    +-parse_location=12-31
    +-type=INT32
    +-expr=
    | +-ExpressionColumn(parse_location=12-31, type=PROTO<zetasql_test__.KitchenSinkPB>, name='int32_val')
    +-field_descriptor=int32_val
    +-default_value=77
==

# Scoping - names introduced locally hide the expression columns and
# in-scope expression column fields.
[in_scope_expression_column_name=value]
(select AS STRUCT value, int64_key_1 from (select 5 value, 6 int64_key_1, int64_key_2))
--
SubqueryExpr
+-parse_location=0-87
+-type=STRUCT<value INT64, int64_key_1 INT64>
+-subquery_type=SCALAR
+-subquery=
  +-ProjectScan
    +-parse_location=1-86
    +-column_list=[$make_struct.$struct#4]
    +-expr_list=
    | +-$struct#4 :=
    |   +-MakeStruct
    |     +-type=STRUCT<value INT64, int64_key_1 INT64>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=$subquery1.value#1)
    |       +-ColumnRef(type=INT64, column=$subquery1.int64_key_1#2)
    +-input_scan=
      +-ProjectScan
        +-column_list=$subquery1.[value#1, int64_key_1#2]
        +-input_scan=
          +-ProjectScan
            +-parse_location=43-85
            +-column_list=$subquery1.[value#1, int64_key_1#2, int64_key_2#3]
            +-expr_list=
            | +-value#1 := Literal(parse_location=50-51, type=INT64, value=5)
            | +-int64_key_1#2 := Literal(parse_location=59-60, type=INT64, value=6)
            | +-int64_key_2#3 :=
            |   +-GetProtoField
            |     +-parse_location=74-85
            |     +-type=INT64
            |     +-expr=
            |     | +-ExpressionColumn(type=PROTO<zetasql_test__.KitchenSinkPB>, name='value')
            |     +-field_descriptor=int64_key_2
            +-input_scan=
              +-SingleRowScan
==

# Analytic function is not allowed in standalone expression unless it is
# inside a subquery expression with FROM.
[default language_features=ANALYTIC_FUNCTIONS]
afn_agg() over ()
--
ERROR: Analytic function not allowed in standalone expression [at 1:1]
afn_agg() over ()
^
==

sqrt(123) over ()
--
ERROR: Analytic function not allowed in standalone expression [at 1:1]
sqrt(123) over ()
^
==

unknown_fn() over ()
--
ERROR: Analytic function not allowed in standalone expression [at 1:1]
unknown_fn() over ()
^
==

# Analytic function can be in a subquery expression within a standalone
# expression.
1 + (select afn_agg() over() from (select 1))
--
FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
+-parse_location=0-45
+-Literal(parse_location=0-1, type=INT64, value=1)
+-SubqueryExpr
  +-parse_location=4-45
  +-type=INT64
  +-subquery_type=SCALAR
  +-subquery=
    +-ProjectScan
      +-parse_location=5-44
      +-column_list=[$analytic.$analytic1#3]
      +-input_scan=
        +-AnalyticScan
          +-column_list=[$subquery1.$col1#1, $analytic.$analytic1#3]
          +-input_scan=
          | +-ProjectScan
          |   +-parse_location=35-43
          |   +-column_list=[$subquery1.$col1#1]
          |   +-expr_list=
          |   | +-$col1#1 := Literal(parse_location=42-43, type=INT64, value=1)
          |   +-input_scan=
          |     +-SingleRowScan
          +-function_group_list=
            +-AnalyticFunctionGroup
              +-analytic_function_list=
                +-$analytic1#3 :=
                  +-AnalyticFunctionCall(sample_functions:afn_agg() -> INT64)
                    +-window_frame=
                      +-WindowFrame(frame_unit=ROWS)
                        +-start_expr=
                        | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                        +-end_expr=
                          +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

NEW zetasql_test__.TestExtraPB(
  ['abc', 'def'] AS str_value,
  17 AS int32_val1)
--
MakeProto
+-parse_location=4-30
+-type=PROTO<zetasql_test__.TestExtraPB>
+-field_list=
  +-str_value := Literal(parse_location=34-48, type=ARRAY<STRING>, value=['abc', 'def'])
  +-int32_val1 := Literal(parse_location=65-67, type=INT32, value=17)
==

[language_features={{|V_1_2_SAFE_FUNCTION_CALL}}]
safe.concat('abc')
--
ALTERNATION GROUP: <empty>
--
ERROR: Function calls with SAFE are not supported [at 1:1]
safe.concat('abc')
^
--
ALTERNATION GROUP: V_1_2_SAFE_FUNCTION_CALL
--
FunctionCall({SAFE_ERROR_MODE} ZetaSQL:concat(STRING, repeated(0) STRING) -> STRING)
+-parse_location=0-18
+-Literal(parse_location=12-17, type=STRING, value='abc')
==

[language_features={{|V_1_2_SAFE_FUNCTION_CALL}}]
(select safe.sum(x) from unnest([1,2,3]) x)
--
ALTERNATION GROUP: <empty>
--
ERROR: Function calls with SAFE are not supported [at 1:9]
(select safe.sum(x) from unnest([1,2,3]) x)
        ^
--
ALTERNATION GROUP: V_1_2_SAFE_FUNCTION_CALL
--
SubqueryExpr
+-parse_location=0-43
+-type=INT64
+-subquery_type=SCALAR
+-subquery=
  +-ProjectScan
    +-parse_location=1-42
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[$array.x#1]
        |   +-array_expr=
        |   | +-Literal(parse_location=32-39, type=ARRAY<INT64>, value=[1, 2, 3])
        |   +-element_column=$array.x#1
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall({SAFE_ERROR_MODE} ZetaSQL:sum(INT64) -> INT64)
              +-parse_location=8-19
              +-ColumnRef(type=INT64, column=$array.x#1)
==

# When resolving standalone expressions, an expression column takes precedence
# over a named constant with the same name.
(SELECT AS STRUCT column_KitchenSink, column_KitchenSink.float_val, TestConstantInt64)
--
SubqueryExpr
+-parse_location=0-86
+-type=STRUCT<column_KitchenSink PROTO<zetasql_test__.KitchenSinkPB>, float_val FLOAT, TestConstantInt64 INT64>
+-subquery_type=SCALAR
+-subquery=
  +-ProjectScan
    +-parse_location=1-85
    +-column_list=[$make_struct.$struct#4]
    +-expr_list=
    | +-$struct#4 :=
    |   +-MakeStruct
    |     +-type=STRUCT<column_KitchenSink PROTO<zetasql_test__.KitchenSinkPB>, float_val FLOAT, TestConstantInt64 INT64>
    |     +-field_list=
    |       +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=$expr_subquery.column_KitchenSink#1)
    |       +-ColumnRef(type=FLOAT, column=$expr_subquery.float_val#2)
    |       +-ColumnRef(type=INT64, column=$expr_subquery.TestConstantInt64#3)
    +-input_scan=
      +-ProjectScan
        +-column_list=$expr_subquery.[column_KitchenSink#1, float_val#2, TestConstantInt64#3]
        +-expr_list=
        | +-column_KitchenSink#1 := ExpressionColumn(parse_location=18-36, type=PROTO<zetasql_test__.KitchenSinkPB>, name='column_kitchensink')
        | +-float_val#2 :=
        | | +-GetProtoField
        | |   +-parse_location=38-66
        | |   +-type=FLOAT
        | |   +-expr=
        | |   | +-ExpressionColumn(parse_location=38-66, type=PROTO<zetasql_test__.KitchenSinkPB>, name='column_kitchensink')
        | |   +-field_descriptor=float_val
        | |   +-default_value=0
        | +-TestConstantInt64#3 := Constant(TestConstantInt64, parse_location=68-85, type=INT64, value=1)
        +-input_scan=
          +-SingleRowScan
==

# The standalone expression resolves a name to a named constant.
{{TestConstantInt64|nested_catalog.TestConstantBool}}
--
ALTERNATION GROUP: TestConstantInt64
--
Constant(TestConstantInt64, parse_location=0-17, type=INT64, value=1)
--
ALTERNATION GROUP: nested_catalog.TestConstantBool
--
Constant(nested_catalog.TestConstantBool, parse_location=0-31, type=BOOL, value=false)
==

# Name suggestion works for standalone expressions.
TestConstant64
--
ERROR: Unrecognized name: TestConstant64; Did you mean TestConstantInt64? [at 1:1]
TestConstant64
^
==

[language_features=V_1_3_WITH_GROUP_ROWS]
sum(x) with group_rows(select x from group_rows())
--
ERROR: Aggregate function SUM not allowed in standalone expression [at 1:1]
sum(x) with group_rows(select x from group_rows())
^
==

[language_features=V_1_3_WITH_GROUP_ROWS]
(select sum(x) with group_rows(select x from group_rows()) from (select 1 x))
--
SubqueryExpr
+-parse_location=0-77
+-type=INT64
+-subquery_type=SCALAR
+-subquery=
  +-ProjectScan
    +-parse_location=1-76
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-ProjectScan
        |   +-parse_location=65-75
        |   +-column_list=[$subquery1.x#1]
        |   +-expr_list=
        |   | +-x#1 := Literal(parse_location=72-73, type=INT64, value=1)
        |   +-input_scan=
        |     +-SingleRowScan
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
              +-parse_location=8-58
              +-ColumnRef(parse_location=12-13, type=INT64, column=$subquery1.x#2)
              +-with_group_rows_subquery=
                +-ProjectScan
                  +-parse_location=31-57
                  +-column_list=[$subquery1.x#2]
                  +-input_scan=
                    +-GroupRowsScan
                      +-column_list=[$subquery1.x#2]
                      +-input_column_list=
                        +-x#2 := ColumnRef(type=INT64, column=$subquery1.x#1)
==

group_rows()
--
ERROR: Function not found: group_rows [at 1:1]
group_rows()
^
==

[language_features=TABLE_VALUED_FUNCTIONS]
(select x from group_rows())
--
ERROR: Table-valued function not found: group_rows [at 1:16]
(select x from group_rows())
               ^
