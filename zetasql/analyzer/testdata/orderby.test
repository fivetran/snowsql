select 1, 2, 3 from KeyValue order by 2 desc, 3, 1 asc;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS "$col1" [INT64]
| +-$query.$col2#4 AS "$col2" [INT64]
| +-$query.$col3#5 AS "$col3" [INT64]
+-query=
  +-OrderByScan
    +-column_list=$query.[$col1#3, $col2#4, $col3#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=$query.[$col1#3, $col2#4, $col3#5]
    |   +-expr_list=
    |   | +-$col1#3 := Literal(type=INT64, value=1)
    |   | +-$col2#4 := Literal(type=INT64, value=2)
    |   | +-$col3#5 := Literal(type=INT64, value=3)
    |   +-input_scan=
    |     +-TableScan(table=KeyValue)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      | | +-ColumnRef(type=INT64, column=$query.$col2#4)
      | +-is_descending=TRUE
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$query.$col3#5)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$query.$col1#3)
==

select key from TestTable order by 1;
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
+-query=
  +-OrderByScan
    +-column_list=[TestTable.key#1]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=TestTable.key#1)
==

select * from TestTable order by 1;
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-OrderByScan
    +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=TestTable.key#1)
==

select key from TestTable group by key order by 1;
--
QueryStmt
+-output_column_list=
| +-$groupby.key#4 AS key [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#4]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.key#4]
    |   +-input_scan=
    |   | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
    |   +-group_by_list=
    |     +-key#4 := ColumnRef(type=INT32, column=TestTable.key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$groupby.key#4)
==

select key, min(value) from KeyValue group by key having key > 5 order by 1;
--
QueryStmt
+-output_column_list=
| +-$groupby.key#4 AS key [INT64]
| +-$aggregate.$agg1#3 AS "$col2" [STRING]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-FilterScan
    |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
    |   +-input_scan=
    |   | +-AggregateScan
    |   |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-group_by_list=
    |   |   | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |   +-aggregate_list=
    |   |     +-$agg1#3 :=
    |   |       +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
    |   |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |   +-filter_expr=
    |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |       +-ColumnRef(type=INT64, column=$groupby.key#4)
    |       +-Literal(type=INT64, value=5)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$groupby.key#4)
==

select key, min(value) from KeyValue group by key having key > 5 order by 2;
--
QueryStmt
+-output_column_list=
| +-$groupby.key#4 AS key [INT64]
| +-$aggregate.$agg1#3 AS "$col2" [STRING]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-FilterScan
    |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
    |   +-input_scan=
    |   | +-AggregateScan
    |   |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-group_by_list=
    |   |   | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |   +-aggregate_list=
    |   |     +-$agg1#3 :=
    |   |       +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
    |   |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |   +-filter_expr=
    |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |       +-ColumnRef(type=INT64, column=$groupby.key#4)
    |       +-Literal(type=INT64, value=5)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=STRING, column=$aggregate.$agg1#3)
==

# ORDER BY is evaluated before struct construction.
select as struct key, value from KeyValue order by 1;
--
QueryStmt
+-output_column_list=
| +-$make_struct.$struct#3 AS "$struct" [STRUCT<key INT64, value STRING>]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$make_struct.$struct#3]
    +-is_ordered=TRUE
    +-expr_list=
    | +-$struct#3 :=
    |   +-MakeStruct
    |     +-type=STRUCT<key INT64, value STRING>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-input_scan=
      +-OrderByScan
        +-column_list=KeyValue.[Key#1, Value#2]
        +-is_ordered=TRUE
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-order_by_item_list=
          +-OrderByItem
            +-column_ref=
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# ORDER BY in a subquery.
# Note that we do not have is_ordered here.
select * from (select key, KitchenSink from TestTable order by 1);
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=TestTable.[key#1, KitchenSink#3]
    +-input_scan=
      +-OrderByScan
        +-column_list=TestTable.[key#1, KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-order_by_item_list=
          +-OrderByItem
            +-column_ref=
              +-ColumnRef(type=INT32, column=TestTable.key#1)
==

# ORDER BY multiple columns.
select key, value from KeyValue order by 2, 1;
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Value#2 AS value [STRING]
+-query=
  +-OrderByScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# ORDER BY multiple columns.
select key, value from KeyValue order by 2, 1, 2, 1, 1, 1;
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Value#2 AS value [STRING]
+-query=
  +-OrderByScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# Multiple columns with ascending/descending.  Can ORDER BY all simple types.
select * from SimpleTypes
order by 1, 2, 3 asc, 4 desc, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14;
--
QueryStmt
+-output_column_list=
| +-SimpleTypes.int32#1 AS int32 [INT32]
| +-SimpleTypes.int64#2 AS int64 [INT64]
| +-SimpleTypes.uint32#3 AS uint32 [UINT32]
| +-SimpleTypes.uint64#4 AS uint64 [UINT64]
| +-SimpleTypes.string#5 AS string [STRING]
| +-SimpleTypes.bytes#6 AS bytes [BYTES]
| +-SimpleTypes.bool#7 AS bool [BOOL]
| +-SimpleTypes.float#8 AS float [FLOAT]
| +-SimpleTypes.double#9 AS double [DOUBLE]
| +-SimpleTypes.date#10 AS date [DATE]
| +-SimpleTypes.timestamp_seconds#11 AS timestamp_seconds [TIMESTAMP]
| +-SimpleTypes.timestamp_millis#12 AS timestamp_millis [TIMESTAMP]
| +-SimpleTypes.timestamp_micros#13 AS timestamp_micros [TIMESTAMP]
| +-SimpleTypes.timestamp_nanos#14 AS timestamp_nanos [TIMESTAMP]
| +-SimpleTypes.timestamp#15 AS timestamp [TIMESTAMP]
| +-SimpleTypes.numeric#16 AS numeric [NUMERIC]
| +-SimpleTypes.bignumeric#17 AS bignumeric [BIGNUMERIC]
| +-SimpleTypes.json#18 AS json [JSON]
+-query=
  +-OrderByScan
    +-column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17])
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
      +-OrderByItem
      | +-column_ref=
      | | +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
      | +-is_descending=TRUE
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=BOOL, column=SimpleTypes.bool#7)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp_seconds#11)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp_millis#12)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp_micros#13)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp_nanos#14)
==

# ORDER BY enum type.
select TestEnum from ComplexTypes
order by 1;
--
QueryStmt
+-output_column_list=
| +-ComplexTypes.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
+-query=
  +-OrderByScan
    +-column_list=[ComplexTypes.TestEnum#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=[ComplexTypes.TestEnum#2], table=ComplexTypes, column_index_list=[1])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#2)
==

# ORDER BY attaches outside of the UNION ALL when unparenthesized.
select key, value from KeyValue
union all
select key, value from KeyValue
order by 2
--
QueryStmt
+-output_column_list=
| +-$union_all.key#5 AS key [INT64]
| +-$union_all.value#6 AS value [STRING]
+-query=
  +-OrderByScan
    +-column_list=$union_all.[key#5, value#6]
    +-is_ordered=TRUE
    +-input_scan=
    | +-SetOperationScan
    |   +-column_list=$union_all.[key#5, value#6]
    |   +-op_type=UNION_ALL
    |   +-input_item_list=
    |     +-SetOperationItem
    |     | +-scan=
    |     | | +-ProjectScan
    |     | |   +-column_list=KeyValue.[Key#1, Value#2]
    |     | |   +-input_scan=
    |     | |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |     | +-output_column_list=KeyValue.[Key#1, Value#2]
    |     +-SetOperationItem
    |       +-scan=
    |       | +-ProjectScan
    |       |   +-column_list=KeyValue.[Key#3, Value#4]
    |       |   +-input_scan=
    |       |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    |       +-output_column_list=KeyValue.[Key#3, Value#4]
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=STRING, column=$union_all.value#6)
==

(select key, key+1, key+2 from TestTable order by 1)
UNION ALL
(select key, key+3, key+4 from TestTable order by 2 limit 3 offset 4)
order by 3
--
QueryStmt
+-output_column_list=
| +-$union_all.key#11 AS key [INT32]
| +-$union_all.$col2#12 AS "$col2" [INT64]
| +-$union_all.$col3#13 AS "$col3" [INT64]
+-query=
  +-OrderByScan
    +-column_list=$union_all.[key#11, $col2#12, $col3#13]
    +-is_ordered=TRUE
    +-input_scan=
    | +-SetOperationScan
    |   +-column_list=$union_all.[key#11, $col2#12, $col3#13]
    |   +-op_type=UNION_ALL
    |   +-input_item_list=
    |     +-SetOperationItem
    |     | +-scan=
    |     | | +-OrderByScan
    |     | |   +-column_list=[TestTable.key#1, $union_all1.$col2#4, $union_all1.$col3#5]
    |     | |   +-is_ordered=TRUE
    |     | |   +-input_scan=
    |     | |   | +-ProjectScan
    |     | |   |   +-column_list=[TestTable.key#1, $union_all1.$col2#4, $union_all1.$col3#5]
    |     | |   |   +-expr_list=
    |     | |   |   | +-$col2#4 :=
    |     | |   |   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     | |   |   | |   +-Cast(INT32 -> INT64)
    |     | |   |   | |   | +-ColumnRef(type=INT32, column=TestTable.key#1)
    |     | |   |   | |   +-Literal(type=INT64, value=1)
    |     | |   |   | +-$col3#5 :=
    |     | |   |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     | |   |   |     +-Cast(INT32 -> INT64)
    |     | |   |   |     | +-ColumnRef(type=INT32, column=TestTable.key#1)
    |     | |   |   |     +-Literal(type=INT64, value=2)
    |     | |   |   +-input_scan=
    |     | |   |     +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
    |     | |   +-order_by_item_list=
    |     | |     +-OrderByItem
    |     | |       +-column_ref=
    |     | |         +-ColumnRef(type=INT32, column=TestTable.key#1)
    |     | +-output_column_list=[TestTable.key#1, $union_all1.$col2#4, $union_all1.$col3#5]
    |     +-SetOperationItem
    |       +-scan=
    |       | +-LimitOffsetScan
    |       |   +-column_list=[TestTable.key#6, $union_all2.$col2#9, $union_all2.$col3#10]
    |       |   +-is_ordered=TRUE
    |       |   +-input_scan=
    |       |   | +-OrderByScan
    |       |   |   +-column_list=[TestTable.key#6, $union_all2.$col2#9, $union_all2.$col3#10]
    |       |   |   +-is_ordered=TRUE
    |       |   |   +-input_scan=
    |       |   |   | +-ProjectScan
    |       |   |   |   +-column_list=[TestTable.key#6, $union_all2.$col2#9, $union_all2.$col3#10]
    |       |   |   |   +-expr_list=
    |       |   |   |   | +-$col2#9 :=
    |       |   |   |   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       |   |   |   | |   +-Cast(INT32 -> INT64)
    |       |   |   |   | |   | +-ColumnRef(type=INT32, column=TestTable.key#6)
    |       |   |   |   | |   +-Literal(type=INT64, value=3)
    |       |   |   |   | +-$col3#10 :=
    |       |   |   |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       |   |   |   |     +-Cast(INT32 -> INT64)
    |       |   |   |   |     | +-ColumnRef(type=INT32, column=TestTable.key#6)
    |       |   |   |   |     +-Literal(type=INT64, value=4)
    |       |   |   |   +-input_scan=
    |       |   |   |     +-TableScan(column_list=[TestTable.key#6], table=TestTable, column_index_list=[0])
    |       |   |   +-order_by_item_list=
    |       |   |     +-OrderByItem
    |       |   |       +-column_ref=
    |       |   |         +-ColumnRef(type=INT64, column=$union_all2.$col2#9)
    |       |   +-limit=
    |       |   | +-Literal(type=INT64, value=3)
    |       |   +-offset=
    |       |     +-Literal(type=INT64, value=4)
    |       +-output_column_list=[TestTable.key#6, $union_all2.$col2#9, $union_all2.$col3#10]
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$union_all.$col3#13)
==

# Bad ordinal.
select key, value from KeyValue
union all
select key, value from KeyValue
order by 0;
--
ERROR: ORDER BY column number item is out of range. Column numbers must be greater than or equal to one. Found : 0 [at 4:10]
order by 0;
         ^
==

# Bad ordinal.
select key, value from KeyValue
union all
select key, value from KeyValue
order by 3;
--
ERROR: ORDER BY is out of SELECT column number range: 3 [at 4:10]
order by 3;
         ^
==

select KitchenSink from ComplexTypes
union all
select KitchenSink from ComplexTypes
order by 1;
--
ERROR: ORDER BY does not support expressions of type zetasql_test__.KitchenSinkPB [at 4:10]
order by 1;
         ^
==

# Cannot order by literal values
select key, value from KeyValue
union all
select key, value from KeyValue
order by 'foo';
--
ERROR: Cannot ORDER BY literal values [at 4:10]
order by 'foo';
         ^
==

# Cannot have ORDER BY without a FROM clause.
select 1, 2, 3 order by 1;
--
ERROR: Query without FROM clause cannot have an ORDER BY clause [at 1:16]
select 1, 2, 3 order by 1;
               ^
==

# Cannot ORDER BY proto.
select KitchenSink from ComplexTypes
order by 1;
--
ERROR: ORDER BY does not support expressions of type zetasql_test__.KitchenSinkPB [at 2:10]
order by 1;
         ^
==

# Cannot ORDER BY array unless the relevant language feature is enabled.
[language_features={{|V_1_3_ARRAY_ORDERING}}]
select Int32Array from ComplexTypes
order by 1;
--
ALTERNATION GROUP: <empty>
--
ERROR: ORDER BY does not support expressions of type ARRAY<INT32> [at 2:10]
order by 1;
         ^
--
ALTERNATION GROUP: V_1_3_ARRAY_ORDERING
--
QueryStmt
+-output_column_list=
| +-ComplexTypes.Int32Array#4 AS Int32Array [ARRAY<INT32>]
+-query=
  +-OrderByScan
    +-column_list=[ComplexTypes.Int32Array#4]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=[ComplexTypes.Int32Array#4], table=ComplexTypes, column_index_list=[3])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=ARRAY<INT32>, column=ComplexTypes.Int32Array#4)
==

# Cannot ORDER BY array with unorderable element type even if the array
# ordering language feature is enabled.
[language_features={{|V_1_3_ARRAY_ORDERING}}]
select [KitchenSink] from ComplexTypes
order by 1;
--
ERROR: ORDER BY does not support expressions of type ARRAY<zetasql_test__.KitchenSinkPB> [at 2:10]
order by 1;
         ^
==

# Cannot ORDER BY struct.
select TestStruct from ComplexTypes
order by 1;
--
ERROR: ORDER BY does not support expressions of type STRUCT<c INT32, d STRUCT<a INT32, b STRING>> [at 2:10]
order by 1;
         ^
==

# Cannot ORDER BY struct.
select (select AS STRUCT key, value from KeyValue) from KeyValue kv order by 1;
--
ERROR: ORDER BY does not support expressions of type STRUCT<key INT64, value STRING> [at 1:78]
select (select AS STRUCT key, value from KeyValue) from KeyValue kv order by 1;
                                                                             ^
==

# Invalid ordinal reference.
select * from SimpleTypes
order by 666;
--
ERROR: ORDER BY is out of SELECT column number range: 666 [at 2:10]
order by 666;
         ^
==

# Invalid ordinal reference.
select * from SimpleTypes
order by 0;
--
ERROR: ORDER BY column number item is out of range. Column numbers must be greater than or equal to one. Found : 0 [at 2:10]
order by 0;
         ^
==

# Invalid ordinal reference.
select * from SimpleTypes
order by -1;
--
ERROR: ORDER BY column number item is out of range. Column numbers must be greater than or equal to one. Found : -1 [at 2:10]
order by -1;
         ^
==

# Invalid ordinal reference (KeyValue only has two columns).
select * from KeyValue
order by 3;
--
ERROR: ORDER BY is out of SELECT column number range: 3 [at 2:10]
order by 3;
         ^
==

select * from TestTable
order by 1.0;
--
ERROR: Cannot ORDER BY literal values [at 2:10]
order by 1.0;
         ^
==

select * from TestTable
order by "foo";
--
ERROR: Cannot ORDER BY literal values [at 2:10]
order by "foo";
         ^
==

select * from KeyValue
order by NULL;
--
ERROR: Cannot ORDER BY literal values [at 2:10]
order by NULL;
         ^
==

# This gets interpreted as an expression.
select * from KeyValue
order by - -1;
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-OrderByScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#3]
    |   +-expr_list=
    |   | +-$orderbycol1#3 :=
    |   |   +-FunctionCall(ZetaSQL:$unary_minus(INT64) -> INT64)
    |   |     +-Literal(type=INT64, value=-1)
    |   +-input_scan=
    |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
==

# Order by column in select list.
select key from KeyValue
order by key;
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[KeyValue.Key#1]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The order by expression is equivalent to a select list expression but is not
# a simple column reference.
# TODO: Remove an order expression from the expression list if it is
# equivalent to a select expression.
select key + 1
from keyvalue
order by key + 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS "$col1" [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$query.$col1#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[KeyValue.Key#1, $query.$col1#3, $orderby.$orderbycol1#4]
    |   +-expr_list=
    |   | +-$orderbycol1#4 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |     +-Literal(type=INT64, value=1)
    |   +-input_scan=
    |     +-ProjectScan
    |       +-column_list=[KeyValue.Key#1, $query.$col1#3]
    |       +-expr_list=
    |       | +-$col1#3 :=
    |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       |     +-Literal(type=INT64, value=1)
    |       +-input_scan=
    |         +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
==

# Order by column not in select list
select key from KeyValue
order by value;
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[KeyValue.Key#1]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# ORDER BY a bunch of redundant expressions and ordinals.  TODO: Do
# duplicate column elimination - do not add new ResolvedColumns for order by
# expressions if they are already present.
select * from KeyValue
order by key, value, 1, 2, value, 1, key, 2, key + 1, 1, key + 1
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-OrderByScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol9#3, $orderby.$orderbycol11#4]
    |   +-expr_list=
    |   | +-$orderbycol9#3 :=
    |   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   | |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   | |   +-Literal(type=INT64, value=1)
    |   | +-$orderbycol11#4 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |     +-Literal(type=INT64, value=1)
    |   +-input_scan=
    |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$orderby.$orderbycol9#3)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol11#4)
==

# ORDER BY redundant column references, ordinals and expressions after
# UNION ALL. TODO: Do duplicate column elimination - do not add new
# ResolvedColumns for order by expressions if they are already present.
select key as key1, value as value1
from KeyValue
union all
select key as key2, value as value2
from KeyValue
order by key1, value1, 1, 2, value1, 1, key1, 2, key1 + 1, 1, key1 + 1
--
QueryStmt
+-output_column_list=
| +-$union_all.key1#5 AS key1 [INT64]
| +-$union_all.value1#6 AS value1 [STRING]
+-query=
  +-OrderByScan
    +-column_list=$union_all.[key1#5, value1#6]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$union_all.key1#5, $union_all.value1#6, $orderby.$orderbycol9#7, $orderby.$orderbycol11#8]
    |   +-expr_list=
    |   | +-$orderbycol9#7 :=
    |   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   | |   +-ColumnRef(type=INT64, column=$union_all.key1#5)
    |   | |   +-Literal(type=INT64, value=1)
    |   | +-$orderbycol11#8 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=$union_all.key1#5)
    |   |     +-Literal(type=INT64, value=1)
    |   +-input_scan=
    |     +-SetOperationScan
    |       +-column_list=$union_all.[key1#5, value1#6]
    |       +-op_type=UNION_ALL
    |       +-input_item_list=
    |         +-SetOperationItem
    |         | +-scan=
    |         | | +-ProjectScan
    |         | |   +-column_list=KeyValue.[Key#1, Value#2]
    |         | |   +-input_scan=
    |         | |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |         | +-output_column_list=KeyValue.[Key#1, Value#2]
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=KeyValue.[Key#3, Value#4]
    |           |   +-input_scan=
    |           |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    |           +-output_column_list=KeyValue.[Key#3, Value#4]
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$union_all.key1#5)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=$union_all.value1#6)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$union_all.key1#5)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=$union_all.value1#6)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=$union_all.value1#6)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$union_all.key1#5)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$union_all.key1#5)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=$union_all.value1#6)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$orderby.$orderbycol9#7)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$union_all.key1#5)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol11#8)
==

# Order by expression
select * from KeyValue
order by key + 2;
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-OrderByScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#3]
    |   +-expr_list=
    |   | +-$orderbycol1#3 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |     +-Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
==

# ORDER BY a subset of the select list columns with gaps in between the
# references.
select int32, int64, uint32, uint64, float, double from simpletypes
order by int64, uint64, double, 2, 4, 6;
--
QueryStmt
+-output_column_list=
| +-SimpleTypes.int32#1 AS int32 [INT32]
| +-SimpleTypes.int64#2 AS int64 [INT64]
| +-SimpleTypes.uint32#3 AS uint32 [UINT32]
| +-SimpleTypes.uint64#4 AS uint64 [UINT64]
| +-SimpleTypes.float#8 AS float [FLOAT]
| +-SimpleTypes.double#9 AS double [DOUBLE]
+-query=
  +-OrderByScan
    +-column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, float#8, double#9]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, float#8, double#9], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 7, 8])
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
==

select key as foo from TestTable
order by foo;
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS foo [INT32]
+-query=
  +-OrderByScan
    +-column_list=[TestTable.key#1]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=TestTable.key#1)
==

# 'key' currently resolves to FROM clause name scope.
select key as foo from TestTable
order by key;
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS foo [INT32]
+-query=
  +-OrderByScan
    +-column_list=[TestTable.key#1]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=TestTable.key#1)
==

select key as foo from KeyValue
order by foo + 2;
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS foo [INT64]
+-query=
  +-OrderByScan
    +-column_list=[KeyValue.Key#1]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[KeyValue.Key#1, $orderby.$orderbycol1#3]
    |   +-expr_list=
    |   | +-$orderbycol1#3 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |     +-Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
==

select key + 2 as foo from KeyValue
order by key + foo;
--
QueryStmt
+-output_column_list=
| +-$query.foo#3 AS foo [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$query.foo#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[KeyValue.Key#1, $query.foo#3, $orderby.$orderbycol1#4]
    |   +-expr_list=
    |   | +-$orderbycol1#4 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |     +-ColumnRef(type=INT64, column=$query.foo#3)
    |   +-input_scan=
    |     +-ProjectScan
    |       +-column_list=[KeyValue.Key#1, $query.foo#3]
    |       +-expr_list=
    |       | +-foo#3 :=
    |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       |     +-Literal(type=INT64, value=2)
    |       +-input_scan=
    |         +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
==

select key from KeyValue
group by key
order by key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.key#3]
    |   +-input_scan=
    |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   +-group_by_list=
    |     +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$groupby.key#3)
==

select value, sum(key) from KeyValue
group by value
order by Sum(key);
--
QueryStmt
+-output_column_list=
| +-$groupby.value#4 AS value [STRING]
| +-$aggregate.$agg1#3 AS "$col2" [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.value#4, $aggregate.$agg1#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.value#4, $aggregate.$agg1#3, $aggregate.$agg2#5]
    |   +-input_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-group_by_list=
    |   | +-value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2)
    |   +-aggregate_list=
    |     +-$agg1#3 :=
    |     | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |     |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-$agg2#5 :=
    |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$aggregate.$agg2#5)
==

# ORDER BY an aggregate expression that is not in the select.
select value from KeyValue
group by value
order by Sum(key);
--
QueryStmt
+-output_column_list=
| +-$groupby.value#3 AS value [STRING]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.value#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.value#3, $aggregate.$agg1#4]
    |   +-input_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-group_by_list=
    |   | +-value#3 := ColumnRef(type=STRING, column=KeyValue.Value#2)
    |   +-aggregate_list=
    |     +-$agg1#4 :=
    |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$aggregate.$agg1#4)
==

select value from KeyValue
order by sum(key);
--
ERROR: The ORDER BY clause only allows aggregation if GROUP BY or SELECT list aggregation is present [at 2:1]
order by sum(key);
^
==

select key as foo, value as value from KeyValue
group by foo, 2
order by foo, key, 1, 2, value, foo, foo, key, 2, keyvalue.key, keyvalue.value;
--
QueryStmt
+-output_column_list=
| +-$groupby.foo#3 AS foo [INT64]
| +-$groupby.value#4 AS value [STRING]
+-query=
  +-OrderByScan
    +-column_list=$groupby.[foo#3, value#4]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=$groupby.[foo#3, value#4]
    |   +-input_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-group_by_list=
    |     +-foo#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.foo#3)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.foo#3)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.foo#3)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=$groupby.value#4)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=$groupby.value#4)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.foo#3)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.foo#3)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.foo#3)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=$groupby.value#4)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.foo#3)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=STRING, column=$groupby.value#4)
==

select key as foo from KeyValue
order by sum(foo);
--
ERROR: The ORDER BY clause only allows aggregation if GROUP BY or SELECT list aggregation is present [at 2:1]
order by sum(foo);
^
==

# Similar to the above query, but with GROUP BY.
select key as foo from KeyValue
group by key
order by sum(foo);
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS foo [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.key#3, $aggregate.$agg1#4]
    |   +-input_scan=
    |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   +-group_by_list=
    |   | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-aggregate_list=
    |     +-$agg1#4 :=
    |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$aggregate.$agg1#4)
==

# We do not have is_ordered on the inner OrderByScan because the table
# subquery does not preserve that ordering.
select * from (select * from KeyValue
               order by key, 2, key, 2, key * key )
order by 1, 2;
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-OrderByScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-OrderByScan
    |   +-column_list=KeyValue.[Key#1, Value#2]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol5#3]
    |   |   +-expr_list=
    |   |   | +-$orderbycol5#3 :=
    |   |   |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |   |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-order_by_item_list=
    |     +-OrderByItem
    |     | +-column_ref=
    |     |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-OrderByItem
    |     | +-column_ref=
    |     |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-OrderByItem
    |     | +-column_ref=
    |     |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-OrderByItem
    |     | +-column_ref=
    |     |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-OrderByItem
    |       +-column_ref=
    |         +-ColumnRef(type=INT64, column=$orderby.$orderbycol5#3)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# Test interactions between ORDER BY and DISTINCT.
select distinct key from keyvalue
order by 1;
--
QueryStmt
+-output_column_list=
| +-$distinct.Key#3 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$distinct.Key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$distinct.Key#3]
    |   +-input_scan=
    |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   +-group_by_list=
    |     +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$distinct.Key#3)
==

select distinct key from keyvalue
order by key;
--
QueryStmt
+-output_column_list=
| +-$distinct.Key#3 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$distinct.Key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$distinct.Key#3]
    |   +-input_scan=
    |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   +-group_by_list=
    |     +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$distinct.Key#3)
==

select distinct key from keyvalue
group by key
order by key;
--
QueryStmt
+-output_column_list=
| +-$distinct.key#4 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$distinct.key#4]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$distinct.key#4]
    |   +-input_scan=
    |   | +-AggregateScan
    |   |   +-column_list=[$groupby.key#3]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   |   +-group_by_list=
    |   |     +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-group_by_list=
    |     +-key#4 := ColumnRef(type=INT64, column=$groupby.key#3)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$distinct.key#4)
==

select distinct key, max(value) as maxvalue from keyvalue
group by key
order by key, 2;
--
QueryStmt
+-output_column_list=
| +-$distinct.key#5 AS key [INT64]
| +-$distinct.maxvalue#6 AS maxvalue [STRING]
+-query=
  +-OrderByScan
    +-column_list=$distinct.[key#5, maxvalue#6]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=$distinct.[key#5, maxvalue#6]
    |   +-input_scan=
    |   | +-AggregateScan
    |   |   +-column_list=[$groupby.key#4, $aggregate.maxvalue#3]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-group_by_list=
    |   |   | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |   +-aggregate_list=
    |   |     +-maxvalue#3 :=
    |   |       +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
    |   |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |   +-group_by_list=
    |     +-key#5 := ColumnRef(type=INT64, column=$groupby.key#4)
    |     +-maxvalue#6 := ColumnRef(type=STRING, column=$aggregate.maxvalue#3)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$distinct.key#5)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=STRING, column=$distinct.maxvalue#6)
==

select distinct key, max(value) as maxvalue from keyvalue
group by key
order by key, 2, maxvalue;
--
QueryStmt
+-output_column_list=
| +-$distinct.key#5 AS key [INT64]
| +-$distinct.maxvalue#6 AS maxvalue [STRING]
+-query=
  +-OrderByScan
    +-column_list=$distinct.[key#5, maxvalue#6]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=$distinct.[key#5, maxvalue#6]
    |   +-input_scan=
    |   | +-AggregateScan
    |   |   +-column_list=[$groupby.key#4, $aggregate.maxvalue#3]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-group_by_list=
    |   |   | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |   +-aggregate_list=
    |   |     +-maxvalue#3 :=
    |   |       +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
    |   |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |   +-group_by_list=
    |     +-key#5 := ColumnRef(type=INT64, column=$groupby.key#4)
    |     +-maxvalue#6 := ColumnRef(type=STRING, column=$aggregate.maxvalue#3)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$distinct.key#5)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=$distinct.maxvalue#6)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=STRING, column=$distinct.maxvalue#6)
==

[language_features=ANALYTIC_FUNCTIONS]
select distinct value, rank() over (order by key) as rankvalue from keyvalue
order by value, 2;
--
QueryStmt
+-output_column_list=
| +-$distinct.Value#5 AS value [STRING]
| +-$distinct.rankvalue#6 AS rankvalue [INT64]
+-query=
  +-OrderByScan
    +-column_list=$distinct.[Value#5, rankvalue#6]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=$distinct.[Value#5, rankvalue#6]
    |   +-input_scan=
    |   | +-AnalyticScan
    |   |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.rankvalue#4]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-function_group_list=
    |   |     +-AnalyticFunctionGroup
    |   |       +-order_by=
    |   |       | +-WindowOrdering
    |   |       |   +-order_by_item_list=
    |   |       |     +-OrderByItem
    |   |       |       +-column_ref=
    |   |       |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |       +-analytic_function_list=
    |   |         +-rankvalue#4 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
    |   +-group_by_list=
    |     +-Value#5 := ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-rankvalue#6 := ColumnRef(type=INT64, column=$analytic.rankvalue#4)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=$distinct.Value#5)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$distinct.rankvalue#6)
==

[language_features=ANALYTIC_FUNCTIONS]
select distinct value, rank() over (order by key) as rankvalue from keyvalue
order by value, rankvalue;
--
QueryStmt
+-output_column_list=
| +-$distinct.Value#5 AS value [STRING]
| +-$distinct.rankvalue#6 AS rankvalue [INT64]
+-query=
  +-OrderByScan
    +-column_list=$distinct.[Value#5, rankvalue#6]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=$distinct.[Value#5, rankvalue#6]
    |   +-input_scan=
    |   | +-AnalyticScan
    |   |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.rankvalue#4]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-function_group_list=
    |   |     +-AnalyticFunctionGroup
    |   |       +-order_by=
    |   |       | +-WindowOrdering
    |   |       |   +-order_by_item_list=
    |   |       |     +-OrderByItem
    |   |       |       +-column_ref=
    |   |       |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |       +-analytic_function_list=
    |   |         +-rankvalue#4 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
    |   +-group_by_list=
    |     +-Value#5 := ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-rankvalue#6 := ColumnRef(type=INT64, column=$analytic.rankvalue#4)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=$distinct.Value#5)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$distinct.rankvalue#6)
==

[language_features=ANALYTIC_FUNCTIONS]
select distinct value, key from keyvalue
order by value, rank() over (order by key);
--
ERROR: Analytic function not allowed in ORDER BY clause after SELECT DISTINCT [at 2:17]
order by value, rank() over (order by key);
                ^
==

# Not valid, column 'key' is not visible to ORDER BY after DISTINCT.
select distinct key+2 from keyvalue
group by key
order by key+1;
--
ERROR: ORDER BY clause expression references column key which is not visible after SELECT DISTINCT [at 3:10]
order by key+1;
         ^
==

# Not valid, aggregate functions are not allowed in ORDER BY after DISTINCT.
select distinct key from keyvalue
group by key
order by key, max(value);
--
ERROR: ORDER BY clause expression references column value which is not visible after SELECT DISTINCT [at 3:19]
order by key, max(value);
                  ^
==

# Not valid, aggregate functions are not allowed in ORDER BY after DISTINCT,
# even if the column being aggregated is available post-DISTINCT.
select distinct key from keyvalue
group by key
order by key, max(key);
--
ERROR: Aggregate function MAX not allowed in ORDER BY clause after SELECT DISTINCT [at 3:15]
order by key, max(key);
              ^
==

select distinct key from keyvalue
group by key
order by key, max(key);
--
ERROR: Aggregate function MAX not allowed in ORDER BY clause after SELECT DISTINCT [at 3:15]
order by key, max(key);
              ^
==

# Valid if DISTINCT not present, but invalid if DISTINCT present.
select {{|distinct}} key from keyvalue
group by key
order by max(value);
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.key#3, $aggregate.$agg1#4]
    |   +-input_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-group_by_list=
    |   | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-aggregate_list=
    |     +-$agg1#4 :=
    |       +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
    |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=STRING, column=$aggregate.$agg1#4)
--
ALTERNATION GROUP: distinct
--
ERROR: ORDER BY clause expression references column value which is not visible after SELECT DISTINCT [at 3:14]
order by max(value);
             ^
==

# Valid if DISTINCT not present, but invalid if DISTINCT present.
select {{|distinct}} key from keyvalue
group by key
order by max(key);
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.key#3, $aggregate.$agg1#4]
    |   +-input_scan=
    |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   +-group_by_list=
    |   | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-aggregate_list=
    |     +-$agg1#4 :=
    |       +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$aggregate.$agg1#4)
--
ALTERNATION GROUP: distinct
--
ERROR: Aggregate function MAX not allowed in ORDER BY clause after SELECT DISTINCT [at 3:10]
order by max(key);
         ^
==

# In combination with set functions
select distinct key
from keyvalue
union all
select distinct key
from keyvalue
order by key
--
QueryStmt
+-output_column_list=
| +-$union_all.key#7 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$union_all.key#7]
    +-is_ordered=TRUE
    +-input_scan=
    | +-SetOperationScan
    |   +-column_list=[$union_all.key#7]
    |   +-op_type=UNION_ALL
    |   +-input_item_list=
    |     +-SetOperationItem
    |     | +-scan=
    |     | | +-AggregateScan
    |     | |   +-column_list=[$distinct.Key#3]
    |     | |   +-input_scan=
    |     | |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |     | |   +-group_by_list=
    |     | |     +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     | +-output_column_list=[$distinct.Key#3]
    |     +-SetOperationItem
    |       +-scan=
    |       | +-AggregateScan
    |       |   +-column_list=[$distinct.Key#6]
    |       |   +-input_scan=
    |       |   | +-TableScan(column_list=[KeyValue.Key#4], table=KeyValue, column_index_list=[0])
    |       |   +-group_by_list=
    |       |     +-Key#6 := ColumnRef(type=INT64, column=KeyValue.Key#4)
    |       +-output_column_list=[$distinct.Key#6]
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$union_all.key#7)
==

(select distinct key
 from keyvalue
 order by key)
union all
(select distinct key
 from keyvalue
 order by key)
order by key
--
QueryStmt
+-output_column_list=
| +-$union_all.key#7 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$union_all.key#7]
    +-is_ordered=TRUE
    +-input_scan=
    | +-SetOperationScan
    |   +-column_list=[$union_all.key#7]
    |   +-op_type=UNION_ALL
    |   +-input_item_list=
    |     +-SetOperationItem
    |     | +-scan=
    |     | | +-OrderByScan
    |     | |   +-column_list=[$distinct.Key#3]
    |     | |   +-is_ordered=TRUE
    |     | |   +-input_scan=
    |     | |   | +-AggregateScan
    |     | |   |   +-column_list=[$distinct.Key#3]
    |     | |   |   +-input_scan=
    |     | |   |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |     | |   |   +-group_by_list=
    |     | |   |     +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     | |   +-order_by_item_list=
    |     | |     +-OrderByItem
    |     | |       +-column_ref=
    |     | |         +-ColumnRef(type=INT64, column=$distinct.Key#3)
    |     | +-output_column_list=[$distinct.Key#3]
    |     +-SetOperationItem
    |       +-scan=
    |       | +-OrderByScan
    |       |   +-column_list=[$distinct.Key#6]
    |       |   +-is_ordered=TRUE
    |       |   +-input_scan=
    |       |   | +-AggregateScan
    |       |   |   +-column_list=[$distinct.Key#6]
    |       |   |   +-input_scan=
    |       |   |   | +-TableScan(column_list=[KeyValue.Key#4], table=KeyValue, column_index_list=[0])
    |       |   |   +-group_by_list=
    |       |   |     +-Key#6 := ColumnRef(type=INT64, column=KeyValue.Key#4)
    |       |   +-order_by_item_list=
    |       |     +-OrderByItem
    |       |       +-column_ref=
    |       |         +-ColumnRef(type=INT64, column=$distinct.Key#6)
    |       +-output_column_list=[$distinct.Key#6]
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$union_all.key#7)
==

(select distinct key
 from keyvalue
 order by key)
union distinct
(select key
 from keyvalue
 order by key)
union distinct
(select distinct key
 from keyvalue
 order by key)
order by key
--
QueryStmt
+-output_column_list=
| +-$union_distinct.key#9 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$union_distinct.key#9]
    +-is_ordered=TRUE
    +-input_scan=
    | +-SetOperationScan
    |   +-column_list=[$union_distinct.key#9]
    |   +-op_type=UNION_DISTINCT
    |   +-input_item_list=
    |     +-SetOperationItem
    |     | +-scan=
    |     | | +-OrderByScan
    |     | |   +-column_list=[$distinct.Key#3]
    |     | |   +-is_ordered=TRUE
    |     | |   +-input_scan=
    |     | |   | +-AggregateScan
    |     | |   |   +-column_list=[$distinct.Key#3]
    |     | |   |   +-input_scan=
    |     | |   |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |     | |   |   +-group_by_list=
    |     | |   |     +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     | |   +-order_by_item_list=
    |     | |     +-OrderByItem
    |     | |       +-column_ref=
    |     | |         +-ColumnRef(type=INT64, column=$distinct.Key#3)
    |     | +-output_column_list=[$distinct.Key#3]
    |     +-SetOperationItem
    |     | +-scan=
    |     | | +-OrderByScan
    |     | |   +-column_list=[KeyValue.Key#4]
    |     | |   +-is_ordered=TRUE
    |     | |   +-input_scan=
    |     | |   | +-TableScan(column_list=[KeyValue.Key#4], table=KeyValue, column_index_list=[0])
    |     | |   +-order_by_item_list=
    |     | |     +-OrderByItem
    |     | |       +-column_ref=
    |     | |         +-ColumnRef(type=INT64, column=KeyValue.Key#4)
    |     | +-output_column_list=[KeyValue.Key#4]
    |     +-SetOperationItem
    |       +-scan=
    |       | +-OrderByScan
    |       |   +-column_list=[$distinct.Key#8]
    |       |   +-is_ordered=TRUE
    |       |   +-input_scan=
    |       |   | +-AggregateScan
    |       |   |   +-column_list=[$distinct.Key#8]
    |       |   |   +-input_scan=
    |       |   |   | +-TableScan(column_list=[KeyValue.Key#6], table=KeyValue, column_index_list=[0])
    |       |   |   +-group_by_list=
    |       |   |     +-Key#8 := ColumnRef(type=INT64, column=KeyValue.Key#6)
    |       |   +-order_by_item_list=
    |       |     +-OrderByItem
    |       |       +-column_ref=
    |       |         +-ColumnRef(type=INT64, column=$distinct.Key#8)
    |       +-output_column_list=[$distinct.Key#8]
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$union_distinct.key#9)
==

# If it is SELECT DISTINCT, then ORDER BY columns must appear in the
# SELECT list.
select distinct key from keyvalue
order by value;
--
ERROR: ORDER BY clause expression references column value which is not visible after SELECT DISTINCT [at 2:10]
order by value;
         ^
==

# TODO: We may eventually want this to work but it is currently
# low priority.
select distinct key+1 from keyvalue
order by key+1
--
ERROR: ORDER BY clause expression references column key which is not visible after SELECT DISTINCT [at 2:10]
order by key+1
         ^
==

select distinct key from keyvalue
order by key+1, 1
--
QueryStmt
+-output_column_list=
| +-$distinct.Key#3 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$distinct.Key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$distinct.Key#3, $orderby.$orderbycol1#4]
    |   +-expr_list=
    |   | +-$orderbycol1#4 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=$distinct.Key#3)
    |   |     +-Literal(type=INT64, value=1)
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$distinct.Key#3]
    |       +-input_scan=
    |       | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |       +-group_by_list=
    |         +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$distinct.Key#3)
==

select distinct key from keyvalue
group by key, 1
order by key+1
--
QueryStmt
+-output_column_list=
| +-$distinct.key#4 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$distinct.key#4]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$distinct.key#4, $orderby.$orderbycol1#5]
    |   +-expr_list=
    |   | +-$orderbycol1#5 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=$distinct.key#4)
    |   |     +-Literal(type=INT64, value=1)
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$distinct.key#4]
    |       +-input_scan=
    |       | +-AggregateScan
    |       |   +-column_list=[$groupby.key#3]
    |       |   +-input_scan=
    |       |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |       |   +-group_by_list=
    |       |     +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       +-group_by_list=
    |         +-key#4 := ColumnRef(type=INT64, column=$groupby.key#3)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#5)
==

select distinct key from keyvalue
group by key
order by key+key;
--
QueryStmt
+-output_column_list=
| +-$distinct.key#4 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$distinct.key#4]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$distinct.key#4, $orderby.$orderbycol1#5]
    |   +-expr_list=
    |   | +-$orderbycol1#5 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=$distinct.key#4)
    |   |     +-ColumnRef(type=INT64, column=$distinct.key#4)
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$distinct.key#4]
    |       +-input_scan=
    |       | +-AggregateScan
    |       |   +-column_list=[$groupby.key#3]
    |       |   +-input_scan=
    |       |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |       |   +-group_by_list=
    |       |     +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       +-group_by_list=
    |         +-key#4 := ColumnRef(type=INT64, column=$groupby.key#3)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#5)
==

select *
from (select distinct key, value
      from KeyValue
      order by key, value)
--
QueryStmt
+-output_column_list=
| +-$distinct.Key#3 AS key [INT64]
| +-$distinct.Value#4 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=$distinct.[Key#3, Value#4]
    +-input_scan=
      +-OrderByScan
        +-column_list=$distinct.[Key#3, Value#4]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=$distinct.[Key#3, Value#4]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-group_by_list=
        |     +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-Value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-order_by_item_list=
          +-OrderByItem
          | +-column_ref=
          |   +-ColumnRef(type=INT64, column=$distinct.Key#3)
          +-OrderByItem
            +-column_ref=
              +-ColumnRef(type=STRING, column=$distinct.Value#4)
==

select distinct *
from KeyValue
order by 1, 2, key, value;
--
QueryStmt
+-output_column_list=
| +-$distinct.Key#3 AS Key [INT64]
| +-$distinct.Value#4 AS Value [STRING]
+-query=
  +-OrderByScan
    +-column_list=$distinct.[Key#3, Value#4]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=$distinct.[Key#3, Value#4]
    |   +-input_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-group_by_list=
    |     +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-Value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$distinct.Key#3)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=STRING, column=$distinct.Value#4)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$distinct.Key#3)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=STRING, column=$distinct.Value#4)
==

select distinct as struct key, value
from KeyValue
order by 1, key, value
--
QueryStmt
+-output_column_list=
| +-$make_struct.$struct#5 AS "$struct" [STRUCT<key INT64, value STRING>]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$make_struct.$struct#5]
    +-is_ordered=TRUE
    +-expr_list=
    | +-$struct#5 :=
    |   +-MakeStruct
    |     +-type=STRUCT<key INT64, value STRING>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=$distinct.Key#3)
    |       +-ColumnRef(type=STRING, column=$distinct.Value#4)
    +-input_scan=
      +-OrderByScan
        +-column_list=$distinct.[Key#3, Value#4]
        +-is_ordered=TRUE
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=$distinct.[Key#3, Value#4]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-group_by_list=
        |     +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-Value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-order_by_item_list=
          +-OrderByItem
          | +-column_ref=
          |   +-ColumnRef(type=INT64, column=$distinct.Key#3)
          +-OrderByItem
          | +-column_ref=
          |   +-ColumnRef(type=INT64, column=$distinct.Key#3)
          +-OrderByItem
            +-column_ref=
              +-ColumnRef(type=STRING, column=$distinct.Value#4)
==

select distinct as value key
from KeyValue
order by 1, key, KeyValue.key
--
QueryStmt
+-output_column_list=
| +-$distinct.Key#3 AS "$value_column" [INT64]
+-is_value_table=TRUE
+-query=
  +-OrderByScan
    +-column_list=[$distinct.Key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$distinct.Key#3]
    |   +-input_scan=
    |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   +-group_by_list=
    |     +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$distinct.Key#3)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$distinct.Key#3)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$distinct.Key#3)
==

select distinct as "zetasql_test__.KeyValueStruct" key, value
from KeyValue
order by 1, key, value, KeyValue.key, KeyValue.value
--
QueryStmt
+-output_column_list=
| +-$make_proto.$proto#5 AS "$proto" [PROTO<zetasql_test__.KeyValueStruct>]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$make_proto.$proto#5]
    +-is_ordered=TRUE
    +-expr_list=
    | +-$proto#5 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KeyValueStruct>
    |     +-field_list=
    |       +-key :=
    |       | +-Cast(INT64 -> STRING)
    |       |   +-ColumnRef(type=INT64, column=$distinct.Key#3)
    |       +-value :=
    |         +-Cast(STRING -> INT64)
    |           +-ColumnRef(type=STRING, column=$distinct.Value#4)
    +-input_scan=
      +-OrderByScan
        +-column_list=$distinct.[Key#3, Value#4]
        +-is_ordered=TRUE
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=$distinct.[Key#3, Value#4]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-group_by_list=
        |     +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-Value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-order_by_item_list=
          +-OrderByItem
          | +-column_ref=
          |   +-ColumnRef(type=INT64, column=$distinct.Key#3)
          +-OrderByItem
          | +-column_ref=
          |   +-ColumnRef(type=INT64, column=$distinct.Key#3)
          +-OrderByItem
          | +-column_ref=
          |   +-ColumnRef(type=STRING, column=$distinct.Value#4)
          +-OrderByItem
          | +-column_ref=
          |   +-ColumnRef(type=INT64, column=$distinct.Key#3)
          +-OrderByItem
            +-column_ref=
              +-ColumnRef(type=STRING, column=$distinct.Value#4)
==

# Works with nested path expressions too.
select distinct nested_value.nested_int64
from KitchenSinkValueTable
order by nested_value.nested_int64;
--
QueryStmt
+-output_column_list=
| +-$distinct.nested_int64#3 AS nested_int64 [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$distinct.nested_int64#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$distinct.nested_int64#3]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[KitchenSinkValueTable.value#1, $query.nested_int64#2]
    |   |   +-expr_list=
    |   |   | +-nested_int64#2 :=
    |   |   |   +-GetProtoField
    |   |   |     +-type=INT64
    |   |   |     +-expr=
    |   |   |     | +-GetProtoField
    |   |   |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |   |   |     |   +-expr=
    |   |   |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |   |     |   +-field_descriptor=nested_value
    |   |   |     |   +-default_value=NULL
    |   |   |     +-field_descriptor=nested_int64
    |   |   |     +-default_value=88
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0])
    |   +-group_by_list=
    |     +-nested_int64#3 := ColumnRef(type=INT64, column=$query.nested_int64#2)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$distinct.nested_int64#3)
==

# Nested path expressions with GROUP BY.
select distinct nested_value.nested_int64
from KitchenSinkValueTable
group by nested_value.nested_int64
order by nested_value.nested_int64 + 1;
--
QueryStmt
+-output_column_list=
| +-$distinct.nested_int64#4 AS nested_int64 [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$distinct.nested_int64#4]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$distinct.nested_int64#4, $orderby.$orderbycol1#5]
    |   +-expr_list=
    |   | +-$orderbycol1#5 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=$distinct.nested_int64#4)
    |   |     +-Literal(type=INT64, value=1)
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$distinct.nested_int64#4]
    |       +-input_scan=
    |       | +-AggregateScan
    |       |   +-column_list=[$groupby.nested_int64#3]
    |       |   +-input_scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[KitchenSinkValueTable.value#1, $pre_groupby.nested_int64#2]
    |       |   |   +-expr_list=
    |       |   |   | +-nested_int64#2 :=
    |       |   |   |   +-GetProtoField
    |       |   |   |     +-type=INT64
    |       |   |   |     +-expr=
    |       |   |   |     | +-GetProtoField
    |       |   |   |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |       |   |   |     |   +-expr=
    |       |   |   |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |       |   |   |     |   +-field_descriptor=nested_value
    |       |   |   |     |   +-default_value=NULL
    |       |   |   |     +-field_descriptor=nested_int64
    |       |   |   |     +-default_value=88
    |       |   |   +-input_scan=
    |       |   |     +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0])
    |       |   +-group_by_list=
    |       |     +-nested_int64#3 := ColumnRef(type=INT64, column=$pre_groupby.nested_int64#2)
    |       +-group_by_list=
    |         +-nested_int64#4 := ColumnRef(type=INT64, column=$groupby.nested_int64#3)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#5)
==

# With set operations, the ORDER BY can reference their output aliases (which
# are derived from the first subquery's alias list).
select key from KeyValue
union all
select key from KeyValue
order by key;
--
QueryStmt
+-output_column_list=
| +-$union_all.key#5 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$union_all.key#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-SetOperationScan
    |   +-column_list=[$union_all.key#5]
    |   +-op_type=UNION_ALL
    |   +-input_item_list=
    |     +-SetOperationItem
    |     | +-scan=
    |     | | +-ProjectScan
    |     | |   +-column_list=[KeyValue.Key#1]
    |     | |   +-input_scan=
    |     | |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |     | +-output_column_list=[KeyValue.Key#1]
    |     +-SetOperationItem
    |       +-scan=
    |       | +-ProjectScan
    |       |   +-column_list=[KeyValue.Key#3]
    |       |   +-input_scan=
    |       |     +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0])
    |       +-output_column_list=[KeyValue.Key#3]
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$union_all.key#5)
==

select key+1 as key from KeyValue
union all
select key from KeyValue
order by key;
--
QueryStmt
+-output_column_list=
| +-$union_all.key#6 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$union_all.key#6]
    +-is_ordered=TRUE
    +-input_scan=
    | +-SetOperationScan
    |   +-column_list=[$union_all.key#6]
    |   +-op_type=UNION_ALL
    |   +-input_item_list=
    |     +-SetOperationItem
    |     | +-scan=
    |     | | +-ProjectScan
    |     | |   +-column_list=[$union_all1.key#3]
    |     | |   +-expr_list=
    |     | |   | +-key#3 :=
    |     | |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     | |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     | |   |     +-Literal(type=INT64, value=1)
    |     | |   +-input_scan=
    |     | |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |     | +-output_column_list=[$union_all1.key#3]
    |     +-SetOperationItem
    |       +-scan=
    |       | +-ProjectScan
    |       |   +-column_list=[KeyValue.Key#4]
    |       |   +-input_scan=
    |       |     +-TableScan(column_list=[KeyValue.Key#4], table=KeyValue, column_index_list=[0])
    |       +-output_column_list=[KeyValue.Key#4]
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$union_all.key#6)
==

select key as key1 from KeyValue
union all
select key as key2 from KeyValue
order by key1;
--
QueryStmt
+-output_column_list=
| +-$union_all.key1#5 AS key1 [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$union_all.key1#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-SetOperationScan
    |   +-column_list=[$union_all.key1#5]
    |   +-op_type=UNION_ALL
    |   +-input_item_list=
    |     +-SetOperationItem
    |     | +-scan=
    |     | | +-ProjectScan
    |     | |   +-column_list=[KeyValue.Key#1]
    |     | |   +-input_scan=
    |     | |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |     | +-output_column_list=[KeyValue.Key#1]
    |     +-SetOperationItem
    |       +-scan=
    |       | +-ProjectScan
    |       |   +-column_list=[KeyValue.Key#3]
    |       |   +-input_scan=
    |       |     +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0])
    |       +-output_column_list=[KeyValue.Key#3]
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$union_all.key1#5)
==

# Cannot order by columns inside the set operation.
select key as key1 from KeyValue
union all
select key as key2 from KeyValue
order by key;
--
ERROR: Unrecognized name: key; Did you mean key1? [at 4:10]
order by key;
         ^
==

# Cannot order by alias from second subquery.
select key as key1 from KeyValue
union all
select key as key2 from KeyValue
order by key2;
--
ERROR: Unrecognized name: key2; Did you mean key1? [at 4:10]
order by key2;
         ^
==

select key from KeyValue
union all
select key from KeyValue
order by key + key;
--
QueryStmt
+-output_column_list=
| +-$union_all.key#5 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$union_all.key#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$union_all.key#5, $orderby.$orderbycol1#6]
    |   +-expr_list=
    |   | +-$orderbycol1#6 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=$union_all.key#5)
    |   |     +-ColumnRef(type=INT64, column=$union_all.key#5)
    |   +-input_scan=
    |     +-SetOperationScan
    |       +-column_list=[$union_all.key#5]
    |       +-op_type=UNION_ALL
    |       +-input_item_list=
    |         +-SetOperationItem
    |         | +-scan=
    |         | | +-ProjectScan
    |         | |   +-column_list=[KeyValue.Key#1]
    |         | |   +-input_scan=
    |         | |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |         | +-output_column_list=[KeyValue.Key#1]
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[KeyValue.Key#3]
    |           |   +-input_scan=
    |           |     +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0])
    |           +-output_column_list=[KeyValue.Key#3]
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#6)
==

# If we allow ordering by expressions, ordering by aggregate expressions
# definitely is not allowed.
select key from KeyValue
union all
select key from KeyValue
order by sum(key);
--
ERROR: Aggregate function SUM not allowed in ORDER BY clause after set operation [at 4:10]
order by sum(key);
         ^
==

# Can order by constant expressions.
select key from KeyValue
union all
select key from KeyValue
order by @test_param_int32
--
QueryStmt
+-output_column_list=
| +-$union_all.key#5 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$union_all.key#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$union_all.key#5, $orderby.$orderbycol1#6]
    |   +-expr_list=
    |   | +-$orderbycol1#6 := Parameter(type=INT32, name="test_param_int32")
    |   +-input_scan=
    |     +-SetOperationScan
    |       +-column_list=[$union_all.key#5]
    |       +-op_type=UNION_ALL
    |       +-input_item_list=
    |         +-SetOperationItem
    |         | +-scan=
    |         | | +-ProjectScan
    |         | |   +-column_list=[KeyValue.Key#1]
    |         | |   +-input_scan=
    |         | |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |         | +-output_column_list=[KeyValue.Key#1]
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[KeyValue.Key#3]
    |           |   +-input_scan=
    |           |     +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0])
    |           +-output_column_list=[KeyValue.Key#3]
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#6)
==

# Can order by a subquery.
select "a" from KeyValue order by (select count(*) from TestTable)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS "$col1" [STRING]
+-query=
  +-OrderByScan
    +-column_list=[$query.$col1#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$query.$col1#3, $orderby.$orderbycol1#8]
    |   +-expr_list=
    |   | +-$orderbycol1#8 :=
    |   |   +-SubqueryExpr
    |   |     +-type=INT64
    |   |     +-subquery_type=SCALAR
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$aggregate.$agg1#7]
    |   |         +-input_scan=
    |   |           +-AggregateScan
    |   |             +-column_list=[$aggregate.$agg1#7]
    |   |             +-input_scan=
    |   |             | +-TableScan(table=TestTable)
    |   |             +-aggregate_list=
    |   |               +-$agg1#7 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    |   +-input_scan=
    |     +-ProjectScan
    |       +-column_list=[$query.$col1#3]
    |       +-expr_list=
    |       | +-$col1#3 := Literal(type=STRING, value="a")
    |       +-input_scan=
    |         +-TableScan(table=KeyValue)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#8)
==

# Cannot order by NULL.
select key from KeyValue
union all
select key from KeyValue
order by NULL
--
ERROR: Cannot ORDER BY literal values [at 4:10]
order by NULL
         ^
==

select key from KeyValue
order by @test_param_int32
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[KeyValue.Key#1]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[KeyValue.Key#1, $orderby.$orderbycol1#3]
    |   +-expr_list=
    |   | +-$orderbycol1#3 := Parameter(type=INT32, name="test_param_int32")
    |   +-input_scan=
    |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#3)
==

select key from KeyValue
order by cast(1 as int64)
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[KeyValue.Key#1]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[KeyValue.Key#1, $orderby.$orderbycol1#3]
    |   +-expr_list=
    |   | +-$orderbycol1#3 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |   +-input_scan=
    |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
==

# ORDER BY expression is a correlated column reference, which is treated
# as non-constant.
select (
    select Kitchensink.int64_val
    from TestTable
    order by keyvalue.key)
from keyvalue
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8]
    +-expr_list=
    | +-$col1#8 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-subquery=
    |       +-OrderByScan
    |         +-column_list=[$expr_subquery.int64_val#6]
    |         +-input_scan=
    |         | +-ProjectScan
    |         |   +-column_list=[TestTable.KitchenSink#5, $expr_subquery.int64_val#6, $orderby.$orderbycol1#7]
    |         |   +-expr_list=
    |         |   | +-$orderbycol1#7 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         |   +-input_scan=
    |         |     +-ProjectScan
    |         |       +-column_list=[TestTable.KitchenSink#5, $expr_subquery.int64_val#6]
    |         |       +-expr_list=
    |         |       | +-int64_val#6 :=
    |         |       |   +-GetProtoField
    |         |       |     +-type=INT64
    |         |       |     +-expr=
    |         |       |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#5)
    |         |       |     +-field_descriptor=int64_val
    |         |       |     +-default_value=0
    |         |       +-input_scan=
    |         |         +-TableScan(column_list=[TestTable.KitchenSink#5], table=TestTable, column_index_list=[2])
    |         +-order_by_item_list=
    |           +-OrderByItem
    |             +-column_ref=
    |               +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#7)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
==

# Correlated reference in ORDER BY without set operation.
select (
    select Kitchensink.int64_val
    from TestTable
    order by keyvalue.key + Kitchensink.int64_val)
from keyvalue
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8]
    +-expr_list=
    | +-$col1#8 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-subquery=
    |       +-OrderByScan
    |         +-column_list=[$expr_subquery.int64_val#6]
    |         +-input_scan=
    |         | +-ProjectScan
    |         |   +-column_list=[TestTable.KitchenSink#5, $expr_subquery.int64_val#6, $orderby.$orderbycol1#7]
    |         |   +-expr_list=
    |         |   | +-$orderbycol1#7 :=
    |         |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |         |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         |   |     +-GetProtoField
    |         |   |       +-type=INT64
    |         |   |       +-expr=
    |         |   |       | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#5)
    |         |   |       +-field_descriptor=int64_val
    |         |   |       +-default_value=0
    |         |   +-input_scan=
    |         |     +-ProjectScan
    |         |       +-column_list=[TestTable.KitchenSink#5, $expr_subquery.int64_val#6]
    |         |       +-expr_list=
    |         |       | +-int64_val#6 :=
    |         |       |   +-GetProtoField
    |         |       |     +-type=INT64
    |         |       |     +-expr=
    |         |       |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#5)
    |         |       |     +-field_descriptor=int64_val
    |         |       |     +-default_value=0
    |         |       +-input_scan=
    |         |         +-TableScan(column_list=[TestTable.KitchenSink#5], table=TestTable, column_index_list=[2])
    |         +-order_by_item_list=
    |           +-OrderByItem
    |             +-column_ref=
    |               +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#7)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
==

# Correlated reference in ORDER BY with set operation.
select (
    select Kitchensink.int64_val
    from TestTable
    union all
    select 5
    order by keyvalue.key)
from keyvalue
--
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-subquery=
    |       +-OrderByScan
    |         +-column_list=[$union_all.int64_val#8]
    |         +-input_scan=
    |         | +-ProjectScan
    |         |   +-column_list=[$union_all.int64_val#8, $orderby.$orderbycol1#9]
    |         |   +-expr_list=
    |         |   | +-$orderbycol1#9 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         |   +-input_scan=
    |         |     +-SetOperationScan
    |         |       +-column_list=[$union_all.int64_val#8]
    |         |       +-op_type=UNION_ALL
    |         |       +-input_item_list=
    |         |         +-SetOperationItem
    |         |         | +-scan=
    |         |         | | +-ProjectScan
    |         |         | |   +-column_list=[$union_all1.int64_val#6]
    |         |         | |   +-expr_list=
    |         |         | |   | +-int64_val#6 :=
    |         |         | |   |   +-GetProtoField
    |         |         | |   |     +-type=INT64
    |         |         | |   |     +-expr=
    |         |         | |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#5)
    |         |         | |   |     +-field_descriptor=int64_val
    |         |         | |   |     +-default_value=0
    |         |         | |   +-input_scan=
    |         |         | |     +-TableScan(column_list=[TestTable.KitchenSink#5], table=TestTable, column_index_list=[2])
    |         |         | +-output_column_list=[$union_all1.int64_val#6]
    |         |         +-SetOperationItem
    |         |           +-scan=
    |         |           | +-ProjectScan
    |         |           |   +-column_list=[$union_all2.$col1#7]
    |         |           |   +-expr_list=
    |         |           |   | +-$col1#7 := Literal(type=INT64, value=5)
    |         |           |   +-input_scan=
    |         |           |     +-SingleRowScan
    |         |           +-output_column_list=[$union_all2.$col1#7]
    |         +-order_by_item_list=
    |           +-OrderByItem
    |             +-column_ref=
    |               +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#9)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
==

# ORDER BY alias, ordinal, column all behave the same.
select int32 as foo
from SimpleTypes
order by {{foo|1|int32}}
--
QueryStmt
+-output_column_list=
| +-SimpleTypes.int32#1 AS foo [INT32]
+-query=
  +-OrderByScan
    +-column_list=[SimpleTypes.int32#1]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
==

# ORDER BY alias, ordinal, column all behave the same when GROUP BY present
# present (internal column names vary depending on what name
# is used/produced by the group by).
select int32 as foo
from SimpleTypes
group by {{foo|1|int32}}
order by {{foo|1|int32}}
--
ALTERNATION GROUPS:
    foo,foo
    foo,1
    foo,int32
    1,foo
    1,1
    1,int32
--
QueryStmt
+-output_column_list=
| +-$groupby.foo#19 AS foo [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.foo#19]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.foo#19]
    |   +-input_scan=
    |   | +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    |   +-group_by_list=
    |     +-foo#19 := ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$groupby.foo#19)
--
ALTERNATION GROUPS:
    int32,foo
    int32,1
    int32,int32
--
QueryStmt
+-output_column_list=
| +-$groupby.int32#19 AS foo [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.int32#19]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.int32#19]
    |   +-input_scan=
    |   | +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    |   +-group_by_list=
    |     +-int32#19 := ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$groupby.int32#19)
==

# ORDER BY alias, ordinal, column all behave the same when DISTINCT present.
select distinct int32 as foo
from SimpleTypes
order by {{foo|1|int32}}
--
QueryStmt
+-output_column_list=
| +-$distinct.int32#19 AS foo [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$distinct.int32#19]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$distinct.int32#19]
    |   +-input_scan=
    |   | +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    |   +-group_by_list=
    |     +-int32#19 := ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$distinct.int32#19)
==

# ORDER BY alias, ordinal, column all behave the same when DISTINCT and
# GROUP BY present (internal column names vary depending on what name
# is used/produced by the group by).
select distinct int32 as foo
from SimpleTypes
group by {{foo|1|int32}}
order by {{foo|1|int32}}
--
ALTERNATION GROUPS:
    foo,foo
    foo,1
    foo,int32
    1,foo
    1,1
    1,int32
--
QueryStmt
+-output_column_list=
| +-$distinct.foo#20 AS foo [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$distinct.foo#20]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$distinct.foo#20]
    |   +-input_scan=
    |   | +-AggregateScan
    |   |   +-column_list=[$groupby.foo#19]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    |   |   +-group_by_list=
    |   |     +-foo#19 := ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    |   +-group_by_list=
    |     +-foo#20 := ColumnRef(type=INT32, column=$groupby.foo#19)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$distinct.foo#20)
--
ALTERNATION GROUPS:
    int32,foo
    int32,1
    int32,int32
--
QueryStmt
+-output_column_list=
| +-$distinct.int32#20 AS foo [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$distinct.int32#20]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$distinct.int32#20]
    |   +-input_scan=
    |   | +-AggregateScan
    |   |   +-column_list=[$groupby.int32#19]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    |   |   +-group_by_list=
    |   |     +-int32#19 := ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    |   +-group_by_list=
    |     +-int32#20 := ColumnRef(type=INT32, column=$groupby.int32#19)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$distinct.int32#20)
==

# This was originally b/20529177, which failed with an internal error about
# an incorrect column reference.
select string_agg(ex)
from UNNEST(["a", "b", "c"]) ex
order by ex;
--
ERROR: ORDER BY clause expression references table alias ex which is neither grouped nor aggregated [at 3:10]
order by ex;
         ^
==

select string_agg(ex.a)
from unnest([struct<a string, b int32>("a", 1), ("b", 2)]) ex
order by ex
--
ERROR: ORDER BY clause expression references table alias ex which is neither grouped nor aggregated [at 3:10]
order by ex
         ^
==

select string_agg({{ex.|}}a)
from unnest([struct<a string, b int32>("a", 1), ("b", 2)]) ex
order by ex.a
--
ERROR: ORDER BY clause expression references ex.a which is neither grouped nor aggregated [at 3:10]
order by ex.a
         ^
==

select string_agg({{ex.|}}a)
from unnest([struct<a string, b int32>("a", 1), ("b", 2)]) ex
order by a
--
ERROR: ORDER BY clause expression references column a which is neither grouped nor aggregated [at 3:10]
order by a
         ^
==

select string_agg(ex.a)
from unnest([struct<a string, b int32>("a", 1), ("b", 2)]) ex
group by ex.b
order by ex.b
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [STRING]
+-query=
  +-OrderByScan
    +-column_list=[$aggregate.$agg1#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.b#3, $aggregate.$agg1#2]
    |   +-input_scan=
    |   | +-ArrayScan
    |   |   +-column_list=[$array.ex#1]
    |   |   +-array_expr=
    |   |   | +-Literal(type=ARRAY<STRUCT<a STRING, b INT32>>, value=[{a:"a", b:1}, {a:"b", b:2}], has_explicit_type=TRUE)
    |   |   +-element_column=$array.ex#1
    |   +-group_by_list=
    |   | +-b#3 :=
    |   |   +-GetStructField
    |   |     +-type=INT32
    |   |     +-expr=
    |   |     | +-ColumnRef(type=STRUCT<a STRING, b INT32>, column=$array.ex#1)
    |   |     +-field_idx=1
    |   +-aggregate_list=
    |     +-$agg1#2 :=
    |       +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
    |         +-GetStructField
    |           +-type=STRING
    |           +-expr=
    |           | +-ColumnRef(type=STRUCT<a STRING, b INT32>, column=$array.ex#1)
    |           +-field_idx=0
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$groupby.b#3)
==

select string_agg(ex.a)
from unnest([struct<a string, b int32>("a", 1), ("b", 2)]) ex
group by ex.b
order by ex.b, ex.a
--
ERROR: ORDER BY clause expression references ex.a which is neither grouped nor aggregated [at 4:16]
order by ex.b, ex.a
               ^
==

# This was originally b/20634935.
# TODO: Unfortunately, we model OFFSET as a range variable (to
# ensure no conflicts with range variable names), so the error message
# here is a bit misleading.  Fix this.
select 1 FROM UNNEST([1,2,3]) as e WITH OFFSET o GROUP BY e ORDER BY o
--
ERROR: ORDER BY clause expression references table alias o which is neither grouped nor aggregated [at 1:70]
select 1 FROM UNNEST([1,2,3]) as e WITH OFFSET o GROUP BY e ORDER BY o
                                                                     ^
==

[language_features=V_1_2_GROUP_BY_STRUCT]
SELECT TestStruct
FROM ComplexTypes
GROUP BY TestStruct
ORDER BY TestStruct.c + TestStruct.d.a
--
QueryStmt
+-output_column_list=
| +-$groupby.TestStruct#7 AS TestStruct [STRUCT<c INT32, d STRUCT<a INT32, b STRING>>]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.TestStruct#7]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.TestStruct#7, $orderby.$orderbycol1#8]
    |   +-expr_list=
    |   | +-$orderbycol1#8 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-Cast(INT32 -> INT64)
    |   |     | +-GetStructField
    |   |     |   +-type=INT32
    |   |     |   +-expr=
    |   |     |   | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=$groupby.TestStruct#7)
    |   |     |   +-field_idx=0
    |   |     +-Cast(INT32 -> INT64)
    |   |       +-GetStructField
    |   |         +-type=INT32
    |   |         +-expr=
    |   |         | +-GetStructField
    |   |         |   +-type=STRUCT<a INT32, b STRING>
    |   |         |   +-expr=
    |   |         |   | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=$groupby.TestStruct#7)
    |   |         |   +-field_idx=1
    |   |         +-field_idx=0
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.TestStruct#7]
    |       +-input_scan=
    |       | +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4])
    |       +-group_by_list=
    |         +-TestStruct#7 := ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#8)
==

[language_features=V_1_2_GROUP_BY_STRUCT]
SELECT TestStruct.d as TestStruct
FROM ComplexTypes ct
GROUP BY TestStruct, ct.TestStruct
ORDER BY {{ct.|}}TestStruct.c
--
ALTERNATION GROUP: ct.

--
QueryStmt
+-output_column_list=
| +-$groupby.TestStruct#8 AS TestStruct [STRUCT<a INT32, b STRING>]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.TestStruct#8]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.TestStruct#8, $groupby.TestStruct#9, $orderby.$orderbycol1#10]
    |   +-expr_list=
    |   | +-$orderbycol1#10 :=
    |   |   +-GetStructField
    |   |     +-type=INT32
    |   |     +-expr=
    |   |     | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=$groupby.TestStruct#9)
    |   |     +-field_idx=0
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=$groupby.[TestStruct#8, TestStruct#9]
    |       +-input_scan=
    |       | +-ProjectScan
    |       |   +-column_list=[ComplexTypes.TestStruct#5, $pre_groupby.TestStruct#7]
    |       |   +-expr_list=
    |       |   | +-TestStruct#7 :=
    |       |   |   +-GetStructField
    |       |   |     +-type=STRUCT<a INT32, b STRING>
    |       |   |     +-expr=
    |       |   |     | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
    |       |   |     +-field_idx=1
    |       |   +-input_scan=
    |       |     +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4], alias="ct")
    |       +-group_by_list=
    |         +-TestStruct#8 := ColumnRef(type=STRUCT<a INT32, b STRING>, column=$pre_groupby.TestStruct#7)
    |         +-TestStruct#9 := ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#10)
--
ALTERNATION GROUP: <empty>
--
ERROR: Field name c does not exist in STRUCT<a INT32, b STRING> [at 4:21]
ORDER BY TestStruct.c
                    ^
==

[language_features=ANALYTIC_FUNCTIONS{{|,V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY}}]
select key from KeyValue order by key nulls {{first|last}};
--
ALTERNATION GROUP: first
--
ERROR: NULLS FIRST and NULLS LAST are not supported [at 1:39]
select key from KeyValue order by key nulls first;
                                      ^
--
ALTERNATION GROUP: last
--
ERROR: NULLS FIRST and NULLS LAST are not supported [at 1:39]
select key from KeyValue order by key nulls last;
                                      ^
--
ALTERNATION GROUP: ,V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY,first
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[KeyValue.Key#1]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
        | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-null_order=NULLS_FIRST
--
ALTERNATION GROUP: ,V_1_3_NULLS_FIRST_LAST_IN_ORDER_BY,last
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[KeyValue.Key#1]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
        | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-null_order=NULLS_LAST
