################################################################################
#
# Positive test cases
#
################################################################################
#
# Call a simple valid templated SQL function. This exercises the code to declare
# SQL UDFs using the TemplatedSQLUDF class and add them to the catalog, then
# defer resolving these SQL bodies until the function is actually called later.
# In this case the function has no arguments, but the return type is templated.
# TODO: Enable Java support when serialization for templated SQL
# functions is implemented.
[default no_java]
select udf_templated_return_one();
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := FunctionCall(Templated_SQL_Function:udf_templated_return_one() -> INT64)
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_return_one() -> INT64
containing resolved templated expression:
Literal(type=INT64, value=1)
==

# The query calls a function that has a deprecation warning, which should be
# propagated.
select udf_calls_deprecation_warning()
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := FunctionCall(Templated_SQL_Function:udf_calls_deprecation_warning() -> INT64)
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_calls_deprecation_warning() -> INT64 (1 deprecation warning)
containing resolved templated expression:
FunctionCall(sample_functions:deprecation_warning() -> INT64)


DEPRECATION WARNING:
Function TEMPLATED_SQL_FUNCTION:UDF_CALLS_DEPRECATION_WARNING triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 1:8]
select udf_calls_deprecation_warning()
       ^
Operation <foo101> is deprecated [at module101.sqlm:111:121]
some caret string for foo_101
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }
==

# The query calls a function that has a deprecation warning, twice. The warning
# should be propagated once. For more extensive tests of functions and
# deprecation warnings, see function.test. We don't need a huge test suite for
# deprecation warnings with templated UDFs because most of the resolution code
# is shared with non-templated UDFs.
select udf_calls_deprecation_warning(), udf_calls_deprecation_warning()
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
| +-$query.$col2#2 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2]
    +-expr_list=
    | +-$col1#1 := FunctionCall(Templated_SQL_Function:udf_calls_deprecation_warning() -> INT64)
    | +-$col2#2 := FunctionCall(Templated_SQL_Function:udf_calls_deprecation_warning() -> INT64)
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_calls_deprecation_warning() -> INT64 (1 deprecation warning)
containing resolved templated expression:
FunctionCall(sample_functions:deprecation_warning() -> INT64)


DEPRECATION WARNING:
Function TEMPLATED_SQL_FUNCTION:UDF_CALLS_DEPRECATION_WARNING triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 1:8]
select udf_calls_deprecation_warning(), udf_calls_deprecation_warning()
       ^
Operation <foo101> is deprecated [at module101.sqlm:111:121]
some caret string for foo_101
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }
==

# Call a UDF passing a query parameter within a scalar argument.
select udf_templated_return_bool_arg(@test_param_bool)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_templated_return_bool_arg(BOOL) -> BOOL)
    |     +-Parameter(type=BOOL, name='test_param_bool')
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_return_bool_arg(BOOL) -> BOOL
containing resolved templated expression:
ArgumentRef(type=BOOL, name="x")
==

# Show a case where the same template resolves to two different signatures:
# part one.
select udf_templated_return_any_scalar_arg("abc");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_templated_return_any_scalar_arg(STRING) -> STRING)
    |     +-Literal(type=STRING, value='abc')
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_return_any_scalar_arg(STRING) -> STRING
containing resolved templated expression:
ArgumentRef(type=STRING, name="x")
==

# Show a case where the same template resolves to two different signatures:
# part two.
select udf_templated_return_any_scalar_arg(true);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_templated_return_any_scalar_arg(BOOL) -> BOOL)
    |     +-Literal(type=BOOL, value=true)
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_return_any_scalar_arg(BOOL) -> BOOL
containing resolved templated expression:
ArgumentRef(type=BOOL, name="x")
==

# Call a UDF with a valid templated SQL body that refers to a scalar argument.
select udf_templated_return_int64_arg(42);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_templated_return_int64_arg(INT64) -> INT64)
    |     +-Literal(type=INT64, value=42)
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_return_int64_arg(INT64) -> INT64
containing resolved templated expression:
ArgumentRef(type=INT64, name="x")
==

# The function performs a projection.
select udf_templated_arg_plus_integer(42),
       udf_templated_arg_concat_string("abc");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
| +-$query.$col2#2 AS "$col2" [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(Templated_SQL_Function:udf_templated_arg_plus_integer(INT64) -> INT64)
    | |   +-Literal(type=INT64, value=42)
    | +-$col2#2 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_templated_arg_concat_string(STRING) -> STRING)
    |     +-Literal(type=STRING, value='abc')
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_arg_plus_integer(INT64) -> INT64
containing resolved templated expression:
FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
+-ArgumentRef(type=INT64, name="x")
+-Literal(type=INT64, value=42)

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_arg_concat_string(STRING) -> STRING
containing resolved templated expression:
FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
+-ArgumentRef(type=STRING, name="x")
+-Literal(type=STRING, value='abc')
==

# The function takes two arguments.
select udf_templated_arg_concat_two_strings("abc", "def");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_templated_arg_concat_two_strings(STRING, STRING) -> STRING)
    |     +-Literal(type=STRING, value='abc')
    |     +-Literal(type=STRING, value='def')
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_arg_concat_two_strings(STRING, STRING) -> STRING
containing resolved templated expression:
FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
+-ArgumentRef(type=STRING, name="x")
+-ArgumentRef(type=STRING, name="y")
==

# The function has a $ in its internal argument name.
select udf_templated_arg_plus_integer_accept_dollars_col_name(52)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_templated_arg_plus_integer_accept_dollars_col_name(INT64) -> INT64)
    |     +-Literal(type=INT64, value=52)
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_arg_plus_integer_accept_dollars_col_name(INT64) -> INT64
containing resolved templated expression:
ArgumentRef(type=INT64, name="$col1")
==

# Call a templated SQL UDF that calls another templated SQL UDF.
select udf_call_udf_templated_return_one();
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := FunctionCall(Templated_SQL_Function:udf_call_udf_templated_return_one() -> INT64)
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_call_udf_templated_return_one() -> INT64
containing resolved templated expression:
FunctionCall(Templated_SQL_Function:udf_templated_return_one() -> INT64)

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_return_one() -> INT64
containing resolved templated expression:
Literal(type=INT64, value=1)
==

# Call a templated SQL UDF that calls another templated SQL UDF twice.
select udf_call_udf_templated_return_one_twice();
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := FunctionCall(Templated_SQL_Function:udf_call_udf_templated_return_one_twice() -> INT64)
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_call_udf_templated_return_one_twice() -> INT64
containing resolved templated expression:
FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
+-FunctionCall(Templated_SQL_Function:udf_call_udf_templated_return_one() -> INT64)
+-FunctionCall(Templated_SQL_Function:udf_call_udf_templated_return_one() -> INT64)

With Templated SQL function call:
  Templated_SQL_Function:udf_call_udf_templated_return_one() -> INT64
containing resolved templated expression:
FunctionCall(Templated_SQL_Function:udf_templated_return_one() -> INT64)

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_return_one() -> INT64
containing resolved templated expression:
Literal(type=INT64, value=1)
==

# Call a templated SQL UDF with an argument type that exactly matches its
# expected return type. The function call finishes successfully.
select udf_one_templated_arg_return_int64(cast(1 as int64))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_one_templated_arg_return_int64(INT64) -> INT64)
    |     +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_one_templated_arg_return_int64(INT64) -> INT64
containing resolved templated expression:
ArgumentRef(type=INT64, name="x")
==

# Call a templated SQL UDF with a literal NULL argument value, and an expected
# return type of INT64. The function call finishes successfully.
select udf_one_templated_arg_return_int64(null)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_one_templated_arg_return_int64(INT64) -> INT64)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_one_templated_arg_return_int64(INT64) -> INT64
containing resolved templated expression:
ArgumentRef(type=INT64, name="x")
==

# Call a templated SQL UDF with literal NULL explicitly casted to DATE, and an
# expected return type of DATE.
select udf_one_templated_arg_return_date(cast(null as date))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [DATE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_one_templated_arg_return_date(DATE) -> DATE)
    |     +-Literal(type=DATE, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_one_templated_arg_return_date(DATE) -> DATE
containing resolved templated expression:
ArgumentRef(type=DATE, name="x")
==

# Call a templated SQL UDF with an argument type that does not exactly match its
# expected return type but is coercible. The resolver adds a coercion and the
# function call finishes successfully.
select udf_one_templated_arg_return_int64(cast(1 as int32))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_one_templated_arg_return_int64(INT32) -> INT64)
    |     +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_one_templated_arg_return_int64(INT32) -> INT64
containing resolved templated expression:
Cast(INT32 -> INT64)
+-ArgumentRef(type=INT32, name="x")
==

# Call a templated SQL UDF with an argument type that exactly matches its
# expected return type. The function call finishes successfully.
select udf_one_templated_arg_return_struct_int64_string(
    (select as struct cast(1 as int64) as int_field, "abc" as string_field))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [STRUCT<int_field INT64, string_field STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_one_templated_arg_return_struct_int64_string(STRUCT<int_field INT64, string_field STRING>) -> STRUCT<int_field INT64, string_field STRING>)
    |     +-SubqueryExpr
    |       +-type=STRUCT<int_field INT64, string_field STRING>
    |       +-subquery_type=SCALAR
    |       +-subquery=
    |         +-ProjectScan
    |           +-column_list=[$make_struct.$struct#3]
    |           +-expr_list=
    |           | +-$struct#3 :=
    |           |   +-MakeStruct
    |           |     +-type=STRUCT<int_field INT64, string_field STRING>
    |           |     +-field_list=
    |           |       +-ColumnRef(type=INT64, column=$expr_subquery.int_field#1)
    |           |       +-ColumnRef(type=STRING, column=$expr_subquery.string_field#2)
    |           +-input_scan=
    |             +-ProjectScan
    |               +-column_list=$expr_subquery.[int_field#1, string_field#2]
    |               +-expr_list=
    |               | +-int_field#1 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |               | +-string_field#2 := Literal(type=STRING, value='abc')
    |               +-input_scan=
    |                 +-SingleRowScan
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_one_templated_arg_return_struct_int64_string(STRUCT<int_field INT64, string_field STRING>) -> STRUCT<int_field INT64, string_field STRING>
containing resolved templated expression:
ArgumentRef(type=STRUCT<int_field INT64, string_field STRING>, name="x")
==

# Call a templated SQL UDF with an argument type comprising a struct with
# literal fields that does not exactly match its expected return type but is
# coercible. The resolver adds a coercion and the function call finishes
# successfully.
select udf_one_templated_arg_return_struct_int64_string(
    (select as struct cast(1 as int32) as int_field, "abc" as string_field))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [STRUCT<int_field INT64, string_field STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_one_templated_arg_return_struct_int64_string(STRUCT<int_field INT32, string_field STRING>) -> STRUCT<int_field INT64, string_field STRING>)
    |     +-SubqueryExpr
    |       +-type=STRUCT<int_field INT32, string_field STRING>
    |       +-subquery_type=SCALAR
    |       +-subquery=
    |         +-ProjectScan
    |           +-column_list=[$make_struct.$struct#3]
    |           +-expr_list=
    |           | +-$struct#3 :=
    |           |   +-MakeStruct
    |           |     +-type=STRUCT<int_field INT32, string_field STRING>
    |           |     +-field_list=
    |           |       +-ColumnRef(type=INT32, column=$expr_subquery.int_field#1)
    |           |       +-ColumnRef(type=STRING, column=$expr_subquery.string_field#2)
    |           +-input_scan=
    |             +-ProjectScan
    |               +-column_list=$expr_subquery.[int_field#1, string_field#2]
    |               +-expr_list=
    |               | +-int_field#1 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    |               | +-string_field#2 := Literal(type=STRING, value='abc')
    |               +-input_scan=
    |                 +-SingleRowScan
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_one_templated_arg_return_struct_int64_string(STRUCT<int_field INT32, string_field STRING>) -> STRUCT<int_field INT64, string_field STRING>
containing resolved templated expression:
Cast(STRUCT<int_field INT32, string_field STRING> -> STRUCT<int_field INT64, string_field STRING>)
+-ArgumentRef(type=STRUCT<int_field INT32, string_field STRING>, name="x")
==

# Call a templated SQL UDF with an argument type comprising a struct with
# non-literal fields that does not exactly match its expected return type but is
# coercible. The resolver adds a coercion in the function's resolved SQL body
# and the function call finishes successfully.
select udf_one_templated_arg_return_struct_int64_string(
    (select as struct cast(value as int32) as int_field,
                      cast(key as string) as string_field
     from keyvalue))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS "$col1" [STRUCT<int_field INT64, string_field STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_one_templated_arg_return_struct_int64_string(STRUCT<int_field INT32, string_field STRING>) -> STRUCT<int_field INT64, string_field STRING>)
    |     +-SubqueryExpr
    |       +-type=STRUCT<int_field INT32, string_field STRING>
    |       +-subquery_type=SCALAR
    |       +-subquery=
    |         +-ProjectScan
    |           +-column_list=[$make_struct.$struct#5]
    |           +-expr_list=
    |           | +-$struct#5 :=
    |           |   +-MakeStruct
    |           |     +-type=STRUCT<int_field INT32, string_field STRING>
    |           |     +-field_list=
    |           |       +-ColumnRef(type=INT32, column=$expr_subquery.int_field#3)
    |           |       +-ColumnRef(type=STRING, column=$expr_subquery.string_field#4)
    |           +-input_scan=
    |             +-ProjectScan
    |               +-column_list=$expr_subquery.[int_field#3, string_field#4]
    |               +-expr_list=
    |               | +-int_field#3 :=
    |               | | +-Cast(STRING -> INT32)
    |               | |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |               | +-string_field#4 :=
    |               |   +-Cast(INT64 -> STRING)
    |               |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |               +-input_scan=
    |                 +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_one_templated_arg_return_struct_int64_string(STRUCT<int_field INT32, string_field STRING>) -> STRUCT<int_field INT64, string_field STRING>
containing resolved templated expression:
Cast(STRUCT<int_field INT32, string_field STRING> -> STRUCT<int_field INT64, string_field STRING>)
+-ArgumentRef(type=STRUCT<int_field INT32, string_field STRING>, name="x")
==

# Call a templated SQL function with a 32-bit integer return type that returns
# the literal value 42.
select udf_templated_return_42_return_type_int32("abc")
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_templated_return_42_return_type_int32(STRING) -> INT32)
    |     +-Literal(type=STRING, value='abc')
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_return_42_return_type_int32(STRING) -> INT32
containing resolved templated expression:
Literal(type=INT32, value=42)
==

# Call a SQL UDA with a valid templated SQL body that refers to an aggregate
# argument only.
select uda_valid_templated_return_sum_int64_arg(key) from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(Templated_SQL_Function:uda_valid_templated_return_sum_int64_arg(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)

With Templated SQL function call:
  Templated_SQL_Function:uda_valid_templated_return_sum_int64_arg(INT64) -> INT64
containing resolved templated expression:
ColumnRef(type=INT64, column=$aggregate.$agg1#1)

  $agg1#1 :=
    +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
      +-ArgumentRef(parse_location=4-5, type=INT64, name="x", argument_kind=AGGREGATE)
==

# Call a SQL UDA with a valid templated SQL body that refers to a NOT
# AGGREGATE argument only.
select uda_valid_templated_return_int64_not_aggregate_arg(42) from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(Templated_SQL_Function:uda_valid_templated_return_int64_not_aggregate_arg(INT64) -> INT64)
              +-Literal(type=INT64, value=42)

With Templated SQL function call:
  Templated_SQL_Function:uda_valid_templated_return_int64_not_aggregate_arg(INT64 {is_not_aggregate: true}) -> INT64
containing resolved templated expression:
ArgumentRef(type=INT64, name="y", argument_kind=NOT_AGGREGATE)
==

# Call a SQL UDA with a valid templated SQL body that refers to an AGGREGATE
# argument and also a NOT AGGREGATE argument in the same script.
select uda_valid_templated_return_int64_aggregate_and_not_aggregate_arg(key, 42)
from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(Templated_SQL_Function:uda_valid_templated_return_int64_aggregate_and_not_aggregate_arg(INT64, INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=42)

With Templated SQL function call:
  Templated_SQL_Function:uda_valid_templated_return_int64_aggregate_and_not_aggregate_arg(INT64, INT64 {is_not_aggregate: true}) -> INT64
containing resolved templated expression:
FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
+-ColumnRef(type=INT64, column=$aggregate.$agg1#1)
+-ArgumentRef(type=INT64, name="y", argument_kind=NOT_AGGREGATE)

  $agg1#1 :=
    +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
      +-ArgumentRef(parse_location=4-5, type=INT64, name="x", argument_kind=AGGREGATE)
==

################################################################################
#
# Negative test cases
#
################################################################################
#
# Call a templated SQL UDF that contains a query parameter reference within the
# function body.
select udf_templated_function_body_refer_to_parameter()
--
ERROR: Invalid function udf_templated_function_body_refer_to_parameter [at 1:8]
select udf_templated_function_body_refer_to_parameter()
       ^
Analysis of function Templated_SQL_Function:udf_templated_function_body_refer_to_parameter failed [at 1:1]
@test_param_bool
^
Query parameters cannot be used inside SQL function bodies [at 1:1]
@test_param_bool
^
==

# Call a templated SQL UDF that references itself directly. This should return
# an error.
select udf_recursive()
--
ERROR: Invalid function udf_recursive [at 1:8]
select udf_recursive()
       ^
Analysis of function Templated_SQL_Function:udf_recursive failed [at 1:1]
udf_recursive()
^
Invalid function udf_recursive [at 1:1]
udf_recursive()
^
The function Templated_SQL_Function:udf_recursive is recursive
==

# Call a templated SQL UDF that references itself indirectly. This should return
# an error.
select udf_calls_self_indirectly_1()
--
ERROR: Invalid function udf_calls_self_indirectly_1 [at 1:8]
select udf_calls_self_indirectly_1()
       ^
Analysis of function Templated_SQL_Function:udf_calls_self_indirectly_1 failed [at 1:1]
udf_calls_self_indirectly_2()
^
Invalid function udf_calls_self_indirectly_2 [at 1:1]
udf_calls_self_indirectly_2()
^
Analysis of function Templated_SQL_Function:udf_calls_self_indirectly_2 failed [at 1:1]
udf_calls_self_indirectly_1()
^
Invalid function udf_calls_self_indirectly_1 [at 1:1]
udf_calls_self_indirectly_1()
^
Recursive dependencies detected when resolving function Templated_SQL_Function:udf_calls_self_indirectly_1, which include objects (Templated_SQL_Function:udf_calls_self_indirectly_1, Templated_SQL_Function:udf_calls_self_indirectly_2, Templated_SQL_Function:udf_calls_self_indirectly_1)
==

# The function performs an invalid projection.
select udf_templated_arg_plus_integer("abc");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_templated_arg_plus_integer(STRING) -> INT64)
    |     +-Literal(type=STRING, value='abc')
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_arg_plus_integer(STRING) -> INT64
containing resolved templated expression:
FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
+-Cast(STRING -> INT64)
| +-ArgumentRef(type=STRING, name="x")
+-Literal(type=INT64, value=42)
==

# Parse error.
select udf_templated_parse_error();
--
ERROR: Invalid function udf_templated_parse_error [at 1:8]
select udf_templated_parse_error();
       ^
Analysis of function Templated_SQL_Function:udf_templated_parse_error failed [at 1:3]
a b c d e
  ^
Syntax error: Expected end of input but got identifier "b" [at 1:3]
a b c d e
  ^

==

# Test that we propagate language options correctly, this should
# be a parser error without V_1_3_LIKE_ANY_SOME_ALL
select udf_templated_like_any('y');
--
ERROR: Invalid function udf_templated_like_any [at 1:8]
select udf_templated_like_any('y');
       ^
Analysis of function Templated_SQL_Function:udf_templated_like_any failed [at 1:8]
x like any ('z')
       ^
LIKE ANY is not supported [at 1:8]
x like any ('z')
       ^
==

[language_features=V_1_3_LIKE_ANY_SOME_ALL]

select udf_templated_like_any('y');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_templated_like_any(STRING) -> BOOL)
    |     +-Literal(type=STRING, value='y')
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_templated_like_any(STRING) -> BOOL
containing resolved templated expression:
FunctionCall(ZetaSQL:$like_any(STRING, repeated(1) STRING) -> BOOL)
+-ArgumentRef(type=STRING, name="x")
+-Literal(type=STRING, value='z')
==

# Call a UDF that refers to 'udf_templated_analysis_error' to show two levels
# of nested error messages.
select key, value, udf_call_udf_templated_analysis_error()
from keyvalue;
--
ERROR: Invalid function udf_call_udf_templated_analysis_error [at 1:20]
select key, value, udf_call_udf_templated_analysis_error()
                   ^
Analysis of function Templated_SQL_Function:udf_call_udf_templated_analysis_error failed [at 1:1]
udf_templated_analysis_error() + 1
^
Invalid function udf_templated_analysis_error [at 1:1]
udf_templated_analysis_error() + 1
^
Analysis of function Templated_SQL_Function:udf_templated_analysis_error failed [at 1:1]
'abc' + 42
^
Could not cast literal "abc" to type INT64 [at 1:1]
'abc' + 42
^
==

# Call a UDF that refers to 'udf_call_udf_templated_analysis_error' to show
# three levels of nested error messages.
select key, value, udf_call_udf_call_udf_templated_analysis_error()
from keyvalue;
--
ERROR: Invalid function udf_call_udf_call_udf_templated_analysis_error [at 1:20]
select key, value, udf_call_udf_call_udf_templated_analysis_error()
                   ^
Analysis of function Templated_SQL_Function:udf_call_udf_call_udf_templated_analysis_error failed [at 1:1]
udf_call_udf_templated_analysis_error() + 1
^
Invalid function udf_call_udf_templated_analysis_error [at 1:1]
udf_call_udf_templated_analysis_error() + 1
^
Analysis of function Templated_SQL_Function:udf_call_udf_templated_analysis_error failed [at 1:1]
udf_templated_analysis_error() + 1
^
Invalid function udf_templated_analysis_error [at 1:1]
udf_templated_analysis_error() + 1
^
Analysis of function Templated_SQL_Function:udf_templated_analysis_error failed [at 1:1]
'abc' + 42
^
Could not cast literal "abc" to type INT64 [at 1:1]
'abc' + 42
^
==

# Call a UDF that refers to 'udf_calludf_call_udf_templated_analysis_error' to
# show four levels of nested error messages.
select key, value, udf_call_udf_call_udf_call_udf_templated_analysis_error()
from keyvalue;
--
ERROR: Invalid function udf_call_udf_call_udf_call_udf_templated_analysis_error [at 1:20]
select key, value, udf_call_udf_call_udf_call_udf_templated_analysis_error()
                   ^
Analysis of function Templated_SQL_Function:udf_call_udf_call_udf_call_udf_templated_analysis_error failed [at 1:1]
udf_call_udf_call_udf_templated_analysis_error() + 1
^
Invalid function udf_call_udf_call_udf_templated_analysis_error [at 1:1]
udf_call_udf_call_udf_templated_analysis_error() + 1
^
Analysis of function Templated_SQL_Function:udf_call_udf_call_udf_templated_analysis_error failed [at 1:1]
udf_call_udf_templated_analysis_error() + 1
^
Invalid function udf_call_udf_templated_analysis_error [at 1:1]
udf_call_udf_templated_analysis_error() + 1
^
Analysis of function Templated_SQL_Function:udf_call_udf_templated_analysis_error failed [at 1:1]
udf_templated_analysis_error() + 1
^
Invalid function udf_templated_analysis_error [at 1:1]
udf_templated_analysis_error() + 1
^
Analysis of function Templated_SQL_Function:udf_templated_analysis_error failed [at 1:1]
'abc' + 42
^
Could not cast literal "abc" to type INT64 [at 1:1]
'abc' + 42
^
==

# Empty function body.
select udf_templated_function_body_empty();
--
ERROR: Invalid function udf_templated_function_body_empty [at 1:8]
select udf_templated_function_body_empty();
       ^
Analysis of function Templated_SQL_Function:udf_templated_function_body_empty failed [at 1:1]

^
Syntax error: Unexpected end of expression [at 1:1]
==

# Add a UDF with a valid templated SQL body that performs a proto field access
# on an argument. The function signature accepts a single argument of any
# type. We pass an integer argument here, resulting in an analysis error.
select udf_templated_arg_proto_field_access(42)
--
ERROR: Invalid function udf_templated_arg_proto_field_access [at 1:8]
select udf_templated_arg_proto_field_access(42)
       ^
Analysis of function Templated_SQL_Function:udf_templated_arg_proto_field_access failed [at 1:3]
x.int32_field
  ^
Cannot access field int32_field on a value with type INT64 [at 1:3]
x.int32_field
  ^
==

# Call a templated SQL UDF with duplicate argument names, to show the error
# messages.
select udf_templated_duplicate_arg_names("abc", "def");
--
ERROR: Invalid function udf_templated_duplicate_arg_names [at 1:8]
select udf_templated_duplicate_arg_names("abc", "def");
       ^
Analysis of function Templated_SQL_Function:udf_templated_duplicate_arg_names failed:
Duplicate argument name x
==

# Call a templated SQL function that calls a templated SQL TVF that calls the
# original templated SQL function again, to make sure cycle detection works.
[language_features=TABLE_VALUED_FUNCTIONS]
select udf_calls_tvf_calls_same_udf();
--
ERROR: Invalid function udf_calls_tvf_calls_same_udf [at 1:8]
select udf_calls_tvf_calls_same_udf();
       ^
Analysis of function Templated_SQL_Function:udf_calls_tvf_calls_same_udf failed [at 1:16]
(select * from tvf_calls_udf_calls_same_tvf())
               ^
Invalid table-valued function tvf_calls_udf_calls_same_tvf [at 1:16]
(select * from tvf_calls_udf_calls_same_tvf())
               ^
Analysis of table-valued function tvf_calls_udf_calls_same_tvf failed [at 1:8]
select udf_calls_tvf_calls_same_udf()
       ^
Invalid function udf_calls_tvf_calls_same_udf [at 1:8]
select udf_calls_tvf_calls_same_udf()
       ^
Recursive dependencies detected when resolving function Templated_SQL_Function:udf_calls_tvf_calls_same_udf, which include objects (Templated_SQL_Function:udf_calls_tvf_calls_same_udf, tvf_calls_udf_calls_same_tvf, Templated_SQL_Function:udf_calls_tvf_calls_same_udf)
==

# Call a templated SQL TVF that calls a templated SQL function that calls the
# original templated SQL TVF again, to make sure cycle detection works.
[language_features=TABLE_VALUED_FUNCTIONS]
select * from tvf_calls_udf_calls_same_tvf();
--
ERROR: Invalid table-valued function tvf_calls_udf_calls_same_tvf [at 1:15]
select * from tvf_calls_udf_calls_same_tvf();
              ^
Analysis of table-valued function tvf_calls_udf_calls_same_tvf failed [at 1:8]
select udf_calls_tvf_calls_same_udf()
       ^
Invalid function udf_calls_tvf_calls_same_udf [at 1:8]
select udf_calls_tvf_calls_same_udf()
       ^
Analysis of function Templated_SQL_Function:udf_calls_tvf_calls_same_udf failed [at 1:16]
(select * from tvf_calls_udf_calls_same_tvf())
               ^
Invalid table-valued function tvf_calls_udf_calls_same_tvf [at 1:16]
(select * from tvf_calls_udf_calls_same_tvf())
               ^
Recursive dependencies detected when resolving table function tvf_calls_udf_calls_same_tvf, which include objects (tvf_calls_udf_calls_same_tvf, Templated_SQL_Function:udf_calls_tvf_calls_same_udf, tvf_calls_udf_calls_same_tvf)
==

# Call a templated SQL UDF that always returns the integer 42 but has a required
# signature return type of STRING. ZetaSQL cannot automatically coerce the
# value and the function call fails.
select udf_templated_return_42_return_type_string(null)
--
ERROR: Invalid function udf_templated_return_42_return_type_string [at 1:8]
select udf_templated_return_42_return_type_string(null)
       ^
Analysis of function Templated_SQL_Function:udf_templated_return_42_return_type_string failed:
Function declared to return STRING but the function body produces incompatible type INT64
==

# Call a templated SQL UDF with literal NULL, and an expected return type of
# DATE.
select udf_one_templated_arg_return_date(null)
--
ERROR: Invalid function udf_one_templated_arg_return_date [at 1:8]
select udf_one_templated_arg_return_date(null)
       ^
Analysis of function Templated_SQL_Function:udf_one_templated_arg_return_date failed:
Function declared to return DATE but the function body produces incompatible type INT64
==

# Call a templated SQL UDF that always returns the integer 42 but has a required
# signature return type of STRING. ZetaSQL cannot automatically coerce the
# value and the function call fails.
select udf_templated_return_42_return_type_string(cast(null as string))
--
ERROR: Invalid function udf_templated_return_42_return_type_string [at 1:8]
select udf_templated_return_42_return_type_string(cast(null as string))
       ^
Analysis of function Templated_SQL_Function:udf_templated_return_42_return_type_string failed:
Function declared to return STRING but the function body produces incompatible type INT64
==

# Call a templated SQL function with a 32-bit integer return type that returns
# an integer too large to fit into 32 bits..
select udf_templated_return_999999999999999_return_type_int32("abc")
--
ERROR: Invalid function udf_templated_return_999999999999999_return_type_int32 [at 1:8]
select udf_templated_return_999999999999999_return_type_int32("abc")
       ^
Analysis of function Templated_SQL_Function:udf_templated_return_999999999999999_return_type_int32 failed:
Could not cast literal 999999999999999 to type INT32
==

# Call a templated SQL UDF with a string, and an expected return type of DATE.
select udf_one_templated_arg_return_date('2018-07-01')
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [DATE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_one_templated_arg_return_date(STRING) -> DATE)
    |     +-Literal(type=STRING, value='2018-07-01')
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_one_templated_arg_return_date(STRING) -> DATE
containing resolved templated expression:
Cast(STRING -> DATE)
+-ArgumentRef(type=STRING, name="x")
==

# Call a templated SQL UDF with a 64-bit integer argument type that fits under
# the maximum integer of the expected 32-bit return type.
select udf_one_templated_arg_return_int32(42)
--
ERROR: Invalid function udf_one_templated_arg_return_int32 [at 1:8]
select udf_one_templated_arg_return_int32(42)
       ^
Analysis of function Templated_SQL_Function:udf_one_templated_arg_return_int32 failed:
Function declared to return INT32 but the function body produces incompatible type INT64
==

# Call a templated SQL UDF with an integer argument type that is larger than the
# maximum integer of the expected 32-bit return type.
select udf_one_templated_arg_return_int32(999999999999999)
--
ERROR: Invalid function udf_one_templated_arg_return_int32 [at 1:8]
select udf_one_templated_arg_return_int32(999999999999999)
       ^
Analysis of function Templated_SQL_Function:udf_one_templated_arg_return_int32 failed:
Function declared to return INT32 but the function body produces incompatible type INT64
==

# Call a templated SQL UDF with an argument type that does not exactly match its
# expected return type.
select udf_one_templated_arg_return_int64(cast(1 as string))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(Templated_SQL_Function:udf_one_templated_arg_return_int64(STRING) -> INT64)
    |     +-Literal(type=STRING, value='1', has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan

With Templated SQL function call:
  Templated_SQL_Function:udf_one_templated_arg_return_int64(STRING) -> INT64
containing resolved templated expression:
Cast(STRING -> INT64)
+-ArgumentRef(type=STRING, name="x")
==

# Call a SQL UDA with an invalid templated SQL body that refers to an AGGREGATE
# argument and also a NOT AGGREGATE argument in the same script. The function
# attempts to refer to the AGGREGATE argument outside of an aggregate function,
# which is invalid.
select uda_invalid_templated_return_int64_aggregate_and_not_aggregate_arg(
    key, 42)
from keyvalue;
--
ERROR: Invalid function uda_invalid_templated_return_int64_aggregate_and_not_aggregate_arg [at 1:8]
select uda_invalid_templated_return_int64_aggregate_and_not_aggregate_arg(
       ^
Analysis of function Templated_SQL_Function:uda_invalid_templated_return_int64_aggregate_and_not_aggregate_arg failed [at 1:1]
sum(y) + x
^
Analysis of function Templated_SQL_Function:uda_invalid_templated_return_int64_aggregate_and_not_aggregate_arg failed:
Function argument x cannot be referenced outside aggregate function calls unless marked as NOT AGGREGATE
==

# Call a SQL UDA with an invalid templated SQL body, since there is an ORDER
# BY clause in an aggregate function nested inside.
select uda_invalid_templated_return_sum_int64_arg_nested_order_by(key)
from keyvalue;
--
ERROR: Invalid function uda_invalid_templated_return_sum_int64_arg_nested_order_by [at 1:8]
select uda_invalid_templated_return_sum_int64_arg_nested_order_by(key)
       ^
Analysis of function Templated_SQL_Function:uda_invalid_templated_return_sum_int64_arg_nested_order_by failed [at 1:7]
sum(x order by x)
      ^
ORDER BY in aggregate function is not supported [at 1:7]
sum(x order by x)
      ^
==

[language_features=TEMPLATE_FUNCTIONS,V_1_3_WITH_GROUP_ROWS]
SELECT WrappedGroupRows(e) FROM UNNEST([1, 2, 3]) AS e

--
ERROR: Invalid function WrappedGroupRows [at 1:8]
SELECT WrappedGroupRows(e) FROM UNNEST([1, 2, 3]) AS e
       ^
Analysis of function Templated_SQL_Function:WrappedGroupRows failed [at 2:13]
            SUM(e) WITH GROUP_ROWS(SELECT e
            ^
WITH GROUP_ROWS is not supported in templated SQL aggregate function call [at 2:13]
            SUM(e) WITH GROUP_ROWS(SELECT e
            ^
