# Tests for resolving table-valued functions with scalar arguments only.
#
################################################################################
#
# Positive test cases
#
################################################################################
#
# Empty argument list.
[default language_features=TABLE_VALUED_FUNCTIONS,FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES]
select 1 from tvf_no_args()
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 := Literal(type=INT64, value=1)
    +-input_scan=
      +-TVFScan(tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
==

# Empty argument list.
select column_bytes from tvf_no_args()
--
QueryStmt
+-output_column_list=
| +-tvf_no_args.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[tvf_no_args.column_bytes#2]
    +-input_scan=
      +-TVFScan(column_list=[tvf_no_args.column_bytes#2], tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[1])
==

# Empty argument list.
select * from tvf_no_args()
--
QueryStmt
+-output_column_list=
| +-tvf_no_args.column_bool#1 AS column_bool [BOOL]
| +-tvf_no_args.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_no_args.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan(column_list=tvf_no_args.[column_bool#1, column_bytes#2], tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
==

# Literals in the argument list.
select * from tvf_exactly_3_int64_args(1, 2, 3)
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_3_int64_args.column_bool#1 AS column_bool [BOOL]
| +-tvf_exactly_3_int64_args.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_3_int64_args.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_3_int64_args.[column_bool#1, column_bytes#2]
        +-tvf=tvf_exactly_3_int64_args((INT64, INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal INT64, literal INT64, literal INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=1)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=2)
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=3)
        +-column_index_list=[0, 1]
==

# A subquery in the argument list.
select * from tvf_exactly_1_int64_arg((select Key from KeyValue group by Key))
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_1_int64_arg.column_bool#4 AS column_bool [BOOL]
| +-tvf_exactly_1_int64_arg.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_1_int64_arg.[column_bool#4, column_bytes#5]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_1_int64_arg.[column_bool#4, column_bytes#5]
        +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-SubqueryExpr
        |       +-type=INT64
        |       +-subquery_type=SCALAR
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$groupby.Key#3]
        |           +-input_scan=
        |             +-AggregateScan
        |               +-column_list=[$groupby.Key#3]
        |               +-input_scan=
        |               | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |               +-group_by_list=
        |                 +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-column_index_list=[0, 1]
==

# A subquery and literals in the argument list.
select * from tvf_exactly_4_int64_args((select Key from KeyValue group by Key), 1, 2, 3)
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_4_int64_args.column_bool#4 AS column_bool [BOOL]
| +-tvf_exactly_4_int64_args.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_4_int64_args.[column_bool#4, column_bytes#5]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_4_int64_args.[column_bool#4, column_bytes#5]
        +-tvf=tvf_exactly_4_int64_args((INT64, INT64, INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(INT64, literal INT64, literal INT64, literal INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-SubqueryExpr
        | |     +-type=INT64
        | |     +-subquery_type=SCALAR
        | |     +-subquery=
        | |       +-ProjectScan
        | |         +-column_list=[$groupby.Key#3]
        | |         +-input_scan=
        | |           +-AggregateScan
        | |             +-column_list=[$groupby.Key#3]
        | |             +-input_scan=
        | |             | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        | |             +-group_by_list=
        | |               +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=1)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=2)
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=3)
        +-column_index_list=[0, 1]
==

# Complex expressions in the argument list.
select * from tvf_exactly_3_int64_args(1 + 2, 3 + 4, 5 + 6)
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_3_int64_args.column_bool#1 AS column_bool [BOOL]
| +-tvf_exactly_3_int64_args.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_3_int64_args.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_3_int64_args.[column_bool#1, column_bytes#2]
        +-tvf=tvf_exactly_3_int64_args((INT64, INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(INT64, INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        | |     +-Literal(type=INT64, value=1)
        | |     +-Literal(type=INT64, value=2)
        | +-FunctionArgument
        | | +-expr=
        | |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        | |     +-Literal(type=INT64, value=3)
        | |     +-Literal(type=INT64, value=4)
        | +-FunctionArgument
        |   +-expr=
        |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       +-Literal(type=INT64, value=5)
        |       +-Literal(type=INT64, value=6)
        +-column_index_list=[0, 1]
==

# A subquery and complex expressions in the argument list.
select * from tvf_exactly_3_int64_args((select Key from KeyValue group by Key), 1 + 2, 3 + 4)
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_3_int64_args.column_bool#4 AS column_bool [BOOL]
| +-tvf_exactly_3_int64_args.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_3_int64_args.[column_bool#4, column_bytes#5]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_3_int64_args.[column_bool#4, column_bytes#5]
        +-tvf=tvf_exactly_3_int64_args((INT64, INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(INT64, INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-SubqueryExpr
        | |     +-type=INT64
        | |     +-subquery_type=SCALAR
        | |     +-subquery=
        | |       +-ProjectScan
        | |         +-column_list=[$groupby.Key#3]
        | |         +-input_scan=
        | |           +-AggregateScan
        | |             +-column_list=[$groupby.Key#3]
        | |             +-input_scan=
        | |             | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        | |             +-group_by_list=
        | |               +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        | +-FunctionArgument
        | | +-expr=
        | |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        | |     +-Literal(type=INT64, value=1)
        | |     +-Literal(type=INT64, value=2)
        | +-FunctionArgument
        |   +-expr=
        |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       +-Literal(type=INT64, value=3)
        |       +-Literal(type=INT64, value=4)
        +-column_index_list=[0, 1]
==

# A subquery and complex expressions in the argument list.
select * from tvf_exactly_3_int64_args((select 1), 1 + 2, 3 + 4)
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_3_int64_args.column_bool#2 AS column_bool [BOOL]
| +-tvf_exactly_3_int64_args.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_3_int64_args.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_3_int64_args.[column_bool#2, column_bytes#3]
        +-tvf=tvf_exactly_3_int64_args((INT64, INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(INT64, INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-SubqueryExpr
        | |     +-type=INT64
        | |     +-subquery_type=SCALAR
        | |     +-subquery=
        | |       +-ProjectScan
        | |         +-column_list=[$expr_subquery.$col1#1]
        | |         +-expr_list=
        | |         | +-$col1#1 := Literal(type=INT64, value=1)
        | |         +-input_scan=
        | |           +-SingleRowScan
        | +-FunctionArgument
        | | +-expr=
        | |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        | |     +-Literal(type=INT64, value=1)
        | |     +-Literal(type=INT64, value=2)
        | +-FunctionArgument
        |   +-expr=
        |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       +-Literal(type=INT64, value=3)
        |       +-Literal(type=INT64, value=4)
        +-column_index_list=[0, 1]
==

# Two subqueries in the argument list.
select * from tvf_exactly_2_int64_args((select Key from KeyValue group by Key), (select 1))
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_2_int64_args.column_bool#5 AS column_bool [BOOL]
| +-tvf_exactly_2_int64_args.column_bytes#6 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_2_int64_args.[column_bool#5, column_bytes#6]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_2_int64_args.[column_bool#5, column_bytes#6]
        +-tvf=tvf_exactly_2_int64_args((INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-SubqueryExpr
        | |     +-type=INT64
        | |     +-subquery_type=SCALAR
        | |     +-subquery=
        | |       +-ProjectScan
        | |         +-column_list=[$groupby.Key#3]
        | |         +-input_scan=
        | |           +-AggregateScan
        | |             +-column_list=[$groupby.Key#3]
        | |             +-input_scan=
        | |             | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        | |             +-group_by_list=
        | |               +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        | +-FunctionArgument
        |   +-expr=
        |     +-SubqueryExpr
        |       +-type=INT64
        |       +-subquery_type=SCALAR
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$expr_subquery.$col1#4]
        |           +-expr_list=
        |           | +-$col1#4 := Literal(type=INT64, value=1)
        |           +-input_scan=
        |             +-SingleRowScan
        +-column_index_list=[0, 1]
==

# A subquery and SQL function calls in the argument list.
select * from tvf_exactly_3_int64_args((select 1), abs(1 + 2), abs(1 - 2))
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_3_int64_args.column_bool#2 AS column_bool [BOOL]
| +-tvf_exactly_3_int64_args.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_3_int64_args.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_3_int64_args.[column_bool#2, column_bytes#3]
        +-tvf=tvf_exactly_3_int64_args((INT64, INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(INT64, INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-SubqueryExpr
        | |     +-type=INT64
        | |     +-subquery_type=SCALAR
        | |     +-subquery=
        | |       +-ProjectScan
        | |         +-column_list=[$expr_subquery.$col1#1]
        | |         +-expr_list=
        | |         | +-$col1#1 := Literal(type=INT64, value=1)
        | |         +-input_scan=
        | |           +-SingleRowScan
        | +-FunctionArgument
        | | +-expr=
        | |   +-FunctionCall(ZetaSQL:abs(INT64) -> INT64)
        | |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        | |       +-Literal(type=INT64, value=1)
        | |       +-Literal(type=INT64, value=2)
        | +-FunctionArgument
        |   +-expr=
        |     +-FunctionCall(ZetaSQL:abs(INT64) -> INT64)
        |       +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
        |         +-Literal(type=INT64, value=1)
        |         +-Literal(type=INT64, value=2)
        +-column_index_list=[0, 1]
==

# Multiple levels of parentheses in various TVF arguments.
select * from tvf_exactly_1_int64_arg((select 1))
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_1_int64_arg.column_bool#2 AS column_bool [BOOL]
| +-tvf_exactly_1_int64_arg.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_1_int64_arg.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_1_int64_arg.[column_bool#2, column_bytes#3]
        +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-SubqueryExpr
        |       +-type=INT64
        |       +-subquery_type=SCALAR
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$expr_subquery.$col1#1]
        |           +-expr_list=
        |           | +-$col1#1 := Literal(type=INT64, value=1)
        |           +-input_scan=
        |             +-SingleRowScan
        +-column_index_list=[0, 1]
==

# The parser interprets the ((1)) argument as a parenthesized literal value.
select * from tvf_exactly_1_int64_arg(((1)))
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_1_int64_arg.column_bool#1 AS column_bool [BOOL]
| +-tvf_exactly_1_int64_arg.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_1_int64_arg.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_1_int64_arg.[column_bool#1, column_bytes#2]
        +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=1)
        +-column_index_list=[0, 1]
==

# The parser correctly handles the ((select 1) + 1) argument.
select * from tvf_exactly_1_int64_arg((select 1) + 1)
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_1_int64_arg.column_bool#2 AS column_bool [BOOL]
| +-tvf_exactly_1_int64_arg.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_1_int64_arg.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_1_int64_arg.[column_bool#2, column_bytes#3]
        +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       +-SubqueryExpr
        |       | +-type=INT64
        |       | +-subquery_type=SCALAR
        |       | +-subquery=
        |       |   +-ProjectScan
        |       |     +-column_list=[$expr_subquery.$col1#1]
        |       |     +-expr_list=
        |       |     | +-$col1#1 := Literal(type=INT64, value=1)
        |       |     +-input_scan=
        |       |       +-SingleRowScan
        |       +-Literal(type=INT64, value=1)
        +-column_index_list=[0, 1]
==

# The parser correctly interprets the argument as a scalar value.
select * from tvf_exactly_1_int64_arg(1 + (select 1))
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_1_int64_arg.column_bool#2 AS column_bool [BOOL]
| +-tvf_exactly_1_int64_arg.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_1_int64_arg.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_1_int64_arg.[column_bool#2, column_bytes#3]
        +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       +-Literal(type=INT64, value=1)
        |       +-SubqueryExpr
        |         +-type=INT64
        |         +-subquery_type=SCALAR
        |         +-subquery=
        |           +-ProjectScan
        |             +-column_list=[$expr_subquery.$col1#1]
        |             +-expr_list=
        |             | +-$col1#1 := Literal(type=INT64, value=1)
        |             +-input_scan=
        |               +-SingleRowScan
        +-column_index_list=[0, 1]
==

# Multiple levels of parentheses in various TVF arguments.
select * from tvf_exactly_1_int64_arg(((select 1 from tvf_no_args())))
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_1_int64_arg.column_bool#4 AS column_bool [BOOL]
| +-tvf_exactly_1_int64_arg.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_1_int64_arg.[column_bool#4, column_bytes#5]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_1_int64_arg.[column_bool#4, column_bytes#5]
        +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-SubqueryExpr
        |       +-type=INT64
        |       +-subquery_type=SCALAR
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$expr_subquery.$col1#3]
        |           +-expr_list=
        |           | +-$col1#3 := Literal(type=INT64, value=1)
        |           +-input_scan=
        |             +-TVFScan(tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-column_index_list=[0, 1]
==


# Select all columns from a TVF that returns all POD types.
select * from tvf_no_args_return_all_pod_types()
--
QueryStmt
+-output_column_list=
| +-tvf_no_args_return_all_pod_types.column_bool#1 AS column_bool [BOOL]
| +-tvf_no_args_return_all_pod_types.column_bytes#2 AS column_bytes [BYTES]
| +-tvf_no_args_return_all_pod_types.column_date#3 AS column_date [DATE]
| +-tvf_no_args_return_all_pod_types.column_double#4 AS column_double [DOUBLE]
| +-tvf_no_args_return_all_pod_types.column_float#5 AS column_float [FLOAT]
| +-tvf_no_args_return_all_pod_types.column_int32#6 AS column_int32 [INT32]
| +-tvf_no_args_return_all_pod_types.column_int64#7 AS column_int64 [INT64]
| +-tvf_no_args_return_all_pod_types.column_string#8 AS column_string [STRING]
| +-tvf_no_args_return_all_pod_types.column_time#9 AS column_time [TIME]
| +-tvf_no_args_return_all_pod_types.column_uint32#10 AS column_uint32 [UINT32]
| +-tvf_no_args_return_all_pod_types.column_uint64#11 AS column_uint64 [UINT64]
+-query=
  +-ProjectScan
    +-column_list=tvf_no_args_return_all_pod_types.[column_bool#1, column_bytes#2, column_date#3, column_double#4, column_float#5, column_int32#6, column_int64#7, column_string#8, column_time#9, column_uint32#10, column_uint64#11]
    +-input_scan=
      +-TVFScan(column_list=tvf_no_args_return_all_pod_types.[column_bool#1, column_bytes#2, column_date#3, column_double#4, column_float#5, column_int32#6, column_int64#7, column_string#8, column_time#9, column_uint32#10, column_uint64#11], tvf=tvf_no_args_return_all_pod_types(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
==

# Select some columns from a TVF that returns all POD types.
select column_date, column_double, column_int32, column_time, column_uint64
from tvf_no_args_return_all_pod_types()
--
QueryStmt
+-output_column_list=
| +-tvf_no_args_return_all_pod_types.column_date#3 AS column_date [DATE]
| +-tvf_no_args_return_all_pod_types.column_double#4 AS column_double [DOUBLE]
| +-tvf_no_args_return_all_pod_types.column_int32#6 AS column_int32 [INT32]
| +-tvf_no_args_return_all_pod_types.column_time#9 AS column_time [TIME]
| +-tvf_no_args_return_all_pod_types.column_uint64#11 AS column_uint64 [UINT64]
+-query=
  +-ProjectScan
    +-column_list=tvf_no_args_return_all_pod_types.[column_date#3, column_double#4, column_int32#6, column_time#9, column_uint64#11]
    +-input_scan=
      +-TVFScan(column_list=tvf_no_args_return_all_pod_types.[column_date#3, column_double#4, column_int32#6, column_time#9, column_uint64#11], tvf=tvf_no_args_return_all_pod_types(() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, column_date DATE, column_double DOUBLE, column_float FLOAT, column_int32 INT32, column_int64 INT64, column_string STRING, column_time TIME, column_uint32 UINT32, column_uint64 UINT64>, column_index_list=[2, 3, 5, 8, 10])
==

[language_features=TABLE_VALUED_FUNCTIONS,FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES,INTERVAL_TYPE]
# Test several TVFs, each of which accepts one argument of some POD type.
select column_bool from tvf_exactly_1_bool_arg(true) union all
select column_bool from tvf_exactly_1_bytes_arg(cast("" as bytes)) union all
select column_bool from tvf_exactly_1_double_arg(cast(42 as double)) union all
select column_bool from tvf_exactly_1_float_arg(cast(42 as float)) union all
select column_bool from tvf_exactly_1_int32_arg(cast(42 as int32)) union all
select column_bool from tvf_exactly_1_int64_arg(cast(42 as int64)) union all
select column_bool from tvf_exactly_1_string_arg("abc") union all
select column_bool from tvf_exactly_1_uint32_arg(cast(42 as uint32)) union all
select column_bool from tvf_exactly_1_uint64_arg(cast(42 as uint64)) union all
select column_bool from tvf_exactly_1_interval_arg(INTERVAL 5 MINUTE)
--
QueryStmt
+-output_column_list=
| +-$union_all.column_bool#21 AS column_bool [BOOL]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.column_bool#21]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_bool_arg.column_bool#1]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_bool_arg.column_bool#1]
      | |       +-tvf=tvf_exactly_1_bool_arg((BOOL) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal BOOL) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=BOOL, value=true)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_bool_arg.column_bool#1]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_bytes_arg.column_bool#3]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_bytes_arg.column_bool#3]
      | |       +-tvf=tvf_exactly_1_bytes_arg((BYTES) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal BYTES) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=BYTES, value=b"", has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_bytes_arg.column_bool#3]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_double_arg.column_bool#5]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_double_arg.column_bool#5]
      | |       +-tvf=tvf_exactly_1_double_arg((DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=DOUBLE, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_double_arg.column_bool#5]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_float_arg.column_bool#7]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_float_arg.column_bool#7]
      | |       +-tvf=tvf_exactly_1_float_arg((FLOAT) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal FLOAT) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=FLOAT, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_float_arg.column_bool#7]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_int32_arg.column_bool#9]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_int32_arg.column_bool#9]
      | |       +-tvf=tvf_exactly_1_int32_arg((INT32) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal INT32) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=INT32, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_int32_arg.column_bool#9]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_int64_arg.column_bool#11]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_int64_arg.column_bool#11]
      | |       +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=INT64, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_int64_arg.column_bool#11]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_string_arg.column_bool#13]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_string_arg.column_bool#13]
      | |       +-tvf=tvf_exactly_1_string_arg((STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=STRING, value="abc")
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_string_arg.column_bool#13]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_uint32_arg.column_bool#15]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_uint32_arg.column_bool#15]
      | |       +-tvf=tvf_exactly_1_uint32_arg((UINT32) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal UINT32) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=UINT32, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_uint32_arg.column_bool#15]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_uint64_arg.column_bool#17]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_uint64_arg.column_bool#17]
      | |       +-tvf=tvf_exactly_1_uint64_arg((UINT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal UINT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=UINT64, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_uint64_arg.column_bool#17]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[tvf_exactly_1_interval_arg.column_bool#19]
        |   +-input_scan=
        |     +-TVFScan
        |       +-column_list=[tvf_exactly_1_interval_arg.column_bool#19]
        |       +-tvf=tvf_exactly_1_interval_arg((INTERVAL) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |       +-signature=(INTERVAL) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |       +-argument_list=
        |       | +-FunctionArgument
        |       |   +-expr=
        |       |     +-FunctionCall(ZetaSQL:$interval(INT64, ENUM<zetasql.functions.DateTimestampPart>) -> INTERVAL)
        |       |       +-Literal(type=INT64, value=5)
        |       |       +-Literal(type=ENUM<zetasql.functions.DateTimestampPart>, value=MINUTE)
        |       +-column_index_list=[0]
        +-output_column_list=[tvf_exactly_1_interval_arg.column_bool#19]
==

# Test coercion in TVF calls when scalar argument types don't exactly match the
# expected argument types. Literal values are replaced with those of the correct
# types.
select column_bool from tvf_exactly_1_double_arg(42) union all
select column_bool from tvf_exactly_1_float_arg(42) union all
select column_bool from tvf_exactly_1_int32_arg(42) union all
select column_bool from tvf_exactly_1_int64_arg(42) union all
select column_bool from tvf_exactly_1_uint32_arg(42) union all
select column_bool from tvf_exactly_1_uint64_arg(42) union all
select column_bool from tvf_exactly_1_uint64_arg(null)
--
QueryStmt
+-output_column_list=
| +-$union_all.column_bool#15 AS column_bool [BOOL]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.column_bool#15]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_double_arg.column_bool#1]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_double_arg.column_bool#1]
      | |       +-tvf=tvf_exactly_1_double_arg((DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=DOUBLE, value=42)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_double_arg.column_bool#1]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_float_arg.column_bool#3]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_float_arg.column_bool#3]
      | |       +-tvf=tvf_exactly_1_float_arg((FLOAT) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal FLOAT) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=FLOAT, value=42)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_float_arg.column_bool#3]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_int32_arg.column_bool#5]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_int32_arg.column_bool#5]
      | |       +-tvf=tvf_exactly_1_int32_arg((INT32) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal INT32) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=INT32, value=42)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_int32_arg.column_bool#5]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_int64_arg.column_bool#7]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_int64_arg.column_bool#7]
      | |       +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=INT64, value=42)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_int64_arg.column_bool#7]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_uint32_arg.column_bool#9]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_uint32_arg.column_bool#9]
      | |       +-tvf=tvf_exactly_1_uint32_arg((UINT32) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal UINT32) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=UINT32, value=42)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_uint32_arg.column_bool#9]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_uint64_arg.column_bool#11]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_uint64_arg.column_bool#11]
      | |       +-tvf=tvf_exactly_1_uint64_arg((UINT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal UINT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=UINT64, value=42)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_uint64_arg.column_bool#11]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[tvf_exactly_1_uint64_arg.column_bool#13]
        |   +-input_scan=
        |     +-TVFScan
        |       +-column_list=[tvf_exactly_1_uint64_arg.column_bool#13]
        |       +-tvf=tvf_exactly_1_uint64_arg((UINT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |       +-signature=(null UINT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |       +-argument_list=
        |       | +-FunctionArgument
        |       |   +-expr=
        |       |     +-Literal(type=UINT64, value=NULL)
        |       +-column_index_list=[0]
        +-output_column_list=[tvf_exactly_1_uint64_arg.column_bool#13]
==

# Test coercion in TVF calls when scalar argument types don't exactly match the
# expected argument types. Casted literal values are replaced with uncasted
# literal values of the correct types.
select column_bool from tvf_exactly_1_double_arg(cast(42 as int32)) union all
select column_bool from tvf_exactly_1_double_arg(cast(42 as int64)) union all
select column_bool from tvf_exactly_1_double_arg(cast(42 as uint32)) union all
select column_bool from tvf_exactly_1_double_arg(cast(42 as uint64)) union all
select column_bool from tvf_exactly_1_double_arg(cast(42 as float)) union all
select column_bool from tvf_exactly_1_int32_arg(cast(42 as int32)) union all
select column_bool from tvf_exactly_1_int64_arg(cast(42 as int32)) union all
select column_bool from tvf_exactly_1_uint64_arg(cast(42 as uint32))
--
QueryStmt
+-output_column_list=
| +-$union_all.column_bool#17 AS column_bool [BOOL]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.column_bool#17]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_double_arg.column_bool#1]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_double_arg.column_bool#1]
      | |       +-tvf=tvf_exactly_1_double_arg((DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=DOUBLE, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_double_arg.column_bool#1]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_double_arg.column_bool#3]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_double_arg.column_bool#3]
      | |       +-tvf=tvf_exactly_1_double_arg((DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=DOUBLE, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_double_arg.column_bool#3]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_double_arg.column_bool#5]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_double_arg.column_bool#5]
      | |       +-tvf=tvf_exactly_1_double_arg((DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=DOUBLE, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_double_arg.column_bool#5]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_double_arg.column_bool#7]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_double_arg.column_bool#7]
      | |       +-tvf=tvf_exactly_1_double_arg((DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=DOUBLE, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_double_arg.column_bool#7]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_double_arg.column_bool#9]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_double_arg.column_bool#9]
      | |       +-tvf=tvf_exactly_1_double_arg((DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=DOUBLE, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_double_arg.column_bool#9]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_int32_arg.column_bool#11]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_int32_arg.column_bool#11]
      | |       +-tvf=tvf_exactly_1_int32_arg((INT32) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal INT32) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=INT32, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_int32_arg.column_bool#11]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_int64_arg.column_bool#13]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_int64_arg.column_bool#13]
      | |       +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(literal INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Literal(type=INT64, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_int64_arg.column_bool#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[tvf_exactly_1_uint64_arg.column_bool#15]
        |   +-input_scan=
        |     +-TVFScan
        |       +-column_list=[tvf_exactly_1_uint64_arg.column_bool#15]
        |       +-tvf=tvf_exactly_1_uint64_arg((UINT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |       +-signature=(literal UINT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |       +-argument_list=
        |       | +-FunctionArgument
        |       |   +-expr=
        |       |     +-Literal(type=UINT64, value=42, has_explicit_type=TRUE)
        |       +-column_index_list=[0]
        +-output_column_list=[tvf_exactly_1_uint64_arg.column_bool#15]
==

# Test coercion in TVF calls when scalar argument types don't exactly match the
# expected argument types. Typed 'coalesce' function calls are wrapped with
# widening casts.
select column_bool from tvf_exactly_1_double_arg(coalesce(42)) union all
select column_bool from tvf_exactly_1_int64_arg(
                            coalesce(cast(42 as int32))) union all
select column_bool from tvf_exactly_1_uint64_arg(
                            coalesce(cast(42 as uint32))) union all
select column_bool from tvf_exactly_1_uint64_arg(coalesce(cast(null as uint32)))
--
QueryStmt
+-output_column_list=
| +-$union_all.column_bool#9 AS column_bool [BOOL]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.column_bool#9]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_double_arg.column_bool#1]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_double_arg.column_bool#1]
      | |       +-tvf=tvf_exactly_1_double_arg((DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(DOUBLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Cast(INT64 -> DOUBLE)
      | |       |       +-FunctionCall(ZetaSQL:coalesce(repeated(1) INT64) -> INT64)
      | |       |         +-Literal(type=INT64, value=42)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_double_arg.column_bool#1]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_int64_arg.column_bool#3]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_int64_arg.column_bool#3]
      | |       +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Cast(INT32 -> INT64)
      | |       |       +-FunctionCall(ZetaSQL:coalesce(repeated(1) INT32) -> INT32)
      | |       |         +-Literal(type=INT32, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_int64_arg.column_bool#3]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[tvf_exactly_1_uint64_arg.column_bool#5]
      | |   +-input_scan=
      | |     +-TVFScan
      | |       +-column_list=[tvf_exactly_1_uint64_arg.column_bool#5]
      | |       +-tvf=tvf_exactly_1_uint64_arg((UINT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | |       +-signature=(UINT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
      | |       +-argument_list=
      | |       | +-FunctionArgument
      | |       |   +-expr=
      | |       |     +-Cast(UINT32 -> UINT64)
      | |       |       +-FunctionCall(ZetaSQL:coalesce(repeated(1) UINT32) -> UINT32)
      | |       |         +-Literal(type=UINT32, value=42, has_explicit_type=TRUE)
      | |       +-column_index_list=[0]
      | +-output_column_list=[tvf_exactly_1_uint64_arg.column_bool#5]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[tvf_exactly_1_uint64_arg.column_bool#7]
        |   +-input_scan=
        |     +-TVFScan
        |       +-column_list=[tvf_exactly_1_uint64_arg.column_bool#7]
        |       +-tvf=tvf_exactly_1_uint64_arg((UINT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |       +-signature=(UINT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |       +-argument_list=
        |       | +-FunctionArgument
        |       |   +-expr=
        |       |     +-Cast(UINT32 -> UINT64)
        |       |       +-FunctionCall(ZetaSQL:coalesce(repeated(1) UINT32) -> UINT32)
        |       |         +-Literal(type=UINT32, value=NULL, has_explicit_type=TRUE)
        |       +-column_index_list=[0]
        +-output_column_list=[tvf_exactly_1_uint64_arg.column_bool#7]
==

# The TVF accepts a templated argument.
select column_bool from tvf_exactly_one_arg_type_any_1(42)
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_one_arg_type_any_1.column_bool#1 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_exactly_one_arg_type_any_1.column_bool#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_exactly_one_arg_type_any_1.column_bool#1]
        +-tvf=tvf_exactly_one_arg_type_any_1((<T1>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=42)
        +-column_index_list=[0]
==

# The TVF accepts a templated argument.
select column_bool from tvf_exactly_one_arg_type_any_2(42)
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_one_arg_type_any_2.column_bool#1 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_exactly_one_arg_type_any_2.column_bool#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_exactly_one_arg_type_any_2.column_bool#1]
        +-tvf=tvf_exactly_one_arg_type_any_2((<T2>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=42)
        +-column_index_list=[0]
==

# The TVF accepts a templated argument.
select column_bool from tvf_exactly_one_arg_array_type_any_1([1, 2, 3])
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_one_arg_array_type_any_1.column_bool#1 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_exactly_one_arg_array_type_any_1.column_bool#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_exactly_one_arg_array_type_any_1.column_bool#1]
        +-tvf=tvf_exactly_one_arg_array_type_any_1((<array<T1>>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(ARRAY<INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
        +-column_index_list=[0]
==

# The TVF accepts a templated argument.
select column_bool from tvf_exactly_one_arg_array_type_any_2([1, 2, 3])
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_one_arg_array_type_any_2.column_bool#1 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_exactly_one_arg_array_type_any_2.column_bool#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_exactly_one_arg_array_type_any_2.column_bool#1]
        +-tvf=tvf_exactly_one_arg_array_type_any_2((<array<T2>>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(ARRAY<INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
        +-column_index_list=[0]
==

# The TVF accepts a templated argument.
select column_bool from tvf_exactly_one_arg_type_arbitrary(42)
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_one_arg_type_arbitrary.column_bool#1 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_exactly_one_arg_type_arbitrary.column_bool#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_exactly_one_arg_type_arbitrary.column_bool#1]
        +-tvf=tvf_exactly_one_arg_type_arbitrary((ANY TYPE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=42)
        +-column_index_list=[0]
==

# The TVF accepts a templated argument.
select column_bool from
tvf_exactly_one_arg_proto_any(new zetasql_test__.TestExtraPB())
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_one_arg_proto_any.column_bool#1 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_exactly_one_arg_proto_any.column_bool#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_exactly_one_arg_proto_any.column_bool#1]
        +-tvf=tvf_exactly_one_arg_proto_any((<proto>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(PROTO<zetasql_test__.TestExtraPB>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-MakeProto(type=PROTO<zetasql_test__.TestExtraPB>)
        +-column_index_list=[0]
==

# The TVF accepts a templated argument.
select column_bool from
tvf_exactly_one_arg_struct_any((select (1,2,3)))
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_one_arg_struct_any.column_bool#2 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_exactly_one_arg_struct_any.column_bool#2]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_exactly_one_arg_struct_any.column_bool#2]
        +-tvf=tvf_exactly_one_arg_struct_any((<struct>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(STRUCT<INT64, INT64, INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-SubqueryExpr
        |       +-type=STRUCT<INT64, INT64, INT64>
        |       +-subquery_type=SCALAR
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$expr_subquery.$col1#1]
        |           +-expr_list=
        |           | +-$col1#1 := Literal(type=STRUCT<INT64, INT64, INT64>, value={1, 2, 3})
        |           +-input_scan=
        |             +-SingleRowScan
        +-column_index_list=[0]
==

# The TVF accepts a templated argument.
select column_bool from
tvf_exactly_one_arg_enum_any(CAST(1 AS `zetasql_test__.TestEnum`))
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_one_arg_enum_any.column_bool#1 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_exactly_one_arg_enum_any.column_bool#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_exactly_one_arg_enum_any.column_bool#1]
        +-tvf=tvf_exactly_one_arg_enum_any((<enum>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(ENUM<zetasql_test__.TestEnum>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
        +-column_index_list=[0]
==

# The TVF accepts a repeating final argument.
select column_bool from
tvf_repeating_int64_args(1, 2, 3, 4, 5)
--
QueryStmt
+-output_column_list=
| +-tvf_repeating_int64_args.column_bool#1 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_repeating_int64_args.column_bool#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_repeating_int64_args.column_bool#1]
        +-tvf=tvf_repeating_int64_args((repeated INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal INT64, literal INT64, literal INT64, literal INT64, literal INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=1)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=2)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=3)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=4)
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=5)
        +-column_index_list=[0]
==

# The TVF accepts a templated repeating final argument.
select column_bool from
tvf_repeating_any_one_type_args(1, 2, 3, 4, 5)
--
QueryStmt
+-output_column_list=
| +-tvf_repeating_any_one_type_args.column_bool#1 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_repeating_any_one_type_args.column_bool#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_repeating_any_one_type_args.column_bool#1]
        +-tvf=tvf_repeating_any_one_type_args((repeated <T1>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal INT64, literal INT64, literal INT64, literal INT64, literal INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=1)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=2)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=3)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=4)
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=5)
        +-column_index_list=[0]
==

# The TVF accepts a templated repeating final argument.
select column_bool from
tvf_repeating_arbitrary_type_args(1, "a", 2, "b")
--
QueryStmt
+-output_column_list=
| +-tvf_repeating_arbitrary_type_args.column_bool#1 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_repeating_arbitrary_type_args.column_bool#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_repeating_arbitrary_type_args.column_bool#1]
        +-tvf=tvf_repeating_arbitrary_type_args((repeated ANY TYPE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(literal INT64, literal STRING, literal INT64, literal STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=1)
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value="a")
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=2)
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="b")
        +-column_index_list=[0]
==

# A subquery and nested TVF calls in the argument list.
select * from tvf_exactly_5_int64_args(
    (select 1),
    (select 2),
    (select 1 from tvf_no_args()),
    (select 1 from tvf_no_args() limit 1),
    (select 1 from tvf_no_args()))
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_5_int64_args.column_bool#12 AS column_bool [BOOL]
| +-tvf_exactly_5_int64_args.column_bytes#13 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_exactly_5_int64_args.[column_bool#12, column_bytes#13]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_exactly_5_int64_args.[column_bool#12, column_bytes#13]
        +-tvf=tvf_exactly_5_int64_args((INT64, INT64, INT64, INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(INT64, INT64, INT64, INT64, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-SubqueryExpr
        | |     +-type=INT64
        | |     +-subquery_type=SCALAR
        | |     +-subquery=
        | |       +-ProjectScan
        | |         +-column_list=[$expr_subquery.$col1#1]
        | |         +-expr_list=
        | |         | +-$col1#1 := Literal(type=INT64, value=1)
        | |         +-input_scan=
        | |           +-SingleRowScan
        | +-FunctionArgument
        | | +-expr=
        | |   +-SubqueryExpr
        | |     +-type=INT64
        | |     +-subquery_type=SCALAR
        | |     +-subquery=
        | |       +-ProjectScan
        | |         +-column_list=[$expr_subquery.$col1#2]
        | |         +-expr_list=
        | |         | +-$col1#2 := Literal(type=INT64, value=2)
        | |         +-input_scan=
        | |           +-SingleRowScan
        | +-FunctionArgument
        | | +-expr=
        | |   +-SubqueryExpr
        | |     +-type=INT64
        | |     +-subquery_type=SCALAR
        | |     +-subquery=
        | |       +-ProjectScan
        | |         +-column_list=[$expr_subquery.$col1#5]
        | |         +-expr_list=
        | |         | +-$col1#5 := Literal(type=INT64, value=1)
        | |         +-input_scan=
        | |           +-TVFScan(tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
        | +-FunctionArgument
        | | +-expr=
        | |   +-SubqueryExpr
        | |     +-type=INT64
        | |     +-subquery_type=SCALAR
        | |     +-subquery=
        | |       +-LimitOffsetScan
        | |         +-column_list=[$expr_subquery.$col1#8]
        | |         +-input_scan=
        | |         | +-ProjectScan
        | |         |   +-column_list=[$expr_subquery.$col1#8]
        | |         |   +-expr_list=
        | |         |   | +-$col1#8 := Literal(type=INT64, value=1)
        | |         |   +-input_scan=
        | |         |     +-TVFScan(tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
        | |         +-limit=
        | |           +-Literal(type=INT64, value=1)
        | +-FunctionArgument
        |   +-expr=
        |     +-SubqueryExpr
        |       +-type=INT64
        |       +-subquery_type=SCALAR
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$expr_subquery.$col1#11]
        |           +-expr_list=
        |           | +-$col1#11 := Literal(type=INT64, value=1)
        |           +-input_scan=
        |             +-TVFScan(tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-column_index_list=[0, 1]
==

# A TVF has a correlated reference to the enclosing query in the SELECT list.
select (select column_bool from tvf_exactly_1_int64_arg(Key)) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[tvf_exactly_1_int64_arg.column_bool#3]
    |         +-input_scan=
    |           +-TVFScan
    |             +-column_list=[tvf_exactly_1_int64_arg.column_bool#3]
    |             +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    |             +-signature=(INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
    |             +-argument_list=
    |             | +-FunctionArgument
    |             |   +-expr=
    |             |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |             +-column_index_list=[0]
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
==

# A TVF has a correlated reference to the enclosing query in the WHERE clause.
select * from KeyValue kv
where true in (select column_bool from tvf_exactly_1_int64_arg(kv.key))
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
      +-FilterScan
        +-column_list=KeyValue.[Key#1, Value#2]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        +-filter_expr=
          +-SubqueryExpr
            +-type=BOOL
            +-subquery_type=IN
            +-parameter_list=
            | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-in_expr=
            | +-Literal(type=BOOL, value=true)
            +-subquery=
              +-ProjectScan
                +-column_list=[tvf_exactly_1_int64_arg.column_bool#3]
                +-input_scan=
                  +-TVFScan
                    +-column_list=[tvf_exactly_1_int64_arg.column_bool#3]
                    +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
                    +-signature=(INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
                    +-argument_list=
                    | +-FunctionArgument
                    |   +-expr=
                    |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
                    +-column_index_list=[0]
==

# A TVF has a correlated reference to the enclosing query in the ORDER BY
# clause.
select * from KeyValue kv
order by (select if(column_bool, kv.key, 42) from
          tvf_exactly_1_int64_arg(kv.key))
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-OrderByScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#6]
    |   +-expr_list=
    |   | +-$orderbycol1#6 :=
    |   |   +-SubqueryExpr
    |   |     +-type=INT64
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$expr_subquery.$col1#5]
    |   |         +-expr_list=
    |   |         | +-$col1#5 :=
    |   |         |   +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
    |   |         |     +-ColumnRef(type=BOOL, column=tvf_exactly_1_int64_arg.column_bool#3)
    |   |         |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |   |         |     +-Literal(type=INT64, value=42)
    |   |         +-input_scan=
    |   |           +-TVFScan
    |   |             +-column_list=[tvf_exactly_1_int64_arg.column_bool#3]
    |   |             +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    |   |             +-signature=(INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
    |   |             +-argument_list=
    |   |             | +-FunctionArgument
    |   |             |   +-expr=
    |   |             |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |   |             +-column_index_list=[0]
    |   +-input_scan=
    |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#6)
==

# A TVF has a correlated reference to the left hand table via the lateral
# behavior of UNNEST
select *
from KeyValue kv,
     unnest(array(select column_bool from tvf_exactly_1_int64_arg(kv.key)));
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-$array.$unnest1#5 AS `$unnest1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $array.$unnest1#5]
    +-input_scan=
      +-ArrayScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $array.$unnest1#5]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        +-array_expr=
        | +-SubqueryExpr
        |   +-type=ARRAY<BOOL>
        |   +-subquery_type=ARRAY
        |   +-parameter_list=
        |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   +-subquery=
        |     +-ProjectScan
        |       +-column_list=[tvf_exactly_1_int64_arg.column_bool#3]
        |       +-input_scan=
        |         +-TVFScan
        |           +-column_list=[tvf_exactly_1_int64_arg.column_bool#3]
        |           +-tvf=tvf_exactly_1_int64_arg((INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        |           +-signature=(INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
        |           +-argument_list=
        |           | +-FunctionArgument
        |           |   +-expr=
        |           |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |           +-column_index_list=[0]
        +-element_column=$array.$unnest1#5
==

# Call a TVF passing a query parameter within a scalar argument.
select column_bool from tvf_exactly_1_bool_arg(@test_param_bool)
--
QueryStmt
+-output_column_list=
| +-tvf_exactly_1_bool_arg.column_bool#1 AS column_bool [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[tvf_exactly_1_bool_arg.column_bool#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_exactly_1_bool_arg.column_bool#1]
        +-tvf=tvf_exactly_1_bool_arg((BOOL) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(BOOL) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Parameter(type=BOOL, name="test_param_bool")
        +-column_index_list=[0]
==

# The query calls a function that has a deprecation warning, which should be
# propagated.
# Java error:
# Table-valued functions must return at least one column, but TVF tvf_deprecation_warning returned no columns [at 1:15]
# select * from tvf_deprecation_warning()
#               ^
[no_java]
select * from tvf_deprecation_warning()
--
QueryStmt
+-output_column_list=
| +-tvf_deprecation_warning.column_bool#1 AS column_bool [BOOL]
| +-tvf_deprecation_warning.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_deprecation_warning.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan(column_list=tvf_deprecation_warning.[column_bool#1, column_bytes#2], tvf=tvf_deprecation_warning(() -> TABLE<> (1 deprecation warning)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])


DEPRECATION WARNING:
Table-valued function tvf_deprecation_warning triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 1:15]
select * from tvf_deprecation_warning()
              ^
Operation <foo11> is deprecated [at module11.sqlm:21:31]
some caret string for foo_11
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }
==

# The query calls a function that has two deprecation warnings of the same kind.
# Only the first should be propagated.
# Java error:
# Table-valued functions must return at least one column, but TVF tvf_two_deprecation_warnings_same_kind returned no columns [at 1:15]
# select * from tvf_two_deprecation_warnings_same_kind()
#               ^
[no_java]
select * from tvf_two_deprecation_warnings_same_kind()
--
QueryStmt
+-output_column_list=
| +-tvf_two_deprecation_warnings_same_kind.column_bool#1 AS column_bool [BOOL]
| +-tvf_two_deprecation_warnings_same_kind.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_two_deprecation_warnings_same_kind.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan(column_list=tvf_two_deprecation_warnings_same_kind.[column_bool#1, column_bytes#2], tvf=tvf_two_deprecation_warnings_same_kind(() -> TABLE<> (2 deprecation warnings)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])


DEPRECATION WARNING:
Table-valued function tvf_two_deprecation_warnings_same_kind triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 1:15]
select * from tvf_two_deprecation_warnings_same_kind()
              ^
Operation <foo12> is deprecated [at module12.sqlm:22:32]
some caret string for foo_12
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }
==

# The query calls a function that has two deprecation warnings with different
# kinds. Both should be propagated.
# Java error:
# Table-valued functions must return at least one column, but TVF tvf_two_deprecation_warnings returned no columns [at 1:15]
# select * from tvf_two_deprecation_warnings()
#               ^
[no_java]
select * from tvf_two_deprecation_warnings()
--
QueryStmt
+-output_column_list=
| +-tvf_two_deprecation_warnings.column_bool#1 AS column_bool [BOOL]
| +-tvf_two_deprecation_warnings.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_two_deprecation_warnings.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan(column_list=tvf_two_deprecation_warnings.[column_bool#1, column_bytes#2], tvf=tvf_two_deprecation_warnings(() -> TABLE<> (2 deprecation warnings)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])


DEPRECATION WARNING:
Table-valued function tvf_two_deprecation_warnings triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 1:15]
select * from tvf_two_deprecation_warnings()
              ^
Operation <foo14> is deprecated [at module14.sqlm:24:34]
some caret string for foo_14
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Table-valued function tvf_two_deprecation_warnings triggers a deprecation warning with kind DEPRECATED_FUNCTION_SIGNATURE [at 1:15]
select * from tvf_two_deprecation_warnings()
              ^
Operation <foo15> is deprecated [at module15.sqlm:25:35]
some caret string for foo_15
                      ^
[zetasql.DeprecationWarning] { kind: DEPRECATED_FUNCTION_SIGNATURE }
==

# The query calls three functions. The first has one deprecation warning, the
# second has two deprecation warnings with the same kind, and the third has
# two deprecation warnings with different kinds. The result should have one
# deprecation warning for each function, using the first deprecation warning for
# each kind, for a total of 4 warnings.
# Java error:
# Table-valued functions must return at least one column, but TVF tvf_deprecation_warning returned no columns [at 1:15]
# select * from tvf_deprecation_warning()
#               ^
[no_java]
select * from tvf_deprecation_warning()
union all
select * from tvf_two_deprecation_warnings_same_kind()
union all
select * from tvf_two_deprecation_warnings()
--
QueryStmt
+-output_column_list=
| +-$union_all.column_bool#7 AS column_bool [BOOL]
| +-$union_all.column_bytes#8 AS column_bytes [BYTES]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[column_bool#7, column_bytes#8]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=tvf_deprecation_warning.[column_bool#1, column_bytes#2]
      | |   +-input_scan=
      | |     +-TVFScan(column_list=tvf_deprecation_warning.[column_bool#1, column_bytes#2], tvf=tvf_deprecation_warning(() -> TABLE<> (1 deprecation warning)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
      | +-output_column_list=tvf_deprecation_warning.[column_bool#1, column_bytes#2]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=tvf_two_deprecation_warnings_same_kind.[column_bool#3, column_bytes#4]
      | |   +-input_scan=
      | |     +-TVFScan(column_list=tvf_two_deprecation_warnings_same_kind.[column_bool#3, column_bytes#4], tvf=tvf_two_deprecation_warnings_same_kind(() -> TABLE<> (2 deprecation warnings)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
      | +-output_column_list=tvf_two_deprecation_warnings_same_kind.[column_bool#3, column_bytes#4]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=tvf_two_deprecation_warnings.[column_bool#5, column_bytes#6]
        |   +-input_scan=
        |     +-TVFScan(column_list=tvf_two_deprecation_warnings.[column_bool#5, column_bytes#6], tvf=tvf_two_deprecation_warnings(() -> TABLE<> (2 deprecation warnings)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
        +-output_column_list=tvf_two_deprecation_warnings.[column_bool#5, column_bytes#6]


DEPRECATION WARNING:
Table-valued function tvf_deprecation_warning triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 1:15]
select * from tvf_deprecation_warning()
              ^
Operation <foo11> is deprecated [at module11.sqlm:21:31]
some caret string for foo_11
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Table-valued function tvf_two_deprecation_warnings_same_kind triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 3:15]
select * from tvf_two_deprecation_warnings_same_kind()
              ^
Operation <foo12> is deprecated [at module12.sqlm:22:32]
some caret string for foo_12
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Table-valued function tvf_two_deprecation_warnings triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 5:15]
select * from tvf_two_deprecation_warnings()
              ^
Operation <foo14> is deprecated [at module14.sqlm:24:34]
some caret string for foo_14
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Table-valued function tvf_two_deprecation_warnings triggers a deprecation warning with kind DEPRECATED_FUNCTION_SIGNATURE [at 5:15]
select * from tvf_two_deprecation_warnings()
              ^
Operation <foo15> is deprecated [at module15.sqlm:25:35]
some caret string for foo_15
                      ^
[zetasql.DeprecationWarning] { kind: DEPRECATED_FUNCTION_SIGNATURE }
==

# Same as the previous test, except each function is called twice. The
# deprecation warnings are de-duplicated, so there are still only 4 warnings.
# Java error:
# Table-valued functions must return at least one column, but TVF tvf_deprecation_warning returned no columns [at 1:15]
# select * from tvf_deprecation_warning()
#               ^
[no_java]
select * from tvf_deprecation_warning()
union all
select * from tvf_deprecation_warning()
union all
select * from tvf_two_deprecation_warnings_same_kind()
union all
select * from tvf_two_deprecation_warnings_same_kind()
union all
select * from tvf_two_deprecation_warnings()
union all
select * from tvf_two_deprecation_warnings()
--
QueryStmt
+-output_column_list=
| +-$union_all.column_bool#13 AS column_bool [BOOL]
| +-$union_all.column_bytes#14 AS column_bytes [BYTES]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[column_bool#13, column_bytes#14]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=tvf_deprecation_warning.[column_bool#1, column_bytes#2]
      | |   +-input_scan=
      | |     +-TVFScan(column_list=tvf_deprecation_warning.[column_bool#1, column_bytes#2], tvf=tvf_deprecation_warning(() -> TABLE<> (1 deprecation warning)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
      | +-output_column_list=tvf_deprecation_warning.[column_bool#1, column_bytes#2]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=tvf_deprecation_warning.[column_bool#3, column_bytes#4]
      | |   +-input_scan=
      | |     +-TVFScan(column_list=tvf_deprecation_warning.[column_bool#3, column_bytes#4], tvf=tvf_deprecation_warning(() -> TABLE<> (1 deprecation warning)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
      | +-output_column_list=tvf_deprecation_warning.[column_bool#3, column_bytes#4]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=tvf_two_deprecation_warnings_same_kind.[column_bool#5, column_bytes#6]
      | |   +-input_scan=
      | |     +-TVFScan(column_list=tvf_two_deprecation_warnings_same_kind.[column_bool#5, column_bytes#6], tvf=tvf_two_deprecation_warnings_same_kind(() -> TABLE<> (2 deprecation warnings)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
      | +-output_column_list=tvf_two_deprecation_warnings_same_kind.[column_bool#5, column_bytes#6]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=tvf_two_deprecation_warnings_same_kind.[column_bool#7, column_bytes#8]
      | |   +-input_scan=
      | |     +-TVFScan(column_list=tvf_two_deprecation_warnings_same_kind.[column_bool#7, column_bytes#8], tvf=tvf_two_deprecation_warnings_same_kind(() -> TABLE<> (2 deprecation warnings)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
      | +-output_column_list=tvf_two_deprecation_warnings_same_kind.[column_bool#7, column_bytes#8]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=tvf_two_deprecation_warnings.[column_bool#9, column_bytes#10]
      | |   +-input_scan=
      | |     +-TVFScan(column_list=tvf_two_deprecation_warnings.[column_bool#9, column_bytes#10], tvf=tvf_two_deprecation_warnings(() -> TABLE<> (2 deprecation warnings)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
      | +-output_column_list=tvf_two_deprecation_warnings.[column_bool#9, column_bytes#10]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=tvf_two_deprecation_warnings.[column_bool#11, column_bytes#12]
        |   +-input_scan=
        |     +-TVFScan(column_list=tvf_two_deprecation_warnings.[column_bool#11, column_bytes#12], tvf=tvf_two_deprecation_warnings(() -> TABLE<> (2 deprecation warnings)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
        +-output_column_list=tvf_two_deprecation_warnings.[column_bool#11, column_bytes#12]


DEPRECATION WARNING:
Table-valued function tvf_deprecation_warning triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 1:15]
select * from tvf_deprecation_warning()
              ^
Operation <foo11> is deprecated [at module11.sqlm:21:31]
some caret string for foo_11
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Table-valued function tvf_two_deprecation_warnings_same_kind triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 5:15]
select * from tvf_two_deprecation_warnings_same_kind()
              ^
Operation <foo12> is deprecated [at module12.sqlm:22:32]
some caret string for foo_12
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Table-valued function tvf_two_deprecation_warnings triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 9:15]
select * from tvf_two_deprecation_warnings()
              ^
Operation <foo14> is deprecated [at module14.sqlm:24:34]
some caret string for foo_14
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Table-valued function tvf_two_deprecation_warnings triggers a deprecation warning with kind DEPRECATED_FUNCTION_SIGNATURE [at 9:15]
select * from tvf_two_deprecation_warnings()
              ^
Operation <foo15> is deprecated [at module15.sqlm:25:35]
some caret string for foo_15
                      ^
[zetasql.DeprecationWarning] { kind: DEPRECATED_FUNCTION_SIGNATURE }
==

# Torture test that calls 3 TVFs and 3 UDFs, twice. There is one TVF/UDF with
# one deprecation warning, one TVF/UDF with two deprecation warnings with the
# same kind, and one TVF/UDF with two deprecation warnings with different kinds.
# We propagate one deprecation warning per TVF/UDF and kind, for a total of
# 8 deprecation warnings.
# Java error:
# Table-valued functions must return at least one column, but TVF tvf_deprecation_warning returned no columns [at 1:35]
# select deprecation_warning() from tvf_deprecation_warning()
#                                   ^
[no_java]
select deprecation_warning() from tvf_deprecation_warning()
union all
select deprecation_warning() from tvf_deprecation_warning()
union all
select two_deprecation_warnings_same_kind()
from tvf_two_deprecation_warnings_same_kind()
union all
select two_deprecation_warnings_same_kind()
from tvf_two_deprecation_warnings_same_kind()
union all
select two_deprecation_warnings() from tvf_two_deprecation_warnings()
union all
select two_deprecation_warnings() from tvf_two_deprecation_warnings()
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#19 AS `$col1` [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#19]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1.$col1#3]
      | |   +-expr_list=
      | |   | +-$col1#3 := FunctionCall(sample_functions:deprecation_warning() -> INT64)
      | |   +-input_scan=
      | |     +-TVFScan(tvf=tvf_deprecation_warning(() -> TABLE<> (1 deprecation warning)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | +-output_column_list=[$union_all1.$col1#3]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2.$col1#6]
      | |   +-expr_list=
      | |   | +-$col1#6 := FunctionCall(sample_functions:deprecation_warning() -> INT64)
      | |   +-input_scan=
      | |     +-TVFScan(tvf=tvf_deprecation_warning(() -> TABLE<> (1 deprecation warning)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | +-output_column_list=[$union_all2.$col1#6]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all3.$col1#9]
      | |   +-expr_list=
      | |   | +-$col1#9 := FunctionCall(sample_functions:two_deprecation_warnings_same_kind() -> INT64)
      | |   +-input_scan=
      | |     +-TVFScan(tvf=tvf_two_deprecation_warnings_same_kind(() -> TABLE<> (2 deprecation warnings)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | +-output_column_list=[$union_all3.$col1#9]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all4.$col1#12]
      | |   +-expr_list=
      | |   | +-$col1#12 := FunctionCall(sample_functions:two_deprecation_warnings_same_kind() -> INT64)
      | |   +-input_scan=
      | |     +-TVFScan(tvf=tvf_two_deprecation_warnings_same_kind(() -> TABLE<> (2 deprecation warnings)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | +-output_column_list=[$union_all4.$col1#12]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all5.$col1#15]
      | |   +-expr_list=
      | |   | +-$col1#15 := FunctionCall(sample_functions:two_deprecation_warnings() -> INT64)
      | |   +-input_scan=
      | |     +-TVFScan(tvf=tvf_two_deprecation_warnings(() -> TABLE<> (2 deprecation warnings)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
      | +-output_column_list=[$union_all5.$col1#15]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all6.$col1#18]
        |   +-expr_list=
        |   | +-$col1#18 := FunctionCall(sample_functions:two_deprecation_warnings() -> INT64)
        |   +-input_scan=
        |     +-TVFScan(tvf=tvf_two_deprecation_warnings(() -> TABLE<> (2 deprecation warnings)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-output_column_list=[$union_all6.$col1#18]


DEPRECATION WARNING:
Table-valued function tvf_deprecation_warning triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 1:35]
select deprecation_warning() from tvf_deprecation_warning()
                                  ^
Operation <foo11> is deprecated [at module11.sqlm:21:31]
some caret string for foo_11
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:DEPRECATION_WARNING triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 1:8]
select deprecation_warning() from tvf_deprecation_warning()
       ^
Operation <foo1> is deprecated [at module1.sqlm:11:21]
some caret string for foo_1
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Table-valued function tvf_two_deprecation_warnings_same_kind triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 6:6]
from tvf_two_deprecation_warnings_same_kind()
     ^
Operation <foo12> is deprecated [at module12.sqlm:22:32]
some caret string for foo_12
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:TWO_DEPRECATION_WARNINGS_SAME_KIND triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 5:8]
select two_deprecation_warnings_same_kind()
       ^
Operation <foo2> is deprecated [at module2.sqlm:12:22]
some caret string for foo_2
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Table-valued function tvf_two_deprecation_warnings triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 11:40]
select two_deprecation_warnings() from tvf_two_deprecation_warnings()
                                       ^
Operation <foo14> is deprecated [at module14.sqlm:24:34]
some caret string for foo_14
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Table-valued function tvf_two_deprecation_warnings triggers a deprecation warning with kind DEPRECATED_FUNCTION_SIGNATURE [at 11:40]
select two_deprecation_warnings() from tvf_two_deprecation_warnings()
                                       ^
Operation <foo15> is deprecated [at module15.sqlm:25:35]
some caret string for foo_15
                      ^
[zetasql.DeprecationWarning] { kind: DEPRECATED_FUNCTION_SIGNATURE }

DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:TWO_DEPRECATION_WARNINGS triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 11:8]
select two_deprecation_warnings() from tvf_two_deprecation_warnings()
       ^
Operation <foo4> is deprecated [at module4.sqlm:14:24]
some caret string for foo_4
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }

DEPRECATION WARNING:
Function SAMPLE_FUNCTIONS:TWO_DEPRECATION_WARNINGS triggers a deprecation warning with kind DEPRECATED_FUNCTION_SIGNATURE [at 11:8]
select two_deprecation_warnings() from tvf_two_deprecation_warnings()
       ^
Operation <foo5> is deprecated [at module5.sqlm:15:25]
some caret string for foo_5
                      ^
[zetasql.DeprecationWarning] { kind: DEPRECATED_FUNCTION_SIGNATURE }
==

# The query calls a templated TVF that has a deprecation warning, which should
# be propagated.
# Java error:
# Invalid table-valued function tvf_templated_calls_tvf_deprecation_warning [at 1:15]
# select * from tvf_templated_calls_tvf_deprecation_warning()
#               ^
# Analysis of table-valued function tvf_templated_calls_tvf_deprecation_warning failed [at 1:15]
# select * from tvf_deprecation_warning()
#               ^
# Table-valued functions must return at least one column, but TVF tvf_deprecation_warning returned no columns [at 1:15]
# select * from tvf_deprecation_warning()
#               ^
[no_java]
select * from tvf_templated_calls_tvf_deprecation_warning()
--
QueryStmt
+-output_column_list=
| +-tvf_templated_calls_tvf_deprecation_warning.column_bool#1 AS column_bool [BOOL]
| +-tvf_templated_calls_tvf_deprecation_warning.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_calls_tvf_deprecation_warning.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan(column_list=tvf_templated_calls_tvf_deprecation_warning.[column_bool#1, column_bytes#2], tvf=tvf_templated_calls_tvf_deprecation_warning(() -> ANY TABLE (1 deprecation warning)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])

With Templated SQL TVF signature:
  tvf_templated_calls_tvf_deprecation_warning() -> TABLE<column_bool BOOL, column_bytes BYTES> (1 deprecation warning)
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-tvf_deprecation_warning.column_bool#1 AS column_bool [BOOL]
| +-tvf_deprecation_warning.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_deprecation_warning.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan(column_list=tvf_deprecation_warning.[column_bool#1, column_bytes#2], tvf=tvf_deprecation_warning(() -> TABLE<> (1 deprecation warning)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])


DEPRECATION WARNING:
Table-valued function tvf_templated_calls_tvf_deprecation_warning triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 1:15]
select * from tvf_templated_calls_tvf_deprecation_warning()
              ^
Operation <foo1001> is deprecated [at module1001.sqlm:1011:1021]
some caret string for foo_1001
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }
==

# The query calls a templated TVF that has a deprecation warning, twice. The
# warning should be propagated once. For more extensive tests of TVFs and
# deprecation warnings, see above. We don't need a huge test suite for
# deprecation warnings with templated TVFs because most of the resolution code
# is shared with non-templated TVFs.
# Java error:
# Invalid table-valued function tvf_templated_calls_tvf_deprecation_warning [at 1:15]
# select * from tvf_templated_calls_tvf_deprecation_warning()
#               ^
# Analysis of table-valued function tvf_templated_calls_tvf_deprecation_warning failed [at 1:15]
# select * from tvf_deprecation_warning()
#               ^
# Table-valued functions must return at least one column, but TVF tvf_deprecation_warning returned no columns [at 1:15]
# select * from tvf_deprecation_warning()
#               ^
[no_java]
select * from tvf_templated_calls_tvf_deprecation_warning()
union all
select * from tvf_templated_calls_tvf_deprecation_warning()
--
QueryStmt
+-output_column_list=
| +-$union_all.column_bool#5 AS column_bool [BOOL]
| +-$union_all.column_bytes#6 AS column_bytes [BYTES]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[column_bool#5, column_bytes#6]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=tvf_templated_calls_tvf_deprecation_warning.[column_bool#1, column_bytes#2]
      | |   +-input_scan=
      | |     +-TVFScan(column_list=tvf_templated_calls_tvf_deprecation_warning.[column_bool#1, column_bytes#2], tvf=tvf_templated_calls_tvf_deprecation_warning(() -> ANY TABLE (1 deprecation warning)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
      | +-output_column_list=tvf_templated_calls_tvf_deprecation_warning.[column_bool#1, column_bytes#2]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=tvf_templated_calls_tvf_deprecation_warning.[column_bool#3, column_bytes#4]
        |   +-input_scan=
        |     +-TVFScan(column_list=tvf_templated_calls_tvf_deprecation_warning.[column_bool#3, column_bytes#4], tvf=tvf_templated_calls_tvf_deprecation_warning(() -> ANY TABLE (1 deprecation warning)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])
        +-output_column_list=tvf_templated_calls_tvf_deprecation_warning.[column_bool#3, column_bytes#4]

With Templated SQL TVF signature:
  tvf_templated_calls_tvf_deprecation_warning() -> TABLE<column_bool BOOL, column_bytes BYTES> (1 deprecation warning)
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-tvf_deprecation_warning.column_bool#1 AS column_bool [BOOL]
| +-tvf_deprecation_warning.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_deprecation_warning.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan(column_list=tvf_deprecation_warning.[column_bool#1, column_bytes#2], tvf=tvf_deprecation_warning(() -> TABLE<> (1 deprecation warning)), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1])


DEPRECATION WARNING:
Table-valued function tvf_templated_calls_tvf_deprecation_warning triggers a deprecation warning with kind PROTO3_FIELD_PRESENCE [at 1:15]
select * from tvf_templated_calls_tvf_deprecation_warning()
              ^
Operation <foo1001> is deprecated [at module1001.sqlm:1011:1021]
some caret string for foo_1001
                      ^
[zetasql.DeprecationWarning] { kind: PROTO3_FIELD_PRESENCE }
==

# This query calls a TVF with a required output schema, passing an input value
# of equal type as the required output column.
select *
from tvf_templated_select_x_with_required_output_schema(cast(1 as int64));
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_x_with_required_output_schema.key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_x_with_required_output_schema.key#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_x_with_required_output_schema.key#1]
        +-tvf=tvf_templated_select_x_with_required_output_schema((ANY TYPE) -> TABLE<key INT64>)
        +-signature=(literal INT64) -> TABLE<key INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_x_with_required_output_schema(literal INT64) -> TABLE<key INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.key#1]
    +-expr_list=
    | +-key#1 := ArgumentRef(type=INT64, name="x")
    +-input_scan=
      +-SingleRowScan
==

# This query calls a TVF with a required output schema, passing an input value
# of a type that is not equal but coercible to the required output column.
select *
from tvf_templated_select_x_with_required_output_schema(cast(1 as int32));
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_x_with_required_output_schema.key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_x_with_required_output_schema.key#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_x_with_required_output_schema.key#1]
        +-tvf=tvf_templated_select_x_with_required_output_schema((ANY TYPE) -> TABLE<key INT64>)
        +-signature=(literal INT32) -> TABLE<key INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_x_with_required_output_schema(literal INT32) -> TABLE<key INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$subquery1.key#2 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$subquery1.key#2]
    +-expr_list=
    | +-key#2 :=
    |   +-Cast(INT32 -> INT64)
    |     +-ColumnRef(type=INT32, column=$query.key#1)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$query.key#1]
        +-expr_list=
        | +-key#1 := ArgumentRef(type=INT32, name="x")
        +-input_scan=
          +-SingleRowScan
==

# This query calls a TVF with a required value-table output schema and the SQL
# body returns a non-value table with a column of the same type.
select *
from tvf_templated_select_x_with_required_value_table_output_schema("abc");
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_x_with_required_value_table_output_schema.$col0#1 AS `$col0` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_x_with_required_value_table_output_schema.$col0#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_x_with_required_value_table_output_schema.$col0#1]
        +-tvf=tvf_templated_select_x_with_required_value_table_output_schema((ANY TYPE) -> TABLE<STRING>)
        +-signature=(literal STRING) -> TABLE<STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="abc")
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_x_with_required_value_table_output_schema(literal STRING) -> TABLE<STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [STRING]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1]
    +-expr_list=
    | +-x#1 := ArgumentRef(type=STRING, name="x")
    +-input_scan=
      +-SingleRowScan
==

# This query calls a TVF with a required value-table output schema and the SQL
# body returns a value table of the same type.
select *
from tvf_templated_select_as_value_x_with_required_value_table_output_schema(
    "abc");
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_as_value_x_with_required_value_table_output_schema.$col0#1 AS `$col0` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_as_value_x_with_required_value_table_output_schema.$col0#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_as_value_x_with_required_value_table_output_schema.$col0#1]
        +-tvf=tvf_templated_select_as_value_x_with_required_value_table_output_schema((ANY TYPE) -> TABLE<STRING>)
        +-signature=(literal STRING) -> TABLE<STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="abc")
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_as_value_x_with_required_value_table_output_schema(literal STRING) -> TABLE<STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.x#1 AS `$value_column` [STRING]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1]
    +-expr_list=
    | +-x#1 := ArgumentRef(type=STRING, name="x")
    +-input_scan=
      +-SingleRowScan
==

# This query calls a TVF with a required value-table output schema and the SQL
# body returns NULL casted to string type.
select *
from tvf_templated_select_null_str_with_required_value_table_output_schema(
    "abc");
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_null_str_with_required_value_table_output_schema.$col0#1 AS `$col0` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_null_str_with_required_value_table_output_schema.$col0#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_null_str_with_required_value_table_output_schema.$col0#1]
        +-tvf=tvf_templated_select_null_str_with_required_value_table_output_schema((ANY TYPE) -> TABLE<STRING>)
        +-signature=(literal STRING) -> TABLE<STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="abc")
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_null_str_with_required_value_table_output_schema(literal STRING) -> TABLE<STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRING]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRING, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# This query calls a TVF with a required output schema with two columns. The
# function body returns the two columns in opposite order.
select *
from tvf_templated_return_swapped_cols_required_output_schema(42, "value");
--
QueryStmt
+-output_column_list=
| +-tvf_templated_return_swapped_cols_required_output_schema.key#1 AS key [INT64]
| +-tvf_templated_return_swapped_cols_required_output_schema.value#2 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_return_swapped_cols_required_output_schema.[key#1, value#2]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_templated_return_swapped_cols_required_output_schema.[key#1, value#2]
        +-tvf=tvf_templated_return_swapped_cols_required_output_schema((ANY TYPE, ANY TYPE) -> TABLE<key INT64, value STRING>)
        +-signature=(literal INT64, literal STRING) -> TABLE<key INT64, value STRING>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=42)
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="value")
        +-column_index_list=[0, 1]

With Templated SQL TVF signature:
  tvf_templated_return_swapped_cols_required_output_schema(literal INT64, literal STRING) -> TABLE<key INT64, value STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.key#2 AS key [INT64]
| +-$query.value#1 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[key#2, value#1]
    +-input_scan=
      +-ProjectScan
        +-column_list=$query.[value#1, key#2]
        +-expr_list=
        | +-value#1 := ArgumentRef(type=STRING, name="value")
        | +-key#2 := ArgumentRef(type=INT64, name="key")
        +-input_scan=
          +-SingleRowScan
==

# This query calls a TVF with a required output schema with two columns. The
# function body returns the two columns in opposite order, plus an extra column.
select *
from tvf_templated_return_swapped_cols_plus_extra_required_output_schema(
    42, "value");
--
QueryStmt
+-output_column_list=
| +-tvf_templated_return_swapped_cols_plus_extra_required_output_schema.key#1 AS key [INT64]
| +-tvf_templated_return_swapped_cols_plus_extra_required_output_schema.value#2 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_return_swapped_cols_plus_extra_required_output_schema.[key#1, value#2]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_templated_return_swapped_cols_plus_extra_required_output_schema.[key#1, value#2]
        +-tvf=tvf_templated_return_swapped_cols_plus_extra_required_output_schema((ANY TYPE, ANY TYPE) -> TABLE<key INT64, value STRING>)
        +-signature=(literal INT64, literal STRING) -> TABLE<key INT64, value STRING>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=INT64, value=42)
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="value")
        +-column_index_list=[0, 1]

With Templated SQL TVF signature:
  tvf_templated_return_swapped_cols_plus_extra_required_output_schema(literal INT64, literal STRING) -> TABLE<key INT64, value STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.key#2 AS key [INT64]
| +-$query.value#1 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[key#2, value#1]
    +-input_scan=
      +-ProjectScan
        +-column_list=$query.[value#1, key#2, x#3]
        +-expr_list=
        | +-value#1 := ArgumentRef(type=STRING, name="value")
        | +-key#2 := ArgumentRef(type=INT64, name="key")
        | +-x#3 := Literal(type=INT64, value=42)
        +-input_scan=
          +-SingleRowScan
==

# This table valued function was written to create an ambiguity between an
# argument name and a column name introduced by an inline subquery. The
# resolution of that name inside the TVF body changes from resolving to the
# column name to argument name when choosing argument names first.
[language_features={{TABLE_VALUED_FUNCTIONS|TABLE_VALUED_FUNCTIONS,FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES}}]
SELECT * FROM tvf_templated_select_int64_arg_with_name_ambiguity(33);
--
ALTERNATION GROUP: TABLE_VALUED_FUNCTIONS
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_int64_arg_with_name_ambiguity.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_int64_arg_with_name_ambiguity.x#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_int64_arg_with_name_ambiguity.x#1]
        +-tvf=tvf_templated_select_int64_arg_with_name_ambiguity((INT64) -> ANY TABLE)
        +-signature=(literal INT64) -> TABLE<x INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=33)
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_int64_arg_with_name_ambiguity(literal INT64) -> TABLE<x INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$subquery1.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$subquery1.x#1]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$subquery1.x#1]
        +-expr_list=
        | +-x#1 := Literal(type=INT64, value=-99)
        +-input_scan=
          +-SingleRowScan
--
ALTERNATION GROUP: TABLE_VALUED_FUNCTIONS,FUNCTION_ARGUMENT_NAMES_HIDE_LOCAL_NAMES
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_int64_arg_with_name_ambiguity.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_int64_arg_with_name_ambiguity.x#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_int64_arg_with_name_ambiguity.x#1]
        +-tvf=tvf_templated_select_int64_arg_with_name_ambiguity((INT64) -> ANY TABLE)
        +-signature=(literal INT64) -> TABLE<x INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=33)
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_int64_arg_with_name_ambiguity(literal INT64) -> TABLE<x INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.x#2 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.x#2]
    +-expr_list=
    | +-x#2 := ArgumentRef(type=INT64, name="x")
    +-input_scan=
      +-ProjectScan
        +-column_list=[$subquery1.x#1]
        +-expr_list=
        | +-x#1 := Literal(type=INT64, value=-99)
        +-input_scan=
          +-SingleRowScan
==

################################################################################
#
# Negative test cases
#
################################################################################
#
# The TVF language feature is disabled for this query.
#
[language_features=]
select 1 from tvf_no_args()
--
ERROR: Table-valued functions are not supported [at 1:15]
select 1 from tvf_no_args()
              ^
==

# Empty argument list.
select column_bytes from tvf_no_args(42)
--
ERROR: No matching signature for tvf_no_args for argument types: INT64. Supported signature: TVF_NO_ARGS() [at 1:26]
select column_bytes from tvf_no_args(42)
                         ^
==

# Empty output schema using "select 1".
select 1 from tvf_empty_output_schema()
--
ERROR: Table-valued functions must return at least one column, but TVF tvf_empty_output_schema returned no columns [at 1:15]
select 1 from tvf_empty_output_schema()
              ^
==

# Empty output schema using "select *".
select * from tvf_empty_output_schema()
--
ERROR: Table-valued functions must return at least one column, but TVF tvf_empty_output_schema returned no columns [at 1:15]
select * from tvf_empty_output_schema()
              ^
==

# Literals in the argument list.
select * from tvf_exactly_3_int64_args()
--
ERROR: No matching signature for tvf_exactly_3_int64_args with no arguments. Supported signature: TVF_EXACTLY_3_INT64_ARGS(INT64, INT64, INT64) [at 1:15]
select * from tvf_exactly_3_int64_args()
              ^
==

# Test several TVFs, each of which accepts one argument of some POD type.
select column_bool from tvf_exactly_1_bool_arg("invalid")
--
ERROR: Could not cast literal "invalid" to type BOOL [at 1:48]
select column_bool from tvf_exactly_1_bool_arg("invalid")
                                               ^
==

# Test several TVFs, each of which accepts one argument of some POD type.
select column_bool from tvf_exactly_1_bytes_arg(42)
--
ERROR: No matching signature for tvf_exactly_1_bytes_arg for argument types: INT64. Supported signature: TVF_EXACTLY_1_BYTES_ARG(BYTES) [at 1:25]
select column_bool from tvf_exactly_1_bytes_arg(42)
                        ^
==

# Test several TVFs, each of which accepts one argument of some POD type.
select column_bool from tvf_exactly_1_double_arg("invalid")
--
ERROR: Could not cast literal "invalid" to type DOUBLE [at 1:50]
select column_bool from tvf_exactly_1_double_arg("invalid")
                                                 ^
==

# Test several TVFs, each of which accepts one argument of some POD type.
select column_bool from tvf_exactly_1_float_arg("invalid")
--
ERROR: No matching signature for tvf_exactly_1_float_arg for argument types: STRING. Supported signature: TVF_EXACTLY_1_FLOAT_ARG(FLOAT) [at 1:25]
select column_bool from tvf_exactly_1_float_arg("invalid")
                        ^
==

# Test several TVFs, each of which accepts one argument of some POD type.
select column_bool from tvf_exactly_1_int32_arg("invalid")
--
ERROR: Could not cast literal "invalid" to type INT32 [at 1:49]
select column_bool from tvf_exactly_1_int32_arg("invalid")
                                                ^
==

# Test several TVFs, each of which accepts one argument of some POD type.
select column_bool from tvf_exactly_1_int64_arg("invalid")
--
ERROR: Could not cast literal "invalid" to type INT64 [at 1:49]
select column_bool from tvf_exactly_1_int64_arg("invalid")
                                                ^
==

# Test several TVFs, each of which accepts one argument of some POD type.
select column_bool from tvf_exactly_1_uint32_arg("invalid")
--
ERROR: No matching signature for tvf_exactly_1_uint32_arg for argument types: STRING. Supported signature: TVF_EXACTLY_1_UINT32_ARG(UINT32) [at 1:25]
select column_bool from tvf_exactly_1_uint32_arg("invalid")
                        ^
==

# Test several TVFs, each of which accepts one argument of some POD type.
select column_bool from tvf_exactly_1_uint64_arg("invalid")
--
ERROR: No matching signature for tvf_exactly_1_uint64_arg for argument types: STRING. Supported signature: TVF_EXACTLY_1_UINT64_ARG(UINT64) [at 1:25]
select column_bool from tvf_exactly_1_uint64_arg("invalid")
                        ^
==

# The TVF accepts a templated argument.
select column_bool from tvf_exactly_one_arg_type_any_1(1, 2, 3)
--
ERROR: No matching signature for tvf_exactly_one_arg_type_any_1 for argument types: INT64, INT64, INT64. Supported signature: TVF_EXACTLY_ONE_ARG_TYPE_ANY_1(ANY) [at 1:25]
select column_bool from tvf_exactly_one_arg_type_any_1(1, 2, 3)
                        ^
==

# The TVF accepts a templated argument.
select column_bool from tvf_exactly_one_arg_type_any_2(1, 2, 3)
--
ERROR: No matching signature for tvf_exactly_one_arg_type_any_2 for argument types: INT64, INT64, INT64. Supported signature: TVF_EXACTLY_ONE_ARG_TYPE_ANY_2(ANY) [at 1:25]
select column_bool from tvf_exactly_one_arg_type_any_2(1, 2, 3)
                        ^
==

# The TVF accepts a templated argument.
select column_bool from tvf_exactly_one_arg_array_type_any_1([1, 2, 3], [4, 5, 6])
--
ERROR: No matching signature for tvf_exactly_one_arg_array_type_any_1 for argument types: ARRAY<INT64>, ARRAY<INT64>. Supported signature: TVF_EXACTLY_ONE_ARG_ARRAY_TYPE_ANY_1(ARRAY) [at 1:25]
select column_bool from tvf_exactly_one_arg_array_type_any_1([1, 2, 3], [4, 5...
                        ^
==

# The TVF accepts a templated argument.
select column_bool from tvf_exactly_one_arg_array_type_any_2([1, 2, 3], [4, 5, 6])
--
ERROR: No matching signature for tvf_exactly_one_arg_array_type_any_2 for argument types: ARRAY<INT64>, ARRAY<INT64>. Supported signature: TVF_EXACTLY_ONE_ARG_ARRAY_TYPE_ANY_2(ARRAY) [at 1:25]
select column_bool from tvf_exactly_one_arg_array_type_any_2([1, 2, 3], [4, 5...
                        ^
==

# The TVF accepts a templated argument.
select column_bool from tvf_exactly_one_arg_type_arbitrary(1, 2, 3)
--
ERROR: No matching signature for tvf_exactly_one_arg_type_arbitrary for argument types: INT64, INT64, INT64. Supported signature: TVF_EXACTLY_ONE_ARG_TYPE_ARBITRARY(ANY) [at 1:25]
select column_bool from tvf_exactly_one_arg_type_arbitrary(1, 2, 3)
                        ^
==

# The TVF accepts a templated argument.
select column_bool from tvf_exactly_one_arg_proto_any(42)
--
ERROR: No matching signature for tvf_exactly_one_arg_proto_any for argument types: INT64. Supported signature: TVF_EXACTLY_ONE_ARG_PROTO_ANY(PROTO) [at 1:25]
select column_bool from tvf_exactly_one_arg_proto_any(42)
                        ^
==

# The TVF accepts a templated argument.
select column_bool from tvf_exactly_one_arg_struct_any(42)
--
ERROR: No matching signature for tvf_exactly_one_arg_struct_any for argument types: INT64. Supported signature: TVF_EXACTLY_ONE_ARG_STRUCT_ANY(STRUCT) [at 1:25]
select column_bool from tvf_exactly_one_arg_struct_any(42)
                        ^
==

# The TVF accepts a templated argument.
select column_bool from tvf_exactly_one_arg_enum_any(42)
--
ERROR: No matching signature for tvf_exactly_one_arg_enum_any for argument types: INT64. Supported signature: TVF_EXACTLY_ONE_ARG_ENUM_ANY(ENUM) [at 1:25]
select column_bool from tvf_exactly_one_arg_enum_any(42)
                        ^
==

# The TVF accepts a repeating final int64 argument.
select column_bool from tvf_repeating_int64_args("a", "b", "c")
--
ERROR: Could not cast literal "a" to type INT64 [at 1:50]
select column_bool from tvf_repeating_int64_args("a", "b", "c")
                                                 ^
==

# The TVF accepts a templated repeating final argument.
select column_bool from tvf_repeating_any_one_type_args(1, "a")
--
ERROR: Could not cast literal "a" to type INT64 [at 1:60]
select column_bool from tvf_repeating_any_one_type_args(1, "a")
                                                           ^
==

# The TVF argument is not enclosed in parentheses and so the parsing fails.
select * from tvf_exactly_1_int64_arg(select * from tvf_no_args(((abs(1 - 2)))))
--
ERROR: Syntax error: Each subquery argument for table-valued function calls must be enclosed in parentheses. To fix this, replace SELECT... with (SELECT...) [at 1:39]
select * from tvf_exactly_1_int64_arg(select * from tvf_no_args(((abs(1 - 2)))))
                                      ^
==

# The TVF name is the same as a reserved keyword.
select * from if(true, (select 1), (select 2))
--
ERROR: Table-valued function not found: `if` [at 1:15]
select * from if(true, (select 1), (select 2))
              ^
==

# A subquery and nested TVF calls in the argument list.
# All TVF arguments must be scalar values, and so resolving fails because the
# subquery SELECT list has two items.
select * from tvf_exactly_5_int64_args(
    (select 1),
    (select 1 from tvf_no_args()),
    (select 1 from tvf_no_args() limit 1),
    (select 1, 2 from tvf_no_args()),
    (select 1 from tvf_no_args()))
--
ERROR: Scalar subquery cannot have more than one column unless using SELECT AS STRUCT to build STRUCT values [at 5:5]
    (select 1, 2 from tvf_no_args()),
    ^
==

# A nested TVF call and some SQL function expressions without arguments in the
# argument list.
select * from tvf_exactly_3_int64_args((select 1 from tvf_no_args()),
                                current_date(),
                                current_timestamp())
--
ERROR: No matching signature for tvf_exactly_3_int64_args for argument types: INT64, DATE, TIMESTAMP. Supported signature: TVF_EXACTLY_3_INT64_ARGS(INT64, INT64, INT64) [at 1:15]
select * from tvf_exactly_3_int64_args((select 1 from tvf_no_args()),
              ^
==

# A TVF has a correlated reference to the enclosing query.
select (select * from tvf_exactly_1_int64_arg(Key)) from KeyValue
--
ERROR: Scalar subquery cannot have more than one column unless using SELECT AS STRUCT to build STRUCT values [at 1:8]
select (select * from tvf_exactly_1_int64_arg(Key)) from KeyValue
       ^
==

# A TVF has a correlated reference to the enclosing query.
select (select * from tvf_exactly_1_int64_arg((SELECT Key))) from KeyValue
--
ERROR: Scalar subquery cannot have more than one column unless using SELECT AS STRUCT to build STRUCT values [at 1:8]
select (select * from tvf_exactly_1_int64_arg((SELECT Key))) from KeyValue
       ^
==

# Invalid test: the TVF call contains a table reference without using a
# subquery.
select * from tvf_exactly_1_int64_arg(keyvalue)
--
ERROR: Unrecognized name: keyvalue [at 1:39]
select * from tvf_exactly_1_int64_arg(keyvalue)
                                      ^
==

# Invalid test: the TVF call contains a nested TVF call without using a
# subquery.
select * from tvf_exactly_1_int64_arg(tvf_no_args())
--
ERROR: Function not found: tvf_no_args [at 1:39]
select * from tvf_exactly_1_int64_arg(tvf_no_args())
                                      ^
==

# Invalid test: the TVF call contains a column reference to a previous table in
# the FROM clause.
select * from KeyValue JOIN tvf_exactly_1_int64_arg(Key) ON (TRUE)
--
ERROR: Unrecognized name: Key [at 1:53]
select * from KeyValue JOIN tvf_exactly_1_int64_arg(Key) ON (TRUE)
                                                    ^
==

# WITH OFFSET is not support for TVFs.
select * from my.dot.separated.tvf((select key from keyvalue)) WITH OFFSET o
--
ERROR: Syntax error: Expected end of input but got keyword WITH [at 1:64]
select * from my.dot.separated.tvf((select key from keyvalue)) WITH OFFSET o
                                                               ^
==

# Parenthesized TVFs are not supported.
select * from (tvf_exactly_1_int64_arg((select key from keyvalue)))
--
ERROR: Syntax error: Expected keyword JOIN but got ")" [at 1:67]
select * from (tvf_exactly_1_int64_arg((select key from keyvalue)))
                                                                  ^
==

# Parenthesized joins are not supported as TVF arguments.
select * from tvf_exactly_1_int64_arg((keyvalue join keyvalue on true))
--
ERROR: Syntax error: Unexpected keyword JOIN [at 1:49]
select * from tvf_exactly_1_int64_arg((keyvalue join keyvalue on true))
                                                ^
==

# TVF names may not start with numerals.
select * from 42.dot.separated.tvf((select key from keyvalue))
--
ERROR: Syntax error: Unexpected floating point literal "42." [at 1:15]
select * from 42.dot.separated.tvf((select key from keyvalue))
              ^
==

# TVF names may not start with numerals.
select * from 42..dot.separated.tvf((select key from keyvalue))
--
ERROR: Syntax error: Unexpected floating point literal "42." [at 1:15]
select * from 42..dot.separated.tvf((select key from keyvalue))
              ^
==

# TVF names may not start with numerals.
select * from 42.dot.separated.42((select key from keyvalue))
--
ERROR: Syntax error: Unexpected floating point literal "42." [at 1:15]
select * from 42.dot.separated.42((select key from keyvalue))
              ^
==

# Special characters are not allowed in TVF names.
select * from my.dot.-separated.tvf((select key from keyvalue))
--
ERROR: Syntax error: Unexpected "-" [at 1:22]
select * from my.dot.-separated.tvf((select key from keyvalue))
                     ^
==

# Multiple levels of parentheses in various TVF arguments.
select * from tvf_exactly_1_int64_arg(select 1 from tvf_no_args())
--
ERROR: Syntax error: Each subquery argument for table-valued function calls must be enclosed in parentheses. To fix this, replace SELECT... with (SELECT...) [at 1:39]
select * from tvf_exactly_1_int64_arg(select 1 from tvf_no_args())
                                      ^
==

# A dot-separated TVF name. This parses correctly but the TVF is not found.
select * from my.dot.separated.tvf((select key from keyvalue))
--
ERROR: Table-valued function not found: my.dot.separated.tvf [at 1:15]
select * from my.dot.separated.tvf((select key from keyvalue))
              ^
==

# A dot-separated TVF name with numerals. This parses correctly but the TVF is
# not found.
select * from my.42.dot.separated.tvf((select key from keyvalue))
--
ERROR: Table-valued function not found: my.`42`.dot.separated.tvf [at 1:15]
select * from my.42.dot.separated.tvf((select key from keyvalue))
              ^
==

# A dot-separated TVF name with numerals. This parses correctly but the TVF is
# not found.
select * from my.42dot.separated.tvf((select key from keyvalue))
--
ERROR: Table-valued function not found: my.`42dot`.separated.tvf [at 1:15]
select * from my.42dot.separated.tvf((select key from keyvalue))
              ^
==

# A dot-separated TVF name with numerals. This parses correctly but the TVF is
# not found.
select * from my.dot42.separated.tvf((select key from keyvalue))
--
ERROR: Table-valued function not found: my.dot42.separated.tvf [at 1:15]
select * from my.dot42.separated.tvf((select key from keyvalue))
              ^
==

# A dot-separated TVF name with numerals. This parses correctly but the TVF is
# not found.
select * from my.dot.separated.42((select key from keyvalue))
--
ERROR: Table-valued function not found: my.dot.separated.`42` [at 1:15]
select * from my.dot.separated.42((select key from keyvalue))
              ^
==

# Underscores are allowed in TVF names. This parses correctly but the TVF is not
# found.
select * from my.dot._separated.tvf((select key from keyvalue))
--
ERROR: Table-valued function not found: my.dot._separated.tvf [at 1:15]
select * from my.dot._separated.tvf((select key from keyvalue))
              ^
==

# The TVF has an alias. This parses correctly but the TVF is not found.
select * from my.dot.separated.tvf((select key from keyvalue)) myalias
--
ERROR: Table-valued function not found: my.dot.separated.tvf [at 1:15]
select * from my.dot.separated.tvf((select key from keyvalue)) myalias
              ^
==

# The TVF has an alias with the AS keyword. This parses correctly but the TVF is
# not found.
select * from my.dot.separated.tvf((select key from keyvalue)) AS myalias
--
ERROR: Table-valued function not found: my.dot.separated.tvf [at 1:15]
select * from my.dot.separated.tvf((select key from keyvalue)) AS myalias
              ^
==

# The TVF has a hint. This parses correctly but the TVF is not found.
select * from my.dot.separated.tvf((select key from keyvalue)) @{num_workers=42}
--
ERROR: Table-valued function not found: my.dot.separated.tvf [at 1:15]
select * from my.dot.separated.tvf((select key from keyvalue)) @{num_workers=42}
              ^
==

# The TVF has an alias and a hint. This parses correctly the TVF is not found.
select * from
my.dot.separated.tvf((select key from keyvalue)) @{num_workers=42} AS myalias
--
ERROR: Table-valued function not found: my.dot.separated.tvf [at 2:1]
my.dot.separated.tvf((select key from keyvalue)) @{num_workers=42} AS myalias
^
==

# Call a templated SQL TVF that contains a query parameter reference within the
# function body.
select * from tvf_templated_function_body_refer_to_parameter()
--
ERROR: Invalid table-valued function tvf_templated_function_body_refer_to_parameter [at 1:15]
select * from tvf_templated_function_body_refer_to_parameter()
              ^
Analysis of table-valued function tvf_templated_function_body_refer_to_parameter failed [at 1:8]
select @test_param_bool from keyvalue
       ^
Query parameters cannot be used inside SQL function bodies [at 1:8]
select @test_param_bool from keyvalue
       ^
==

# Call a templated SQL TVF that references itself directly. This should return
# an error.
select * from tvf_recursive()
--
ERROR: Invalid table-valued function tvf_recursive [at 1:15]
select * from tvf_recursive()
              ^
Analysis of table-valued function tvf_recursive failed [at 1:15]
select * from tvf_recursive()
              ^
Invalid table-valued function tvf_recursive [at 1:15]
select * from tvf_recursive()
              ^
The table function tvf_recursive is recursive
==

# Call a templated SQL TVF that references itself indirectly. This should return
# an error.
# TODO: finalize a consistent approach for error messages
# returned from calls to templated functions and modules.
select * from tvf_calls_self_indirectly_1()
--
ERROR: Invalid table-valued function tvf_calls_self_indirectly_1 [at 1:15]
select * from tvf_calls_self_indirectly_1()
              ^
Analysis of table-valued function tvf_calls_self_indirectly_1 failed [at 1:15]
select * from tvf_calls_self_indirectly_2()
              ^
Invalid table-valued function tvf_calls_self_indirectly_2 [at 1:15]
select * from tvf_calls_self_indirectly_2()
              ^
Analysis of table-valued function tvf_calls_self_indirectly_2 failed [at 1:15]
select * from tvf_calls_self_indirectly_1()
              ^
Invalid table-valued function tvf_calls_self_indirectly_1 [at 1:15]
select * from tvf_calls_self_indirectly_1()
              ^
Recursive dependencies detected when resolving table function tvf_calls_self_indirectly_1, which include objects (tvf_calls_self_indirectly_1, tvf_calls_self_indirectly_2, tvf_calls_self_indirectly_1)
==

# This query calls a TVF with a required output schema, passing an input value
# of a type that is not equal or coercible to the required output column.
select *
from tvf_templated_select_x_with_required_output_schema("abc");
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_x_with_required_output_schema.key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_x_with_required_output_schema.key#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_x_with_required_output_schema.key#1]
        +-tvf=tvf_templated_select_x_with_required_output_schema((ANY TYPE) -> TABLE<key INT64>)
        +-signature=(literal STRING) -> TABLE<key INT64>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value="abc")
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_x_with_required_output_schema(literal STRING) -> TABLE<key INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$subquery1.key#2 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$subquery1.key#2]
    +-expr_list=
    | +-key#2 :=
    |   +-Cast(STRING -> INT64)
    |     +-ColumnRef(type=STRING, column=$query.key#1)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$query.key#1]
        +-expr_list=
        | +-key#1 := ArgumentRef(type=STRING, name="x")
        +-input_scan=
          +-SingleRowScan
==

# This query calls a TVF with a required output schema, but the SQL body does
# not return a column with the required name.
select *
from tvf_templated_missing_output_column_with_required_output_schema("abc");
--
ERROR: Invalid table-valued function tvf_templated_missing_output_column_with_required_output_schema [at 2:6]
from tvf_templated_missing_output_column_with_required_output_schema("abc");
     ^
Analysis of table-valued function tvf_templated_missing_output_column_with_required_output_schema failed [at 1:1]
select x
^
Required column name key not returned from SQL body of CREATE TABLE FUNCTION statement
==

# This query calls a TVF with a required output schema, but the SQL body returns
# two columns with the same name as the required column. This is not allowed.
select *
from tvf_templated_duplicate_output_column_with_required_output_schema("abc");
--
ERROR: Invalid table-valued function tvf_templated_duplicate_output_column_with_required_output_schema [at 2:6]
from tvf_templated_duplicate_output_column_with_required_output_schema("abc");
     ^
Analysis of table-valued function tvf_templated_duplicate_output_column_with_required_output_schema failed [at 1:1]
select x as key, 42 as key
^
Required column name key returned multiple times from SQL body of CREATE TABLE FUNCTION statement
==

# This query calls a TVF with a required value-table output schema, but the SQL
# body returns a column with an incompatible type.
select *
from tvf_templated_select_x_with_required_value_table_output_schema(42);
--
ERROR: Invalid table-valued function tvf_templated_select_x_with_required_value_table_output_schema [at 2:6]
from tvf_templated_select_x_with_required_value_table_output_schema(42);
     ^
Analysis of table-valued function tvf_templated_select_x_with_required_value_table_output_schema failed [at 1:1]
select x
^
Value-table column for the output table of a CREATE TABLE FUNCTION statement has type STRING, but the SQL body provides incompatible type INT64 for the value-table column
==

# This query calls a TVF with a required value-table output schema and the SQL
# body returns untyped NULL.
select *
from tvf_templated_select_null_with_required_value_table_output_schema("abc");
--
ERROR: Invalid table-valued function tvf_templated_select_null_with_required_value_table_output_schema [at 2:6]
from tvf_templated_select_null_with_required_value_table_output_schema("abc");
     ^
Analysis of table-valued function tvf_templated_select_null_with_required_value_table_output_schema failed [at 1:1]
select null
^
Value-table column for the output table of a CREATE TABLE FUNCTION statement has type STRING, but the SQL body provides incompatible type INT64 for the value-table column
==

# SELECT * doesn't show the pseudo-columns.
# Note that the TableScan has them in the column_list, but the Project drops
# them.
select * from tvf_no_arg_returning_fixed_output_with_pseudo_columns();
--
QueryStmt
+-output_column_list=
| +-tvf_no_arg_returning_fixed_output_with_pseudo_columns.column_bool#1 AS column_bool [BOOL]
| +-tvf_no_arg_returning_fixed_output_with_pseudo_columns.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_no_arg_returning_fixed_output_with_pseudo_columns.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan(column_list=tvf_no_arg_returning_fixed_output_with_pseudo_columns.[column_bool#1, column_bytes#2], tvf=tvf_no_arg_returning_fixed_output_with_pseudo_columns(() -> TABLE<column_bool BOOL, column_bytes BYTES, RowId INT64, PartitionName STRING>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, RowId INT64, PartitionName STRING>, column_index_list=[0, 1])
==

select t.* from tvf_no_arg_returning_fixed_output_with_pseudo_columns() t;
--
QueryStmt
+-output_column_list=
| +-tvf_no_arg_returning_fixed_output_with_pseudo_columns.column_bool#1 AS column_bool [BOOL]
| +-tvf_no_arg_returning_fixed_output_with_pseudo_columns.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_no_arg_returning_fixed_output_with_pseudo_columns.[column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan(column_list=tvf_no_arg_returning_fixed_output_with_pseudo_columns.[column_bool#1, column_bytes#2], tvf=tvf_no_arg_returning_fixed_output_with_pseudo_columns(() -> TABLE<column_bool BOOL, column_bytes BYTES, RowId INT64, PartitionName STRING>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, RowId INT64, PartitionName STRING>, column_index_list=[0, 1], alias="t")
==

# The constructed struct for a table excludes pseudo-columns.
select t from tvf_no_arg_returning_fixed_output_with_pseudo_columns() t;
--
QueryStmt
+-output_column_list=
| +-$query.t#6 AS t [STRUCT<column_bool BOOL, column_bytes BYTES>]
+-query=
  +-ProjectScan
    +-column_list=[$query.t#6]
    +-expr_list=
    | +-t#6 :=
    |   +-MakeStruct
    |     +-type=STRUCT<column_bool BOOL, column_bytes BYTES>
    |     +-field_list=
    |       +-ColumnRef(type=BOOL, column=tvf_no_arg_returning_fixed_output_with_pseudo_columns.column_bool#1)
    |       +-ColumnRef(type=BYTES, column=tvf_no_arg_returning_fixed_output_with_pseudo_columns.column_bytes#2)
    +-input_scan=
      +-TVFScan(column_list=tvf_no_arg_returning_fixed_output_with_pseudo_columns.[column_bool#1, column_bytes#2], tvf=tvf_no_arg_returning_fixed_output_with_pseudo_columns(() -> TABLE<column_bool BOOL, column_bytes BYTES, RowId INT64, PartitionName STRING>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, RowId INT64, PartitionName STRING>, column_index_list=[0, 1], alias="t")
==

# Pseudo-columns are explicitly selectable.
select PartitionName, RowId, column_bool, column_bytes
  from tvf_no_arg_returning_fixed_output_with_pseudo_columns();
--
QueryStmt
+-output_column_list=
| +-tvf_no_arg_returning_fixed_output_with_pseudo_columns.PartitionName#4 AS PartitionName [STRING]
| +-tvf_no_arg_returning_fixed_output_with_pseudo_columns.RowId#3 AS RowId [INT64]
| +-tvf_no_arg_returning_fixed_output_with_pseudo_columns.column_bool#1 AS column_bool [BOOL]
| +-tvf_no_arg_returning_fixed_output_with_pseudo_columns.column_bytes#2 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_no_arg_returning_fixed_output_with_pseudo_columns.[PartitionName#4, RowId#3, column_bool#1, column_bytes#2]
    +-input_scan=
      +-TVFScan(column_list=tvf_no_arg_returning_fixed_output_with_pseudo_columns.[column_bool#1, column_bytes#2, RowId#3, PartitionName#4], tvf=tvf_no_arg_returning_fixed_output_with_pseudo_columns(() -> TABLE<column_bool BOOL, column_bytes BYTES, RowId INT64, PartitionName STRING>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES, RowId INT64, PartitionName STRING>, column_index_list=[0, 1, 2, 3])
==

# With a value table, pseudo-columns don't show up in the value or in *.
# Java diffs:
#      +-input_scan=
# -      +-TVFScan(column_list=[tvf_no_arg_returning_value_table_with_pseudo_columns.$col0#1], tvf=tvf_no_arg_returning_value_table_with_pseudo_columns(() -> TABLE<PROTO<zetasql_test__.TestExtraPB>, RowId INT64, PartitionName STRING>), signature=() -> TABLE<PROTO<zetasql_test__.TestExtraPB>, RowId INT64, PartitionName STRING>, alias="t")
# +      +-TVFScan(column_list=[tvf_no_arg_returning_value_table_with_pseudo_columns.$col0#1], tvf=tvf_no_arg_returning_value_table_with_pseudo_columns(() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>), signature=() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>, alias="t")
[no_java]
select t, * from tvf_no_arg_returning_value_table_with_pseudo_columns() t;
--
QueryStmt
+-output_column_list=
| +-tvf_no_arg_returning_value_table_with_pseudo_columns.$col0#1 AS t [PROTO<zetasql_test__.TestExtraPB>]
| +-$query.int32_val1#4 AS int32_val1 [INT32]
| +-$query.int32_val2#5 AS int32_val2 [INT32]
| +-$query.str_value#6 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[tvf_no_arg_returning_value_table_with_pseudo_columns.$col0#1, $query.int32_val1#4, $query.int32_val2#5, $query.str_value#6]
    +-expr_list=
    | +-int32_val1#4 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_no_arg_returning_value_table_with_pseudo_columns.$col0#1)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-int32_val2#5 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_no_arg_returning_value_table_with_pseudo_columns.$col0#1)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#6 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=tvf_no_arg_returning_value_table_with_pseudo_columns.$col0#1)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-TVFScan(column_list=[tvf_no_arg_returning_value_table_with_pseudo_columns.$col0#1], tvf=tvf_no_arg_returning_value_table_with_pseudo_columns(() -> TABLE<PROTO<zetasql_test__.TestExtraPB>, RowId INT64, PartitionName STRING>), signature=() -> TABLE<PROTO<zetasql_test__.TestExtraPB>, RowId INT64, PartitionName STRING>, column_index_list=[0], alias="t")
==

# Value table pseudo-columns can be selected unqualified or qualified.
# Java error:
# Unrecognized name: PartitionName [at 1:8]
# select PartitionName, t.RowId, t
#        ^
[no_java]
select PartitionName, t.RowId, t
  from tvf_no_arg_returning_value_table_with_pseudo_columns() t
--
QueryStmt
+-output_column_list=
| +-tvf_no_arg_returning_value_table_with_pseudo_columns.PartitionName#3 AS PartitionName [STRING]
| +-tvf_no_arg_returning_value_table_with_pseudo_columns.RowId#2 AS RowId [INT64]
| +-tvf_no_arg_returning_value_table_with_pseudo_columns.$col0#1 AS t [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=tvf_no_arg_returning_value_table_with_pseudo_columns.[PartitionName#3, RowId#2, $col0#1]
    +-input_scan=
      +-TVFScan(column_list=tvf_no_arg_returning_value_table_with_pseudo_columns.[$col0#1, RowId#2, PartitionName#3], tvf=tvf_no_arg_returning_value_table_with_pseudo_columns(() -> TABLE<PROTO<zetasql_test__.TestExtraPB>, RowId INT64, PartitionName STRING>), signature=() -> TABLE<PROTO<zetasql_test__.TestExtraPB>, RowId INT64, PartitionName STRING>, column_index_list=[0, 1, 2], alias="t")
==

# Regression test against b/182060963: Make sure the AST location of TVF
# arguments are correctly passed to FunctionResolver::AddCastOrConvertLiteral.
#
# The TVF signature is like:
#   tvf_named_struct_args(
#       struct_arg1 STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>>,
#       struct_arg2 STRUCT<field1 ARRAY<STRING>,
#                          field2 ARRAY<STRING>,
#                          field3 ARRAY<STRING>)
#
# Note the TVF call here specifies a wrong struct field name ('feild2__'
# instead of 'field2').
SELECT * FROM tvf_named_struct_args(
    STRUCT([""] AS field1, ["A","B"]AS field2),
    STRUCT(
        [""] AS field1,
        (ARRAY(SELECT v FROM UNNEST([""]) v WHERE v <> "")) AS field2__,
        [""] AS field3));
--
QueryStmt
+-output_column_list=
| +-tvf_named_struct_args.column_bool#2 AS column_bool [BOOL]
| +-tvf_named_struct_args.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-ProjectScan
    +-column_list=tvf_named_struct_args.[column_bool#2, column_bytes#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_named_struct_args.[column_bool#2, column_bytes#3]
        +-tvf=tvf_named_struct_args((STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>> struct_arg1, STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>, field3 ARRAY<STRING>> struct_arg2) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>>, STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>, field3 ARRAY<STRING>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>>, value={field1:[""], field2:["A", "B"]})
        | +-FunctionArgument
        |   +-expr=
        |     +-MakeStruct
        |       +-type=STRUCT<field1 ARRAY<STRING>, field2 ARRAY<STRING>, field3 ARRAY<STRING>>
        |       +-field_list=
        |         +-Literal(type=ARRAY<STRING>, value=[""])
        |         +-SubqueryExpr
        |         | +-type=ARRAY<STRING>
        |         | +-subquery_type=ARRAY
        |         | +-subquery=
        |         |   +-ProjectScan
        |         |     +-column_list=[$array.v#1]
        |         |     +-input_scan=
        |         |       +-FilterScan
        |         |         +-column_list=[$array.v#1]
        |         |         +-input_scan=
        |         |         | +-ArrayScan
        |         |         |   +-column_list=[$array.v#1]
        |         |         |   +-array_expr=
        |         |         |   | +-Literal(type=ARRAY<STRING>, value=[""])
        |         |         |   +-element_column=$array.v#1
        |         |         +-filter_expr=
        |         |           +-FunctionCall(ZetaSQL:$not_equal(STRING, STRING) -> BOOL)
        |         |             +-ColumnRef(type=STRING, column=$array.v#1)
        |         |             +-Literal(type=STRING, value="")
        |         +-Literal(type=ARRAY<STRING>, value=[""])
        +-column_index_list=[0, 1]
