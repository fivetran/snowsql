INSERT {{| IGNORE| REPLACE| UPDATE}} INTO KeyValue (key, value)
VALUES (1, 'one'), (2, 'two')
--
ALTERNATION GROUP: <empty>
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=INT64, value=1)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=STRING, value='one')
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=2)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value='two')
+-column_access_list=WRITE,WRITE
--
ALTERNATION GROUP:  IGNORE
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_mode=OR IGNORE
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=INT64, value=1)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=STRING, value='one')
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=2)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value='two')
+-column_access_list=WRITE,WRITE
--
ALTERNATION GROUP:  REPLACE
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_mode=OR REPLACE
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=INT64, value=1)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=STRING, value='one')
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=2)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value='two')
+-column_access_list=WRITE,WRITE
--
ALTERNATION GROUP:  UPDATE
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_mode=OR UPDATE
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=INT64, value=1)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=STRING, value='one')
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=2)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value='two')
+-column_access_list=WRITE,WRITE
==

INSERT KeyValue (kEy, vAlUe)
select {{key, value|*}} from KeyValue
ASSERT_ROWS_MODIFIED 10
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-assert_rows_modified=
| +-AssertRowsModified
|   +-rows=
|     +-Literal(type=INT64, value=10)
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-query=
| +-ProjectScan
|   +-column_list=KeyValue.[Key#3, Value#4]
|   +-input_scan=
|     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
+-query_output_column_list=KeyValue.[Key#3, Value#4]
+-column_access_list=WRITE,WRITE
==

INSERT KeyValue (key, value)
WITH subQ as (select * from KeyValue)
select * from subQ
ASSERT_ROWS_MODIFIED @test_param_int64
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-assert_rows_modified=
| +-AssertRowsModified
|   +-rows=
|     +-Parameter(type=INT64, name='test_param_int64')
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-query=
| +-WithScan
|   +-column_list=subQ.[Key#5, Value#6]
|   +-with_entry_list=
|   | +-WithEntry
|   |   +-with_query_name='subQ'
|   |   +-with_subquery=
|   |     +-ProjectScan
|   |       +-column_list=KeyValue.[Key#3, Value#4]
|   |       +-input_scan=
|   |         +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
|   +-query=
|     +-ProjectScan
|       +-column_list=subQ.[Key#5, Value#6]
|       +-input_scan=
|         +-WithRefScan(column_list=subQ.[Key#5, Value#6], with_query_name='subQ')
+-query_output_column_list=subQ.[Key#5, Value#6]
+-column_access_list=WRITE,WRITE
==

INSERT KeyValue (key, value)
VALUES (1, 'one')
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value='one')
+-column_access_list=WRITE,WRITE
==

INSERT KeyValue (value, key)
VALUES ('one', 1)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_column_list=KeyValue.[Value#2, Key#1]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=STRING, value='one')
|     +-DMLValue
|       +-value=
|         +-Literal(type=INT64, value=1)
+-column_access_list=WRITE,WRITE
==

# This is a widening coercion where an INT32 parameter is coerced to an INT64.
INSERT KeyValue (key)
VALUES (@test_param_int32)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-insert_column_list=[KeyValue.Key#1]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Cast(INT32 -> INT64)
|           +-Parameter(type=INT32, name='test_param_int32')
+-column_access_list=WRITE
==

INSERT KeyValue (key)
select key from TestTable
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-insert_column_list=[KeyValue.Key#1]
+-query=
| +-ProjectScan
|   +-column_list=[$insert_cast.key#6]
|   +-expr_list=
|   | +-key#6 :=
|   |   +-Cast(INT32 -> INT64)
|   |     +-ColumnRef(type=INT32, column=TestTable.key#3)
|   +-input_scan=
|     +-ProjectScan
|       +-column_list=[TestTable.key#3]
|       +-input_scan=
|         +-TableScan(column_list=[TestTable.key#3], table=TestTable, column_index_list=[0])
+-query_output_column_list=[$insert_cast.key#6]
+-column_access_list=WRITE
==

INSERT KeyValue (key)
VALUES (@test_param_uint32)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-insert_column_list=[KeyValue.Key#1]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Cast(UINT32 -> INT64)
|           +-Parameter(type=UINT32, name='test_param_uint32')
+-column_access_list=WRITE
==

INSERT KeyValue (key)
VALUES (@test_param_uint64)
--
ERROR: Value has type UINT64 which cannot be inserted into column Key, which has type INT64 [at 2:9]
VALUES (@test_param_uint64)
        ^
==

INSERT KeyValue (key)
VALUES (1.5)
--
ERROR: Value has type DOUBLE which cannot be inserted into column Key, which has type INT64 [at 2:9]
VALUES (1.5)
        ^
==

INSERT KeyValue (key)
VALUES (@test_param_double)
--
ERROR: Value has type DOUBLE which cannot be inserted into column Key, which has type INT64 [at 2:9]
VALUES (@test_param_double)
        ^
==

INSERT KeyValue (value)
VALUES (@test_param_string)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
+-insert_column_list=[KeyValue.Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Parameter(type=STRING, name='test_param_string')
+-column_access_list=WRITE
==

INSERT KeyValue (value)
VALUES (@test_param_bytes)
--
ERROR: Value has type BYTES which cannot be inserted into column Value, which has type STRING [at 2:9]
VALUES (@test_param_bytes)
        ^
==

INSERT KeyValue (value)
VALUES (@test_param_int64)
--
ERROR: Value has type INT64 which cannot be inserted into column Value, which has type STRING [at 2:9]
VALUES (@test_param_int64)
        ^
==

INSERT KeyValue (key, key)
select key, key from KeyValue
--
ERROR: INSERT has columns with duplicate name: key [at 1:23]
INSERT KeyValue (key, key)
                      ^
==

INSERT KeyValue (key, value, key)
VALUES (1, 'one', 2)
--
ERROR: INSERT has columns with duplicate name: key [at 1:30]
INSERT KeyValue (key, value, key)
                             ^
==

INSERT KeyValue (key, value)
VALUES (1, 'one'), (2)
--
ERROR: Inserted row has wrong column count; Has 1, expected 2 [at 2:20]
VALUES (1, 'one'), (2)
                   ^
==

INSERT KeyValue (key, value)
VALUES ('one'), (2, 'two')
--
ERROR: Inserted row has wrong column count; Has 1, expected 2 [at 2:8]
VALUES ('one'), (2, 'two')
       ^
==

INSERT KeyValue (key)
VALUES (1, 2)
--
ERROR: Inserted row has wrong column count; Has 2, expected 1 [at 2:8]
VALUES (1, 2)
       ^
==

INSERT KeyValue (key, value, k1)
VALUES (1, 'one', 1)
--
ERROR: Column k1 is not present in table KeyValue [at 1:30]
INSERT KeyValue (key, value, k1)
                             ^
==

# Mismatched order of columns.
INSERT KeyValue (value, key)
select key, value from KeyValue
--
ERROR: Query column 1 has type INT64 which cannot be inserted into column Value, which has type STRING [at 2:1]
select key, value from KeyValue
^
==

INSERT KeyValue (key, value)
VALUES (1, 2)
--
ERROR: Value has type INT64 which cannot be inserted into column Value, which has type STRING [at 2:12]
VALUES (1, 2)
           ^
==

INSERT KeyValue (value, key)
VALUES (1, 2)
--
ERROR: Value has type INT64 which cannot be inserted into column Value, which has type STRING [at 2:9]
VALUES (1, 2)
        ^
==

INSERT TestTable (TestEnum)
VALUES (1), ('TESTENUM0')
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[TestTable.TestEnum#2], table=TestTable, column_index_list=[1])
+-insert_column_list=[TestTable.TestEnum#2]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
+-column_access_list=WRITE
==

INSERT TestTable (TestEnum)
VALUES ("INVALID_ENUM")
--
ERROR: Could not cast literal "INVALID_ENUM" to type zetasql_test__.TestEnum [at 2:9]
VALUES ("INVALID_ENUM")
        ^
==

INSERT KeyValue
select * from KeyValue
--
ERROR: INSERT must specify a column list [at 1:1]
INSERT KeyValue
^
==

# Omit column list using SELECT subquery
[language_features=V_1_3_OMIT_INSERT_COLUMN_LIST]
INSERT KeyValue
select * from KeyValue
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-query=
| +-ProjectScan
|   +-column_list=KeyValue.[Key#3, Value#4]
|   +-input_scan=
|     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
+-query_output_column_list=KeyValue.[Key#3, Value#4]
+-column_access_list=WRITE,WRITE
==

# Omit column list using VALUES
[language_features=V_1_3_OMIT_INSERT_COLUMN_LIST]
INSERT KeyValue VALUES(0, 'abc')
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=0)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value='abc')
+-column_access_list=WRITE,WRITE
==

# Omit column list using SELECT subquery but mismatched number of column
[language_features=V_1_3_OMIT_INSERT_COLUMN_LIST]
INSERT KeyValue
select *, 1 from KeyValue
--
ERROR: Inserted row has wrong column count; Has 3, expected 2 [at 2:1]
select *, 1 from KeyValue
^
==

# Omit column list using VALUES but mismatched number of column
[language_features=V_1_3_OMIT_INSERT_COLUMN_LIST]
INSERT KeyValue VALUES(1, 'abc', 100)
--
ERROR: Inserted row has wrong column count; Has 3, expected 2 [at 1:23]
INSERT KeyValue VALUES(1, 'abc', 100)
                      ^
==

# Omit column list using SELECT subquery but mismatched column type
[language_features=V_1_3_OMIT_INSERT_COLUMN_LIST]
INSERT KeyValue
select 1, 100
--
ERROR: Query column 2 has type INT64 which cannot be inserted into column Value, which has type STRING [at 2:1]
select 1, 100
^
==

# Omit column list using VALUES but mismatched column type
[language_features=V_1_3_OMIT_INSERT_COLUMN_LIST]
INSERT KeyValue VALUES(1, 100)
--
ERROR: Value has type INT64 which cannot be inserted into column Value, which has type STRING [at 1:27]
INSERT KeyValue VALUES(1, 100)
                          ^
==

# Pseudo-columns are excluded when omitting column list
[language_features=V_1_3_OMIT_INSERT_COLUMN_LIST]
INSERT EnumTable
select * from EnumTable
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3], table=EnumTable, column_index_list=[0, 1, 2])
+-insert_column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3]
+-query=
| +-ProjectScan
|   +-column_list=EnumTable.[key#6, TestEnum#7, AnotherTestEnum#8]
|   +-input_scan=
|     +-TableScan(column_list=EnumTable.[key#6, TestEnum#7, AnotherTestEnum#8], table=EnumTable, column_index_list=[0, 1, 2])
+-query_output_column_list=EnumTable.[key#6, TestEnum#7, AnotherTestEnum#8]
+-column_access_list=WRITE,WRITE,WRITE
==

# Pseudo-columns are excluded when omitting column list
[language_features=V_1_3_OMIT_INSERT_COLUMN_LIST]
INSERT EnumTable
VALUES (100, 'TESTENUM0', 'ANOTHERTESTENUM2')
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3], table=EnumTable, column_index_list=[0, 1, 2])
+-insert_column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT32, value=100)
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
|     +-DMLValue
|       +-value=
|         +-Literal(type=ENUM<zetasql_test__.AnotherTestEnum>, value=ANOTHERTESTENUM2)
+-column_access_list=WRITE,WRITE,WRITE
==

# All columns are pseudo-columns
[language_features=V_1_3_OMIT_INSERT_COLUMN_LIST]
INSERT AllPseudoColumns
SELECT * FROM AllPseudoColumns
--
ERROR: No writable column in target table [at 1:1]
INSERT AllPseudoColumns
^
==

# Non-writable columns are excluded
[language_features=V_1_3_OMIT_INSERT_COLUMN_LIST]
INSERT AllNonKeysNonWritable
SELECT key FROM AllNonKeysNonWritable
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[AllNonKeysNonWritable.Key#1], table=AllNonKeysNonWritable, column_index_list=[0])
+-insert_column_list=[AllNonKeysNonWritable.Key#1]
+-query=
| +-ProjectScan
|   +-column_list=[AllNonKeysNonWritable.Key#6]
|   +-input_scan=
|     +-TableScan(column_list=[AllNonKeysNonWritable.Key#6], table=AllNonKeysNonWritable, column_index_list=[0])
+-query_output_column_list=[AllNonKeysNonWritable.Key#6]
+-column_access_list=WRITE
==

INSERT KitchenSinkValueTable {{|(value)}}
select KitchenSink from TestTable
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0])
+-insert_column_list=[KitchenSinkValueTable.value#1]
+-query=
| +-ProjectScan
|   +-column_list=[TestTable.KitchenSink#4]
|   +-input_scan=
|     +-TableScan(column_list=[TestTable.KitchenSink#4], table=TestTable, column_index_list=[2])
+-query_output_column_list=[TestTable.KitchenSink#4]
+-column_access_list=WRITE
==

INSERT KitchenSinkValueTable
select as "zetasql_test__.KitchenSinkPB" 1 as int64_key_1, 2 as int64_key_2
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0])
+-insert_column_list=[KitchenSinkValueTable.value#1]
+-query=
| +-ProjectScan
|   +-column_list=[$make_proto.$proto#4]
|   +-expr_list=
|   | +-$proto#4 :=
|   |   +-MakeProto
|   |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
|   |     +-field_list=
|   |       +-int64_key_1 := ColumnRef(type=INT64, column=$insert.int64_key_1#2)
|   |       +-int64_key_2 := ColumnRef(type=INT64, column=$insert.int64_key_2#3)
|   +-input_scan=
|     +-ProjectScan
|       +-column_list=$insert.[int64_key_1#2, int64_key_2#3]
|       +-expr_list=
|       | +-int64_key_1#2 := Literal(type=INT64, value=1)
|       | +-int64_key_2#3 := Literal(type=INT64, value=2)
|       +-input_scan=
|         +-SingleRowScan
+-query_output_column_list=[$make_proto.$proto#4]
+-column_access_list=WRITE
==

INSERT KitchenSinkValueTable
VALUES ((select KitchenSink from TestTable)),
       (1, "a")
--
ERROR: Inserted row has wrong column count; Has 2, expected 1 [at 3:8]
       (1, "a")
       ^
==

INSERT KitchenSinkValueTable
select key, value from KeyValue
--
ERROR: Inserted row has wrong column count; Has 2, expected 1 [at 2:1]
select key, value from KeyValue
^
==

INSERT KeyValue (key)
{{VALUES (key)|select key}}
--
ALTERNATION GROUP: VALUES (key)
--
ERROR: Unrecognized name: key [at 2:9]
VALUES (key)
        ^
--
ALTERNATION GROUP: select key
--
ERROR: Unrecognized name: key [at 2:8]
select key
       ^
==

INSERT KeyValue (key, value)
(select * from KeyValue UNION ALL (select * from KeyValue))
ORDER BY 1
LIMIT 5
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-query=
| +-LimitOffsetScan
|   +-column_list=$union_all.[Key#7, Value#8]
|   +-is_ordered=TRUE
|   +-input_scan=
|   | +-OrderByScan
|   |   +-column_list=$union_all.[Key#7, Value#8]
|   |   +-is_ordered=TRUE
|   |   +-input_scan=
|   |   | +-SetOperationScan
|   |   |   +-column_list=$union_all.[Key#7, Value#8]
|   |   |   +-op_type=UNION_ALL
|   |   |   +-input_item_list=
|   |   |     +-SetOperationItem
|   |   |     | +-scan=
|   |   |     | | +-ProjectScan
|   |   |     | |   +-column_list=KeyValue.[Key#3, Value#4]
|   |   |     | |   +-input_scan=
|   |   |     | |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
|   |   |     | +-output_column_list=KeyValue.[Key#3, Value#4]
|   |   |     +-SetOperationItem
|   |   |       +-scan=
|   |   |       | +-ProjectScan
|   |   |       |   +-column_list=KeyValue.[Key#5, Value#6]
|   |   |       |   +-input_scan=
|   |   |       |     +-TableScan(column_list=KeyValue.[Key#5, Value#6], table=KeyValue, column_index_list=[0, 1])
|   |   |       +-output_column_list=KeyValue.[Key#5, Value#6]
|   |   +-order_by_item_list=
|   |     +-OrderByItem
|   |       +-column_ref=
|   |         +-ColumnRef(type=INT64, column=$union_all.Key#7)
|   +-limit=
|     +-Literal(type=INT64, value=5)
+-query_output_column_list=$union_all.[Key#7, Value#8]
+-column_access_list=WRITE,WRITE
==

INSERT TestTable (key, KitchenSink)
VALUES (CAST(1 as INT32),
        (select as "zetasql_test__.KitchenSinkPB"
           1 as int64_key_1, 2 as int64_key_2)),
       (1, "int64_key_1: 1, int64_key_2: 2")
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
+-insert_column_list=TestTable.[key#1, KitchenSink#3]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
| |   +-DMLValue
| |     +-value=
| |       +-SubqueryExpr
| |         +-type=PROTO<zetasql_test__.KitchenSinkPB>
| |         +-subquery_type=SCALAR
| |         +-subquery=
| |           +-ProjectScan
| |             +-column_list=[$make_proto.$proto#6]
| |             +-expr_list=
| |             | +-$proto#6 :=
| |             |   +-MakeProto
| |             |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
| |             |     +-field_list=
| |             |       +-int64_key_1 := ColumnRef(type=INT64, column=$expr_subquery.int64_key_1#4)
| |             |       +-int64_key_2 := ColumnRef(type=INT64, column=$expr_subquery.int64_key_2#5)
| |             +-input_scan=
| |               +-ProjectScan
| |                 +-column_list=$expr_subquery.[int64_key_1#4, int64_key_2#5]
| |                 +-expr_list=
| |                 | +-int64_key_1#4 := Literal(type=INT64, value=1)
| |                 | +-int64_key_2#5 := Literal(type=INT64, value=2)
| |                 +-input_scan=
| |                   +-SingleRowScan
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT32, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={int64_key_1: 1 int64_key_2: 2})
+-column_access_list=WRITE,WRITE
==

INSERT TestTable (KitchenSink)
VALUES ("aaa")
--
ERROR: Could not cast literal "aaa" to type zetasql_test__.KitchenSinkPB (Error parsing proto: Message type "zetasql_test__.KitchenSinkPB" has no field named "aaa". [1:4]) [at 2:9]
VALUES ("aaa")
        ^
==

[no_test_extract_table_names]
INSERT nested_catalog.NestedKeyValue (key, value)
select * from KeyValue where exists(select key from KeyValue)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-query=
| +-ProjectScan
|   +-column_list=KeyValue.[Key#3, Value#4]
|   +-input_scan=
|     +-FilterScan
|       +-column_list=KeyValue.[Key#3, Value#4]
|       +-input_scan=
|       | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
|       +-filter_expr=
|         +-SubqueryExpr
|           +-type=BOOL
|           +-subquery_type=EXISTS
|           +-subquery=
|             +-ProjectScan
|               +-column_list=[KeyValue.Key#5]
|               +-input_scan=
|                 +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0])
+-query_output_column_list=KeyValue.[Key#3, Value#4]
+-column_access_list=WRITE,WRITE
==

INSERT ComplexTypes (Int32Array, key)
VALUES ([CAST(1 AS INT32), 2], 1),
       (ARRAY(select key from TestTable), (select key from TestTable)),
       ((select Int32Array from ComplexTypes),
        (select * from UNNEST(@test_param_array)))
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=ComplexTypes.[key#1, Int32Array#4], table=ComplexTypes, column_index_list=[0, 3])
+-insert_column_list=ComplexTypes.[Int32Array#4, key#1]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-Literal(type=ARRAY<INT32>, value=[1, 2], has_explicit_type=TRUE)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=INT32, value=1)
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-SubqueryExpr
| |   |     +-type=ARRAY<INT32>
| |   |     +-subquery_type=ARRAY
| |   |     +-subquery=
| |   |       +-ProjectScan
| |   |         +-column_list=[TestTable.key#7]
| |   |         +-input_scan=
| |   |           +-TableScan(column_list=[TestTable.key#7], table=TestTable, column_index_list=[0])
| |   +-DMLValue
| |     +-value=
| |       +-SubqueryExpr
| |         +-type=INT32
| |         +-subquery_type=SCALAR
| |         +-subquery=
| |           +-ProjectScan
| |             +-column_list=[TestTable.key#10]
| |             +-input_scan=
| |               +-TableScan(column_list=[TestTable.key#10], table=TestTable, column_index_list=[0])
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-SubqueryExpr
|     |     +-type=ARRAY<INT32>
|     |     +-subquery_type=SCALAR
|     |     +-subquery=
|     |       +-ProjectScan
|     |         +-column_list=[ComplexTypes.Int32Array#16]
|     |         +-input_scan=
|     |           +-TableScan(column_list=[ComplexTypes.Int32Array#16], table=ComplexTypes, column_index_list=[3])
|     +-DMLValue
|       +-value=
|         +-SubqueryExpr
|           +-type=INT32
|           +-subquery_type=SCALAR
|           +-subquery=
|             +-ProjectScan
|               +-column_list=[$array.$unnest1#19]
|               +-input_scan=
|                 +-ArrayScan
|                   +-column_list=[$array.$unnest1#19]
|                   +-array_expr=
|                   | +-Parameter(type=ARRAY<INT32>, name='test_param_array')
|                   +-element_column=$array.$unnest1#19
+-column_access_list=WRITE,WRITE
==

# Inserting values into a pseudo column.
INSERT EnumTable (Filename)
VALUES ("name")
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[EnumTable.Filename#4], table=EnumTable, column_index_list=[3])
+-insert_column_list=[EnumTable.Filename#4]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value='name')
+-column_access_list=WRITE
==

INSERT KeyValue (key, value)
VALUES (NULL, NULL)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=NULL)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value=NULL)
+-column_access_list=WRITE,WRITE
==

INSERT ComplexTypes (key, TestEnum, KitchenSink, Int32Array, TestStruct, TestProto)
select NULL, NULL, NULL, NULL, NULL, NULL
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=ComplexTypes.[key#1, TestEnum#2, KitchenSink#3, Int32Array#4, TestStruct#5, TestProto#6], table=ComplexTypes, column_index_list=[0, 1, 2, 3, 4, 5])
+-insert_column_list=ComplexTypes.[key#1, TestEnum#2, KitchenSink#3, Int32Array#4, TestStruct#5, TestProto#6]
+-query=
| +-ProjectScan
|   +-column_list=$insert_cast.[$col1#13, $col2#14, $col3#15, $col4#16, $col5#17, $col6#18]
|   +-expr_list=
|   | +-$col1#13 := Literal(type=INT32, value=NULL)
|   | +-$col2#14 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=NULL)
|   | +-$col3#15 := Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value=NULL)
|   | +-$col4#16 := Literal(type=ARRAY<INT32>, value=NULL)
|   | +-$col5#17 := Literal(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, value=NULL)
|   | +-$col6#18 := Literal(type=PROTO<zetasql_test__.TestExtraPB>, value=NULL)
|   +-input_scan=
|     +-ProjectScan
|       +-column_list=$insert.[$col1#7, $col2#8, $col3#9, $col4#10, $col5#11, $col6#12]
|       +-expr_list=
|       | +-$col1#7 := Literal(type=INT64, value=NULL)
|       | +-$col2#8 := Literal(type=INT64, value=NULL)
|       | +-$col3#9 := Literal(type=INT64, value=NULL)
|       | +-$col4#10 := Literal(type=INT64, value=NULL)
|       | +-$col5#11 := Literal(type=INT64, value=NULL)
|       | +-$col6#12 := Literal(type=INT64, value=NULL)
|       +-input_scan=
|         +-SingleRowScan
+-query_output_column_list=$insert_cast.[$col1#13, $col2#14, $col3#15, $col4#16, $col5#17, $col6#18]
+-column_access_list=WRITE,WRITE,WRITE,WRITE,WRITE,WRITE
==

INSERT KitchenSinkValueTable
select NULL
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0])
+-insert_column_list=[KitchenSinkValueTable.value#1]
+-query=
| +-ProjectScan
|   +-column_list=[$insert_cast.$col1#3]
|   +-expr_list=
|   | +-$col1#3 := Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value=NULL)
|   +-input_scan=
|     +-ProjectScan
|       +-column_list=[$insert.$col1#2]
|       +-expr_list=
|       | +-$col1#2 := Literal(type=INT64, value=NULL)
|       +-input_scan=
|         +-SingleRowScan
+-query_output_column_list=[$insert_cast.$col1#3]
+-column_access_list=WRITE
==

INSERT ComplexTypes (Int32Array)
select []
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[ComplexTypes.Int32Array#4], table=ComplexTypes, column_index_list=[3])
+-insert_column_list=[ComplexTypes.Int32Array#4]
+-query=
| +-ProjectScan
|   +-column_list=[$insert_cast.$col1#8]
|   +-expr_list=
|   | +-$col1#8 := Literal(type=ARRAY<INT32>, value=[])
|   +-input_scan=
|     +-ProjectScan
|       +-column_list=[$insert.$col1#7]
|       +-expr_list=
|       | +-$col1#7 := Literal(type=ARRAY<INT64>, value=[])
|       +-input_scan=
|         +-SingleRowScan
+-query_output_column_list=[$insert_cast.$col1#8]
+-column_access_list=WRITE
==

# Typed null literal is not coerced.
INSERT KeyValue (value)
SELECT CAST(NULL AS INT64)
--
ERROR: Query column 1 has type INT64 which cannot be inserted into column Value, which has type STRING [at 2:1]
SELECT CAST(NULL AS INT64)
^
==

# Typed empty array literal is not coerced.
INSERT ComplexTypes (Int32Array)
select ARRAY<INT64>[NULL]
--
ERROR: Query column 1 has type ARRAY<INT64> which cannot be inserted into column Int32Array, which has type ARRAY<INT32> [at 2:1]
select ARRAY<INT64>[NULL]
^
==

# Non-empty array literal is not coerced.
INSERT ComplexTypes (Int32Array)
select [NULL]
--
ERROR: Query column 1 has type ARRAY<INT64> which cannot be inserted into column Int32Array, which has type ARRAY<INT32> [at 2:1]
select [NULL]
^
==

# Empty array literal cannot be coerced to non-array types.
INSERT KeyValue (key)
select []
--
ERROR: Could not cast literal [] to type INT64 [at 2:8]
select []
       ^
==

INSERT KeyValue (value, key)
VALUES (DEFAULT, DEFAULT),
       (DEFAULT, 5),
       ("a", DEFAULT)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_column_list=KeyValue.[Value#2, Key#1]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-DMLDefault(type=STRING)
| |   +-DMLValue
| |     +-value=
| |       +-DMLDefault(type=INT64)
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |   | +-value=
| |   |   +-DMLDefault(type=STRING)
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=INT64, value=5)
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=STRING, value='a')
|     +-DMLValue
|       +-value=
|         +-DMLDefault(type=INT64)
+-column_access_list=WRITE,WRITE
==

# DEFAULT is not supported in queries.
INSERT KeyValue (key, value)
select DEFAULT, DEFAULT
--
ERROR: Syntax error: Unexpected keyword DEFAULT [at 2:8]
select DEFAULT, DEFAULT
       ^
==

INSERT KitchenSinkValueTable
VALUES (DEFAULT)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0])
+-insert_column_list=[KitchenSinkValueTable.value#1]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-DMLDefault(type=PROTO<zetasql_test__.KitchenSinkPB>)
+-column_access_list=WRITE
==

INSERT KeyValue (value, key)
VALUES (NULL, DEFAULT)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_column_list=KeyValue.[Value#2, Key#1]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=STRING, value=NULL)
|     +-DMLValue
|       +-value=
|         +-DMLDefault(type=INT64)
+-column_access_list=WRITE,WRITE
==

INSERT ComplexTypes (TestStruct)
VALUES ((select as struct 1 c, (select as struct 1 a, "a" b) d))
--
ERROR: Value has type STRUCT<c INT64, d STRUCT<a INT64, b STRING>> which cannot be inserted into column TestStruct, which has type STRUCT<c INT32, d STRUCT<a INT32, b STRING>> [at 2:9]
VALUES ((select as struct 1 c, (select as struct 1 a, "a" b) d))
        ^
==

INSERT ComplexTypes (TestStruct)
VALUES ((select as struct CAST(1 AS INT32) c,
         (select as struct CAST(1 AS INT32) a, "a" b) d))
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4])
+-insert_column_list=[ComplexTypes.TestStruct#5]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-SubqueryExpr
|           +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
|           +-subquery_type=SCALAR
|           +-subquery=
|             +-ProjectScan
|               +-column_list=[$make_struct.$struct#12]
|               +-expr_list=
|               | +-$struct#12 :=
|               |   +-MakeStruct
|               |     +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
|               |     +-field_list=
|               |       +-ColumnRef(type=INT32, column=$expr_subquery.c#10)
|               |       +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$expr_subquery.d#11)
|               +-input_scan=
|                 +-ProjectScan
|                   +-column_list=$expr_subquery.[c#10, d#11]
|                   +-expr_list=
|                   | +-c#10 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
|                   | +-d#11 :=
|                   |   +-SubqueryExpr
|                   |     +-type=STRUCT<a INT32, b STRING>
|                   |     +-subquery_type=SCALAR
|                   |     +-subquery=
|                   |       +-ProjectScan
|                   |         +-column_list=[$make_struct.$struct#9]
|                   |         +-expr_list=
|                   |         | +-$struct#9 :=
|                   |         |   +-MakeStruct
|                   |         |     +-type=STRUCT<a INT32, b STRING>
|                   |         |     +-field_list=
|                   |         |       +-ColumnRef(type=INT32, column=$expr_subquery.a#7)
|                   |         |       +-ColumnRef(type=STRING, column=$expr_subquery.b#8)
|                   |         +-input_scan=
|                   |           +-ProjectScan
|                   |             +-column_list=$expr_subquery.[a#7, b#8]
|                   |             +-expr_list=
|                   |             | +-a#7 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
|                   |             | +-b#8 := Literal(type=STRING, value='a')
|                   |             +-input_scan=
|                   |               +-SingleRowScan
|                   +-input_scan=
|                     +-SingleRowScan
+-column_access_list=WRITE
==

# Same test as previous, but with different field names.
INSERT ComplexTypes (TestStruct)
VALUES ((select as struct CAST(1 AS INT32) x,
         (select as struct CAST(1 AS INT32) z1, "a" z2) y))
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4])
+-insert_column_list=[ComplexTypes.TestStruct#5]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Cast(STRUCT<x INT32, y STRUCT<z1 INT32, z2 STRING>> -> STRUCT<c INT32, d STRUCT<a INT32, b STRING>>)
|           +-SubqueryExpr
|             +-type=STRUCT<x INT32, y STRUCT<z1 INT32, z2 STRING>>
|             +-subquery_type=SCALAR
|             +-subquery=
|               +-ProjectScan
|                 +-column_list=[$make_struct.$struct#12]
|                 +-expr_list=
|                 | +-$struct#12 :=
|                 |   +-MakeStruct
|                 |     +-type=STRUCT<x INT32, y STRUCT<z1 INT32, z2 STRING>>
|                 |     +-field_list=
|                 |       +-ColumnRef(type=INT32, column=$expr_subquery.x#10)
|                 |       +-ColumnRef(type=STRUCT<z1 INT32, z2 STRING>, column=$expr_subquery.y#11)
|                 +-input_scan=
|                   +-ProjectScan
|                     +-column_list=$expr_subquery.[x#10, y#11]
|                     +-expr_list=
|                     | +-x#10 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
|                     | +-y#11 :=
|                     |   +-SubqueryExpr
|                     |     +-type=STRUCT<z1 INT32, z2 STRING>
|                     |     +-subquery_type=SCALAR
|                     |     +-subquery=
|                     |       +-ProjectScan
|                     |         +-column_list=[$make_struct.$struct#9]
|                     |         +-expr_list=
|                     |         | +-$struct#9 :=
|                     |         |   +-MakeStruct
|                     |         |     +-type=STRUCT<z1 INT32, z2 STRING>
|                     |         |     +-field_list=
|                     |         |       +-ColumnRef(type=INT32, column=$expr_subquery.z1#7)
|                     |         |       +-ColumnRef(type=STRING, column=$expr_subquery.z2#8)
|                     |         +-input_scan=
|                     |           +-ProjectScan
|                     |             +-column_list=$expr_subquery.[z1#7, z2#8]
|                     |             +-expr_list=
|                     |             | +-z1#7 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
|                     |             | +-z2#8 := Literal(type=STRING, value='a')
|                     |             +-input_scan=
|                     |               +-SingleRowScan
|                     +-input_scan=
|                       +-SingleRowScan
+-column_access_list=WRITE
==

# Similar test as previous (with different field names) but with
# a struct constructor literal that is coerced to the target type.
INSERT ComplexTypes (TestStruct)
VALUES (STRUCT(1 AS x, STRUCT(1 as z1, "a" AS z2) AS y));
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4])
+-insert_column_list=[ComplexTypes.TestStruct#5]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, value={c:1, d:{a:1, b:"a"}})
+-column_access_list=WRITE
==

# Similar test as previous (with different field names) but with
# a non-literal struct constructor.
INSERT ComplexTypes (TestStruct)
VALUES (STRUCT(CAST(1 AS INT32) AS x, STRUCT(1 as z1, "a" AS z2) AS y));
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4])
+-insert_column_list=[ComplexTypes.TestStruct#5]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-MakeStruct
|           +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
|           +-field_list=
|             +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
|             +-Literal(type=STRUCT<a INT32, b STRING>, value={a:1, b:"a"})
+-column_access_list=WRITE
==

INSERT ComplexTypes (TestStruct)
select as struct CAST(1 AS INT32) c, (select as struct CAST(1 AS INT32) a, "2" b) d
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4])
+-insert_column_list=[ComplexTypes.TestStruct#5]
+-query=
| +-ProjectScan
|   +-column_list=[$make_struct.$struct#12]
|   +-expr_list=
|   | +-$struct#12 :=
|   |   +-MakeStruct
|   |     +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
|   |     +-field_list=
|   |       +-ColumnRef(type=INT32, column=$insert.c#10)
|   |       +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$insert.d#11)
|   +-input_scan=
|     +-ProjectScan
|       +-column_list=$insert.[c#10, d#11]
|       +-expr_list=
|       | +-c#10 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
|       | +-d#11 :=
|       |   +-SubqueryExpr
|       |     +-type=STRUCT<a INT32, b STRING>
|       |     +-subquery_type=SCALAR
|       |     +-subquery=
|       |       +-ProjectScan
|       |         +-column_list=[$make_struct.$struct#9]
|       |         +-expr_list=
|       |         | +-$struct#9 :=
|       |         |   +-MakeStruct
|       |         |     +-type=STRUCT<a INT32, b STRING>
|       |         |     +-field_list=
|       |         |       +-ColumnRef(type=INT32, column=$expr_subquery.a#7)
|       |         |       +-ColumnRef(type=STRING, column=$expr_subquery.b#8)
|       |         +-input_scan=
|       |           +-ProjectScan
|       |             +-column_list=$expr_subquery.[a#7, b#8]
|       |             +-expr_list=
|       |             | +-a#7 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
|       |             | +-b#8 := Literal(type=STRING, value='2')
|       |             +-input_scan=
|       |               +-SingleRowScan
|       +-input_scan=
|         +-SingleRowScan
+-query_output_column_list=[$make_struct.$struct#12]
+-column_access_list=WRITE
==

# Same test as previous, but with different field names.
INSERT ComplexTypes (TestStruct)
select as struct CAST(1 AS INT32) x,
                 (select as struct CAST(1 AS INT32) z1, "2" z2) y
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4])
+-insert_column_list=[ComplexTypes.TestStruct#5]
+-query=
| +-ProjectScan
|   +-column_list=[$insert_cast.$struct#13]
|   +-expr_list=
|   | +-$struct#13 :=
|   |   +-Cast(STRUCT<x INT32, y STRUCT<z1 INT32, z2 STRING>> -> STRUCT<c INT32, d STRUCT<a INT32, b STRING>>)
|   |     +-ColumnRef(type=STRUCT<x INT32, y STRUCT<z1 INT32, z2 STRING>>, column=$make_struct.$struct#12)
|   +-input_scan=
|     +-ProjectScan
|       +-column_list=[$make_struct.$struct#12]
|       +-expr_list=
|       | +-$struct#12 :=
|       |   +-MakeStruct
|       |     +-type=STRUCT<x INT32, y STRUCT<z1 INT32, z2 STRING>>
|       |     +-field_list=
|       |       +-ColumnRef(type=INT32, column=$insert.x#10)
|       |       +-ColumnRef(type=STRUCT<z1 INT32, z2 STRING>, column=$insert.y#11)
|       +-input_scan=
|         +-ProjectScan
|           +-column_list=$insert.[x#10, y#11]
|           +-expr_list=
|           | +-x#10 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
|           | +-y#11 :=
|           |   +-SubqueryExpr
|           |     +-type=STRUCT<z1 INT32, z2 STRING>
|           |     +-subquery_type=SCALAR
|           |     +-subquery=
|           |       +-ProjectScan
|           |         +-column_list=[$make_struct.$struct#9]
|           |         +-expr_list=
|           |         | +-$struct#9 :=
|           |         |   +-MakeStruct
|           |         |     +-type=STRUCT<z1 INT32, z2 STRING>
|           |         |     +-field_list=
|           |         |       +-ColumnRef(type=INT32, column=$expr_subquery.z1#7)
|           |         |       +-ColumnRef(type=STRING, column=$expr_subquery.z2#8)
|           |         +-input_scan=
|           |           +-ProjectScan
|           |             +-column_list=$expr_subquery.[z1#7, z2#8]
|           |             +-expr_list=
|           |             | +-z1#7 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
|           |             | +-z2#8 := Literal(type=STRING, value='2')
|           |             +-input_scan=
|           |               +-SingleRowScan
|           +-input_scan=
|             +-SingleRowScan
+-query_output_column_list=[$insert_cast.$struct#13]
+-column_access_list=WRITE
==

INSERT MoreComplexTypes (ArrayOfStruct)
VALUES ([(select as struct CAST(1 AS INT32) a, "b" b), NULL]);
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[MoreComplexTypes.ArrayOfStruct#2], table=MoreComplexTypes, column_index_list=[1])
+-insert_column_list=[MoreComplexTypes.ArrayOfStruct#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRUCT<a INT32, b STRING>) -> ARRAY<STRUCT<a INT32, b STRING>>)
|           +-SubqueryExpr
|           | +-type=STRUCT<a INT32, b STRING>
|           | +-subquery_type=SCALAR
|           | +-subquery=
|           |   +-ProjectScan
|           |     +-column_list=[$make_struct.$struct#6]
|           |     +-expr_list=
|           |     | +-$struct#6 :=
|           |     |   +-MakeStruct
|           |     |     +-type=STRUCT<a INT32, b STRING>
|           |     |     +-field_list=
|           |     |       +-ColumnRef(type=INT32, column=$expr_subquery.a#4)
|           |     |       +-ColumnRef(type=STRING, column=$expr_subquery.b#5)
|           |     +-input_scan=
|           |       +-ProjectScan
|           |         +-column_list=$expr_subquery.[a#4, b#5]
|           |         +-expr_list=
|           |         | +-a#4 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
|           |         | +-b#5 := Literal(type=STRING, value='b')
|           |         +-input_scan=
|           |           +-SingleRowScan
|           +-Literal(type=STRUCT<a INT32, b STRING>, value=NULL)
+-column_access_list=WRITE
==

# Same test as previous, but with different struct field names.
INSERT MoreComplexTypes (ArrayOfStruct)
VALUES ([(select as struct CAST(1 AS INT32) x, "b" y), NULL]);
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[MoreComplexTypes.ArrayOfStruct#2], table=MoreComplexTypes, column_index_list=[1])
+-insert_column_list=[MoreComplexTypes.ArrayOfStruct#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Cast(ARRAY<STRUCT<x INT32, y STRING>> -> ARRAY<STRUCT<a INT32, b STRING>>)
|           +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRUCT<x INT32, y STRING>) -> ARRAY<STRUCT<x INT32, y STRING>>)
|             +-SubqueryExpr
|             | +-type=STRUCT<x INT32, y STRING>
|             | +-subquery_type=SCALAR
|             | +-subquery=
|             |   +-ProjectScan
|             |     +-column_list=[$make_struct.$struct#6]
|             |     +-expr_list=
|             |     | +-$struct#6 :=
|             |     |   +-MakeStruct
|             |     |     +-type=STRUCT<x INT32, y STRING>
|             |     |     +-field_list=
|             |     |       +-ColumnRef(type=INT32, column=$expr_subquery.x#4)
|             |     |       +-ColumnRef(type=STRING, column=$expr_subquery.y#5)
|             |     +-input_scan=
|             |       +-ProjectScan
|             |         +-column_list=$expr_subquery.[x#4, y#5]
|             |         +-expr_list=
|             |         | +-x#4 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
|             |         | +-y#5 := Literal(type=STRING, value='b')
|             |         +-input_scan=
|             |           +-SingleRowScan
|             +-Literal(type=STRUCT<x INT32, y STRING>, value=NULL)
+-column_access_list=WRITE
==

INSERT MoreComplexTypes (StructOfArrayOfStruct)
VALUES (struct(1 AS x,
               struct(CAST(1 AS INT32) AS a, "b" AS b) AS y,
               [(select as struct CAST(1 AS INT32) a, "a" b), NULL] AS z));
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[MoreComplexTypes.StructOfArrayOfStruct#3], table=MoreComplexTypes, column_index_list=[2])
+-insert_column_list=[MoreComplexTypes.StructOfArrayOfStruct#3]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-MakeStruct
|           +-type=STRUCT<x INT64, y STRUCT<a INT32, b STRING>, z ARRAY<STRUCT<a INT32, b STRING>>>
|           +-field_list=
|             +-Literal(type=INT64, value=1)
|             +-MakeStruct
|             | +-type=STRUCT<a INT32, b STRING>
|             | +-field_list=
|             |   +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
|             |   +-Literal(type=STRING, value='b')
|             +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRUCT<a INT32, b STRING>) -> ARRAY<STRUCT<a INT32, b STRING>>)
|               +-SubqueryExpr
|               | +-type=STRUCT<a INT32, b STRING>
|               | +-subquery_type=SCALAR
|               | +-subquery=
|               |   +-ProjectScan
|               |     +-column_list=[$make_struct.$struct#6]
|               |     +-expr_list=
|               |     | +-$struct#6 :=
|               |     |   +-MakeStruct
|               |     |     +-type=STRUCT<a INT32, b STRING>
|               |     |     +-field_list=
|               |     |       +-ColumnRef(type=INT32, column=$expr_subquery.a#4)
|               |     |       +-ColumnRef(type=STRING, column=$expr_subquery.b#5)
|               |     +-input_scan=
|               |       +-ProjectScan
|               |         +-column_list=$expr_subquery.[a#4, b#5]
|               |         +-expr_list=
|               |         | +-a#4 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
|               |         | +-b#5 := Literal(type=STRING, value='a')
|               |         +-input_scan=
|               |           +-SingleRowScan
|               +-Literal(type=STRUCT<a INT32, b STRING>, value=NULL)
+-column_access_list=WRITE
==

# Same test as previous, but with different struct field names.
INSERT MoreComplexTypes (StructOfArrayOfStruct)
VALUES (struct(1 AS f1,
               struct(CAST(1 AS INT32) AS g1, "b" AS h1) AS i1,
               [(select as struct CAST(1 AS INT32) j1, "a" k1), NULL] AS l1));
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[MoreComplexTypes.StructOfArrayOfStruct#3], table=MoreComplexTypes, column_index_list=[2])
+-insert_column_list=[MoreComplexTypes.StructOfArrayOfStruct#3]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-MakeStruct
|           +-type=STRUCT<x INT64, y STRUCT<a INT32, b STRING>, z ARRAY<STRUCT<a INT32, b STRING>>>
|           +-field_list=
|             +-Literal(type=INT64, value=1)
|             +-MakeStruct
|             | +-type=STRUCT<a INT32, b STRING>
|             | +-field_list=
|             |   +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
|             |   +-Literal(type=STRING, value='b')
|             +-Cast(ARRAY<STRUCT<j1 INT32, k1 STRING>> -> ARRAY<STRUCT<a INT32, b STRING>>)
|               +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRUCT<j1 INT32, k1 STRING>) -> ARRAY<STRUCT<j1 INT32, k1 STRING>>)
|                 +-SubqueryExpr
|                 | +-type=STRUCT<j1 INT32, k1 STRING>
|                 | +-subquery_type=SCALAR
|                 | +-subquery=
|                 |   +-ProjectScan
|                 |     +-column_list=[$make_struct.$struct#6]
|                 |     +-expr_list=
|                 |     | +-$struct#6 :=
|                 |     |   +-MakeStruct
|                 |     |     +-type=STRUCT<j1 INT32, k1 STRING>
|                 |     |     +-field_list=
|                 |     |       +-ColumnRef(type=INT32, column=$expr_subquery.j1#4)
|                 |     |       +-ColumnRef(type=STRING, column=$expr_subquery.k1#5)
|                 |     +-input_scan=
|                 |       +-ProjectScan
|                 |         +-column_list=$expr_subquery.[j1#4, k1#5]
|                 |         +-expr_list=
|                 |         | +-j1#4 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
|                 |         | +-k1#5 := Literal(type=STRING, value='a')
|                 |         +-input_scan=
|                 |           +-SingleRowScan
|                 +-Literal(type=STRUCT<j1 INT32, k1 STRING>, value=NULL)
+-column_access_list=WRITE
==

INSERT SimpleTypes (int32)
select 1
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
+-insert_column_list=[SimpleTypes.int32#1]
+-query=
| +-ProjectScan
|   +-column_list=[$insert_cast.$col1#20]
|   +-expr_list=
|   | +-$col1#20 := Literal(type=INT32, value=1)
|   +-input_scan=
|     +-ProjectScan
|       +-column_list=[$insert.$col1#19]
|       +-expr_list=
|       | +-$col1#19 := Literal(type=INT64, value=1)
|       +-input_scan=
|         +-SingleRowScan
+-query_output_column_list=[$insert_cast.$col1#20]
+-column_access_list=WRITE
==

INSERT SimpleTypes (int32)
VALUES (1)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
+-insert_column_list=[SimpleTypes.int32#1]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Literal(type=INT32, value=1)
+-column_access_list=WRITE
==

INSERT SimpleTypes (int32)
select int32 + 1 from SimpleTypes
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
+-insert_column_list=[SimpleTypes.int32#1]
+-query=
| +-ProjectScan
|   +-column_list=[$insert_cast.$col1#38]
|   +-expr_list=
|   | +-$col1#38 :=
|   |   +-Cast(INT64 -> INT32)
|   |     +-ColumnRef(type=INT64, column=$insert.$col1#37)
|   +-input_scan=
|     +-ProjectScan
|       +-column_list=[$insert.$col1#37]
|       +-expr_list=
|       | +-$col1#37 :=
|       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
|       |     +-Cast(INT32 -> INT64)
|       |     | +-ColumnRef(type=INT32, column=SimpleTypes.int32#19)
|       |     +-Literal(type=INT64, value=1)
|       +-input_scan=
|         +-TableScan(column_list=[SimpleTypes.int32#19], table=SimpleTypes, column_index_list=[0])
+-query_output_column_list=[$insert_cast.$col1#38]
+-column_access_list=WRITE
==

INSERT SimpleTypes (int32)
select int64 from SimpleTypes
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
+-insert_column_list=[SimpleTypes.int32#1]
+-query=
| +-ProjectScan
|   +-column_list=[$insert_cast.int64#37]
|   +-expr_list=
|   | +-int64#37 :=
|   |   +-Cast(INT64 -> INT32)
|   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#20)
|   +-input_scan=
|     +-ProjectScan
|       +-column_list=[SimpleTypes.int64#20]
|       +-input_scan=
|         +-TableScan(column_list=[SimpleTypes.int64#20], table=SimpleTypes, column_index_list=[1])
+-query_output_column_list=[$insert_cast.int64#37]
+-column_access_list=WRITE
==

INSERT SimpleTypes (int32)
select uint32 from SimpleTypes
--
ERROR: Query column 1 has type UINT32 which cannot be inserted into column int32, which has type INT32 [at 2:1]
select uint32 from SimpleTypes
^
==

INSERT SimpleTypes(int32)
VALUES (CAST(1 AS INT32)), (CAST(1 AS INT64))
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
+-insert_column_list=[SimpleTypes.int32#1]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
+-column_access_list=WRITE
==

INSERT SimpleTypes (uint32)
VALUES (CAST(1 AS UINT32)), (CAST(1 AS UINT64))
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[SimpleTypes.uint32#3], table=SimpleTypes, column_index_list=[2])
+-insert_column_list=[SimpleTypes.uint32#3]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |     +-value=
| |       +-Literal(type=UINT32, value=1, has_explicit_type=TRUE)
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Literal(type=UINT32, value=1, has_explicit_type=TRUE)
+-column_access_list=WRITE
==

# Inserting protos from different DescriptorPools. A cast gets added.
insert into TestTable (KitchenSink)
values
  ((select coalesce(CAST("""int64_key_1: 1 int64_key_2"""
                    as zetasql_test__.KitchenSinkPB)))),
  ((select coalesce(CAST("""int64_key_1: 1 int64_key_2"""
                    as alt_descriptor_pool.zetasql_test__.KitchenSinkPB))))
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
+-insert_column_list=[TestTable.KitchenSink#3]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |     +-value=
| |       +-SubqueryExpr
| |         +-type=PROTO<zetasql_test__.KitchenSinkPB>
| |         +-subquery_type=SCALAR
| |         +-subquery=
| |           +-ProjectScan
| |             +-column_list=[$expr_subquery.$col1#4]
| |             +-expr_list=
| |             | +-$col1#4 :=
| |             |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
| |             |     +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
| |             |       +-Literal(type=STRING, value='int64_key_1: 1 int64_key_2')
| |             +-input_scan=
| |               +-SingleRowScan
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
|           +-SubqueryExpr
|             +-type=PROTO<zetasql_test__.KitchenSinkPB>
|             +-subquery_type=SCALAR
|             +-subquery=
|               +-ProjectScan
|                 +-column_list=[$expr_subquery.$col1#5]
|                 +-expr_list=
|                 | +-$col1#5 :=
|                 |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
|                 |     +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
|                 |       +-Literal(type=STRING, value='int64_key_1: 1 int64_key_2')
|                 +-input_scan=
|                   +-SingleRowScan
+-column_access_list=WRITE
==

INSERT KitchenSinkValueTable
select as "zetasql_test__.KitchenSinkPB"
    1 as int64_key_1, 2 as int64_key_2,
    [] as repeated_int64_val, [] as repeated_int32_val,
    [] as repeated_string_val
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0])
+-insert_column_list=[KitchenSinkValueTable.value#1]
+-query=
| +-ProjectScan
|   +-column_list=[$make_proto.$proto#7]
|   +-expr_list=
|   | +-$proto#7 :=
|   |   +-MakeProto
|   |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
|   |     +-field_list=
|   |       +-int64_key_1 := ColumnRef(type=INT64, column=$insert.int64_key_1#2)
|   |       +-int64_key_2 := ColumnRef(type=INT64, column=$insert.int64_key_2#3)
|   |       +-repeated_int64_val := ColumnRef(type=ARRAY<INT64>, column=$insert.repeated_int64_val#4)
|   |       +-repeated_int32_val := Literal(type=ARRAY<INT32>, value=[])
|   |       +-repeated_string_val := Literal(type=ARRAY<STRING>, value=[])
|   +-input_scan=
|     +-ProjectScan
|       +-column_list=$insert.[int64_key_1#2, int64_key_2#3, repeated_int64_val#4, repeated_int32_val#5, repeated_string_val#6]
|       +-expr_list=
|       | +-int64_key_1#2 := Literal(type=INT64, value=1)
|       | +-int64_key_2#3 := Literal(type=INT64, value=2)
|       | +-repeated_int64_val#4 := Literal(type=ARRAY<INT64>, value=[])
|       | +-repeated_int32_val#5 := Literal(type=ARRAY<INT64>, value=[])
|       | +-repeated_string_val#6 := Literal(type=ARRAY<INT64>, value=[])
|       +-input_scan=
|         +-SingleRowScan
+-query_output_column_list=[$make_proto.$proto#7]
+-column_access_list=WRITE
==

INSERT KitchenSinkValueTable
select as "zetasql_test__.KitchenSinkPB"
    int64_key_1, int64_key_1 as int64_key_2
from (select int64_key_1 from KitchenSinkValueTable)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0])
+-insert_column_list=[KitchenSinkValueTable.value#1]
+-query=
| +-ProjectScan
|   +-column_list=[$make_proto.$proto#4]
|   +-expr_list=
|   | +-$proto#4 :=
|   |   +-MakeProto
|   |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
|   |     +-field_list=
|   |       +-int64_key_1 := ColumnRef(type=INT64, column=$subquery1.int64_key_1#3)
|   |       +-int64_key_2 := ColumnRef(type=INT64, column=$subquery1.int64_key_1#3)
|   +-input_scan=
|     +-ProjectScan
|       +-column_list=$subquery1.[int64_key_1#3, int64_key_1#3]
|       +-input_scan=
|         +-ProjectScan
|           +-column_list=[$subquery1.int64_key_1#3]
|           +-expr_list=
|           | +-int64_key_1#3 :=
|           |   +-GetProtoField
|           |     +-type=INT64
|           |     +-expr=
|           |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#2)
|           |     +-field_descriptor=int64_key_1
|           +-input_scan=
|             +-TableScan(column_list=[KitchenSinkValueTable.value#2], table=KitchenSinkValueTable, column_index_list=[0])
+-query_output_column_list=[$make_proto.$proto#4]
+-column_access_list=WRITE
==

# This tests a case where we have a duplicate key in the query's column_list,
# so we have to match based on output_column_list instead.
INSERT TwoIntegers (key, value)
SELECT key, key from TwoIntegers
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
+-insert_column_list=TwoIntegers.[key#1, value#2]
+-query=
| +-ProjectScan
|   +-column_list=TwoIntegers.[key#3, key#3]
|   +-input_scan=
|     +-TableScan(column_list=[TwoIntegers.key#3], table=TwoIntegers, column_index_list=[0])
+-query_output_column_list=TwoIntegers.[key#3, key#3]
+-column_access_list=WRITE,WRITE
==

# Non-nested INSERT does not allow a generalized path.
INSERT TwoIntegers.(a.b) (key, value) VALUES (0, 1)
--
ERROR: Non-nested INSERT statement requires a table name [at 1:21]
INSERT TwoIntegers.(a.b) (key, value) VALUES (0, 1)
                    ^
==

# Non-nested INSERT does not allow a generalized path.
INSERT TwoIntegers.(a.b).c (key, value) VALUES (0, 1)
--
ERROR: Non-nested INSERT statement requires a table name [at 1:21]
INSERT TwoIntegers.(a.b).c (key, value) VALUES (0, 1)
                    ^
==

# Non-nested INSERT does not allow a generalized path.
INSERT TwoIntegers.(a.b).c.d (key, value) VALUES (0, 1)
--
ERROR: Non-nested INSERT statement requires a table name [at 1:21]
INSERT TwoIntegers.(a.b).c.d (key, value) VALUES (0, 1)
                    ^
==

# Non-nested INSERT does not allow a generalized path.
INSERT TwoIntegers[3] VALUES (0, 1)
--
ERROR: Non-nested INSERT statement requires a table name [at 1:20]
INSERT TwoIntegers[3] VALUES (0, 1)
                   ^
==

# Non-nested INSERT does not allow a generalized path.
INSERT TwoIntegers.(a.b)[3] VALUES (0, 1)
--
ERROR: Non-nested INSERT statement requires a table name [at 1:21]
INSERT TwoIntegers.(a.b)[3] VALUES (0, 1)
                    ^
==

# Non-nested INSERT does not allow a generalized path.
INSERT TwoIntegers.(a.b).c[3] VALUES (0, 1)
--
ERROR: Non-nested INSERT statement requires a table name [at 1:21]
INSERT TwoIntegers.(a.b).c[3] VALUES (0, 1)
                    ^
==

INSERT AllNonKeysNonWritable (Key, Value) VALUES(1, 'abc');
--
ERROR: Cannot INSERT value on non-writable column: Value [at 1:36]
INSERT AllNonKeysNonWritable (Key, Value) VALUES(1, 'abc');
                                   ^
==

INSERT AllNonKeysNonWritable (Key) Values (1);
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[AllNonKeysNonWritable.Key#1], table=AllNonKeysNonWritable, column_index_list=[0])
+-insert_column_list=[AllNonKeysNonWritable.Key#1]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Literal(type=INT32, value=1)
+-column_access_list=WRITE
==

# ProtoValue was defined as non-writable in the sample_catalog.
INSERT AllNonKeysNonWritable (Key, ProtoValue) VALUES (1, NULL);
--
ERROR: Cannot INSERT value on non-writable column: ProtoValue [at 1:36]
INSERT AllNonKeysNonWritable (Key, ProtoValue) VALUES (1, NULL);
                                   ^
==

# INSERT using 'SELECT DISTINCT' query (b/117789638)
INSERT TwoIntegers (key, value)
  SELECT DISTINCT x, x FROM (SELECT 1 AS x);
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=TwoIntegers.[key#1, value#2], table=TwoIntegers, column_index_list=[0, 1])
+-insert_column_list=TwoIntegers.[key#1, value#2]
+-query=
| +-AggregateScan
|   +-column_list=[$distinct.x#4]
|   +-input_scan=
|   | +-ProjectScan
|   |   +-column_list=[$subquery1.x#3]
|   |   +-expr_list=
|   |   | +-x#3 := Literal(type=INT64, value=1)
|   |   +-input_scan=
|   |     +-SingleRowScan
|   +-group_by_list=
|     +-x#4 := ColumnRef(type=INT64, column=$subquery1.x#3)
+-query_output_column_list=$distinct.[x#4, x#4]
+-column_access_list=WRITE,WRITE
==

# INSERT using 'SELECT DISTINCT' query (b/117789638)
# (multiple columns in DISTINCT query)
INSERT FourIntegers (key1, value1, key2, value2)
  SELECT DISTINCT x, y, y, x FROM (SELECT 1 AS x, 2 AS y);
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=FourIntegers.[key1#1, value1#2, key2#3, value2#4], table=FourIntegers, column_index_list=[0, 1, 2, 3])
+-insert_column_list=FourIntegers.[key1#1, value1#2, key2#3, value2#4]
+-query=
| +-AggregateScan
|   +-column_list=$distinct.[x#7, y#8]
|   +-input_scan=
|   | +-ProjectScan
|   |   +-column_list=$subquery1.[x#5, y#6]
|   |   +-expr_list=
|   |   | +-x#5 := Literal(type=INT64, value=1)
|   |   | +-y#6 := Literal(type=INT64, value=2)
|   |   +-input_scan=
|   |     +-SingleRowScan
|   +-group_by_list=
|     +-x#7 := ColumnRef(type=INT64, column=$subquery1.x#5)
|     +-y#8 := ColumnRef(type=INT64, column=$subquery1.y#6)
+-query_output_column_list=$distinct.[x#7, y#8, y#8, x#7]
+-column_access_list=WRITE,WRITE,WRITE,WRITE
==

# INSERT using 'SELECT DISTINCT' query (b/117789638)
# (too few columns in DISTINCT query)
INSERT FourIntegers (key1, value1, key2, value2)
  SELECT DISTINCT x, y FROM (SELECT 1 AS x, 2 AS y);
--
ERROR: Inserted row has wrong column count; Has 2, expected 4 [at 2:3]
  SELECT DISTINCT x, y FROM (SELECT 1 AS x, 2 AS y);
  ^
==

# INSERT using 'SELECT DISTINCT' query (b/117789638)
# (too many columns in DISTINCT query)
INSERT FourIntegers (key1, value1)
  SELECT DISTINCT x, y, y, x FROM (SELECT 1 AS x, 2 AS y);
--
ERROR: Inserted row has wrong column count; Has 4, expected 2 [at 2:3]
  SELECT DISTINCT x, y, y, x FROM (SELECT 1 AS x, 2 AS y);
  ^
==

# INSERT using 'SELECT DISTINCT' query (b/117789638)
# (only some columns assigned to)
INSERT FourIntegers (key1, value1)
  SELECT DISTINCT x, y FROM (SELECT 1 AS x, 2 AS y);
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=FourIntegers.[key1#1, value1#2], table=FourIntegers, column_index_list=[0, 1])
+-insert_column_list=FourIntegers.[key1#1, value1#2]
+-query=
| +-AggregateScan
|   +-column_list=$distinct.[x#7, y#8]
|   +-input_scan=
|   | +-ProjectScan
|   |   +-column_list=$subquery1.[x#5, y#6]
|   |   +-expr_list=
|   |   | +-x#5 := Literal(type=INT64, value=1)
|   |   | +-y#6 := Literal(type=INT64, value=2)
|   |   +-input_scan=
|   |     +-SingleRowScan
|   +-group_by_list=
|     +-x#7 := ColumnRef(type=INT64, column=$subquery1.x#5)
|     +-y#8 := ColumnRef(type=INT64, column=$subquery1.y#6)
+-query_output_column_list=$distinct.[x#7, y#8]
+-column_access_list=WRITE,WRITE
==

# INSERT using 'SELECT DISTINCT' query (b/117789638)
# (some columns ignored)
INSERT FourIntegers (key1, value1, key2, value2)
  SELECT DISTINCT x, x, x, x FROM (SELECT 1 AS x, 2 AS y);
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=FourIntegers.[key1#1, value1#2, key2#3, value2#4], table=FourIntegers, column_index_list=[0, 1, 2, 3])
+-insert_column_list=FourIntegers.[key1#1, value1#2, key2#3, value2#4]
+-query=
| +-AggregateScan
|   +-column_list=[$distinct.x#7]
|   +-input_scan=
|   | +-ProjectScan
|   |   +-column_list=$subquery1.[x#5, y#6]
|   |   +-expr_list=
|   |   | +-x#5 := Literal(type=INT64, value=1)
|   |   | +-y#6 := Literal(type=INT64, value=2)
|   |   +-input_scan=
|   |     +-SingleRowScan
|   +-group_by_list=
|     +-x#7 := ColumnRef(type=INT64, column=$subquery1.x#5)
+-query_output_column_list=$distinct.[x#7, x#7, x#7, x#7]
+-column_access_list=WRITE,WRITE,WRITE,WRITE
==

INSERT FourIntegers (key1, value1, key2, value2)
SELECT DISTINCT a, b, c, d, d
FROM (SELECT 1 AS a, 2 AS b, 3 AS c, 4 AS d)
--
ERROR: Inserted row has wrong column count; Has 5, expected 4 [at 2:1]
SELECT DISTINCT a, b, c, d, d
^
==

INSERT UpdateToDefaultTable (writable) VALUES (DEFAULT);
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[UpdateToDefaultTable.writable#1], table=UpdateToDefaultTable, column_index_list=[0])
+-insert_column_list=[UpdateToDefaultTable.writable#1]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-DMLDefault(type=INT64)
+-column_access_list=WRITE
==

INSERT UpdateToDefaultTable (readonly) VALUES (1234);
--
ERROR: Cannot INSERT value on non-writable column: readonly [at 1:30]
INSERT UpdateToDefaultTable (readonly) VALUES (1234);
                             ^
==

INSERT UpdateToDefaultTable (readonly) VALUES (DEFAULT);
--
ERROR: Cannot INSERT value on non-writable column: readonly [at 1:30]
INSERT UpdateToDefaultTable (readonly) VALUES (DEFAULT);
                             ^
==

INSERT UpdateToDefaultTable (readonly_settable_to_default) VALUES (1234);
--
ERROR: Cannot INSERT value on non-writable column: readonly_settable_to_default [at 1:30]
INSERT UpdateToDefaultTable (readonly_settable_to_default) VALUES (1234);
                             ^
==

# DEFAULT may be represented as nullptr internally -- make sure it doesn't leak.
INSERT UpdateToDefaultTable (readonly_settable_to_default) VALUES (NULL);
--
ERROR: Cannot INSERT value on non-writable column: readonly_settable_to_default [at 1:30]
INSERT UpdateToDefaultTable (readonly_settable_to_default) VALUES (NULL);
                             ^
==

INSERT UpdateToDefaultTable (readonly_settable_to_default) VALUES (DEFAULT);
--
ERROR: Cannot INSERT value on non-writable column: readonly_settable_to_default [at 1:30]
INSERT UpdateToDefaultTable (readonly_settable_to_default) VALUES (DEFAULT);
                             ^
==

INSERT INTO KeyValue@{hint_name=hint_value} (key, value) VALUES (1, 'one');
--
InsertStmt
+-table_scan=
| +-TableScan
|   +-column_list=KeyValue.[Key#1, Value#2]
|   +-hint_list=
|   | +-hint_name := Literal(type=STRING, value='hint_value')
|   +-table=KeyValue
|   +-column_index_list=[0, 1]
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|     | +-value=
|     |   +-Literal(type=INT64, value=1)
|     +-DMLValue
|       +-value=
|         +-Literal(type=STRING, value='one')
+-column_access_list=WRITE,WRITE
==

INSERT INTO KeyValue (key) VALUES (1);
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-insert_column_list=[KeyValue.Key#1]
+-row_list=
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Literal(type=INT64, value=1)
+-column_access_list=WRITE
