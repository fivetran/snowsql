# This file includes tests with correlation references in a subquery to
# an outer query that contains aggregation.  The subquery can appear in
# the SELECT, WHERE, GROUP BY, HAVING, and ORDER BY, and the visibility
# of the correlated column can be different in each of those clauses.
# For instance, consider:
#
# SELECT T.x, (<subquery1>)
# FROM T
# WHERE (<subquery2>)
# GROUP BY T.x, <subquery3>
# HAVING (<subquery4>)
# ORDER BY (<subquery5>)
#
# In this query, <subquery1> and <subquery2> resolve against the FROM clause
# against pre-GROUP BY versions of columns.  <subquery3>, <subquery4>,
# and <subquery5> can resolve against the FROM clause or aliases introduced
# in the SELECT list.  They also must resolve to post-GROUP BY versions of
# columns and any references must be checked to see if they are visible
# post-grouping.
#
# This file contains tests for correlated references that go out one or
# more levels.
#
# The tests in this file are roughly organized by:
# 1) Correlated subquery in the SELECT list
# 2) Correlated subquery in the GROUP BY
# 3) Correlated subquery in the HAVING
# 4) Correlated subquery in the ORDER BY
# 5) Correlated subqueries multiple levels deep
# 6) Correlated subqueries and the USING clause
# 7) Additional correlated subquery tests that don't fit in previous
#    buckets, such as pseudocolumns (has_proto_field)
#
# Note that if/when we support GROUP BY array, we'll need to add new
# versions of these tests where the correlation reference is an
# array that is correlated in the FROM clause of the subquery.

##########################################################################
# Correlated subquery in the SELECT list.
##########################################################################

# Subquery 'key' resolves to a post-grouped version of the column.

[default language_features=GROUP_BY_ROLLUP,V_1_2_GROUP_BY_STRUCT]

SELECT key, (select key)
FROM KeyValue kv
GROUP BY {{key|ROLLUP(key)}}
--
ALTERNATION GROUP: key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#4 AS key [INT64]
| +-$query.$col2#6 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#4, $query.$col2#6]
    +-expr_list=
    | +-$col2#6 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.key#5]
    |         +-expr_list=
    |         | +-key#5 := ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
--
ALTERNATION GROUP: ROLLUP(key)
--
QueryStmt
+-output_column_list=
| +-$groupby.key#4 AS key [INT64]
| +-$query.$col2#6 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#4, $query.$col2#6]
    +-expr_list=
    | +-$col2#6 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.key#5]
    |         +-expr_list=
    |         | +-key#5 := ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
        | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-grouping_set_list=
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=INT64, column=$groupby.key#4)
        | +-GroupingSet
        +-rollup_column_list=
          +-ColumnRef(type=INT64, column=$groupby.key#4)
==

# This is the same as the previous query, but instead of the correlation
# reference being 'key' it is 'kv.key'.
SELECT key, (select kv.key)
FROM KeyValue kv
GROUP BY {{key|ROLLUP(key)}}
--
ALTERNATION GROUP: key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#4 AS key [INT64]
| +-$query.$col2#6 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#4, $query.$col2#6]
    +-expr_list=
    | +-$col2#6 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.key#5]
    |         +-expr_list=
    |         | +-key#5 := ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
--
ALTERNATION GROUP: ROLLUP(key)
--
QueryStmt
+-output_column_list=
| +-$groupby.key#4 AS key [INT64]
| +-$query.$col2#6 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#4, $query.$col2#6]
    +-expr_list=
    | +-$col2#6 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.key#5]
    |         +-expr_list=
    |         | +-key#5 := ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
        | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-grouping_set_list=
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=INT64, column=$groupby.key#4)
        | +-GroupingSet
        +-rollup_column_list=
          +-ColumnRef(type=INT64, column=$groupby.key#4)
==

# Error - the subquery references a column not visible post-GROUP BY.
# TODO: There is no 'clause_name' in this error message, nor
# in many of the subsequent error messages.  Figure out if there is
# something intelligent that we can put in these cases, since the
# reference is in the SELECT LIST of the subquery but the error is
# really to the outer query clause (in this case SELECT LIST also,
# but in other cases the HAVING or ORDER BY clause of the outer query).
SELECT key, (select value)
FROM KeyValue kv
GROUP BY key
--
ERROR: An expression references column value which is neither grouped nor aggregated [at 1:21]
SELECT key, (select value)
                    ^
==

SELECT key, (select kv.value)
FROM KeyValue kv
GROUP BY key
--
ERROR: An expression references kv.value which is neither grouped nor aggregated [at 1:21]
SELECT key, (select kv.value)
                    ^
==

# Error - the subquery references a range variable not visible post-GROUP BY.
SELECT key, (select kv)
FROM KeyValue kv
GROUP BY key
--
ERROR: An expression references table alias kv which is neither grouped nor aggregated [at 1:21]
SELECT key, (select kv)
                    ^
==

# Correlated references to previous SELECT list aliases is not allowed
SELECT key as key1, (select key1)
FROM KeyValue kv
GROUP BY {{key1|ROLLUP(key1)}}
--
ERROR: Unrecognized name: key1 [at 1:29]
SELECT key as key1, (select key1)
                            ^
==

# A correlated subquery that is embedded in the SELECT list expression (i.e.,
# it is not a 'top-level' SELECT list expression).
select 1 + (select key)
from KeyValue;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Literal(type=INT64, value=1)
    |     +-SubqueryExpr
    |       +-type=INT64
    |       +-subquery_type=SCALAR
    |       +-parameter_list=
    |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       +-subquery=
    |         +-ProjectScan
    |           +-column_list=[$expr_subquery.key#3]
    |           +-expr_list=
    |           | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |           +-input_scan=
    |             +-SingleRowScan
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
==

# The correlated subquery is not a 'top-level' SELECT list expression, and
# the correlation reference is not visible post-GROUP BY.
select 1 + (select key)
from KeyValue
group by value
--
ERROR: An expression references column key which is neither grouped nor aggregated [at 1:20]
select 1 + (select key)
                   ^
==

# An expression that has two correlated subqueries.
select (select char_length(value)) + (select key) + 5
from KeyValue
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     | +-SubqueryExpr
    |     | | +-type=INT64
    |     | | +-subquery_type=SCALAR
    |     | | +-parameter_list=
    |     | | | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     | | +-subquery=
    |     | |   +-ProjectScan
    |     | |     +-column_list=[$expr_subquery.$col1#3]
    |     | |     +-expr_list=
    |     | |     | +-$col1#3 :=
    |     | |     |   +-FunctionCall(ZetaSQL:char_length(STRING) -> INT64)
    |     | |     |     +-ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |     | |     +-input_scan=
    |     | |       +-SingleRowScan
    |     | +-SubqueryExpr
    |     |   +-type=INT64
    |     |   +-subquery_type=SCALAR
    |     |   +-parameter_list=
    |     |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     |   +-subquery=
    |     |     +-ProjectScan
    |     |       +-column_list=[$expr_subquery.key#4]
    |     |       +-expr_list=
    |     |       | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |     |       +-input_scan=
    |     |         +-SingleRowScan
    |     +-Literal(type=INT64, value=5)
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
==

# With GROUP BY 'key', column 'value' is not visible.
select (select char_length(value)) + (select key) + 5
from KeyValue
group by key
--
ERROR: An expression references column value which is neither grouped nor aggregated [at 1:28]
select (select char_length(value)) + (select key) + 5
                           ^
==

# With GROUP BY 'value', column 'key' is not visible.
select (select char_length(value)) + (select key) + 5
from KeyValue
group by value
--
ERROR: An expression references column key which is neither grouped nor aggregated [at 1:46]
select (select char_length(value)) + (select key) + 5
                                             ^
==

# In the following tests, the correlation reference is a repeated in the
# FROM clause.
#
# This correlation reference is fine, since the subquery itself is grouped.
select (select count(*) from tt.KitchenSink.repeated_int32_val)
from TestTable tt
group by 1;
--
QueryStmt
+-output_column_list=
| +-$groupby.$col1#6 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.$col1#6]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.$col1#6]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
        +-group_by_list=
          +-$col1#6 :=
            +-SubqueryExpr
              +-type=INT64
              +-subquery_type=SCALAR
              +-parameter_list=
              | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              +-subquery=
                +-ProjectScan
                  +-column_list=[$aggregate.$agg1#5]
                  +-input_scan=
                    +-AggregateScan
                      +-column_list=[$aggregate.$agg1#5]
                      +-input_scan=
                      | +-ArrayScan
                      |   +-array_expr=
                      |   | +-GetProtoField
                      |   |   +-type=ARRAY<INT32>
                      |   |   +-expr=
                      |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
                      |   |   +-field_descriptor=repeated_int32_val
                      |   |   +-default_value=[]
                      |   +-element_column=$array.repeated_int32_val#4
                      +-aggregate_list=
                        +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

# The correlation reference is not visible post-GROUP BY in the outer query.
select tt.TestEnum, (select count(*) from tt.KitchenSink.repeated_int32_val)
from TestTable tt
group by 1;
--
ERROR: Correlated aliases referenced in the from clause must refer to arrays that are valid to access from the outer query, but tt refers to an array that is not valid to access after GROUP BY or DISTINCT in the outer query [at 1:43]
select tt.TestEnum, (select count(*) from tt.KitchenSink.repeated_int32_val)
                                          ^
==

# The correlation reference is not visible post-DISTINCT in the outer query.
select distinct tt.TestEnum
from TestTable tt
order by (select count(*) from tt.KitchenSink.repeated_int32_val)
--
ERROR: Correlated aliases referenced in the from clause must refer to arrays that are valid to access from the outer query, but tt refers to an array that is not valid to access after GROUP BY or DISTINCT in the outer query [at 3:32]
order by (select count(*) from tt.KitchenSink.repeated_int32_val)
                               ^
==

# Test case mirroring b/26227536.
select sum(tt.KitchenSink.int32_val) +
       (SELECT SUM(nested_repeated_value.nested_int64)
        FROM tt.KitchenSink.nested_repeated_value)
from TestTable tt
where tt.KitchenSink.bool_val = true;
--
ERROR: Correlated aliases referenced in the from clause must refer to arrays that are valid to access from the outer query, but tt refers to an array that is not valid to access after GROUP BY or DISTINCT in the outer query [at 3:14]
        FROM tt.KitchenSink.nested_repeated_value)
             ^
==

# This error test case is a simplified version of b/20920755 that originally
# failed with an internal error.  It should fail because we GROUP BY tt.key
# but reference tt.KitchenSink.repeated_int32_val in the SELECT list
# subquery, even though tt.KitchenSink.repeated_int32_val is not grouped in
# the main query so it is not visible post-GROUP BY.
select tt.key as key, IF(EXISTS(select *
                                from tt.KitchenSink.repeated_int32_val),
                         count(distinct(tt.key)),
                         0)
from TestTable tt
group by tt.key
--
ERROR: Correlated aliases referenced in the from clause must refer to arrays that are valid to access from the outer query, but tt refers to an array that is not valid to access after GROUP BY or DISTINCT in the outer query [at 2:38]
                                from tt.KitchenSink.repeated_int32_val),
                                     ^
==

select a.b.c, (select key from KeyValue where key = a.b.c)
from (select struct<c int64>(1) as b) as a
group by a.b.c
--
QueryStmt
+-output_column_list=
| +-$groupby.c#4 AS c [INT64]
| +-$query.$col2#7 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.c#4, $query.$col2#7]
    +-expr_list=
    | +-$col2#7 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.c#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[KeyValue.Key#5]
    |         +-input_scan=
    |           +-FilterScan
    |             +-column_list=[KeyValue.Key#5]
    |             +-input_scan=
    |             | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0])
    |             +-filter_expr=
    |               +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |                 +-ColumnRef(type=INT64, column=KeyValue.Key#5)
    |                 +-ColumnRef(type=INT64, column=$groupby.c#4, is_correlated=TRUE)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.c#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[a.b#1]
        |   +-expr_list=
        |   | +-b#1 := Literal(type=STRUCT<c INT64>, value={c:1}, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-group_by_list=
          +-c#4 :=
            +-GetStructField
              +-type=INT64
              +-expr=
              | +-ColumnRef(type=STRUCT<c INT64>, column=a.b#1)
              +-field_idx=0
==

##########################################################################
# Correlated subquery in the WHERE clause.
##########################################################################
#
# In the WHERE clause, correlated subquery columns resolve to the
# pre-grouped version of the column.
#
# The correlation reference is to the pre-grouped version of the
# grouping column.
SELECT key
FROM KeyValue kv
WHERE (select {{kv.|}}key) = 5
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#4 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#4]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[KeyValue.Key#1]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-SubqueryExpr
        |       | +-type=INT64
        |       | +-subquery_type=SCALAR
        |       | +-parameter_list=
        |       | | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       | +-subquery=
        |       |   +-ProjectScan
        |       |     +-column_list=[$expr_subquery.key#3]
        |       |     +-expr_list=
        |       |     | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |       |     +-input_scan=
        |       |       +-SingleRowScan
        |       +-Literal(type=INT64, value=5)
        +-group_by_list=
          +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The correlation reference is not to the grouping column.
SELECT key
FROM KeyValue kv
WHERE (select {{kv.|}}value) = '5'
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#4 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#4]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=KeyValue.[Key#1, Value#2]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
        |       +-SubqueryExpr
        |       | +-type=STRING
        |       | +-subquery_type=SCALAR
        |       | +-parameter_list=
        |       | | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       | +-subquery=
        |       |   +-ProjectScan
        |       |     +-column_list=[$expr_subquery.value#3]
        |       |     +-expr_list=
        |       |     | +-value#3 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
        |       |     +-input_scan=
        |       |       +-SingleRowScan
        |       +-Literal(type=STRING, value="5")
        +-group_by_list=
          +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The correlation reference is in the FROM clause of the subquery.
SELECT tt.TestEnum
from TestTable tt
WHERE (select count(*) from tt.KitchenSink.repeated_int32_val) = 5
group by 1;
--
QueryStmt
+-output_column_list=
| +-$groupby.TestEnum#6 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.TestEnum#6]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.TestEnum#6]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=TestTable.[TestEnum#2, KitchenSink#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=TestTable.[TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[1, 2], alias="tt")
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-SubqueryExpr
        |       | +-type=INT64
        |       | +-subquery_type=SCALAR
        |       | +-parameter_list=
        |       | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |       | +-subquery=
        |       |   +-ProjectScan
        |       |     +-column_list=[$aggregate.$agg1#5]
        |       |     +-input_scan=
        |       |       +-AggregateScan
        |       |         +-column_list=[$aggregate.$agg1#5]
        |       |         +-input_scan=
        |       |         | +-ArrayScan
        |       |         |   +-array_expr=
        |       |         |   | +-GetProtoField
        |       |         |   |   +-type=ARRAY<INT32>
        |       |         |   |   +-expr=
        |       |         |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
        |       |         |   |   +-field_descriptor=repeated_int32_val
        |       |         |   |   +-default_value=[]
        |       |         |   +-element_column=$array.repeated_int32_val#4
        |       |         +-aggregate_list=
        |       |           +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |       +-Literal(type=INT64, value=5)
        +-group_by_list=
          +-TestEnum#6 := ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#2)
==

# Error, the WHERE clause subquery cannot see SELECT list aliases.
SELECT key as k1
FROM KeyValue kv
WHERE (select k1) = 1
GROUP BY key
--
ERROR: Unrecognized name: k1 [at 3:15]
WHERE (select k1) = 1
              ^
==

##########################################################################
# Correlated subquery in the GROUP BY clause.
##########################################################################
#
# In the GROUP BY clause, correlated subquery columns resolve to the
# pre-grouped version of the column, and/or to SELECT list aliases.
#
# Note that this isn't a very useful query pattern, since it is not valid
# to put the subquery in both the SELECT and GROUP BY (ZetaSQL does not
# do arbitrary expression matching so you can only GROUP BY the subquery
# but not SELECT it).
#
SELECT 'foo'
FROM KeyValue kv
GROUP BY (select {{kv.|}}key)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 := Literal(type=STRING, value="foo")
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-$groupbycol1#4 :=
            +-SubqueryExpr
              +-type=INT64
              +-subquery_type=SCALAR
              +-parameter_list=
              | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-subquery=
                +-ProjectScan
                  +-column_list=[$expr_subquery.key#3]
                  +-expr_list=
                  | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
                  +-input_scan=
                    +-SingleRowScan
==

# TODO: This should work, fix it.  The subquery should resolve 'foo'
# to the SELECT list alias, consistently with the other expressions in the
# GROUP BY.  This is probably low priority since correlated subqueries in
# GROUP BY do not seem particularly useful, and this problem does not exist
# for HAVING or ORDER BY correlated subqueries (aliases there work ok).
SELECT 'foo' as foo
FROM KeyValue kv
GROUP BY foo, (select max(foo))
--
ERROR: Unrecognized name: foo [at 3:27]
GROUP BY foo, (select max(foo))
                          ^
==

# The correlation reference is in the subquery FROM clause.
SELECT 'foo'
from TestTable tt
GROUP BY (select count(*) from tt.KitchenSink.repeated_int32_val)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 := Literal(type=STRING, value="foo")
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
        +-group_by_list=
          +-$groupbycol1#6 :=
            +-SubqueryExpr
              +-type=INT64
              +-subquery_type=SCALAR
              +-parameter_list=
              | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              +-subquery=
                +-ProjectScan
                  +-column_list=[$aggregate.$agg1#5]
                  +-input_scan=
                    +-AggregateScan
                      +-column_list=[$aggregate.$agg1#5]
                      +-input_scan=
                      | +-ArrayScan
                      |   +-array_expr=
                      |   | +-GetProtoField
                      |   |   +-type=ARRAY<INT32>
                      |   |   +-expr=
                      |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
                      |   |   +-field_descriptor=repeated_int32_val
                      |   |   +-default_value=[]
                      |   +-element_column=$array.repeated_int32_val#4
                      +-aggregate_list=
                        +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

##########################################################################
# Correlated subquery in the HAVING clause.
##########################################################################
#
# In the HAVING clause, correlated subquery columns resolve to the
# post-grouped version of the column, and/or to SELECT list aliases (that
# are GROUPed).
#
SELECT key
FROM KeyValue kv
GROUP BY key
HAVING (select key) = 5
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#3]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.key#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        |   +-group_by_list=
        |     +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-SubqueryExpr
            | +-type=INT64
            | +-subquery_type=SCALAR
            | +-parameter_list=
            | | +-ColumnRef(type=INT64, column=$groupby.key#3)
            | +-subquery=
            |   +-ProjectScan
            |     +-column_list=[$expr_subquery.key#4]
            |     +-expr_list=
            |     | +-key#4 := ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
            |     +-input_scan=
            |       +-SingleRowScan
            +-Literal(type=INT64, value=5)
==

# Correlation references to both columns and aliases are supported.
SELECT key as k1
FROM KeyValue kv
GROUP BY key
HAVING (select k1 + key) = 1
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS k1 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#3]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.key#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        |   +-group_by_list=
        |     +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-SubqueryExpr
            | +-type=INT64
            | +-subquery_type=SCALAR
            | +-parameter_list=
            | | +-ColumnRef(type=INT64, column=$groupby.key#3)
            | +-subquery=
            |   +-ProjectScan
            |     +-column_list=[$expr_subquery.$col1#4]
            |     +-expr_list=
            |     | +-$col1#4 :=
            |     |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |     |     +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
            |     |     +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
            |     +-input_scan=
            |       +-SingleRowScan
            +-Literal(type=INT64, value=1)
==

# The correlated reference is not visible post-grouping.
SELECT key
FROM KeyValue kv
GROUP BY key
HAVING (select value) = 'a'
--
ERROR: An expression references column value which is neither grouped nor aggregated [at 4:16]
HAVING (select value) = 'a'
               ^
==

# Both kv_outer and kv_inner have column 'value'.  The correlated HAVING
# clause subquery '(select value)' references 'value', which is visible
# from kv_outer but not valid to access in kv_inner (since it is not
# grouped by).  The correlated 'value' resolves to kv_inner.value, so
# an error is produced.
SELECT (SELECT key
        FROM KeyValue kv_inner
        GROUP BY key
        HAVING (select value) = 'a')
FROM KeyValue kv_outer
--
ERROR: An expression references column value which is neither grouped nor aggregated [at 4:24]
        HAVING (select value) = 'a')
                       ^
==

# The correlation reference is in the subquery FROM clause.
#
# Cannot GROUP BY proto.  If at some point we allow this, then in
# theory this query could work.
SELECT tt.KitchenSink
from TestTable tt
GROUP BY tt.KitchenSink
HAVING (select count(*) from tt.KitchenSink.repeated_int32_val) > 0
--
ERROR: Grouping by expressions of type PROTO is not allowed [at 3:10]
GROUP BY tt.KitchenSink
         ^
==

# TODO: The current error message is incorrect, that is a bug.
# We do not seem to correctly coerce literal fields.  This should work,
# fix it so that coercion/literal array/struct construction works.
SELECT tt.struct1
from (select struct<array1 array<int32>, array2 array<int32>>([1, 2], [3, 4])
        as struct1) tt
GROUP BY tt.struct1
HAVING (select count(*) from tt.struct1.array1) > 0
--
ERROR: Struct field 1 has type ARRAY<INT64> which does not coerce to ARRAY<INT32> [at 2:63]
from (select struct<array1 array<int32>, array2 array<int32>>([1, 2], [3, 4])
                                                              ^
==

# Similar to the previous query. After changing the struct spec in FROM, the
# subquery is resolved without error. Now we see error from GROUP BY clause.
SELECT tt.struct1
from (select struct<array1 array<int64>, array2 array<int64>>([1, 2], [3, 4])
        as struct1) tt
GROUP BY tt.struct1
HAVING (select count(*) from tt.struct1.array1) > 0
--
ERROR: Grouping by expressions of type STRUCT containing ARRAY is not allowed [at 4:10]
GROUP BY tt.struct1
         ^
==

# TODO: the error message is misleading, 'tt' is not an array.
SELECT tt.struct1
from (select struct<sub_struct_1 struct <a int64, b int64>, sub_struct_2 struct<a int64, b int64>>((1, 2), (3, 4))
        as struct1) tt
GROUP BY tt.struct1
HAVING (select count(*) from tt.struct1.sub_struct_1) > 0

--
ERROR: Correlated aliases referenced in the from clause must refer to arrays that are valid to access from the outer query, but tt refers to an array that is not valid to access after GROUP BY or DISTINCT in the outer query [at 5:30]
HAVING (select count(*) from tt.struct1.sub_struct_1) > 0
                             ^
==

# For value table, range variable and all its nested fields are resolved
# properly, and now we hit the data type error.
SELECT 'foo'
FROM TestNestedStructValueTable vt
GROUP BY vt
HAVING (SELECT COUNT(*) FROM vt.f.d.a) > 1
--
ERROR: Values referenced in FROM clause must be arrays. vt.f.d.a has type INT32 [at 4:30]
HAVING (SELECT COUNT(*) FROM vt.f.d.a) > 1
                             ^
==

# Cannot GROUP BY array.  If at some point we allow this, then in
# theory this query could work (assuming we resolve the entire
# path expression as a correlation reference, and not the range variable
# 'tt' nor the array 'tt.KitchenSink' by itself).
SELECT tt.KitchenSink.repeated_int32_val
from TestTable tt
GROUP BY tt.KitchenSink.repeated_int32_val
HAVING (select count(*) from tt.KitchenSink.repeated_int32_val) > 0
--
ERROR: Grouping by expressions of type ARRAY is not allowed [at 3:10]
GROUP BY tt.KitchenSink.repeated_int32_val
         ^
==

# Correlated reference not visible post-GROUP BY.
SELECT tt.TestEnum
from TestTable tt
GROUP BY tt.TestEnum
HAVING (select count(*) from tt.KitchenSink.repeated_int32_val) > 0
--
ERROR: Correlated aliases referenced in the from clause must refer to arrays that are valid to access from the outer query, but tt refers to an array that is not valid to access after GROUP BY or DISTINCT in the outer query [at 4:30]
HAVING (select count(*) from tt.KitchenSink.repeated_int32_val) > 0
                             ^
==

# This test case mirrors one identified in b/20663400.  We need to ensure that
# HAVING clause references get mapped to post-GROUP BY versions of columns.
SELECT 1 AS ct
FROM KeyValue kv
GROUP BY {{kv.key|ROLLUP(kv.key)}}
HAVING (SELECT kv.key) = 1;
--
ALTERNATION GROUP: kv.key
--
QueryStmt
+-output_column_list=
| +-$query.ct#5 AS ct [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.ct#5]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#4, $query.ct#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$groupby.key#4, $query.ct#5]
        |   +-expr_list=
        |   | +-ct#5 := Literal(type=INT64, value=1)
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.key#4]
        |       +-input_scan=
        |       | +-ProjectScan
        |       |   +-column_list=[KeyValue.Key#1, $pre_groupby.ct#3]
        |       |   +-expr_list=
        |       |   | +-ct#3 := Literal(type=INT64, value=1)
        |       |   +-input_scan=
        |       |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        |       +-group_by_list=
        |         +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-SubqueryExpr
            | +-type=INT64
            | +-subquery_type=SCALAR
            | +-parameter_list=
            | | +-ColumnRef(type=INT64, column=$groupby.key#4)
            | +-subquery=
            |   +-ProjectScan
            |     +-column_list=[$expr_subquery.key#6]
            |     +-expr_list=
            |     | +-key#6 := ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
            |     +-input_scan=
            |       +-SingleRowScan
            +-Literal(type=INT64, value=1)
--
ALTERNATION GROUP: ROLLUP(kv.key)
--
QueryStmt
+-output_column_list=
| +-$query.ct#5 AS ct [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.ct#5]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#4, $query.ct#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$groupby.key#4, $query.ct#5]
        |   +-expr_list=
        |   | +-ct#5 := Literal(type=INT64, value=1)
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.key#4]
        |       +-input_scan=
        |       | +-ProjectScan
        |       |   +-column_list=[KeyValue.Key#1, $pre_groupby.ct#3]
        |       |   +-expr_list=
        |       |   | +-ct#3 := Literal(type=INT64, value=1)
        |       |   +-input_scan=
        |       |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        |       +-group_by_list=
        |       | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-grouping_set_list=
        |       | +-GroupingSet
        |       | | +-group_by_column_list=
        |       | |   +-ColumnRef(type=INT64, column=$groupby.key#4)
        |       | +-GroupingSet
        |       +-rollup_column_list=
        |         +-ColumnRef(type=INT64, column=$groupby.key#4)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-SubqueryExpr
            | +-type=INT64
            | +-subquery_type=SCALAR
            | +-parameter_list=
            | | +-ColumnRef(type=INT64, column=$groupby.key#4)
            | +-subquery=
            |   +-ProjectScan
            |     +-column_list=[$expr_subquery.key#6]
            |     +-expr_list=
            |     | +-key#6 := ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
            |     +-input_scan=
            |       +-SingleRowScan
            +-Literal(type=INT64, value=1)
==

# This test case mirrors one in b/23193609.
SELECT tt.TestEnum, count(*)
from TestTable tt
GROUP BY tt.TestEnum
HAVING (select count(*) from tt.KitchenSink.repeated_int32_val) > 0
--
ERROR: Correlated aliases referenced in the from clause must refer to arrays that are valid to access from the outer query, but tt refers to an array that is not valid to access after GROUP BY or DISTINCT in the outer query [at 4:30]
HAVING (select count(*) from tt.KitchenSink.repeated_int32_val) > 0
                             ^
==

# This test case mirrors one in b/23193609.
SELECT tt.TestEnum, count(*)
from TestTable tt
GROUP BY tt.TestEnum, (select count(*) from tt.KitchenSink.repeated_int32_val)
HAVING (select count(*) from tt.KitchenSink.repeated_int32_val) > 0
--
ERROR: Correlated aliases referenced in the from clause must refer to arrays that are valid to access from the outer query, but tt refers to an array that is not valid to access after GROUP BY or DISTINCT in the outer query [at 4:30]
HAVING (select count(*) from tt.KitchenSink.repeated_int32_val) > 0
                             ^
==

##########################################################################
# Correlated subquery in the ORDER BY clause.
##########################################################################
#
# In the ORDER BY clause, correlated subquery columns resolve to the
# post-grouped version of the column, and/or to SELECT list aliases (that
# are GROUPed).
#
SELECT key
FROM KeyValue kv
GROUP BY key
ORDER BY (select key)
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.key#3, $orderby.$orderbycol1#5]
    |   +-expr_list=
    |   | +-$orderbycol1#5 :=
    |   |   +-SubqueryExpr
    |   |     +-type=INT64
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=$groupby.key#3)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$expr_subquery.key#4]
    |   |         +-expr_list=
    |   |         | +-key#4 := ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
    |   |         +-input_scan=
    |   |           +-SingleRowScan
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.key#3]
    |       +-input_scan=
    |       | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
    |       +-group_by_list=
    |         +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#5)
==

# Correlation references to SELECT list aliases are allowed.
SELECT key as k1
FROM KeyValue kv
GROUP BY key
ORDER BY (select k1 + key)
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS k1 [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.key#3, $orderby.$orderbycol1#5]
    |   +-expr_list=
    |   | +-$orderbycol1#5 :=
    |   |   +-SubqueryExpr
    |   |     +-type=INT64
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=$groupby.key#3)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$expr_subquery.$col1#4]
    |   |         +-expr_list=
    |   |         | +-$col1#4 :=
    |   |         |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |         |     +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
    |   |         |     +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
    |   |         +-input_scan=
    |   |           +-SingleRowScan
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.key#3]
    |       +-input_scan=
    |       | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
    |       +-group_by_list=
    |         +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#5)
==

# The correlated reference is not visible post-grouping.
SELECT key
FROM KeyValue kv
GROUP BY key
ORDER BY (select value)
--
ERROR: An expression references column value which is neither grouped nor aggregated [at 4:18]
ORDER BY (select value)
                 ^
==

# The correlated reference is not visible post-grouping.
SELECT key
FROM KeyValue kv
GROUP BY key
ORDER BY (select kv.value)
--
ERROR: An expression references kv.value which is neither grouped nor aggregated [at 4:18]
ORDER BY (select kv.value)
                 ^
==

# The correlation reference is in the subquery FROM clause.
#
# This test case mirrors one in b/23193609.
SELECT tt.TestEnum, count(*)
from TestTable tt
GROUP BY tt.TestEnum
ORDER BY (select count(*) from tt.KitchenSink.repeated_int32_val) DESC
--
ERROR: Correlated aliases referenced in the from clause must refer to arrays that are valid to access from the outer query, but tt refers to an array that is not valid to access after GROUP BY or DISTINCT in the outer query [at 4:32]
ORDER BY (select count(*) from tt.KitchenSink.repeated_int32_val) DESC
                               ^
==

##########################################################################
# Correlated subquery tests, nested correlated subqueries two levels
# deep.
##########################################################################
#
# Correlated subquery in the SELECT list.
#
SELECT key, (select (select key))
FROM KeyValue kv
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#5 AS key [INT64]
| +-$query.$col2#8 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#5, $query.$col2#8]
    +-expr_list=
    | +-$col2#8 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#5)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#7]
    |         +-expr_list=
    |         | +-$col1#7 :=
    |         |   +-SubqueryExpr
    |         |     +-type=INT64
    |         |     +-subquery_type=SCALAR
    |         |     +-parameter_list=
    |         |     | +-ColumnRef(type=INT64, column=$groupby.key#5, is_correlated=TRUE)
    |         |     +-subquery=
    |         |       +-ProjectScan
    |         |         +-column_list=[$expr_subquery.key#6]
    |         |         +-expr_list=
    |         |         | +-key#6 := ColumnRef(type=INT64, column=$groupby.key#5, is_correlated=TRUE)
    |         |         +-input_scan=
    |         |           +-SingleRowScan
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#5]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-key#5 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

SELECT value, (select max((select value)) from TestTable)
FROM KeyValue kv
GROUP BY value
--
QueryStmt
+-output_column_list=
| +-$groupby.value#8 AS value [STRING]
| +-$query.$col2#14 AS "$col2" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.value#8, $query.$col2#14]
    +-expr_list=
    | +-$col2#14 :=
    |   +-SubqueryExpr
    |     +-type=STRING
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=STRING, column=$groupby.value#8)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$aggregate.$agg1#13]
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$aggregate.$agg1#13]
    |             +-input_scan=
    |             | +-TableScan(table=TestTable)
    |             +-aggregate_list=
    |               +-$agg1#13 :=
    |                 +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
    |                   +-SubqueryExpr
    |                     +-type=STRING
    |                     +-subquery_type=SCALAR
    |                     +-parameter_list=
    |                     | +-ColumnRef(type=STRING, column=$groupby.value#8, is_correlated=TRUE)
    |                     +-subquery=
    |                       +-ProjectScan
    |                         +-column_list=[$expr_subquery.value#12]
    |                         +-expr_list=
    |                         | +-value#12 := ColumnRef(type=STRING, column=$groupby.value#8, is_correlated=TRUE)
    |                         +-input_scan=
    |                           +-SingleRowScan
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.value#8]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1], alias="kv")
        +-group_by_list=
          +-value#8 := ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# Error - the subquery references a column not visible post-GROUP BY.
SELECT key, (select (select value))
FROM KeyValue kv
GROUP BY key
--
ERROR: An expression references column value which is neither grouped nor aggregated [at 1:29]
SELECT key, (select (select value))
                            ^
==

# Error - the subquery references a range variable not visible post-GROUP BY.
SELECT key, (select (select kv.value))
FROM KeyValue kv
GROUP BY key
--
ERROR: An expression references kv.value which is neither grouped nor aggregated [at 1:29]
SELECT key, (select (select kv.value))
                            ^
==

# The correlation reference is 'kv', not 'kv.key', so the query provides
# an error.
SELECT key, (select (select kv.key))
FROM KeyValue kv
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#5 AS key [INT64]
| +-$query.$col2#8 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#5, $query.$col2#8]
    +-expr_list=
    | +-$col2#8 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#5)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#7]
    |         +-expr_list=
    |         | +-$col1#7 :=
    |         |   +-SubqueryExpr
    |         |     +-type=INT64
    |         |     +-subquery_type=SCALAR
    |         |     +-parameter_list=
    |         |     | +-ColumnRef(type=INT64, column=$groupby.key#5, is_correlated=TRUE)
    |         |     +-subquery=
    |         |       +-ProjectScan
    |         |         +-column_list=[$expr_subquery.key#6]
    |         |         +-expr_list=
    |         |         | +-key#6 := ColumnRef(type=INT64, column=$groupby.key#5, is_correlated=TRUE)
    |         |         +-input_scan=
    |         |           +-SingleRowScan
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#5]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-key#5 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# Error - the subquery references a range variable not visible post-GROUP BY.
SELECT key, (select (select kv))
FROM KeyValue kv
GROUP BY key
--
ERROR: An expression references table alias kv which is neither grouped nor aggregated [at 1:29]
SELECT key, (select (select kv))
                            ^
==

# Correlated references to previous SELECT list aliases is not allowed
SELECT key as key1, (select (select key1))
FROM KeyValue kv
GROUP BY key1
--
ERROR: Unrecognized name: key1 [at 1:37]
SELECT key as key1, (select (select key1))
                                    ^
==

# This works since the correlated subquery references the pre-GROUP BY
# version of the column because the correlated subquery itself is
# grouped.
select (select (select count(*) from tt.KitchenSink.repeated_int32_val))
from TestTable tt
group by 1;
--
QueryStmt
+-output_column_list=
| +-$groupby.$col1#7 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.$col1#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.$col1#7]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
        +-group_by_list=
          +-$col1#7 :=
            +-SubqueryExpr
              +-type=INT64
              +-subquery_type=SCALAR
              +-parameter_list=
              | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              +-subquery=
                +-ProjectScan
                  +-column_list=[$expr_subquery.$col1#6]
                  +-expr_list=
                  | +-$col1#6 :=
                  |   +-SubqueryExpr
                  |     +-type=INT64
                  |     +-subquery_type=SCALAR
                  |     +-parameter_list=
                  |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
                  |     +-subquery=
                  |       +-ProjectScan
                  |         +-column_list=[$aggregate.$agg1#5]
                  |         +-input_scan=
                  |           +-AggregateScan
                  |             +-column_list=[$aggregate.$agg1#5]
                  |             +-input_scan=
                  |             | +-ArrayScan
                  |             |   +-array_expr=
                  |             |   | +-GetProtoField
                  |             |   |   +-type=ARRAY<INT32>
                  |             |   |   +-expr=
                  |             |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
                  |             |   |   +-field_descriptor=repeated_int32_val
                  |             |   |   +-default_value=[]
                  |             |   +-element_column=$array.repeated_int32_val#4
                  |             +-aggregate_list=
                  |               +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
                  +-input_scan=
                    +-SingleRowScan
==

# This works since the correlated subquery references the pre-GROUP BY
# version of the column because it is inside an aggregate function call.
select AVG((select (select count(*) from tt.KitchenSink.repeated_int32_val)))
from TestTable tt
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#7 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#7]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
        +-aggregate_list=
          +-$agg1#7 :=
            +-AggregateFunctionCall(ZetaSQL:avg(INT64) -> DOUBLE)
              +-SubqueryExpr
                +-type=INT64
                +-subquery_type=SCALAR
                +-parameter_list=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-subquery=
                  +-ProjectScan
                    +-column_list=[$expr_subquery.$col1#6]
                    +-expr_list=
                    | +-$col1#6 :=
                    |   +-SubqueryExpr
                    |     +-type=INT64
                    |     +-subquery_type=SCALAR
                    |     +-parameter_list=
                    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
                    |     +-subquery=
                    |       +-ProjectScan
                    |         +-column_list=[$aggregate.$agg1#5]
                    |         +-input_scan=
                    |           +-AggregateScan
                    |             +-column_list=[$aggregate.$agg1#5]
                    |             +-input_scan=
                    |             | +-ArrayScan
                    |             |   +-array_expr=
                    |             |   | +-GetProtoField
                    |             |   |   +-type=ARRAY<INT32>
                    |             |   |   +-expr=
                    |             |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
                    |             |   |   +-field_descriptor=repeated_int32_val
                    |             |   |   +-default_value=[]
                    |             |   +-element_column=$array.repeated_int32_val#4
                    |             +-aggregate_list=
                    |               +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
                    +-input_scan=
                      +-SingleRowScan
==

# The correlation reference is in the subquery FROM clause.
#
# The correlation reference is not visible post-GROUP BY in the outer query.
select tt.TestEnum,
       (select (select count(*) from tt.KitchenSink.repeated_int32_val))
from TestTable tt
group by 1;
--
ERROR: Correlated aliases referenced in the from clause must refer to arrays that are valid to access from the outer query, but tt refers to an array that is not valid to access after GROUP BY or DISTINCT in the outer query [at 2:38]
       (select (select count(*) from tt.KitchenSink.repeated_int32_val))
                                     ^
==

# Correlated subquery in the WHERE clause.
#
SELECT key
FROM KeyValue kv
WHERE (select (select {{kv.|}}key + char_length(value))) = 5
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#5 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#5]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=KeyValue.[Key#1, Value#2]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-SubqueryExpr
        |       | +-type=INT64
        |       | +-subquery_type=SCALAR
        |       | +-parameter_list=
        |       | | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       | | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       | +-subquery=
        |       |   +-ProjectScan
        |       |     +-column_list=[$expr_subquery.$col1#4]
        |       |     +-expr_list=
        |       |     | +-$col1#4 :=
        |       |     |   +-SubqueryExpr
        |       |     |     +-type=INT64
        |       |     |     +-subquery_type=SCALAR
        |       |     |     +-parameter_list=
        |       |     |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |       |     |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
        |       |     |     +-subquery=
        |       |     |       +-ProjectScan
        |       |     |         +-column_list=[$expr_subquery.$col1#3]
        |       |     |         +-expr_list=
        |       |     |         | +-$col1#3 :=
        |       |     |         |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       |     |         |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |       |     |         |     +-FunctionCall(ZetaSQL:char_length(STRING) -> INT64)
        |       |     |         |       +-ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
        |       |     |         +-input_scan=
        |       |     |           +-SingleRowScan
        |       |     +-input_scan=
        |       |       +-SingleRowScan
        |       +-Literal(type=INT64, value=5)
        +-group_by_list=
          +-key#5 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The correlation reference is in the subquery's FROM clause.
SELECT tt.TestEnum
from TestTable tt
WHERE (select (select count(*) from tt.KitchenSink.repeated_int32_val)) = 5
group by 1;
--
QueryStmt
+-output_column_list=
| +-$groupby.TestEnum#7 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.TestEnum#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.TestEnum#7]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=TestTable.[TestEnum#2, KitchenSink#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=TestTable.[TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[1, 2], alias="tt")
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-SubqueryExpr
        |       | +-type=INT64
        |       | +-subquery_type=SCALAR
        |       | +-parameter_list=
        |       | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |       | +-subquery=
        |       |   +-ProjectScan
        |       |     +-column_list=[$expr_subquery.$col1#6]
        |       |     +-expr_list=
        |       |     | +-$col1#6 :=
        |       |     |   +-SubqueryExpr
        |       |     |     +-type=INT64
        |       |     |     +-subquery_type=SCALAR
        |       |     |     +-parameter_list=
        |       |     |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
        |       |     |     +-subquery=
        |       |     |       +-ProjectScan
        |       |     |         +-column_list=[$aggregate.$agg1#5]
        |       |     |         +-input_scan=
        |       |     |           +-AggregateScan
        |       |     |             +-column_list=[$aggregate.$agg1#5]
        |       |     |             +-input_scan=
        |       |     |             | +-ArrayScan
        |       |     |             |   +-array_expr=
        |       |     |             |   | +-GetProtoField
        |       |     |             |   |   +-type=ARRAY<INT32>
        |       |     |             |   |   +-expr=
        |       |     |             |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
        |       |     |             |   |   +-field_descriptor=repeated_int32_val
        |       |     |             |   |   +-default_value=[]
        |       |     |             |   +-element_column=$array.repeated_int32_val#4
        |       |     |             +-aggregate_list=
        |       |     |               +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |       |     +-input_scan=
        |       |       +-SingleRowScan
        |       +-Literal(type=INT64, value=5)
        +-group_by_list=
          +-TestEnum#7 := ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#2)
==

# Correlated subquery in the GROUP BY clause.
#
SELECT 'foo'
FROM KeyValue kv
GROUP BY (select (select {{kv.|}}key))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 := Literal(type=STRING, value="foo")
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-$groupbycol1#5 :=
            +-SubqueryExpr
              +-type=INT64
              +-subquery_type=SCALAR
              +-parameter_list=
              | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-subquery=
                +-ProjectScan
                  +-column_list=[$expr_subquery.$col1#4]
                  +-expr_list=
                  | +-$col1#4 :=
                  |   +-SubqueryExpr
                  |     +-type=INT64
                  |     +-subquery_type=SCALAR
                  |     +-parameter_list=
                  |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
                  |     +-subquery=
                  |       +-ProjectScan
                  |         +-column_list=[$expr_subquery.key#3]
                  |         +-expr_list=
                  |         | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
                  |         +-input_scan=
                  |           +-SingleRowScan
                  +-input_scan=
                    +-SingleRowScan
==

# The correlation reference is in the subquery's FROM clause.
SELECT 'foo'
from TestTable tt
GROUP BY (select (select count(*) from tt.KitchenSink.repeated_int32_val))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8]
    +-expr_list=
    | +-$col1#8 := Literal(type=STRING, value="foo")
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias="tt")
        +-group_by_list=
          +-$groupbycol1#7 :=
            +-SubqueryExpr
              +-type=INT64
              +-subquery_type=SCALAR
              +-parameter_list=
              | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              +-subquery=
                +-ProjectScan
                  +-column_list=[$expr_subquery.$col1#6]
                  +-expr_list=
                  | +-$col1#6 :=
                  |   +-SubqueryExpr
                  |     +-type=INT64
                  |     +-subquery_type=SCALAR
                  |     +-parameter_list=
                  |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
                  |     +-subquery=
                  |       +-ProjectScan
                  |         +-column_list=[$aggregate.$agg1#5]
                  |         +-input_scan=
                  |           +-AggregateScan
                  |             +-column_list=[$aggregate.$agg1#5]
                  |             +-input_scan=
                  |             | +-ArrayScan
                  |             |   +-array_expr=
                  |             |   | +-GetProtoField
                  |             |   |   +-type=ARRAY<INT32>
                  |             |   |   +-expr=
                  |             |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
                  |             |   |   +-field_descriptor=repeated_int32_val
                  |             |   |   +-default_value=[]
                  |             |   +-element_column=$array.repeated_int32_val#4
                  |             +-aggregate_list=
                  |               +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
                  +-input_scan=
                    +-SingleRowScan
==

# Correlated subquery in the HAVING clause.
#
SELECT key
FROM KeyValue kv
GROUP BY key
HAVING (select (select key)) = 5
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#3]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.key#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        |   +-group_by_list=
        |     +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-SubqueryExpr
            | +-type=INT64
            | +-subquery_type=SCALAR
            | +-parameter_list=
            | | +-ColumnRef(type=INT64, column=$groupby.key#3)
            | +-subquery=
            |   +-ProjectScan
            |     +-column_list=[$expr_subquery.$col1#5]
            |     +-expr_list=
            |     | +-$col1#5 :=
            |     |   +-SubqueryExpr
            |     |     +-type=INT64
            |     |     +-subquery_type=SCALAR
            |     |     +-parameter_list=
            |     |     | +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
            |     |     +-subquery=
            |     |       +-ProjectScan
            |     |         +-column_list=[$expr_subquery.key#4]
            |     |         +-expr_list=
            |     |         | +-key#4 := ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
            |     |         +-input_scan=
            |     |           +-SingleRowScan
            |     +-input_scan=
            |       +-SingleRowScan
            +-Literal(type=INT64, value=5)
==

SELECT key as k1
FROM KeyValue kv
GROUP BY key
HAVING (select (select k1 + key)) = 1
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS k1 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#3]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.key#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        |   +-group_by_list=
        |     +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-SubqueryExpr
            | +-type=INT64
            | +-subquery_type=SCALAR
            | +-parameter_list=
            | | +-ColumnRef(type=INT64, column=$groupby.key#3)
            | +-subquery=
            |   +-ProjectScan
            |     +-column_list=[$expr_subquery.$col1#5]
            |     +-expr_list=
            |     | +-$col1#5 :=
            |     |   +-SubqueryExpr
            |     |     +-type=INT64
            |     |     +-subquery_type=SCALAR
            |     |     +-parameter_list=
            |     |     | +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
            |     |     +-subquery=
            |     |       +-ProjectScan
            |     |         +-column_list=[$expr_subquery.$col1#4]
            |     |         +-expr_list=
            |     |         | +-$col1#4 :=
            |     |         |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |     |         |     +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
            |     |         |     +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
            |     |         +-input_scan=
            |     |           +-SingleRowScan
            |     +-input_scan=
            |       +-SingleRowScan
            +-Literal(type=INT64, value=1)
==

# The correlated reference is not visible post-grouping.
SELECT key
FROM KeyValue kv
GROUP BY key
HAVING (select (select value)) = 'a'
--
ERROR: An expression references column value which is neither grouped nor aggregated [at 4:24]
HAVING (select (select value)) = 'a'
                       ^
==

SELECT key
FROM KeyValue kv
GROUP BY key
HAVING (select (select kv.value)) = 'a'
--
ERROR: An expression references kv.value which is neither grouped nor aggregated [at 4:24]
HAVING (select (select kv.value)) = 'a'
                       ^
==

# The correlation reference is in the subquery's FROM clause.
SELECT tt.TestEnum
from TestTable tt
GROUP BY tt.TestEnum
HAVING (select (select count(*) from tt.KitchenSink.repeated_int32_val)) > 0
--
ERROR: Correlated aliases referenced in the from clause must refer to arrays that are valid to access from the outer query, but tt refers to an array that is not valid to access after GROUP BY or DISTINCT in the outer query [at 4:38]
HAVING (select (select count(*) from tt.KitchenSink.repeated_int32_val)) > 0
                                     ^
==

# Correlated subquery in the ORDER BY clause.
#
SELECT key
FROM KeyValue kv
GROUP BY key
ORDER BY (select (select key))
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.key#3, $orderby.$orderbycol1#6]
    |   +-expr_list=
    |   | +-$orderbycol1#6 :=
    |   |   +-SubqueryExpr
    |   |     +-type=INT64
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=$groupby.key#3)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$expr_subquery.$col1#5]
    |   |         +-expr_list=
    |   |         | +-$col1#5 :=
    |   |         |   +-SubqueryExpr
    |   |         |     +-type=INT64
    |   |         |     +-subquery_type=SCALAR
    |   |         |     +-parameter_list=
    |   |         |     | +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
    |   |         |     +-subquery=
    |   |         |       +-ProjectScan
    |   |         |         +-column_list=[$expr_subquery.key#4]
    |   |         |         +-expr_list=
    |   |         |         | +-key#4 := ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
    |   |         |         +-input_scan=
    |   |         |           +-SingleRowScan
    |   |         +-input_scan=
    |   |           +-SingleRowScan
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.key#3]
    |       +-input_scan=
    |       | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
    |       +-group_by_list=
    |         +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#6)
==

SELECT key as k1
FROM KeyValue kv
GROUP BY key
ORDER BY (select (select k1 + key))
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS k1 [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.key#3, $orderby.$orderbycol1#6]
    |   +-expr_list=
    |   | +-$orderbycol1#6 :=
    |   |   +-SubqueryExpr
    |   |     +-type=INT64
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=$groupby.key#3)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$expr_subquery.$col1#5]
    |   |         +-expr_list=
    |   |         | +-$col1#5 :=
    |   |         |   +-SubqueryExpr
    |   |         |     +-type=INT64
    |   |         |     +-subquery_type=SCALAR
    |   |         |     +-parameter_list=
    |   |         |     | +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
    |   |         |     +-subquery=
    |   |         |       +-ProjectScan
    |   |         |         +-column_list=[$expr_subquery.$col1#4]
    |   |         |         +-expr_list=
    |   |         |         | +-$col1#4 :=
    |   |         |         |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |         |         |     +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
    |   |         |         |     +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
    |   |         |         +-input_scan=
    |   |         |           +-SingleRowScan
    |   |         +-input_scan=
    |   |           +-SingleRowScan
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.key#3]
    |       +-input_scan=
    |       | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
    |       +-group_by_list=
    |         +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#6)
==

# The correlated reference is not visible post-grouping.
SELECT key
FROM KeyValue kv
GROUP BY key
ORDER BY (select (select value))
--
ERROR: An expression references column value which is neither grouped nor aggregated [at 4:26]
ORDER BY (select (select value))
                         ^
==

SELECT key
FROM KeyValue kv
GROUP BY key
ORDER BY (select (select kv.value))
--
ERROR: An expression references kv.value which is neither grouped nor aggregated [at 4:26]
ORDER BY (select (select kv.value))
                         ^
==

# The correlated reference is in the subquery's FROM clause.
SELECT tt.TestEnum
from TestTable tt
GROUP BY tt.TestEnum
ORDER BY (select (select count(*) from tt.KitchenSink.repeated_int32_val))
--
ERROR: Correlated aliases referenced in the from clause must refer to arrays that are valid to access from the outer query, but tt refers to an array that is not valid to access after GROUP BY or DISTINCT in the outer query [at 4:40]
ORDER BY (select (select count(*) from tt.KitchenSink.repeated_int32_val))
                                       ^
==

######################################################################
# Tests with two levels of correlation, where both outer queries have
# GROUP BY.
######################################################################
#
# The correlated 'key' reference resolves to the middle query, and
# resolves to the post-grouped version.
SELECT key,
       any_value((select (key, (select key))
                  from KeyValue
                  group by key))
FROM KeyValue kv
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#10 AS key [INT64]
| +-$aggregate.$agg1#9 AS "$col2" [STRUCT<INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#10, $aggregate.$agg1#9]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#10, $aggregate.$agg1#9]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
        | +-key#10 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-aggregate_list=
          +-$agg1#9 :=
            +-AggregateFunctionCall(ZetaSQL:any_value(STRUCT<INT64, INT64>) -> STRUCT<INT64, INT64>)
              +-SubqueryExpr
                +-type=STRUCT<INT64, INT64>
                +-subquery_type=SCALAR
                +-subquery=
                  +-ProjectScan
                    +-column_list=[$expr_subquery.$col1#8]
                    +-expr_list=
                    | +-$col1#8 :=
                    |   +-MakeStruct
                    |     +-type=STRUCT<INT64, INT64>
                    |     +-field_list=
                    |       +-ColumnRef(type=INT64, column=$groupby.key#6)
                    |       +-SubqueryExpr
                    |         +-type=INT64
                    |         +-subquery_type=SCALAR
                    |         +-parameter_list=
                    |         | +-ColumnRef(type=INT64, column=$groupby.key#6)
                    |         +-subquery=
                    |           +-ProjectScan
                    |             +-column_list=[$expr_subquery.key#7]
                    |             +-expr_list=
                    |             | +-key#7 := ColumnRef(type=INT64, column=$groupby.key#6, is_correlated=TRUE)
                    |             +-input_scan=
                    |               +-SingleRowScan
                    +-input_scan=
                      +-AggregateScan
                        +-column_list=[$groupby.key#6]
                        +-input_scan=
                        | +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0])
                        +-group_by_list=
                          +-key#6 := ColumnRef(type=INT64, column=KeyValue.Key#3)
==

# Same as the above query, but the outermost query groups by
# value.
SELECT value,
       any_value((select (key, (select key))
                 from KeyValue
                 group by key))
FROM KeyValue kv
GROUP BY value
--
QueryStmt
+-output_column_list=
| +-$groupby.value#10 AS value [STRING]
| +-$aggregate.$agg1#9 AS "$col2" [STRUCT<INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.value#10, $aggregate.$agg1#9]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.value#10, $aggregate.$agg1#9]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1], alias="kv")
        +-group_by_list=
        | +-value#10 := ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-aggregate_list=
          +-$agg1#9 :=
            +-AggregateFunctionCall(ZetaSQL:any_value(STRUCT<INT64, INT64>) -> STRUCT<INT64, INT64>)
              +-SubqueryExpr
                +-type=STRUCT<INT64, INT64>
                +-subquery_type=SCALAR
                +-subquery=
                  +-ProjectScan
                    +-column_list=[$expr_subquery.$col1#8]
                    +-expr_list=
                    | +-$col1#8 :=
                    |   +-MakeStruct
                    |     +-type=STRUCT<INT64, INT64>
                    |     +-field_list=
                    |       +-ColumnRef(type=INT64, column=$groupby.key#6)
                    |       +-SubqueryExpr
                    |         +-type=INT64
                    |         +-subquery_type=SCALAR
                    |         +-parameter_list=
                    |         | +-ColumnRef(type=INT64, column=$groupby.key#6)
                    |         +-subquery=
                    |           +-ProjectScan
                    |             +-column_list=[$expr_subquery.key#7]
                    |             +-expr_list=
                    |             | +-key#7 := ColumnRef(type=INT64, column=$groupby.key#6, is_correlated=TRUE)
                    |             +-input_scan=
                    |               +-SingleRowScan
                    +-input_scan=
                      +-AggregateScan
                        +-column_list=[$groupby.key#6]
                        +-input_scan=
                        | +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0])
                        +-group_by_list=
                          +-key#6 := ColumnRef(type=INT64, column=KeyValue.Key#3)
==

# The correlated 'key' reference resolves to the middle query, and
# fails to resolve since 'key' is not visible post-GROUP BY in
# the middle query (note that 'key' is visible post-GROUP BY in the
# outer query, but that is irrelevant in this case since the correlated
# 'key' resolves to the middle query).
SELECT key,
       any_value((select (value, (select key))
                 from KeyValue
                 group by value))
FROM KeyValue kv
GROUP BY key
--
ERROR: An expression references column key which is neither grouped nor aggregated [at 2:42]
       any_value((select (value, (select key))
                                         ^
==

# Correlated 'value' resolves to the outer query, and the
# intervening query has GROUP BY.
SELECT value,
       any_value((select (tt.TestEnum, (select value))
                 from TestTable TT
                 group by tt.TestEnum))
FROM KeyValue kv
GROUP BY value
--
QueryStmt
+-output_column_list=
| +-$groupby.value#11 AS value [STRING]
| +-$aggregate.$agg1#10 AS "$col2" [STRUCT<ENUM<zetasql_test__.TestEnum>, STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.value#11, $aggregate.$agg1#10]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.value#11, $aggregate.$agg1#10]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1], alias="kv")
        +-group_by_list=
        | +-value#11 := ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-aggregate_list=
          +-$agg1#10 :=
            +-AggregateFunctionCall(ZetaSQL:any_value(STRUCT<ENUM<zetasql_test__.TestEnum>, STRING>) -> STRUCT<ENUM<zetasql_test__.TestEnum>, STRING>)
              +-SubqueryExpr
                +-type=STRUCT<ENUM<zetasql_test__.TestEnum>, STRING>
                +-subquery_type=SCALAR
                +-parameter_list=
                | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                +-subquery=
                  +-ProjectScan
                    +-column_list=[$expr_subquery.$col1#9]
                    +-expr_list=
                    | +-$col1#9 :=
                    |   +-MakeStruct
                    |     +-type=STRUCT<ENUM<zetasql_test__.TestEnum>, STRING>
                    |     +-field_list=
                    |       +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=$groupby.TestEnum#7)
                    |       +-SubqueryExpr
                    |         +-type=STRING
                    |         +-subquery_type=SCALAR
                    |         +-parameter_list=
                    |         | +-ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
                    |         +-subquery=
                    |           +-ProjectScan
                    |             +-column_list=[$expr_subquery.value#8]
                    |             +-expr_list=
                    |             | +-value#8 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
                    |             +-input_scan=
                    |               +-SingleRowScan
                    +-input_scan=
                      +-AggregateScan
                        +-column_list=[$groupby.TestEnum#7]
                        +-input_scan=
                        | +-TableScan(column_list=[TestTable.TestEnum#4], table=TestTable, column_index_list=[1], alias="TT")
                        +-group_by_list=
                          +-TestEnum#7 := ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#4)
==

# The correlated reference 'KeyValue.key' is correlated to the outermost query,
# where the middle subquery is also resolved post-GROUP BY in the intermediate
# query.
select key
from KeyValue
group by key
having (select tt.TestEnum
        from TestTable TT
        group by tt.TestEnum
        having (select TestEnum = cast(KeyValue.key as "zetasql_test__.TestEnum"))) = 1;
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#3]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.key#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |   +-group_by_list=
        |     +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
            +-SubqueryExpr
            | +-type=ENUM<zetasql_test__.TestEnum>
            | +-subquery_type=SCALAR
            | +-parameter_list=
            | | +-ColumnRef(type=INT64, column=$groupby.key#3)
            | +-subquery=
            |   +-ProjectScan
            |     +-column_list=[$groupby.TestEnum#7]
            |     +-input_scan=
            |       +-FilterScan
            |         +-column_list=[$groupby.TestEnum#7]
            |         +-input_scan=
            |         | +-AggregateScan
            |         |   +-column_list=[$groupby.TestEnum#7]
            |         |   +-input_scan=
            |         |   | +-TableScan(column_list=[TestTable.TestEnum#5], table=TestTable, column_index_list=[1], alias="TT")
            |         |   +-group_by_list=
            |         |     +-TestEnum#7 := ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#5)
            |         +-filter_expr=
            |           +-SubqueryExpr
            |             +-type=BOOL
            |             +-subquery_type=SCALAR
            |             +-parameter_list=
            |             | +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
            |             | +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=$groupby.TestEnum#7)
            |             +-subquery=
            |               +-ProjectScan
            |                 +-column_list=[$expr_subquery.$col1#8]
            |                 +-expr_list=
            |                 | +-$col1#8 :=
            |                 |   +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
            |                 |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=$groupby.TestEnum#7, is_correlated=TRUE)
            |                 |     +-Cast(INT64 -> ENUM<zetasql_test__.TestEnum>)
            |                 |       +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
            |                 +-input_scan=
            |                   +-SingleRowScan
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
==

# Similar test as the previous query, but the correlated subquery is in
# the ORDER BY.
select key
from KeyValue
group by key
order by (select tt.TestEnum
          from TestTable TT
          group by tt.TestEnum
          order by (select TestEnum = cast(KeyValue.key as "zetasql_test__.TestEnum")));
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.key#3, $orderby.$orderbycol1#10]
    |   +-expr_list=
    |   | +-$orderbycol1#10 :=
    |   |   +-SubqueryExpr
    |   |     +-type=ENUM<zetasql_test__.TestEnum>
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=$groupby.key#3)
    |   |     +-subquery=
    |   |       +-OrderByScan
    |   |         +-column_list=[$groupby.TestEnum#7]
    |   |         +-input_scan=
    |   |         | +-ProjectScan
    |   |         |   +-column_list=[$groupby.TestEnum#7, $orderby.$orderbycol1#9]
    |   |         |   +-expr_list=
    |   |         |   | +-$orderbycol1#9 :=
    |   |         |   |   +-SubqueryExpr
    |   |         |   |     +-type=BOOL
    |   |         |   |     +-subquery_type=SCALAR
    |   |         |   |     +-parameter_list=
    |   |         |   |     | +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
    |   |         |   |     | +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=$groupby.TestEnum#7)
    |   |         |   |     +-subquery=
    |   |         |   |       +-ProjectScan
    |   |         |   |         +-column_list=[$expr_subquery.$col1#8]
    |   |         |   |         +-expr_list=
    |   |         |   |         | +-$col1#8 :=
    |   |         |   |         |   +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
    |   |         |   |         |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=$groupby.TestEnum#7, is_correlated=TRUE)
    |   |         |   |         |     +-Cast(INT64 -> ENUM<zetasql_test__.TestEnum>)
    |   |         |   |         |       +-ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
    |   |         |   |         +-input_scan=
    |   |         |   |           +-SingleRowScan
    |   |         |   +-input_scan=
    |   |         |     +-AggregateScan
    |   |         |       +-column_list=[$groupby.TestEnum#7]
    |   |         |       +-input_scan=
    |   |         |       | +-TableScan(column_list=[TestTable.TestEnum#5], table=TestTable, column_index_list=[1], alias="TT")
    |   |         |       +-group_by_list=
    |   |         |         +-TestEnum#7 := ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#5)
    |   |         +-order_by_item_list=
    |   |           +-OrderByItem
    |   |             +-column_ref=
    |   |               +-ColumnRef(type=BOOL, column=$orderby.$orderbycol1#9)
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.key#3]
    |       +-input_scan=
    |       | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |       +-group_by_list=
    |         +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=$orderby.$orderbycol1#10)
==

# The correlated reference in the HAVING clause is 'key'.  Both outer queries
# have 'key' in their scope (i.e., KeyValue.key, and TT.key).  In this query
# 'key' resolves to TT.key, and TT.key is not available post-GROUP BY, so
# this query produces an error.
# TODO: Determine if we can make the error message more explicit,
# in this case saying that it resolves to TT.key which is not available
# after GROUP BY.  I initially thought this query should work, since I
# thought 'key' resolved to KeyValue.key which *is* available after
# GROUP BY.  If we could improve the error message that would be helpful.
select key
from KeyValue
group by key
having (select tt.TestEnum
        from TestTable TT
        group by tt.TestEnum
        having (select TestEnum = cast(key as "zetasql_test__.TestEnum"))) = 1;
--
ERROR: An expression references column key which is neither grouped nor aggregated [at 7:40]
        having (select TestEnum = cast(key as "zetasql_test__.TestEnum"))) = 1;
                                       ^
==

# The correlated reference 'TestEnum' is correlated to the middle query, where
# the middle subquery is also resolved post-GROUP BY in the outermost query.
select key
from KeyValue
group by key
having (select tt.TestEnum
        from TestTable TT
        group by tt.TestEnum
        having (select TestEnum = 1)) = 2;
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#3]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.key#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |   +-group_by_list=
        |     +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
            +-SubqueryExpr
            | +-type=ENUM<zetasql_test__.TestEnum>
            | +-subquery_type=SCALAR
            | +-subquery=
            |   +-ProjectScan
            |     +-column_list=[$groupby.TestEnum#7]
            |     +-input_scan=
            |       +-FilterScan
            |         +-column_list=[$groupby.TestEnum#7]
            |         +-input_scan=
            |         | +-AggregateScan
            |         |   +-column_list=[$groupby.TestEnum#7]
            |         |   +-input_scan=
            |         |   | +-TableScan(column_list=[TestTable.TestEnum#5], table=TestTable, column_index_list=[1], alias="TT")
            |         |   +-group_by_list=
            |         |     +-TestEnum#7 := ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#5)
            |         +-filter_expr=
            |           +-SubqueryExpr
            |             +-type=BOOL
            |             +-subquery_type=SCALAR
            |             +-parameter_list=
            |             | +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=$groupby.TestEnum#7)
            |             +-subquery=
            |               +-ProjectScan
            |                 +-column_list=[$expr_subquery.$col1#8]
            |                 +-expr_list=
            |                 | +-$col1#8 :=
            |                 |   +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
            |                 |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=$groupby.TestEnum#7, is_correlated=TRUE)
            |                 |     +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
            |                 +-input_scan=
            |                   +-SingleRowScan
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2)
==

# This query mirrors a powerdrill test query.
#
# SELECT IFNULL(CAST(__table0.l AS INT64), 0) AS field,
#        IFNULL(SUM((SELECT IFNULL(SUM(IFNULL(CAST(__for2 AS DOUBLE), 0.0)),
#                                  0.0)
#                    FROM UNNEST(__flat1.dbl) AS __for2)), 0.0) AS value
# FROM simple_table_with_repeated_fields_0 AS __table0,
#      __table0.Records3 AS __flat1
# GROUP BY field
# HAVING (IFNULL(SUM((SELECT IFNULL(SUM((IFNULL(CAST(__for3 AS DOUBLE),
#                                               0.0) + 1.0)), 0.0)
#                     FROM UNNEST(__flat1.dbl) AS __for3)), 0.0) >= 14.0)
# ORDER BY field ASC, value ASC LIMIT 100
#
# The unparsed query for this is so large that re-analysis overflows stack
# (in debug mode only), so we skip testing the unparser here.
[no_run_unparser]
SELECT IFNULL(CAST(__table0.TestEnum AS INT64), 0) AS field,
       IFNULL(SUM((SELECT IFNULL(SUM(IFNULL(CAST(__for2 AS DOUBLE), 0.0)),
                                 0.0)
                   FROM UNNEST(__flat1.nested_repeated_int64) AS __for2)), 0.0)
         AS value
FROM TestTable AS __table0,
     __table0.KitchenSink.nested_repeated_value AS __flat1
GROUP BY field
HAVING (IFNULL(SUM((SELECT IFNULL(SUM((IFNULL(CAST(__for3 AS DOUBLE),
                                              0.0) + 1.0)), 0.0)
                    FROM UNNEST(__flat1.nested_repeated_int64) AS __for3)), 0.0) >= 14.0)
ORDER BY field ASC, value ASC LIMIT 100
--
QueryStmt
+-output_column_list=
| +-$groupby.field#10 AS field [INT64]
| +-$query.value#11 AS value [DOUBLE]
+-query=
  +-LimitOffsetScan
    +-column_list=[$groupby.field#10, $query.value#11]
    +-is_ordered=TRUE
    +-input_scan=
    | +-OrderByScan
    |   +-column_list=[$groupby.field#10, $query.value#11]
    |   +-is_ordered=TRUE
    |   +-input_scan=
    |   | +-FilterScan
    |   |   +-column_list=[$aggregate.$agg1#8, $groupby.field#10, $query.value#11, $aggregate.$agg2#15]
    |   |   +-input_scan=
    |   |   | +-ProjectScan
    |   |   |   +-column_list=[$aggregate.$agg1#8, $groupby.field#10, $query.value#11, $aggregate.$agg2#15]
    |   |   |   +-expr_list=
    |   |   |   | +-value#11 :=
    |   |   |   |   +-FunctionCall(ZetaSQL:ifnull(DOUBLE, DOUBLE) -> DOUBLE)
    |   |   |   |     +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1#8)
    |   |   |   |     +-Literal(type=DOUBLE, value=0)
    |   |   |   +-input_scan=
    |   |   |     +-AggregateScan
    |   |   |       +-column_list=[$groupby.field#10, $aggregate.$agg1#8, $aggregate.$agg2#15]
    |   |   |       +-input_scan=
    |   |   |       | +-ProjectScan
    |   |   |       |   +-column_list=[TestTable.TestEnum#2, TestTable.KitchenSink#3, $array.__flat1#4, $pre_groupby.field#9]
    |   |   |       |   +-expr_list=
    |   |   |       |   | +-field#9 :=
    |   |   |       |   |   +-FunctionCall(ZetaSQL:ifnull(INT64, INT64) -> INT64)
    |   |   |       |   |     +-Cast(ENUM<zetasql_test__.TestEnum> -> INT64)
    |   |   |       |   |     | +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#2)
    |   |   |       |   |     +-Literal(type=INT64, value=0)
    |   |   |       |   +-input_scan=
    |   |   |       |     +-ArrayScan
    |   |   |       |       +-column_list=[TestTable.TestEnum#2, TestTable.KitchenSink#3, $array.__flat1#4]
    |   |   |       |       +-input_scan=
    |   |   |       |       | +-TableScan(column_list=TestTable.[TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[1, 2], alias="__table0")
    |   |   |       |       +-array_expr=
    |   |   |       |       | +-GetProtoField
    |   |   |       |       |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
    |   |   |       |       |   +-expr=
    |   |   |       |       |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |   |   |       |       |   +-field_descriptor=nested_repeated_value
    |   |   |       |       |   +-default_value=[]
    |   |   |       |       +-element_column=$array.__flat1#4
    |   |   |       +-group_by_list=
    |   |   |       | +-field#10 := ColumnRef(type=INT64, column=$pre_groupby.field#9)
    |   |   |       +-aggregate_list=
    |   |   |         +-$agg1#8 :=
    |   |   |         | +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
    |   |   |         |   +-SubqueryExpr
    |   |   |         |     +-type=DOUBLE
    |   |   |         |     +-subquery_type=SCALAR
    |   |   |         |     +-parameter_list=
    |   |   |         |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.__flat1#4)
    |   |   |         |     +-subquery=
    |   |   |         |       +-ProjectScan
    |   |   |         |         +-column_list=[$expr_subquery.$col1#7]
    |   |   |         |         +-expr_list=
    |   |   |         |         | +-$col1#7 :=
    |   |   |         |         |   +-FunctionCall(ZetaSQL:ifnull(DOUBLE, DOUBLE) -> DOUBLE)
    |   |   |         |         |     +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1#6)
    |   |   |         |         |     +-Literal(type=DOUBLE, value=0)
    |   |   |         |         +-input_scan=
    |   |   |         |           +-AggregateScan
    |   |   |         |             +-column_list=[$aggregate.$agg1#6]
    |   |   |         |             +-input_scan=
    |   |   |         |             | +-ArrayScan
    |   |   |         |             |   +-column_list=[$array.__for2#5]
    |   |   |         |             |   +-array_expr=
    |   |   |         |             |   | +-GetProtoField
    |   |   |         |             |   |   +-type=ARRAY<INT64>
    |   |   |         |             |   |   +-expr=
    |   |   |         |             |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.__flat1#4, is_correlated=TRUE)
    |   |   |         |             |   |   +-field_descriptor=nested_repeated_int64
    |   |   |         |             |   |   +-default_value=[]
    |   |   |         |             |   +-element_column=$array.__for2#5
    |   |   |         |             +-aggregate_list=
    |   |   |         |               +-$agg1#6 :=
    |   |   |         |                 +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
    |   |   |         |                   +-FunctionCall(ZetaSQL:ifnull(DOUBLE, DOUBLE) -> DOUBLE)
    |   |   |         |                     +-Cast(INT64 -> DOUBLE)
    |   |   |         |                     | +-ColumnRef(type=INT64, column=$array.__for2#5)
    |   |   |         |                     +-Literal(type=DOUBLE, value=0)
    |   |   |         +-$agg2#15 :=
    |   |   |           +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
    |   |   |             +-SubqueryExpr
    |   |   |               +-type=DOUBLE
    |   |   |               +-subquery_type=SCALAR
    |   |   |               +-parameter_list=
    |   |   |               | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.__flat1#4)
    |   |   |               +-subquery=
    |   |   |                 +-ProjectScan
    |   |   |                   +-column_list=[$expr_subquery.$col1#14]
    |   |   |                   +-expr_list=
    |   |   |                   | +-$col1#14 :=
    |   |   |                   |   +-FunctionCall(ZetaSQL:ifnull(DOUBLE, DOUBLE) -> DOUBLE)
    |   |   |                   |     +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1#13)
    |   |   |                   |     +-Literal(type=DOUBLE, value=0)
    |   |   |                   +-input_scan=
    |   |   |                     +-AggregateScan
    |   |   |                       +-column_list=[$aggregate.$agg1#13]
    |   |   |                       +-input_scan=
    |   |   |                       | +-ArrayScan
    |   |   |                       |   +-column_list=[$array.__for3#12]
    |   |   |                       |   +-array_expr=
    |   |   |                       |   | +-GetProtoField
    |   |   |                       |   |   +-type=ARRAY<INT64>
    |   |   |                       |   |   +-expr=
    |   |   |                       |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.__flat1#4, is_correlated=TRUE)
    |   |   |                       |   |   +-field_descriptor=nested_repeated_int64
    |   |   |                       |   |   +-default_value=[]
    |   |   |                       |   +-element_column=$array.__for3#12
    |   |   |                       +-aggregate_list=
    |   |   |                         +-$agg1#13 :=
    |   |   |                           +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
    |   |   |                             +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
    |   |   |                               +-FunctionCall(ZetaSQL:ifnull(DOUBLE, DOUBLE) -> DOUBLE)
    |   |   |                               | +-Cast(INT64 -> DOUBLE)
    |   |   |                               | | +-ColumnRef(type=INT64, column=$array.__for3#12)
    |   |   |                               | +-Literal(type=DOUBLE, value=0)
    |   |   |                               +-Literal(type=DOUBLE, value=1)
    |   |   +-filter_expr=
    |   |     +-FunctionCall(ZetaSQL:$greater_or_equal(DOUBLE, DOUBLE) -> BOOL)
    |   |       +-FunctionCall(ZetaSQL:ifnull(DOUBLE, DOUBLE) -> DOUBLE)
    |   |       | +-ColumnRef(type=DOUBLE, column=$aggregate.$agg2#15)
    |   |       | +-Literal(type=DOUBLE, value=0)
    |   |       +-Literal(type=DOUBLE, value=14)
    |   +-order_by_item_list=
    |     +-OrderByItem
    |     | +-column_ref=
    |     |   +-ColumnRef(type=INT64, column=$groupby.field#10)
    |     +-OrderByItem
    |       +-column_ref=
    |         +-ColumnRef(type=DOUBLE, column=$query.value#11)
    +-limit=
      +-Literal(type=INT64, value=100)
==

select int32_val as field,
       sum((select sum(t2)
            from UNNEST(t1.nested_repeated_int64) as t2))
from KitchenSinkValueTable t0,
     t0.nested_repeated_value t1
group by field
having sum((select sum(t3)
            from unnest(t1.nested_repeated_int64) as t3)) > 14;
--
QueryStmt
+-output_column_list=
| +-$groupby.field#7 AS field [INT32]
| +-$aggregate.$agg1#5 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.field#7, $aggregate.$agg1#5]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.field#7, $aggregate.$agg1#5, $aggregate.$agg2#10]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.field#7, $aggregate.$agg1#5, $aggregate.$agg2#10]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KitchenSinkValueTable.value#1, $array.t1#2, $pre_groupby.field#6]
        |   |   +-expr_list=
        |   |   | +-field#6 :=
        |   |   |   +-GetProtoField
        |   |   |     +-type=INT32
        |   |   |     +-expr=
        |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
        |   |   |     +-field_descriptor=int32_val
        |   |   |     +-default_value=77
        |   |   +-input_scan=
        |   |     +-ArrayScan
        |   |       +-column_list=[KitchenSinkValueTable.value#1, $array.t1#2]
        |   |       +-input_scan=
        |   |       | +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0], alias="t0")
        |   |       +-array_expr=
        |   |       | +-GetProtoField
        |   |       |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
        |   |       |   +-expr=
        |   |       |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
        |   |       |   +-field_descriptor=nested_repeated_value
        |   |       |   +-default_value=[]
        |   |       +-element_column=$array.t1#2
        |   +-group_by_list=
        |   | +-field#7 := ColumnRef(type=INT32, column=$pre_groupby.field#6)
        |   +-aggregate_list=
        |     +-$agg1#5 :=
        |     | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |     |   +-SubqueryExpr
        |     |     +-type=INT64
        |     |     +-subquery_type=SCALAR
        |     |     +-parameter_list=
        |     |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.t1#2)
        |     |     +-subquery=
        |     |       +-ProjectScan
        |     |         +-column_list=[$aggregate.$agg1#4]
        |     |         +-input_scan=
        |     |           +-AggregateScan
        |     |             +-column_list=[$aggregate.$agg1#4]
        |     |             +-input_scan=
        |     |             | +-ArrayScan
        |     |             |   +-column_list=[$array.t2#3]
        |     |             |   +-array_expr=
        |     |             |   | +-GetProtoField
        |     |             |   |   +-type=ARRAY<INT64>
        |     |             |   |   +-expr=
        |     |             |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.t1#2, is_correlated=TRUE)
        |     |             |   |   +-field_descriptor=nested_repeated_int64
        |     |             |   |   +-default_value=[]
        |     |             |   +-element_column=$array.t2#3
        |     |             +-aggregate_list=
        |     |               +-$agg1#4 :=
        |     |                 +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |     |                   +-ColumnRef(type=INT64, column=$array.t2#3)
        |     +-$agg2#10 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-SubqueryExpr
        |           +-type=INT64
        |           +-subquery_type=SCALAR
        |           +-parameter_list=
        |           | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.t1#2)
        |           +-subquery=
        |             +-ProjectScan
        |               +-column_list=[$aggregate.$agg1#9]
        |               +-input_scan=
        |                 +-AggregateScan
        |                   +-column_list=[$aggregate.$agg1#9]
        |                   +-input_scan=
        |                   | +-ArrayScan
        |                   |   +-column_list=[$array.t3#8]
        |                   |   +-array_expr=
        |                   |   | +-GetProtoField
        |                   |   |   +-type=ARRAY<INT64>
        |                   |   |   +-expr=
        |                   |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.t1#2, is_correlated=TRUE)
        |                   |   |   +-field_descriptor=nested_repeated_int64
        |                   |   |   +-default_value=[]
        |                   |   +-element_column=$array.t3#8
        |                   +-aggregate_list=
        |                     +-$agg1#9 :=
        |                       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |                         +-ColumnRef(type=INT64, column=$array.t3#8)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=$aggregate.$agg2#10)
            +-Literal(type=INT64, value=14)
==

# Tests with IN subquery, where the IN subquery is correlated.
#
# Correlated IN subquery in SELECT list.
SELECT key in (select key)
FROM KeyValue kv
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#4)
    |     +-in_expr=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.key#5]
    |         +-expr_list=
    |         | +-key#5 := ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

SELECT key in (select char_length(value))
FROM KeyValue kv
GROUP BY key
--
ERROR: An expression references column value which is neither grouped nor aggregated [at 1:35]
SELECT key in (select char_length(value))
                                  ^
==

# Correlated IN subquery in WHERE clause.
SELECT key
FROM KeyValue kv
WHERE key in (select char_length({{kv.|}}value))
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#4 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#4]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=KeyValue.[Key#1, Value#2]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        |   +-filter_expr=
        |     +-SubqueryExpr
        |       +-type=BOOL
        |       +-subquery_type=IN
        |       +-parameter_list=
        |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       +-in_expr=
        |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$expr_subquery.$col1#3]
        |           +-expr_list=
        |           | +-$col1#3 :=
        |           |   +-FunctionCall(ZetaSQL:char_length(STRING) -> INT64)
        |           |     +-ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
        |           +-input_scan=
        |             +-SingleRowScan
        +-group_by_list=
          +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# Correlated IN subquery in GROUP BY clause.
SELECT "a"
FROM KeyValue kv
GROUP BY key in (select key)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 := Literal(type=STRING, value="a")
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-$groupbycol1#4 :=
            +-SubqueryExpr
              +-type=BOOL
              +-subquery_type=IN
              +-parameter_list=
              | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-in_expr=
              | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-subquery=
                +-ProjectScan
                  +-column_list=[$expr_subquery.key#3]
                  +-expr_list=
                  | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
                  +-input_scan=
                    +-SingleRowScan
==

# Correlated IN subquery in HAVING clause.
SELECT key
FROM KeyValue kv
GROUP BY key
HAVING key in (select key)
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#3]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.key#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        |   +-group_by_list=
        |     +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-filter_expr=
          +-SubqueryExpr
            +-type=BOOL
            +-subquery_type=IN
            +-parameter_list=
            | +-ColumnRef(type=INT64, column=$groupby.key#3)
            +-in_expr=
            | +-ColumnRef(type=INT64, column=$groupby.key#3)
            +-subquery=
              +-ProjectScan
                +-column_list=[$expr_subquery.key#4]
                +-expr_list=
                | +-key#4 := ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
                +-input_scan=
                  +-SingleRowScan
==

# Correlated IN subquery in ORDER BY clause.
SELECT key
FROM KeyValue kv
GROUP BY key
ORDER BY key in (select key)
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.key#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.key#3, $orderby.$orderbycol1#5]
    |   +-expr_list=
    |   | +-$orderbycol1#5 :=
    |   |   +-SubqueryExpr
    |   |     +-type=BOOL
    |   |     +-subquery_type=IN
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=$groupby.key#3)
    |   |     +-in_expr=
    |   |     | +-ColumnRef(type=INT64, column=$groupby.key#3)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$expr_subquery.key#4]
    |   |         +-expr_list=
    |   |         | +-key#4 := ColumnRef(type=INT64, column=$groupby.key#3, is_correlated=TRUE)
    |   |         +-input_scan=
    |   |           +-SingleRowScan
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.key#3]
    |       +-input_scan=
    |       | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
    |       +-group_by_list=
    |         +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=BOOL, column=$orderby.$orderbycol1#5)
==

# The following tests cover correlated subqueries that have aggregation.
#
# Correlated aggregate subquery in SELECT list.
#
# The correlated value is aggregated in the subquery.
SELECT key, array(select max(kv.key) from KeyValue)
FROM KeyValue kv
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#6 AS key [INT64]
| +-$query.$col2#10 AS "$col2" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#6, $query.$col2#10]
    +-expr_list=
    | +-$col2#10 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<INT64>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#6)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$aggregate.$agg1#9]
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$aggregate.$agg1#9]
    |             +-input_scan=
    |             | +-TableScan(table=KeyValue)
    |             +-aggregate_list=
    |               +-$agg1#9 :=
    |                 +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |                   +-ColumnRef(type=INT64, column=$groupby.key#6, is_correlated=TRUE)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#6]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-key#6 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The correlated value is in the subquery SELECT LIST.
SELECT key, array(select as struct kv.key, max(kv1.key)
                  from KeyValue kv1
                  group by kv1.value)
FROM KeyValue kv
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#9 AS key [INT64]
| +-$query.$col2#16 AS "$col2" [ARRAY<STRUCT<key INT64, INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#9, $query.$col2#16]
    +-expr_list=
    | +-$col2#16 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<STRUCT<key INT64, INT64>>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#9)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#15]
    |         +-expr_list=
    |         | +-$struct#15 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<key INT64, INT64>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=$expr_subquery.key#14)
    |         |       +-ColumnRef(type=INT64, column=$aggregate.$agg1#12)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$expr_subquery.key#14, $aggregate.$agg1#12]
    |             +-expr_list=
    |             | +-key#14 := ColumnRef(type=INT64, column=$groupby.key#9, is_correlated=TRUE)
    |             +-input_scan=
    |               +-AggregateScan
    |                 +-column_list=[$aggregate.$agg1#12]
    |                 +-input_scan=
    |                 | +-TableScan(column_list=KeyValue.[Key#10, Value#11], table=KeyValue, column_index_list=[0, 1], alias="kv1")
    |                 +-group_by_list=
    |                 | +-value#13 := ColumnRef(type=STRING, column=KeyValue.Value#11)
    |                 +-aggregate_list=
    |                   +-$agg1#12 :=
    |                     +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |                       +-ColumnRef(type=INT64, column=KeyValue.Key#10)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#9]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-key#9 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The correlated value is in the subquery WHERE.
SELECT key, array(select max(kv1.key)
                  from KeyValue kv1
                  where kv1.key = kv.key
                  group by kv1.value)
FROM KeyValue kv
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#7 AS key [INT64]
| +-$query.$col2#12 AS "$col2" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#7, $query.$col2#12]
    +-expr_list=
    | +-$col2#12 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<INT64>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#7)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$aggregate.$agg1#10]
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$aggregate.$agg1#10]
    |             +-input_scan=
    |             | +-FilterScan
    |             |   +-column_list=KeyValue.[Key#8, Value#9]
    |             |   +-input_scan=
    |             |   | +-TableScan(column_list=KeyValue.[Key#8, Value#9], table=KeyValue, column_index_list=[0, 1], alias="kv1")
    |             |   +-filter_expr=
    |             |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |             |       +-ColumnRef(type=INT64, column=KeyValue.Key#8)
    |             |       +-ColumnRef(type=INT64, column=$groupby.key#7, is_correlated=TRUE)
    |             +-group_by_list=
    |             | +-value#11 := ColumnRef(type=STRING, column=KeyValue.Value#9)
    |             +-aggregate_list=
    |               +-$agg1#10 :=
    |                 +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |                   +-ColumnRef(type=INT64, column=KeyValue.Key#8)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#7]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The correlated value is in the subquery GROUP BY.
SELECT key, array(select max(kv1.key)
                  from KeyValue kv1
                  group by kv1.key, kv.key)
FROM KeyValue kv
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#8 AS key [INT64]
| +-$query.$col2#14 AS "$col2" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#8, $query.$col2#14]
    +-expr_list=
    | +-$col2#14 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<INT64>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#8)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$aggregate.$agg1#11]
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$aggregate.$agg1#11]
    |             +-input_scan=
    |             | +-TableScan(column_list=[KeyValue.Key#9], table=KeyValue, column_index_list=[0], alias="kv1")
    |             +-group_by_list=
    |             | +-key#12 := ColumnRef(type=INT64, column=KeyValue.Key#9)
    |             | +-key#13 := ColumnRef(type=INT64, column=$groupby.key#8, is_correlated=TRUE)
    |             +-aggregate_list=
    |               +-$agg1#11 :=
    |                 +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |                   +-ColumnRef(type=INT64, column=KeyValue.Key#9)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#8]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-key#8 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The correlated value is in the subquery HAVING.
SELECT key, array(select max(kv1.key)
                  from KeyValue kv1
                  group by kv1.key
                  having kv.key > 5)
FROM KeyValue kv
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#7 AS key [INT64]
| +-$query.$col2#12 AS "$col2" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#7, $query.$col2#12]
    +-expr_list=
    | +-$col2#12 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<INT64>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#7)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$aggregate.$agg1#10]
    |         +-input_scan=
    |           +-FilterScan
    |             +-column_list=[$aggregate.$agg1#10]
    |             +-input_scan=
    |             | +-AggregateScan
    |             |   +-column_list=[$aggregate.$agg1#10]
    |             |   +-input_scan=
    |             |   | +-TableScan(column_list=[KeyValue.Key#8], table=KeyValue, column_index_list=[0], alias="kv1")
    |             |   +-group_by_list=
    |             |   | +-key#11 := ColumnRef(type=INT64, column=KeyValue.Key#8)
    |             |   +-aggregate_list=
    |             |     +-$agg1#10 :=
    |             |       +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |             |         +-ColumnRef(type=INT64, column=KeyValue.Key#8)
    |             +-filter_expr=
    |               +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |                 +-ColumnRef(type=INT64, column=$groupby.key#7, is_correlated=TRUE)
    |                 +-Literal(type=INT64, value=5)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#7]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The correlated value is in the subquery ORDER BY.
SELECT key, (select max(kv1.key)
             from KeyValue kv1
             group by kv1.key
             order by kv.key)
FROM KeyValue kv
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#8 AS key [INT64]
| +-$query.$col2#14 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#8, $query.$col2#14]
    +-expr_list=
    | +-$col2#14 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#8)
    |     +-subquery=
    |       +-OrderByScan
    |         +-column_list=[$aggregate.$agg1#11]
    |         +-input_scan=
    |         | +-ProjectScan
    |         |   +-column_list=[$aggregate.$agg1#11, $orderby.$orderbycol1#13]
    |         |   +-expr_list=
    |         |   | +-$orderbycol1#13 := ColumnRef(type=INT64, column=$groupby.key#8, is_correlated=TRUE)
    |         |   +-input_scan=
    |         |     +-AggregateScan
    |         |       +-column_list=[$aggregate.$agg1#11]
    |         |       +-input_scan=
    |         |       | +-TableScan(column_list=[KeyValue.Key#9], table=KeyValue, column_index_list=[0], alias="kv1")
    |         |       +-group_by_list=
    |         |       | +-key#12 := ColumnRef(type=INT64, column=KeyValue.Key#9)
    |         |       +-aggregate_list=
    |         |         +-$agg1#11 :=
    |         |           +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |         |             +-ColumnRef(type=INT64, column=KeyValue.Key#9)
    |         +-order_by_item_list=
    |           +-OrderByItem
    |             +-column_ref=
    |               +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#13)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#8]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        +-group_by_list=
          +-key#8 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# Correlated aggregate subquery in WHERE clause.
#
# The correlated value is aggregated in the subquery.
SELECT key
FROM KeyValue kv
WHERE key = (select max(kv.key)
             from KeyValue)
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#6 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#6]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#6]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[KeyValue.Key#1]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-SubqueryExpr
        |         +-type=INT64
        |         +-subquery_type=SCALAR
        |         +-parameter_list=
        |         | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |         +-subquery=
        |           +-ProjectScan
        |             +-column_list=[$aggregate.$agg1#5]
        |             +-input_scan=
        |               +-AggregateScan
        |                 +-column_list=[$aggregate.$agg1#5]
        |                 +-input_scan=
        |                 | +-TableScan(table=KeyValue)
        |                 +-aggregate_list=
        |                   +-$agg1#5 :=
        |                     +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
        |                       +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        +-group_by_list=
          +-key#6 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The correlated value is in the subquery SELECT LIST.
SELECT key
FROM KeyValue kv
WHERE key in (select kv.key
              from KeyValue
              group by value)
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#7 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#7]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[KeyValue.Key#1]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        |   +-filter_expr=
        |     +-SubqueryExpr
        |       +-type=BOOL
        |       +-subquery_type=IN
        |       +-parameter_list=
        |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-in_expr=
        |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$expr_subquery.key#6]
        |           +-expr_list=
        |           | +-key#6 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |           +-input_scan=
        |             +-AggregateScan
        |               +-input_scan=
        |               | +-TableScan(column_list=[KeyValue.Value#4], table=KeyValue, column_index_list=[1])
        |               +-group_by_list=
        |                 +-value#5 := ColumnRef(type=STRING, column=KeyValue.Value#4)
        +-group_by_list=
          +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The correlated value is in the subquery WHERE.
SELECT key
FROM KeyValue kv
WHERE key in (select count(key)
              from KeyValue
              where key = kv.key
              group by value)
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#7 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#7]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[KeyValue.Key#1]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        |   +-filter_expr=
        |     +-SubqueryExpr
        |       +-type=BOOL
        |       +-subquery_type=IN
        |       +-parameter_list=
        |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-in_expr=
        |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$aggregate.$agg1#5]
        |           +-input_scan=
        |             +-AggregateScan
        |               +-column_list=[$aggregate.$agg1#5]
        |               +-input_scan=
        |               | +-FilterScan
        |               |   +-column_list=KeyValue.[Key#3, Value#4]
        |               |   +-input_scan=
        |               |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
        |               |   +-filter_expr=
        |               |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |               |       +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        |               |       +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |               +-group_by_list=
        |               | +-value#6 := ColumnRef(type=STRING, column=KeyValue.Value#4)
        |               +-aggregate_list=
        |                 +-$agg1#5 :=
        |                   +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |                     +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        +-group_by_list=
          +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The correlated value is in the subquery GROUP BY.
SELECT key
FROM KeyValue kv
WHERE key in (select count(key)
              from KeyValue
              group by kv.value, kv.key, value)
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#9 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#9]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#9]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=KeyValue.[Key#1, Value#2]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        |   +-filter_expr=
        |     +-SubqueryExpr
        |       +-type=BOOL
        |       +-subquery_type=IN
        |       +-parameter_list=
        |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       +-in_expr=
        |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$aggregate.$agg1#5]
        |           +-input_scan=
        |             +-AggregateScan
        |               +-column_list=[$aggregate.$agg1#5]
        |               +-input_scan=
        |               | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
        |               +-group_by_list=
        |               | +-value#6 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
        |               | +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |               | +-value#8 := ColumnRef(type=STRING, column=KeyValue.Value#4)
        |               +-aggregate_list=
        |                 +-$agg1#5 :=
        |                   +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |                     +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        +-group_by_list=
          +-key#9 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The correlated value is in the subquery HAVING.
SELECT key
FROM KeyValue kv
WHERE key in (select count(key)
              from KeyValue
              group by value
              having kv.key > 0)
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#7 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#7]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[KeyValue.Key#1]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        |   +-filter_expr=
        |     +-SubqueryExpr
        |       +-type=BOOL
        |       +-subquery_type=IN
        |       +-parameter_list=
        |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-in_expr=
        |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-subquery=
        |         +-ProjectScan
        |           +-column_list=[$aggregate.$agg1#5]
        |           +-input_scan=
        |             +-FilterScan
        |               +-column_list=[$aggregate.$agg1#5]
        |               +-input_scan=
        |               | +-AggregateScan
        |               |   +-column_list=[$aggregate.$agg1#5]
        |               |   +-input_scan=
        |               |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
        |               |   +-group_by_list=
        |               |   | +-value#6 := ColumnRef(type=STRING, column=KeyValue.Value#4)
        |               |   +-aggregate_list=
        |               |     +-$agg1#5 :=
        |               |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |               |         +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        |               +-filter_expr=
        |                 +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |                   +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |                   +-Literal(type=INT64, value=0)
        +-group_by_list=
          +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# The correlated value is in the subquery ORDER BY.
SELECT key
FROM KeyValue kv
WHERE key in (select count(key)
              from KeyValue
              group by value
              order by kv.key)
GROUP BY key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#8 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#8]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#8]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[KeyValue.Key#1]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
        |   +-filter_expr=
        |     +-SubqueryExpr
        |       +-type=BOOL
        |       +-subquery_type=IN
        |       +-parameter_list=
        |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-in_expr=
        |       | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-subquery=
        |         +-OrderByScan
        |           +-column_list=[$aggregate.$agg1#5]
        |           +-input_scan=
        |           | +-ProjectScan
        |           |   +-column_list=[$aggregate.$agg1#5, $orderby.$orderbycol1#7]
        |           |   +-expr_list=
        |           |   | +-$orderbycol1#7 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |           |   +-input_scan=
        |           |     +-AggregateScan
        |           |       +-column_list=[$aggregate.$agg1#5]
        |           |       +-input_scan=
        |           |       | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
        |           |       +-group_by_list=
        |           |       | +-value#6 := ColumnRef(type=STRING, column=KeyValue.Value#4)
        |           |       +-aggregate_list=
        |           |         +-$agg1#5 :=
        |           |           +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |           |             +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        |           +-order_by_item_list=
        |             +-OrderByItem
        |               +-column_ref=
        |                 +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#7)
        +-group_by_list=
          +-key#8 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# Correlated aggregate subquery in GROUP BY clause.
#
# The correlated value is aggregated in the subquery.
SELECT max(value)
FROM KeyValue kv
GROUP BY key in (select max(kv.key)
                 from KeyValue
                 group by key)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        +-group_by_list=
        | +-$groupbycol1#8 :=
        |   +-SubqueryExpr
        |     +-type=BOOL
        |     +-subquery_type=IN
        |     +-parameter_list=
        |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-in_expr=
        |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-subquery=
        |       +-ProjectScan
        |         +-column_list=[$aggregate.$agg1#6]
        |         +-input_scan=
        |           +-AggregateScan
        |             +-column_list=[$aggregate.$agg1#6]
        |             +-input_scan=
        |             | +-TableScan(column_list=[KeyValue.Key#4], table=KeyValue, column_index_list=[0])
        |             +-group_by_list=
        |             | +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#4)
        |             +-aggregate_list=
        |               +-$agg1#6 :=
        |                 +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
        |                   +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
              +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# The correlated value is in the subquery SELECT LIST.
SELECT max(value)
FROM KeyValue kv
GROUP BY (key, key) in (select as struct kv.key, key as key1
                        from KeyValue
                        group by key1)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        +-group_by_list=
        | +-$groupbycol1#11 :=
        |   +-SubqueryExpr
        |     +-type=BOOL
        |     +-subquery_type=IN
        |     +-parameter_list=
        |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-in_expr=
        |     | +-MakeStruct
        |     |   +-type=STRUCT<INT64, INT64>
        |     |   +-field_list=
        |     |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-subquery=
        |       +-ProjectScan
        |         +-column_list=[$in_subquery_cast.$struct#10]
        |         +-expr_list=
        |         | +-$struct#10 :=
        |         |   +-Cast(STRUCT<key INT64, key1 INT64> -> STRUCT<INT64, INT64>)
        |         |     +-ColumnRef(type=STRUCT<key INT64, key1 INT64>, column=$make_struct.$struct#8)
        |         +-input_scan=
        |           +-ProjectScan
        |             +-column_list=[$make_struct.$struct#8]
        |             +-expr_list=
        |             | +-$struct#8 :=
        |             |   +-MakeStruct
        |             |     +-type=STRUCT<key INT64, key1 INT64>
        |             |     +-field_list=
        |             |       +-ColumnRef(type=INT64, column=$expr_subquery.key#7)
        |             |       +-ColumnRef(type=INT64, column=$groupby.key1#6)
        |             +-input_scan=
        |               +-ProjectScan
        |                 +-column_list=[$expr_subquery.key#7, $groupby.key1#6]
        |                 +-expr_list=
        |                 | +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |                 +-input_scan=
        |                   +-AggregateScan
        |                     +-column_list=[$groupby.key1#6]
        |                     +-input_scan=
        |                     | +-TableScan(column_list=[KeyValue.Key#4], table=KeyValue, column_index_list=[0])
        |                     +-group_by_list=
        |                       +-key1#6 := ColumnRef(type=INT64, column=KeyValue.Key#4)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
              +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

SELECT max(value)
FROM KeyValue kv
GROUP BY key in (select kv.key
                 from KeyValue
                 group by key)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        +-group_by_list=
        | +-$groupbycol1#7 :=
        |   +-SubqueryExpr
        |     +-type=BOOL
        |     +-subquery_type=IN
        |     +-parameter_list=
        |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-in_expr=
        |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-subquery=
        |       +-ProjectScan
        |         +-column_list=[$groupby.key#6]
        |         +-input_scan=
        |           +-AggregateScan
        |             +-column_list=[$groupby.key#6]
        |             +-input_scan=
        |             | +-TableScan(table=KeyValue)
        |             +-group_by_list=
        |               +-key#6 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
              +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# The correlated value is in the subquery WHERE.
SELECT max(value)
FROM KeyValue kv
GROUP BY key in (select count(key)
                 from KeyValue
                 where key = kv.key
                 group by key)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        +-group_by_list=
        | +-$groupbycol1#8 :=
        |   +-SubqueryExpr
        |     +-type=BOOL
        |     +-subquery_type=IN
        |     +-parameter_list=
        |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-in_expr=
        |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-subquery=
        |       +-ProjectScan
        |         +-column_list=[$aggregate.$agg1#6]
        |         +-input_scan=
        |           +-AggregateScan
        |             +-column_list=[$aggregate.$agg1#6]
        |             +-input_scan=
        |             | +-FilterScan
        |             |   +-column_list=[KeyValue.Key#4]
        |             |   +-input_scan=
        |             |   | +-TableScan(column_list=[KeyValue.Key#4], table=KeyValue, column_index_list=[0])
        |             |   +-filter_expr=
        |             |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |             |       +-ColumnRef(type=INT64, column=KeyValue.Key#4)
        |             |       +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |             +-group_by_list=
        |             | +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#4)
        |             +-aggregate_list=
        |               +-$agg1#6 :=
        |                 +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |                   +-ColumnRef(type=INT64, column=KeyValue.Key#4)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
              +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# The correlated value is in the subquery GROUP BY.
SELECT max(value)
FROM KeyValue kv
GROUP BY key in (select count(key)
                 from KeyValue
                 group by kv.key, key)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        +-group_by_list=
        | +-$groupbycol1#9 :=
        |   +-SubqueryExpr
        |     +-type=BOOL
        |     +-subquery_type=IN
        |     +-parameter_list=
        |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-in_expr=
        |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-subquery=
        |       +-ProjectScan
        |         +-column_list=[$aggregate.$agg1#6]
        |         +-input_scan=
        |           +-AggregateScan
        |             +-column_list=[$aggregate.$agg1#6]
        |             +-input_scan=
        |             | +-TableScan(column_list=[KeyValue.Key#4], table=KeyValue, column_index_list=[0])
        |             +-group_by_list=
        |             | +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |             | +-key#8 := ColumnRef(type=INT64, column=KeyValue.Key#4)
        |             +-aggregate_list=
        |               +-$agg1#6 :=
        |                 +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |                   +-ColumnRef(type=INT64, column=KeyValue.Key#4)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
              +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# The correlated value is in the subquery HAVING.
SELECT max(value)
FROM KeyValue kv
GROUP BY key in (select count(key)
                 from KeyValue
                 group by key
                 having kv.key > 1)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        +-group_by_list=
        | +-$groupbycol1#8 :=
        |   +-SubqueryExpr
        |     +-type=BOOL
        |     +-subquery_type=IN
        |     +-parameter_list=
        |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-in_expr=
        |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-subquery=
        |       +-ProjectScan
        |         +-column_list=[$aggregate.$agg1#6]
        |         +-input_scan=
        |           +-FilterScan
        |             +-column_list=[$aggregate.$agg1#6]
        |             +-input_scan=
        |             | +-AggregateScan
        |             |   +-column_list=[$aggregate.$agg1#6]
        |             |   +-input_scan=
        |             |   | +-TableScan(column_list=[KeyValue.Key#4], table=KeyValue, column_index_list=[0])
        |             |   +-group_by_list=
        |             |   | +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#4)
        |             |   +-aggregate_list=
        |             |     +-$agg1#6 :=
        |             |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |             |         +-ColumnRef(type=INT64, column=KeyValue.Key#4)
        |             +-filter_expr=
        |               +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |                 +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |                 +-Literal(type=INT64, value=1)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
              +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# The correlated value is in the subquery ORDER BY.
SELECT max(value)
FROM KeyValue kv
GROUP BY key in (select count(key)
                 from KeyValue
                 group by key
                 order by kv.key)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        +-group_by_list=
        | +-$groupbycol1#9 :=
        |   +-SubqueryExpr
        |     +-type=BOOL
        |     +-subquery_type=IN
        |     +-parameter_list=
        |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-in_expr=
        |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-subquery=
        |       +-OrderByScan
        |         +-column_list=[$aggregate.$agg1#6]
        |         +-input_scan=
        |         | +-ProjectScan
        |         |   +-column_list=[$aggregate.$agg1#6, $orderby.$orderbycol1#8]
        |         |   +-expr_list=
        |         |   | +-$orderbycol1#8 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
        |         |   +-input_scan=
        |         |     +-AggregateScan
        |         |       +-column_list=[$aggregate.$agg1#6]
        |         |       +-input_scan=
        |         |       | +-TableScan(column_list=[KeyValue.Key#4], table=KeyValue, column_index_list=[0])
        |         |       +-group_by_list=
        |         |       | +-key#7 := ColumnRef(type=INT64, column=KeyValue.Key#4)
        |         |       +-aggregate_list=
        |         |         +-$agg1#6 :=
        |         |           +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |         |             +-ColumnRef(type=INT64, column=KeyValue.Key#4)
        |         +-order_by_item_list=
        |           +-OrderByItem
        |             +-column_ref=
        |               +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#8)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
              +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# Correlated aggregate subquery in HAVING clause.
#
# The correlated value is aggregated in the subquery.
SELECT max(value)
FROM KeyValue kv
GROUP BY key
HAVING (select max(kv.key)
        from KeyValue
        group by key) > 0
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        |   +-group_by_list=
        |   | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   +-aggregate_list=
        |     +-$agg1#3 :=
        |       +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
        |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            +-SubqueryExpr
            | +-type=INT64
            | +-subquery_type=SCALAR
            | +-parameter_list=
            | | +-ColumnRef(type=INT64, column=$groupby.key#4)
            | +-subquery=
            |   +-ProjectScan
            |     +-column_list=[$aggregate.$agg1#7]
            |     +-input_scan=
            |       +-AggregateScan
            |         +-column_list=[$aggregate.$agg1#7]
            |         +-input_scan=
            |         | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0])
            |         +-group_by_list=
            |         | +-key#8 := ColumnRef(type=INT64, column=KeyValue.Key#5)
            |         +-aggregate_list=
            |           +-$agg1#7 :=
            |             +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
            |               +-ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
            +-Literal(type=INT64, value=0)
==

# The correlated value is in the subquery SELECT LIST.
SELECT max(value)
FROM KeyValue kv
GROUP BY key
HAVING (select kv.key
        from KeyValue
        group by key) > 0
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        |   +-group_by_list=
        |   | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   +-aggregate_list=
        |     +-$agg1#3 :=
        |       +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
        |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            +-SubqueryExpr
            | +-type=INT64
            | +-subquery_type=SCALAR
            | +-parameter_list=
            | | +-ColumnRef(type=INT64, column=$groupby.key#4)
            | +-subquery=
            |   +-ProjectScan
            |     +-column_list=[$groupby.key#7]
            |     +-input_scan=
            |       +-AggregateScan
            |         +-column_list=[$groupby.key#7]
            |         +-input_scan=
            |         | +-TableScan(table=KeyValue)
            |         +-group_by_list=
            |           +-key#7 := ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
            +-Literal(type=INT64, value=0)
==

# The correlated value is in the subquery WHERE.
SELECT max(value)
FROM KeyValue kv
GROUP BY key
HAVING (select max(key)
        from KeyValue
        where key = kv.key
        group by key) > 0
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        |   +-group_by_list=
        |   | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   +-aggregate_list=
        |     +-$agg1#3 :=
        |       +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
        |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            +-SubqueryExpr
            | +-type=INT64
            | +-subquery_type=SCALAR
            | +-parameter_list=
            | | +-ColumnRef(type=INT64, column=$groupby.key#4)
            | +-subquery=
            |   +-ProjectScan
            |     +-column_list=[$aggregate.$agg1#7]
            |     +-input_scan=
            |       +-AggregateScan
            |         +-column_list=[$aggregate.$agg1#7]
            |         +-input_scan=
            |         | +-FilterScan
            |         |   +-column_list=[KeyValue.Key#5]
            |         |   +-input_scan=
            |         |   | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0])
            |         |   +-filter_expr=
            |         |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |         |       +-ColumnRef(type=INT64, column=KeyValue.Key#5)
            |         |       +-ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
            |         +-group_by_list=
            |         | +-key#8 := ColumnRef(type=INT64, column=KeyValue.Key#5)
            |         +-aggregate_list=
            |           +-$agg1#7 :=
            |             +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
            |               +-ColumnRef(type=INT64, column=KeyValue.Key#5)
            +-Literal(type=INT64, value=0)
==

# The correlated value is in the subquery GROUP BY.
SELECT max(value)
FROM KeyValue kv
GROUP BY key
HAVING (select max(key)
        from KeyValue
        group by kv.key, key) > 0
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        |   +-group_by_list=
        |   | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   +-aggregate_list=
        |     +-$agg1#3 :=
        |       +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
        |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            +-SubqueryExpr
            | +-type=INT64
            | +-subquery_type=SCALAR
            | +-parameter_list=
            | | +-ColumnRef(type=INT64, column=$groupby.key#4)
            | +-subquery=
            |   +-ProjectScan
            |     +-column_list=[$aggregate.$agg1#7]
            |     +-input_scan=
            |       +-AggregateScan
            |         +-column_list=[$aggregate.$agg1#7]
            |         +-input_scan=
            |         | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0])
            |         +-group_by_list=
            |         | +-key#8 := ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
            |         | +-key#9 := ColumnRef(type=INT64, column=KeyValue.Key#5)
            |         +-aggregate_list=
            |           +-$agg1#7 :=
            |             +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
            |               +-ColumnRef(type=INT64, column=KeyValue.Key#5)
            +-Literal(type=INT64, value=0)
==

# The correlated value is in the subquery HAVING.
SELECT max(value)
FROM KeyValue kv
GROUP BY key
HAVING (select max(key)
        from KeyValue
        group by key
        having kv.key > 0) > 0
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        |   +-group_by_list=
        |   | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   +-aggregate_list=
        |     +-$agg1#3 :=
        |       +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
        |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            +-SubqueryExpr
            | +-type=INT64
            | +-subquery_type=SCALAR
            | +-parameter_list=
            | | +-ColumnRef(type=INT64, column=$groupby.key#4)
            | +-subquery=
            |   +-ProjectScan
            |     +-column_list=[$aggregate.$agg1#7]
            |     +-input_scan=
            |       +-FilterScan
            |         +-column_list=[$aggregate.$agg1#7]
            |         +-input_scan=
            |         | +-AggregateScan
            |         |   +-column_list=[$aggregate.$agg1#7]
            |         |   +-input_scan=
            |         |   | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0])
            |         |   +-group_by_list=
            |         |   | +-key#8 := ColumnRef(type=INT64, column=KeyValue.Key#5)
            |         |   +-aggregate_list=
            |         |     +-$agg1#7 :=
            |         |       +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
            |         |         +-ColumnRef(type=INT64, column=KeyValue.Key#5)
            |         +-filter_expr=
            |           +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            |             +-ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
            |             +-Literal(type=INT64, value=0)
            +-Literal(type=INT64, value=0)
==

# The correlated value is in the subquery ORDER BY.
SELECT max(value)
FROM KeyValue kv
GROUP BY key
HAVING (select max(key)
        from KeyValue
        group by key
        order by kv.key) > 0
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
        |   +-group_by_list=
        |   | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   +-aggregate_list=
        |     +-$agg1#3 :=
        |       +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
        |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            +-SubqueryExpr
            | +-type=INT64
            | +-subquery_type=SCALAR
            | +-parameter_list=
            | | +-ColumnRef(type=INT64, column=$groupby.key#4)
            | +-subquery=
            |   +-OrderByScan
            |     +-column_list=[$aggregate.$agg1#7]
            |     +-input_scan=
            |     | +-ProjectScan
            |     |   +-column_list=[$aggregate.$agg1#7, $orderby.$orderbycol1#9]
            |     |   +-expr_list=
            |     |   | +-$orderbycol1#9 := ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
            |     |   +-input_scan=
            |     |     +-AggregateScan
            |     |       +-column_list=[$aggregate.$agg1#7]
            |     |       +-input_scan=
            |     |       | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0])
            |     |       +-group_by_list=
            |     |       | +-key#8 := ColumnRef(type=INT64, column=KeyValue.Key#5)
            |     |       +-aggregate_list=
            |     |         +-$agg1#7 :=
            |     |           +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
            |     |             +-ColumnRef(type=INT64, column=KeyValue.Key#5)
            |     +-order_by_item_list=
            |       +-OrderByItem
            |         +-column_ref=
            |           +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#9)
            +-Literal(type=INT64, value=0)
==

# Correlated aggregate subquery in ORDER BY clause.
#
# The correlated value is aggregated in the subquery.
SELECT max(value)
FROM KeyValue kv
GROUP BY key
ORDER BY (select max(kv.key)
          from KeyValue
          group by key);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-OrderByScan
    +-column_list=[$aggregate.$agg1#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3, $orderby.$orderbycol1#9]
    |   +-expr_list=
    |   | +-$orderbycol1#9 :=
    |   |   +-SubqueryExpr
    |   |     +-type=INT64
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=$groupby.key#4)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$aggregate.$agg1#7]
    |   |         +-input_scan=
    |   |           +-AggregateScan
    |   |             +-column_list=[$aggregate.$agg1#7]
    |   |             +-input_scan=
    |   |             | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0])
    |   |             +-group_by_list=
    |   |             | +-key#8 := ColumnRef(type=INT64, column=KeyValue.Key#5)
    |   |             +-aggregate_list=
    |   |               +-$agg1#7 :=
    |   |                 +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |   |                   +-ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
    |       +-input_scan=
    |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
    |       +-group_by_list=
    |       | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       +-aggregate_list=
    |         +-$agg1#3 :=
    |           +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
    |             +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#9)
==

# The correlated value is in the subquery SELECT LIST.
SELECT max(value)
FROM KeyValue kv
GROUP BY key
ORDER BY (select kv.key
          from KeyValue
          group by key);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-OrderByScan
    +-column_list=[$aggregate.$agg1#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3, $orderby.$orderbycol1#8]
    |   +-expr_list=
    |   | +-$orderbycol1#8 :=
    |   |   +-SubqueryExpr
    |   |     +-type=INT64
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=$groupby.key#4)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$groupby.key#7]
    |   |         +-input_scan=
    |   |           +-AggregateScan
    |   |             +-column_list=[$groupby.key#7]
    |   |             +-input_scan=
    |   |             | +-TableScan(table=KeyValue)
    |   |             +-group_by_list=
    |   |               +-key#7 := ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
    |       +-input_scan=
    |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
    |       +-group_by_list=
    |       | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       +-aggregate_list=
    |         +-$agg1#3 :=
    |           +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
    |             +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#8)
==

# The correlated value is in the subquery WHERE.
SELECT max(value)
FROM KeyValue kv
GROUP BY key
ORDER BY (select max(key)
          from KeyValue
          where kv.key = key
          group by key);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-OrderByScan
    +-column_list=[$aggregate.$agg1#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3, $orderby.$orderbycol1#9]
    |   +-expr_list=
    |   | +-$orderbycol1#9 :=
    |   |   +-SubqueryExpr
    |   |     +-type=INT64
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=$groupby.key#4)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$aggregate.$agg1#7]
    |   |         +-input_scan=
    |   |           +-AggregateScan
    |   |             +-column_list=[$aggregate.$agg1#7]
    |   |             +-input_scan=
    |   |             | +-FilterScan
    |   |             |   +-column_list=[KeyValue.Key#5]
    |   |             |   +-input_scan=
    |   |             |   | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0])
    |   |             |   +-filter_expr=
    |   |             |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   |             |       +-ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
    |   |             |       +-ColumnRef(type=INT64, column=KeyValue.Key#5)
    |   |             +-group_by_list=
    |   |             | +-key#8 := ColumnRef(type=INT64, column=KeyValue.Key#5)
    |   |             +-aggregate_list=
    |   |               +-$agg1#7 :=
    |   |                 +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |   |                   +-ColumnRef(type=INT64, column=KeyValue.Key#5)
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
    |       +-input_scan=
    |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
    |       +-group_by_list=
    |       | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       +-aggregate_list=
    |         +-$agg1#3 :=
    |           +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
    |             +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#9)
==

# The correlated value is in the subquery GROUP BY.
SELECT max(value)
FROM KeyValue kv
GROUP BY key
ORDER BY (select max(key)
          from KeyValue
          group by kv.key, key);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-OrderByScan
    +-column_list=[$aggregate.$agg1#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3, $orderby.$orderbycol1#10]
    |   +-expr_list=
    |   | +-$orderbycol1#10 :=
    |   |   +-SubqueryExpr
    |   |     +-type=INT64
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=$groupby.key#4)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$aggregate.$agg1#7]
    |   |         +-input_scan=
    |   |           +-AggregateScan
    |   |             +-column_list=[$aggregate.$agg1#7]
    |   |             +-input_scan=
    |   |             | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0])
    |   |             +-group_by_list=
    |   |             | +-key#8 := ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
    |   |             | +-key#9 := ColumnRef(type=INT64, column=KeyValue.Key#5)
    |   |             +-aggregate_list=
    |   |               +-$agg1#7 :=
    |   |                 +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |   |                   +-ColumnRef(type=INT64, column=KeyValue.Key#5)
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
    |       +-input_scan=
    |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
    |       +-group_by_list=
    |       | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       +-aggregate_list=
    |         +-$agg1#3 :=
    |           +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
    |             +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#10)
==

# The correlated value is in the subquery HAVING.
SELECT max(value)
FROM KeyValue kv
GROUP BY key
ORDER BY (select max(key)
          from KeyValue
          group by key
          having kv.key > 0);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-OrderByScan
    +-column_list=[$aggregate.$agg1#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3, $orderby.$orderbycol1#9]
    |   +-expr_list=
    |   | +-$orderbycol1#9 :=
    |   |   +-SubqueryExpr
    |   |     +-type=INT64
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=$groupby.key#4)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$aggregate.$agg1#7]
    |   |         +-input_scan=
    |   |           +-FilterScan
    |   |             +-column_list=[$aggregate.$agg1#7]
    |   |             +-input_scan=
    |   |             | +-AggregateScan
    |   |             |   +-column_list=[$aggregate.$agg1#7]
    |   |             |   +-input_scan=
    |   |             |   | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0])
    |   |             |   +-group_by_list=
    |   |             |   | +-key#8 := ColumnRef(type=INT64, column=KeyValue.Key#5)
    |   |             |   +-aggregate_list=
    |   |             |     +-$agg1#7 :=
    |   |             |       +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |   |             |         +-ColumnRef(type=INT64, column=KeyValue.Key#5)
    |   |             +-filter_expr=
    |   |               +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |   |                 +-ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
    |   |                 +-Literal(type=INT64, value=0)
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
    |       +-input_scan=
    |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
    |       +-group_by_list=
    |       | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       +-aggregate_list=
    |         +-$agg1#3 :=
    |           +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
    |             +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#9)
==

# The correlated value is in the subquery ORDER BY.
SELECT max(value)
FROM KeyValue kv
GROUP BY key
ORDER BY (select max(key)
          from KeyValue
          group by key
          order by kv.key);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
+-query=
  +-OrderByScan
    +-column_list=[$aggregate.$agg1#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.key#4, $aggregate.$agg1#3, $orderby.$orderbycol1#10]
    |   +-expr_list=
    |   | +-$orderbycol1#10 :=
    |   |   +-SubqueryExpr
    |   |     +-type=INT64
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=INT64, column=$groupby.key#4)
    |   |     +-subquery=
    |   |       +-OrderByScan
    |   |         +-column_list=[$aggregate.$agg1#7]
    |   |         +-input_scan=
    |   |         | +-ProjectScan
    |   |         |   +-column_list=[$aggregate.$agg1#7, $orderby.$orderbycol1#9]
    |   |         |   +-expr_list=
    |   |         |   | +-$orderbycol1#9 := ColumnRef(type=INT64, column=$groupby.key#4, is_correlated=TRUE)
    |   |         |   +-input_scan=
    |   |         |     +-AggregateScan
    |   |         |       +-column_list=[$aggregate.$agg1#7]
    |   |         |       +-input_scan=
    |   |         |       | +-TableScan(column_list=[KeyValue.Key#5], table=KeyValue, column_index_list=[0])
    |   |         |       +-group_by_list=
    |   |         |       | +-key#8 := ColumnRef(type=INT64, column=KeyValue.Key#5)
    |   |         |       +-aggregate_list=
    |   |         |         +-$agg1#7 :=
    |   |         |           +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |   |         |             +-ColumnRef(type=INT64, column=KeyValue.Key#5)
    |   |         +-order_by_item_list=
    |   |           +-OrderByItem
    |   |             +-column_ref=
    |   |               +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#9)
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
    |       +-input_scan=
    |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
    |       +-group_by_list=
    |       | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       +-aggregate_list=
    |         +-$agg1#3 :=
    |           +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
    |             +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#10)
==

##########################################################################
# Correlated subquery and USING
# The USING clause produces new names visible from the using clause.
# These tests cover correlated references that resolve to USING clause
# names.
##########################################################################

# GROUP BY 'kv1.key', reference 'key' variants in the subquery.
select kv1.key, (select {{kv1.|kv2.|}}key = 5)
from KeyValue kv1 JOIN KeyValue kv2 USING (key)
GROUP BY kv1.key
--
ALTERNATION GROUPS:
    kv1.
    <empty>
--
QueryStmt
+-output_column_list=
| +-$groupby.key#6 AS key [INT64]
| +-$query.$col2#8 AS "$col2" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#6, $query.$col2#8]
    +-expr_list=
    | +-$col2#8 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#6)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#7]
    |         +-expr_list=
    |         | +-$col1#7 :=
    |         |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |         |     +-ColumnRef(type=INT64, column=$groupby.key#6, is_correlated=TRUE)
    |         |     +-Literal(type=INT64, value=5)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#6]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=KeyValue.[Key#1, Key#3]
        |   +-left_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv1")
        |   +-right_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0], alias="kv2")
        |   +-join_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        +-group_by_list=
          +-key#6 := ColumnRef(type=INT64, column=KeyValue.Key#1)
--
ALTERNATION GROUP: kv2.
--
ERROR: An expression references kv2.key which is neither grouped nor aggregated [at 1:25]
select kv1.key, (select kv2.key = 5)
                        ^
==

# GROUP BY the USING 'key', reference 'key' variants in the subquery.
select key, (select {{kv1.|kv2.|}}key = 5)
from KeyValue kv1 JOIN KeyValue kv2 USING (key)
GROUP BY key
--
ALTERNATION GROUPS:
    kv1.
    <empty>
--
QueryStmt
+-output_column_list=
| +-$groupby.key#6 AS key [INT64]
| +-$query.$col2#8 AS "$col2" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#6, $query.$col2#8]
    +-expr_list=
    | +-$col2#8 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.key#6)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#7]
    |         +-expr_list=
    |         | +-$col1#7 :=
    |         |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |         |     +-ColumnRef(type=INT64, column=$groupby.key#6, is_correlated=TRUE)
    |         |     +-Literal(type=INT64, value=5)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#6]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=KeyValue.[Key#1, Key#3]
        |   +-left_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv1")
        |   +-right_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0], alias="kv2")
        |   +-join_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        +-group_by_list=
          +-key#6 := ColumnRef(type=INT64, column=KeyValue.Key#1)
--
ALTERNATION GROUP: kv2.
--
ERROR: An expression references kv2.key which is neither grouped nor aggregated [at 1:21]
select key, (select kv2.key = 5)
                    ^
==

# GROUP BY the USING 'key', reference 'value' variants in the subquery.
select kv1.key, (select {{kv1.|kv2.|}}value = 'a')
from KeyValue kv1 JOIN KeyValue kv2 USING (key)
GROUP BY kv1.key
--
ALTERNATION GROUP: kv1.
--
ERROR: An expression references kv1.value which is neither grouped nor aggregated [at 1:25]
select kv1.key, (select kv1.value = 'a')
                        ^
--
ALTERNATION GROUP: kv2.
--
ERROR: An expression references kv2.value which is neither grouped nor aggregated [at 1:25]
select kv1.key, (select kv2.value = 'a')
                        ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Column name value is ambiguous [at 1:25]
select kv1.key, (select value = 'a')
                        ^
==

# Correlated range variables are not valid to access (they cannot currently
# be grouped by), so kv1.* is not valid.
select key, (select as struct {{kv1|kv2}}.*)
from KeyValue kv1 JOIN KeyValue kv2 USING (key)
GROUP BY key
--
ALTERNATION GROUP: kv1
--
ERROR: An expression references table alias kv1 which is neither grouped nor aggregated [at 1:31]
select key, (select as struct kv1.*)
                              ^
--
ALTERNATION GROUP: kv2
--
ERROR: An expression references table alias kv2 which is neither grouped nor aggregated [at 1:31]
select key, (select as struct kv2.*)
                              ^
==

select kv1.key, (select kv1.bad_col_name)
from KeyValue kv1
GROUP BY kv1.key
--
ERROR: Name bad_col_name not found inside kv1 [at 1:29]
select kv1.key, (select kv1.bad_col_name)
                            ^
==

######################################################################
# Tests at the intersection of GROUP BY/DISTINCT, correlation,
# and pseudocolumns.
######################################################################
#
# The pseudocolumn should not be visible post-GROUP BY.
select int32_val as field,
       (select t0.has_int32_val)
from KitchenSinkValueTable t0
group by field
--
ERROR: An expression references t0.has_int32_val which is neither grouped nor aggregated [at 2:16]
       (select t0.has_int32_val)
               ^
==

# The pseudocolumn should not be visible post-DISTINCT.
select distinct int32_val
from KitchenSinkValueTable t0
order by int32_val, t0.has_int32_val;
--
ERROR: ORDER BY clause expression references t0.has_int32_val which is not visible after SELECT DISTINCT [at 3:21]
order by int32_val, t0.has_int32_val;
                    ^
==

# The pseudocolumn is in the GROUP BY, so it should be visible
# after GROUP BY.
select t0.has_int32_val
from KitchenSinkValueTable t0
group by 1
order by (select {{t0.|}}has_int32_val)
--
QueryStmt
+-output_column_list=
| +-$groupby.has_int32_val#3 AS has_int32_val [BOOL]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.has_int32_val#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.has_int32_val#3, $orderby.$orderbycol1#5]
    |   +-expr_list=
    |   | +-$orderbycol1#5 :=
    |   |   +-SubqueryExpr
    |   |     +-type=BOOL
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=BOOL, column=$groupby.has_int32_val#3)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$expr_subquery.has_int32_val#4]
    |   |         +-expr_list=
    |   |         | +-has_int32_val#4 := ColumnRef(type=BOOL, column=$groupby.has_int32_val#3, is_correlated=TRUE)
    |   |         +-input_scan=
    |   |           +-SingleRowScan
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.has_int32_val#3]
    |       +-input_scan=
    |       | +-ProjectScan
    |       |   +-column_list=[KitchenSinkValueTable.value#1, $pre_groupby.has_int32_val#2]
    |       |   +-expr_list=
    |       |   | +-has_int32_val#2 :=
    |       |   |   +-GetProtoField
    |       |   |     +-type=BOOL
    |       |   |     +-expr=
    |       |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |       |   |     +-field_descriptor=int32_val
    |       |   |     +-get_has_bit=TRUE
    |       |   +-input_scan=
    |       |     +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0], alias="t0")
    |       +-group_by_list=
    |         +-has_int32_val#3 := ColumnRef(type=BOOL, column=$pre_groupby.has_int32_val#2)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=BOOL, column=$orderby.$orderbycol1#5)
==

# The pseudocolumn is in the DISTINCT, so it should be visible
# after DISTINCT.
select distinct t0.has_int32_val
from KitchenSinkValueTable t0
order by (select {{t0.|}}has_int32_val)
--
QueryStmt
+-output_column_list=
| +-$distinct.has_int32_val#3 AS has_int32_val [BOOL]
+-query=
  +-OrderByScan
    +-column_list=[$distinct.has_int32_val#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$distinct.has_int32_val#3, $orderby.$orderbycol1#5]
    |   +-expr_list=
    |   | +-$orderbycol1#5 :=
    |   |   +-SubqueryExpr
    |   |     +-type=BOOL
    |   |     +-subquery_type=SCALAR
    |   |     +-parameter_list=
    |   |     | +-ColumnRef(type=BOOL, column=$distinct.has_int32_val#3)
    |   |     +-subquery=
    |   |       +-ProjectScan
    |   |         +-column_list=[$expr_subquery.has_int32_val#4]
    |   |         +-expr_list=
    |   |         | +-has_int32_val#4 := ColumnRef(type=BOOL, column=$distinct.has_int32_val#3, is_correlated=TRUE)
    |   |         +-input_scan=
    |   |           +-SingleRowScan
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$distinct.has_int32_val#3]
    |       +-input_scan=
    |       | +-ProjectScan
    |       |   +-column_list=[KitchenSinkValueTable.value#1, $query.has_int32_val#2]
    |       |   +-expr_list=
    |       |   | +-has_int32_val#2 :=
    |       |   |   +-GetProtoField
    |       |   |     +-type=BOOL
    |       |   |     +-expr=
    |       |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |       |   |     +-field_descriptor=int32_val
    |       |   |     +-get_has_bit=TRUE
    |       |   +-input_scan=
    |       |     +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0], alias="t0")
    |       +-group_by_list=
    |         +-has_int32_val#3 := ColumnRef(type=BOOL, column=$query.has_int32_val#2)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=BOOL, column=$orderby.$orderbycol1#5)
==

# Referencing a completely bogus field name after GROUP BY
# gives a reasonable error message for proto value tables.
select int32_val, (select t0.some_bogus_field_name)
from KitchenSinkValueTable t0
group by int32_val
--
ERROR: Protocol buffer zetasql_test__.KitchenSinkPB does not have a field called some_bogus_field_name [at 1:30]
select int32_val, (select t0.some_bogus_field_name)
                             ^
==

# Referencing a completely bogus field name after DISTINCT
# gives a misleading error message - it implies that field
# 'some_bogus_field_name' exists, but it does not.
# TODO: Fix this, though it will take a lot of
# new plumbing to keep track of every field that exists
# for each range variable/value table column.
select DISTINCT int32_val
from KitchenSinkValueTable t0
order by (select t0.some_bogus_field_name)
--
ERROR: An expression references t0.some_bogus_field_name which is neither grouped nor aggregated [at 3:18]
order by (select t0.some_bogus_field_name)
                 ^
==

select a, (select t0.some_bogus_field_name)
from TestStructValueTable t0
group by a
--
ERROR: Field name some_bogus_field_name does not exist in STRUCT<a INT32, b STRING> [at 1:22]
select a, (select t0.some_bogus_field_name)
                     ^
==

# Referencing a completely bogus field name after DISTINCT
# gives a similarly misleading error message for struct
# value tables.
select DISTINCT a
from TestStructValueTable t0
order by (select t0.some_bogus_field_name)
--
ERROR: An expression references t0.some_bogus_field_name which is neither grouped nor aggregated [at 3:18]
order by (select t0.some_bogus_field_name)
                 ^
==

# The original test case for b/25114252.
SELECT
  X,
  (SELECT COUNT(*) FROM (SELECT 1 AS Y) AS Bar WHERE Bar.Y = Foo.X) AS Matches
FROM (SELECT 1 AS X) AS Foo
GROUP BY X;
--
QueryStmt
+-output_column_list=
| +-$groupby.X#4 AS X [INT64]
| +-$query.Matches#7 AS Matches [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.X#4, $query.Matches#7]
    +-expr_list=
    | +-Matches#7 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$groupby.X#4)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$aggregate.$agg1#6]
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$aggregate.$agg1#6]
    |             +-input_scan=
    |             | +-FilterScan
    |             |   +-column_list=[Bar.Y#5]
    |             |   +-input_scan=
    |             |   | +-ProjectScan
    |             |   |   +-column_list=[Bar.Y#5]
    |             |   |   +-expr_list=
    |             |   |   | +-Y#5 := Literal(type=INT64, value=1)
    |             |   |   +-input_scan=
    |             |   |     +-SingleRowScan
    |             |   +-filter_expr=
    |             |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |             |       +-ColumnRef(type=INT64, column=Bar.Y#5)
    |             |       +-ColumnRef(type=INT64, column=$groupby.X#4, is_correlated=TRUE)
    |             +-aggregate_list=
    |               +-$agg1#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.X#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[Foo.X#1]
        |   +-expr_list=
        |   | +-X#1 := Literal(type=INT64, value=1)
        |   +-input_scan=
        |     +-SingleRowScan
        +-group_by_list=
          +-X#4 := ColumnRef(type=INT64, column=Foo.X#1)
