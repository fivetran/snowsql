# This file tests value tables.
#
# Value tables have have a single anonymous row type rather than a vector
# of named columns.
#
# When we select * from a value table, if the value has fields, we'll get
# flattened output with a column for each field.  Otherwise, we get the value.
#
# Field names inside value tables are also directly accessible like
# implicit column names.
select t from TestStructValueTable t
--
QueryStmt
+-output_column_list=
| +-TestStructValueTable.value#1 AS t [STRUCT<a INT32, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[TestStructValueTable.value#1]
    +-input_scan=
      +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0], alias='t')
==

select TestStructValueTable from TestStructValueTable
--
QueryStmt
+-output_column_list=
| +-TestStructValueTable.value#1 AS TestStructValueTable [STRUCT<a INT32, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[TestStructValueTable.value#1]
    +-input_scan=
      +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0])
==

select t.b from TestStructValueTable t
--
QueryStmt
+-output_column_list=
| +-$query.b#2 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.b#2]
    +-expr_list=
    | +-b#2 :=
    |   +-GetStructField
    |     +-type=STRING
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    |     +-field_idx=1
    +-input_scan=
      +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0], alias='t')
==

select TestStructValueTable.b from TestStructValueTable
--
QueryStmt
+-output_column_list=
| +-$query.b#2 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.b#2]
    +-expr_list=
    | +-b#2 :=
    |   +-GetStructField
    |     +-type=STRING
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    |     +-field_idx=1
    +-input_scan=
      +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0])
==

select t.* from TestStructValueTable t
--
QueryStmt
+-output_column_list=
| +-$query.a#2 AS a [INT32]
| +-$query.b#3 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[a#2, b#3]
    +-expr_list=
    | +-a#2 :=
    | | +-GetStructField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    | |   +-field_idx=0
    | +-b#3 :=
    |   +-GetStructField
    |     +-type=STRING
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    |     +-field_idx=1
    +-input_scan=
      +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0], alias='t')
==

select TestStructValueTable.* from TestStructValueTable
--
QueryStmt
+-output_column_list=
| +-$query.a#2 AS a [INT32]
| +-$query.b#3 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[a#2, b#3]
    +-expr_list=
    | +-a#2 :=
    | | +-GetStructField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    | |   +-field_idx=0
    | +-b#3 :=
    |   +-GetStructField
    |     +-type=STRING
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    |     +-field_idx=1
    +-input_scan=
      +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0])
==


# We can get value table fields implicitly, without a qualifier.
select t.a, a from TestStructValueTable t
--
QueryStmt
+-output_column_list=
| +-$query.a#2 AS a [INT32]
| +-$query.a#3 AS a [INT32]
+-query=
  +-ProjectScan
    +-column_list=$query.[a#2, a#3]
    +-expr_list=
    | +-a#2 :=
    | | +-GetStructField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    | |   +-field_idx=0
    | +-a#3 :=
    |   +-GetStructField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    |     +-field_idx=0
    +-input_scan=
      +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0], alias='t')
==

# Star returns the fields of a value table, not the value.
select * from TestStructValueTable
--
QueryStmt
+-output_column_list=
| +-$query.a#2 AS a [INT32]
| +-$query.b#3 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[a#2, b#3]
    +-expr_list=
    | +-a#2 :=
    | | +-GetStructField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    | |   +-field_idx=0
    | +-b#3 :=
    |   +-GetStructField
    |     +-type=STRING
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    |     +-field_idx=1
    +-input_scan=
      +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0])
==

# The SimpleTable implementation used in SampleCatalog uses "value" as the
# internal name for the column for the value table.
# This name "value" is never visible in SQL.
select {{value|t.value}} from TestStructValueTable t
--
ALTERNATION GROUP: value
--
ERROR: Unrecognized name: value [at 1:8]
select value from TestStructValueTable t
       ^
--
ALTERNATION GROUP: t.value
--
ERROR: Field name value does not exist in STRUCT<a INT32, b STRING> [at 1:10]
select t.value from TestStructValueTable t
         ^
==

select k from TestExtraValueTable k
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS k [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[TestExtraValueTable.value#1]
    +-input_scan=
      +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias='k')
==

# We can implicitly access fields and has_ fields of protos without qualifiers.
select k.int32_val1, str_value, has_int32_val2 from TestExtraValueTable k
--
QueryStmt
+-output_column_list=
| +-$query.int32_val1#4 AS int32_val1 [INT32]
| +-$query.str_value#5 AS str_value [ARRAY<STRING>]
| +-$query.has_int32_val2#6 AS has_int32_val2 [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[int32_val1#4, str_value#5, has_int32_val2#6]
    +-expr_list=
    | +-int32_val1#4 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-str_value#5 :=
    | | +-GetProtoField
    | |   +-type=ARRAY<STRING>
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    | |   +-field_descriptor=str_value
    | |   +-default_value=[]
    | +-has_int32_val2#6 :=
    |   +-GetProtoField
    |     +-type=BOOL
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |     +-field_descriptor=int32_val2
    |     +-get_has_bit=TRUE
    +-input_scan=
      +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias='k')
==

# We can implicitly access fields and has_ fields of protos from an outer
# scope inside a correlated subquery.
# Note that the parameter to the subquery is the proto, and the GetField
# happens inside.
select ARRAY(select AS STRUCT k.int32_val1, str_value, has_int32_val2)
from TestExtraValueTable k
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS "$col1" [ARRAY<STRUCT<int32_val1 INT32, str_value ARRAY<STRING>, has_int32_val2 BOOL>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8]
    +-expr_list=
    | +-$col1#8 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<STRUCT<int32_val1 INT32, str_value ARRAY<STRING>, has_int32_val2 BOOL>>
    |     +-subquery_type=ARRAY
    |     +-parameter_list=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#7]
    |         +-expr_list=
    |         | +-$struct#7 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<int32_val1 INT32, str_value ARRAY<STRING>, has_int32_val2 BOOL>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT32, column=$expr_subquery.int32_val1#4)
    |         |       +-ColumnRef(type=ARRAY<STRING>, column=$expr_subquery.str_value#5)
    |         |       +-ColumnRef(type=BOOL, column=$expr_subquery.has_int32_val2#6)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=$expr_subquery.[int32_val1#4, str_value#5, has_int32_val2#6]
    |             +-expr_list=
    |             | +-int32_val1#4 :=
    |             | | +-GetProtoField
    |             | |   +-type=INT32
    |             | |   +-expr=
    |             | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1, is_correlated=TRUE)
    |             | |   +-field_descriptor=int32_val1
    |             | |   +-default_value=0
    |             | +-str_value#5 :=
    |             | | +-GetProtoField
    |             | |   +-type=ARRAY<STRING>
    |             | |   +-expr=
    |             | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1, is_correlated=TRUE)
    |             | |   +-field_descriptor=str_value
    |             | |   +-default_value=[]
    |             | +-has_int32_val2#6 :=
    |             |   +-GetProtoField
    |             |     +-type=BOOL
    |             |     +-expr=
    |             |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1, is_correlated=TRUE)
    |             |     +-field_descriptor=int32_val2
    |             |     +-get_has_bit=TRUE
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias='k')
==

select k.* from TestExtraValueTable k
--
QueryStmt
+-output_column_list=
| +-$query.int32_val1#4 AS int32_val1 [INT32]
| +-$query.int32_val2#5 AS int32_val2 [INT32]
| +-$query.str_value#6 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$query.[int32_val1#4, int32_val2#5, str_value#6]
    +-expr_list=
    | +-int32_val1#4 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-int32_val2#5 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#6 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias='k')
==

select k.* from TestExtraValueTable k
--
[SAME AS PREVIOUS]
==

select k.k from TestExtraValueTable k
--
ERROR: Protocol buffer zetasql_test__.TestExtraPB does not have a field called k [at 1:10]
select k.k from TestExtraValueTable k
         ^
==

# Table alias overlaps with a field name.  Table alias is explicit and takes
# precedence.
select int32_val1 from TestExtraValueTable int32_val1
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS int32_val1 [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[TestExtraValueTable.value#1]
    +-input_scan=
      +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias='int32_val1')
==

select int32_val1.int32_val1 from TestExtraValueTable int32_val1
--
QueryStmt
+-output_column_list=
| +-$query.int32_val1#4 AS int32_val1 [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.int32_val1#4]
    +-expr_list=
    | +-int32_val1#4 :=
    |   +-GetProtoField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |     +-field_descriptor=int32_val1
    |     +-default_value=0
    +-input_scan=
      +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias='int32_val1')
==

select int32_val1.int32_val1.int32_val1 from TestExtraValueTable int32_val1
--
ERROR: Cannot access field int32_val1 on a value with type INT32 [at 1:30]
select int32_val1.int32_val1.int32_val1 from TestExtraValueTable int32_val1
                             ^
==

select e from EmptyMessageValueTable e
--
QueryStmt
+-output_column_list=
| +-EmptyMessageValueTable.value#1 AS e [PROTO<zetasql_test__.EmptyMessage>]
+-query=
  +-ProjectScan
    +-column_list=[EmptyMessageValueTable.value#1]
    +-input_scan=
      +-TableScan(column_list=[EmptyMessageValueTable.value#1], table=EmptyMessageValueTable, column_index_list=[0], alias='e')
==

# The empty proto has no fields so we get the proto back instead of an empty
# list of fields.  SELECT * should not fail and cannot return zero columns.
select * from EmptyMessageValueTable e
--
QueryStmt
+-output_column_list=
| +-EmptyMessageValueTable.value#1 AS e [PROTO<zetasql_test__.EmptyMessage>]
+-query=
  +-ProjectScan
    +-column_list=[EmptyMessageValueTable.value#1]
    +-input_scan=
      +-TableScan(column_list=[EmptyMessageValueTable.value#1], table=EmptyMessageValueTable, column_index_list=[0], alias='e')
==

select e.* from EmptyMessageValueTable e
--
ERROR: Star expansion is not allowed on proto zetasql_test__.EmptyMessage which has zero fields [at 1:8]
select e.* from EmptyMessageValueTable e
       ^
==

select e.f from EmptyMessageValueTable e
--
ERROR: Protocol buffer zetasql_test__.EmptyMessage does not have a field called f; Proto has no fields. Is the full proto descriptor available? [at 1:10]
select e.f from EmptyMessageValueTable e
         ^
==

select count(*) from EmptyMessageValueTable e where true
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-FilterScan
        |   +-input_scan=
        |   | +-TableScan(table=EmptyMessageValueTable, alias='e')
        |   +-filter_expr=
        |     +-Literal(type=BOOL, value=true)
        +-aggregate_list=
          +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

select Int32ValueTable from Int32ValueTable
--
QueryStmt
+-output_column_list=
| +-Int32ValueTable.value#1 AS Int32ValueTable [INT32]
+-query=
  +-ProjectScan
    +-column_list=[Int32ValueTable.value#1]
    +-input_scan=
      +-TableScan(column_list=[Int32ValueTable.value#1], table=Int32ValueTable, column_index_list=[0])
==

select i from Int32ValueTable i
--
QueryStmt
+-output_column_list=
| +-Int32ValueTable.value#1 AS i [INT32]
+-query=
  +-ProjectScan
    +-column_list=[Int32ValueTable.value#1]
    +-input_scan=
      +-TableScan(column_list=[Int32ValueTable.value#1], table=Int32ValueTable, column_index_list=[0], alias='i')
==

# SELECT * from a scalar value table returns the scalar value.
select * from Int32ValueTable i
--
[SAME AS PREVIOUS]
==

select i.* from Int32ValueTable i
--
ERROR: Dot-star is not supported for type INT32 [at 1:8]
select i.* from Int32ValueTable i
       ^
==

select i.i from Int32ValueTable i
--
ERROR: Cannot access field i on a value with type INT32 [at 1:10]
select i.i from Int32ValueTable i
         ^
==

select a from Int32ArrayValueTable a
--
QueryStmt
+-output_column_list=
| +-Int32ArrayValueTable.value#1 AS a [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[Int32ArrayValueTable.value#1]
    +-input_scan=
      +-TableScan(column_list=[Int32ArrayValueTable.value#1], table=Int32ArrayValueTable, column_index_list=[0], alias='a')
==

select * from Int32ArrayValueTable a
--
[SAME AS PREVIOUS]
==

select a.* from Int32ArrayValueTable a
--
ERROR: Dot-star is not supported for type ARRAY<INT32> [at 1:8]
select a.* from Int32ArrayValueTable a
       ^
==

select a, b from Int32ArrayValueTable a, unnest(a) b
--
QueryStmt
+-output_column_list=
| +-Int32ArrayValueTable.value#1 AS a [ARRAY<INT32>]
| +-$array.b#2 AS b [INT32]
+-query=
  +-ProjectScan
    +-column_list=[Int32ArrayValueTable.value#1, $array.b#2]
    +-input_scan=
      +-ArrayScan
        +-column_list=[Int32ArrayValueTable.value#1, $array.b#2]
        +-input_scan=
        | +-TableScan(column_list=[Int32ArrayValueTable.value#1], table=Int32ArrayValueTable, column_index_list=[0], alias='a')
        +-array_expr=
        | +-ColumnRef(type=ARRAY<INT32>, column=Int32ArrayValueTable.value#1)
        +-element_column=$array.b#2
==

select * from Int32ArrayValueTable, unnest(Int32ArrayValueTable)
--
QueryStmt
+-output_column_list=
| +-Int32ArrayValueTable.value#1 AS Int32ArrayValueTable [ARRAY<INT32>]
| +-$array.$unnest1#2 AS "$unnest1" [INT32]
+-query=
  +-ProjectScan
    +-column_list=[Int32ArrayValueTable.value#1, $array.$unnest1#2]
    +-input_scan=
      +-ArrayScan
        +-column_list=[Int32ArrayValueTable.value#1, $array.$unnest1#2]
        +-input_scan=
        | +-TableScan(column_list=[Int32ArrayValueTable.value#1], table=Int32ArrayValueTable, column_index_list=[0])
        +-array_expr=
        | +-ColumnRef(type=ARRAY<INT32>, column=Int32ArrayValueTable.value#1)
        +-element_column=$array.$unnest1#2
==

select * from Int32ArrayValueTable, Int32ArrayValueTable
--
ERROR: Duplicate table alias Int32ArrayValueTable in the same FROM clause [at 1:37]
select * from Int32ArrayValueTable, Int32ArrayValueTable
                                    ^
==

# Selecting cross product of three value tables.
select s,i,p from TestStructValueTable s, Int32ValueTable i, TestExtraValueTable p
--
QueryStmt
+-output_column_list=
| +-TestStructValueTable.value#1 AS s [STRUCT<a INT32, b STRING>]
| +-Int32ValueTable.value#2 AS i [INT32]
| +-TestExtraValueTable.value#3 AS p [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[TestStructValueTable.value#1, Int32ValueTable.value#2, TestExtraValueTable.value#3]
    +-input_scan=
      +-JoinScan
        +-column_list=[TestStructValueTable.value#1, Int32ValueTable.value#2, TestExtraValueTable.value#3]
        +-left_scan=
        | +-JoinScan
        |   +-column_list=[TestStructValueTable.value#1, Int32ValueTable.value#2]
        |   +-left_scan=
        |   | +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0], alias='s')
        |   +-right_scan=
        |     +-TableScan(column_list=[Int32ValueTable.value#2], table=Int32ValueTable, column_index_list=[0], alias='i')
        +-right_scan=
          +-TableScan(column_list=[TestExtraValueTable.value#3], table=TestExtraValueTable, column_index_list=[0], alias='p')
==

select * from TestStructValueTable s, Int32ValueTable i, TestExtraValueTable p
--
QueryStmt
+-output_column_list=
| +-$query.a#6 AS a [INT32]
| +-$query.b#7 AS b [STRING]
| +-Int32ValueTable.value#2 AS i [INT32]
| +-$query.int32_val1#8 AS int32_val1 [INT32]
| +-$query.int32_val2#9 AS int32_val2 [INT32]
| +-$query.str_value#10 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.a#6, $query.b#7, Int32ValueTable.value#2, $query.int32_val1#8, $query.int32_val2#9, $query.str_value#10]
    +-expr_list=
    | +-a#6 :=
    | | +-GetStructField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    | |   +-field_idx=0
    | +-b#7 :=
    | | +-GetStructField
    | |   +-type=STRING
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    | |   +-field_idx=1
    | +-int32_val1#8 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#3)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-int32_val2#9 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#3)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#10 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#3)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-JoinScan
        +-column_list=[TestStructValueTable.value#1, Int32ValueTable.value#2, TestExtraValueTable.value#3]
        +-left_scan=
        | +-JoinScan
        |   +-column_list=[TestStructValueTable.value#1, Int32ValueTable.value#2]
        |   +-left_scan=
        |   | +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0], alias='s')
        |   +-right_scan=
        |     +-TableScan(column_list=[Int32ValueTable.value#2], table=Int32ValueTable, column_index_list=[0], alias='i')
        +-right_scan=
          +-TableScan(column_list=[TestExtraValueTable.value#3], table=TestExtraValueTable, column_index_list=[0], alias='p')
==

# Select implicit fields from cross product of value tables.
select a, Int32ValueTable, int32_val1
from TestStructValueTable, Int32ValueTable, TestExtraValueTable
--
QueryStmt
+-output_column_list=
| +-$query.a#6 AS a [INT32]
| +-Int32ValueTable.value#2 AS Int32ValueTable [INT32]
| +-$query.int32_val1#7 AS int32_val1 [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.a#6, Int32ValueTable.value#2, $query.int32_val1#7]
    +-expr_list=
    | +-a#6 :=
    | | +-GetStructField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    | |   +-field_idx=0
    | +-int32_val1#7 :=
    |   +-GetProtoField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#3)
    |     +-field_descriptor=int32_val1
    |     +-default_value=0
    +-input_scan=
      +-JoinScan
        +-column_list=[TestStructValueTable.value#1, Int32ValueTable.value#2, TestExtraValueTable.value#3]
        +-left_scan=
        | +-JoinScan
        |   +-column_list=[TestStructValueTable.value#1, Int32ValueTable.value#2]
        |   +-left_scan=
        |   | +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0])
        |   +-right_scan=
        |     +-TableScan(column_list=[Int32ValueTable.value#2], table=Int32ValueTable, column_index_list=[0])
        +-right_scan=
          +-TableScan(column_list=[TestExtraValueTable.value#3], table=TestExtraValueTable, column_index_list=[0])
==

# Field 'a' conflicts with explicit column 'a' in the subquery.
select subq.a, vt.a, a
from (select 'xxx' a) subq, TestStructValueTable vt
--
ERROR: Column name a is ambiguous [at 1:22]
select subq.a, vt.a, a
                     ^
==

# Field 'str_value' is an implicit column from the unnested struct, and also
# a field on the rhs value table.
select t1.str_value, t2.str_value, str_value
from UNNEST(ARRAY(select AS STRUCT 'abc' str_value)) t1, TestExtraValueTable t2
--
ERROR: Column name str_value is ambiguous [at 1:36]
select t1.str_value, t2.str_value, str_value
                                   ^
==

# Ambiguous implicit field between two value tables.
select vt1.a, vt2.a {{|, a}}
from TestStructValueTable vt1, TestStructValueTable vt2
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.a#3 AS a [INT32]
| +-$query.a#4 AS a [INT32]
+-query=
  +-ProjectScan
    +-column_list=$query.[a#3, a#4]
    +-expr_list=
    | +-a#3 :=
    | | +-GetStructField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    | |   +-field_idx=0
    | +-a#4 :=
    |   +-GetStructField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#2)
    |     +-field_idx=0
    +-input_scan=
      +-JoinScan
        +-column_list=TestStructValueTable.[value#1, value#2]
        +-left_scan=
        | +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0], alias='vt1')
        +-right_scan=
          +-TableScan(column_list=[TestStructValueTable.value#2], table=TestStructValueTable, column_index_list=[0], alias='vt2')
--
ALTERNATION GROUP: , a
--
ERROR: Column name a is ambiguous [at 1:23]
select vt1.a, vt2.a , a
                      ^
==

# All these variants of upper/lowercase should work.
select {{c|C}}.{{a|A}}
from (select AS STRUCT struct<a int32, b int32>(8,9) C, 2 D) as foo
group by {{c|C}}.{{a|A}}
order by {{c|C}}.{{a|A}}
--
ALTERNATION GROUPS:
    c,a,c,a,c,a
    c,a,c,a,c,A
    c,a,c,a,C,a
    c,a,c,a,C,A
    c,a,C,a,c,a
    c,a,C,a,c,A
    c,a,C,a,C,a
    c,a,C,a,C,A
    C,a,c,a,c,a
    C,a,c,a,c,A
    C,a,c,a,C,a
    C,a,c,a,C,A
    C,a,C,a,c,a
    C,a,C,a,c,A
    C,a,C,a,C,a
    C,a,C,a,C,A
--
QueryStmt
+-output_column_list=
| +-$groupby.a#5 AS a [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.a#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.a#5]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$make_struct.$struct#3, $pre_groupby.a#4]
    |   |   +-expr_list=
    |   |   | +-a#4 :=
    |   |   |   +-GetStructField
    |   |   |     +-type=INT32
    |   |   |     +-expr=
    |   |   |     | +-GetStructField
    |   |   |     |   +-type=STRUCT<a INT32, b INT32>
    |   |   |     |   +-expr=
    |   |   |     |   | +-ColumnRef(type=STRUCT<C STRUCT<a INT32, b INT32>, D INT64>, column=$make_struct.$struct#3)
    |   |   |     |   +-field_idx=0
    |   |   |     +-field_idx=0
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$make_struct.$struct#3]
    |   |       +-expr_list=
    |   |       | +-$struct#3 :=
    |   |       |   +-MakeStruct
    |   |       |     +-type=STRUCT<C STRUCT<a INT32, b INT32>, D INT64>
    |   |       |     +-field_list=
    |   |       |       +-ColumnRef(type=STRUCT<a INT32, b INT32>, column=foo.C#1)
    |   |       |       +-ColumnRef(type=INT64, column=foo.D#2)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=foo.[C#1, D#2]
    |   |           +-expr_list=
    |   |           | +-C#1 := Literal(type=STRUCT<a INT32, b INT32>, value={a:8, b:9}, has_explicit_type=TRUE)
    |   |           | +-D#2 := Literal(type=INT64, value=2)
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-group_by_list=
    |     +-a#5 := ColumnRef(type=INT32, column=$pre_groupby.a#4)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$groupby.a#5)
--
ALTERNATION GROUPS:
    c,a,c,A,c,a
    c,a,c,A,c,A
    c,a,c,A,C,a
    c,a,c,A,C,A
    c,a,C,A,c,a
    c,a,C,A,c,A
    c,a,C,A,C,a
    c,a,C,A,C,A
    C,a,c,A,c,a
    C,a,c,A,c,A
    C,a,c,A,C,a
    C,a,c,A,C,A
    C,a,C,A,c,a
    C,a,C,A,c,A
    C,a,C,A,C,a
    C,a,C,A,C,A
--
QueryStmt
+-output_column_list=
| +-$groupby.A#5 AS a [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.A#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.A#5]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$make_struct.$struct#3, $pre_groupby.a#4]
    |   |   +-expr_list=
    |   |   | +-a#4 :=
    |   |   |   +-GetStructField
    |   |   |     +-type=INT32
    |   |   |     +-expr=
    |   |   |     | +-GetStructField
    |   |   |     |   +-type=STRUCT<a INT32, b INT32>
    |   |   |     |   +-expr=
    |   |   |     |   | +-ColumnRef(type=STRUCT<C STRUCT<a INT32, b INT32>, D INT64>, column=$make_struct.$struct#3)
    |   |   |     |   +-field_idx=0
    |   |   |     +-field_idx=0
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$make_struct.$struct#3]
    |   |       +-expr_list=
    |   |       | +-$struct#3 :=
    |   |       |   +-MakeStruct
    |   |       |     +-type=STRUCT<C STRUCT<a INT32, b INT32>, D INT64>
    |   |       |     +-field_list=
    |   |       |       +-ColumnRef(type=STRUCT<a INT32, b INT32>, column=foo.C#1)
    |   |       |       +-ColumnRef(type=INT64, column=foo.D#2)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=foo.[C#1, D#2]
    |   |           +-expr_list=
    |   |           | +-C#1 := Literal(type=STRUCT<a INT32, b INT32>, value={a:8, b:9}, has_explicit_type=TRUE)
    |   |           | +-D#2 := Literal(type=INT64, value=2)
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-group_by_list=
    |     +-A#5 := ColumnRef(type=INT32, column=$pre_groupby.a#4)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$groupby.A#5)
--
ALTERNATION GROUPS:
    c,A,c,a,c,a
    c,A,c,a,c,A
    c,A,c,a,C,a
    c,A,c,a,C,A
    c,A,C,a,c,a
    c,A,C,a,c,A
    c,A,C,a,C,a
    c,A,C,a,C,A
    C,A,c,a,c,a
    C,A,c,a,c,A
    C,A,c,a,C,a
    C,A,c,a,C,A
    C,A,C,a,c,a
    C,A,C,a,c,A
    C,A,C,a,C,a
    C,A,C,a,C,A
--
QueryStmt
+-output_column_list=
| +-$groupby.a#5 AS A [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.a#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.a#5]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$make_struct.$struct#3, $pre_groupby.A#4]
    |   |   +-expr_list=
    |   |   | +-A#4 :=
    |   |   |   +-GetStructField
    |   |   |     +-type=INT32
    |   |   |     +-expr=
    |   |   |     | +-GetStructField
    |   |   |     |   +-type=STRUCT<a INT32, b INT32>
    |   |   |     |   +-expr=
    |   |   |     |   | +-ColumnRef(type=STRUCT<C STRUCT<a INT32, b INT32>, D INT64>, column=$make_struct.$struct#3)
    |   |   |     |   +-field_idx=0
    |   |   |     +-field_idx=0
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$make_struct.$struct#3]
    |   |       +-expr_list=
    |   |       | +-$struct#3 :=
    |   |       |   +-MakeStruct
    |   |       |     +-type=STRUCT<C STRUCT<a INT32, b INT32>, D INT64>
    |   |       |     +-field_list=
    |   |       |       +-ColumnRef(type=STRUCT<a INT32, b INT32>, column=foo.C#1)
    |   |       |       +-ColumnRef(type=INT64, column=foo.D#2)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=foo.[C#1, D#2]
    |   |           +-expr_list=
    |   |           | +-C#1 := Literal(type=STRUCT<a INT32, b INT32>, value={a:8, b:9}, has_explicit_type=TRUE)
    |   |           | +-D#2 := Literal(type=INT64, value=2)
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-group_by_list=
    |     +-a#5 := ColumnRef(type=INT32, column=$pre_groupby.A#4)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$groupby.a#5)
--
ALTERNATION GROUPS:
    c,A,c,A,c,a
    c,A,c,A,c,A
    c,A,c,A,C,a
    c,A,c,A,C,A
    c,A,C,A,c,a
    c,A,C,A,c,A
    c,A,C,A,C,a
    c,A,C,A,C,A
    C,A,c,A,c,a
    C,A,c,A,c,A
    C,A,c,A,C,a
    C,A,c,A,C,A
    C,A,C,A,c,a
    C,A,C,A,c,A
    C,A,C,A,C,a
    C,A,C,A,C,A
--
QueryStmt
+-output_column_list=
| +-$groupby.A#5 AS A [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.A#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.A#5]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$make_struct.$struct#3, $pre_groupby.A#4]
    |   |   +-expr_list=
    |   |   | +-A#4 :=
    |   |   |   +-GetStructField
    |   |   |     +-type=INT32
    |   |   |     +-expr=
    |   |   |     | +-GetStructField
    |   |   |     |   +-type=STRUCT<a INT32, b INT32>
    |   |   |     |   +-expr=
    |   |   |     |   | +-ColumnRef(type=STRUCT<C STRUCT<a INT32, b INT32>, D INT64>, column=$make_struct.$struct#3)
    |   |   |     |   +-field_idx=0
    |   |   |     +-field_idx=0
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$make_struct.$struct#3]
    |   |       +-expr_list=
    |   |       | +-$struct#3 :=
    |   |       |   +-MakeStruct
    |   |       |     +-type=STRUCT<C STRUCT<a INT32, b INT32>, D INT64>
    |   |       |     +-field_list=
    |   |       |       +-ColumnRef(type=STRUCT<a INT32, b INT32>, column=foo.C#1)
    |   |       |       +-ColumnRef(type=INT64, column=foo.D#2)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=foo.[C#1, D#2]
    |   |           +-expr_list=
    |   |           | +-C#1 := Literal(type=STRUCT<a INT32, b INT32>, value={a:8, b:9}, has_explicit_type=TRUE)
    |   |           | +-D#2 := Literal(type=INT64, value=2)
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-group_by_list=
    |     +-A#5 := ColumnRef(type=INT32, column=$pre_groupby.A#4)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$groupby.A#5)
==

# It seems like all cases should work here: b/239418095
SELECT {{t.|}}*
FROM StructWithOneFieldValueTable AS t
GROUP BY {{t.x|x|1}}
--
ALTERNATION GROUP: t.,t.x
--
ERROR: Star expansion expression references column x which is neither grouped nor aggregated [at 1:8]
SELECT t.*
       ^
--
ALTERNATION GROUPS:
    t.,x
    t.,1
    x
    1
--
QueryStmt
+-output_column_list=
| +-$groupby.x#2 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.x#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.x#2]
        +-input_scan=
        | +-TableScan(column_list=[StructWithOneFieldValueTable.value#1], table=StructWithOneFieldValueTable, column_index_list=[0], alias='t')
        +-group_by_list=
          +-x#2 :=
            +-GetStructField
              +-type=INT64
              +-expr=
              | +-ColumnRef(type=STRUCT<x INT64>, column=StructWithOneFieldValueTable.value#1)
              +-field_idx=0
--
ALTERNATION GROUP: t.x
--
ERROR: Star expansion expression references column x which is neither grouped nor aggregated [at 1:8]
SELECT *
       ^
==

# Ambiguous name because it occurs as two fields in the same value table.
select c from (select AS STRUCT 1 C, "a" c)
--
ERROR: Column name c is ambiguous [at 1:8]
select c from (select AS STRUCT 1 C, "a" c)
       ^
==

# Same thing where we get a value table because we are unnesting
# an array (of structs).
select c from UNNEST(ARRAY(select AS STRUCT 1 c, "a" c))
--
ERROR: Column name c is ambiguous [at 1:8]
select c from UNNEST(ARRAY(select AS STRUCT 1 c, "a" c))
       ^
==

# Here, the name is already ambiguous, and then we add a value table.
select a
from (select 'x' a), (select b'y' a), TestStructValueTable
--
ERROR: Column name a is ambiguous [at 1:8]
select a
       ^
==

# Here, an implicit field name overlaps with an explicit range variable name.
# The explicit name wins.
select a, a.x, t.a
from (select 'x' x, 'y' y) a, TestStructValueTable t
--
QueryStmt
+-output_column_list=
| +-$query.a#5 AS a [STRUCT<x STRING, y STRING>]
| +-a.x#1 AS x [STRING]
| +-$query.a#6 AS a [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.a#5, a.x#1, $query.a#6]
    +-expr_list=
    | +-a#5 :=
    | | +-MakeStruct
    | |   +-type=STRUCT<x STRING, y STRING>
    | |   +-field_list=
    | |     +-ColumnRef(type=STRING, column=a.x#1)
    | |     +-ColumnRef(type=STRING, column=a.y#2)
    | +-a#6 :=
    |   +-GetStructField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#3)
    |     +-field_idx=0
    +-input_scan=
      +-JoinScan
        +-column_list=[a.x#1, a.y#2, TestStructValueTable.value#3]
        +-left_scan=
        | +-ProjectScan
        |   +-column_list=a.[x#1, y#2]
        |   +-expr_list=
        |   | +-x#1 := Literal(type=STRING, value='x')
        |   | +-y#2 := Literal(type=STRING, value='y')
        |   +-input_scan=
        |     +-SingleRowScan
        +-right_scan=
          +-TableScan(column_list=[TestStructValueTable.value#3], table=TestStructValueTable, column_index_list=[0], alias='t')
==

# When we do an array scan of a proto, we can access fields of that
# proto implicitly because the array scan acts like a value table.
select nested_int64, nested_repeated_int64
from TestTable t,
     t.KitchenSink.nested_repeated_value nrv
--
QueryStmt
+-output_column_list=
| +-$query.nested_int64#5 AS nested_int64 [INT64]
| +-$query.nested_repeated_int64#6 AS nested_repeated_int64 [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=$query.[nested_int64#5, nested_repeated_int64#6]
    +-expr_list=
    | +-nested_int64#5 :=
    | | +-GetProtoField
    | |   +-type=INT64
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nrv#4)
    | |   +-field_descriptor=nested_int64
    | |   +-default_value=88
    | +-nested_repeated_int64#6 :=
    |   +-GetProtoField
    |     +-type=ARRAY<INT64>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nrv#4)
    |     +-field_descriptor=nested_repeated_int64
    |     +-default_value=[]
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.KitchenSink#3, $array.nrv#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias='t')
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   +-field_descriptor=nested_repeated_value
        |   +-default_value=[]
        +-element_column=$array.nrv#4
==

# We cannot access fields of 'nrv' implicitly in the from clause,
# but they will work with UNNEST.
select 1
from TestTable t,
     t.KitchenSink.nested_repeated_value nrv,
     {{nested_repeated_int64|nested_repeated_int64.xxx|UNNEST(nested_repeated_int64)}}
--
ALTERNATION GROUP: nested_repeated_int64
--
ERROR: Table not found: nested_repeated_int64 (Unqualified identifiers in a FROM clause are always resolved as tables. Identifier nested_repeated_int64 is in scope but unqualified names cannot be resolved here.) [at 4:6]
     nested_repeated_int64
     ^
--
ALTERNATION GROUP: nested_repeated_int64.xxx
--
ERROR: Aliases referenced in the from clause must refer to preceding scans, and cannot refer to columns or fields on those scans. nested_repeated_int64 refers to a field and must be qualified with a table name. [at 4:6]
     nested_repeated_int64.xxx
     ^
--
ALTERNATION GROUP: UNNEST(nested_repeated_int64)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 := Literal(type=INT64, value=1)
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.KitchenSink#3, $array.nrv#4]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[TestTable.KitchenSink#3, $array.nrv#4]
        |   +-input_scan=
        |   | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias='t')
        |   +-array_expr=
        |   | +-GetProtoField
        |   |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
        |   |   +-expr=
        |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   +-field_descriptor=nested_repeated_value
        |   |   +-default_value=[]
        |   +-element_column=$array.nrv#4
        +-array_expr=
        | +-GetProtoField
        |   +-type=ARRAY<INT64>
        |   +-expr=
        |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>, column=$array.nrv#4)
        |   +-field_descriptor=nested_repeated_int64
        |   +-default_value=[]
        +-element_column=$array.$unnest1#5
==

# Field names of value tables work in JOIN USING.
# Here, the lhs is a value table and the rhs is not.
# See join_using.test for more JOIN USING tests on value tables.
select *
from TestStructValueTable join
     (select "xxx" xxx, 15 a) using (a)
--
QueryStmt
+-output_column_list=
| +-$join_left.a#4 AS a [INT32]
| +-$query.b#5 AS b [STRING]
| +-$subquery1.xxx#2 AS xxx [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$join_left.a#4, $query.b#5, $subquery1.xxx#2]
    +-expr_list=
    | +-b#5 :=
    |   +-GetStructField
    |     +-type=STRING
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
    |     +-field_idx=1
    +-input_scan=
      +-JoinScan
        +-column_list=[TestStructValueTable.value#1, $join_left.a#4, $subquery1.xxx#2, $subquery1.a#3]
        +-left_scan=
        | +-ProjectScan
        |   +-column_list=[TestStructValueTable.value#1, $join_left.a#4]
        |   +-expr_list=
        |   | +-a#4 :=
        |   |   +-GetStructField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
        |   |     +-field_idx=0
        |   +-input_scan=
        |     +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0])
        +-right_scan=
        | +-ProjectScan
        |   +-column_list=$subquery1.[xxx#2, a#3]
        |   +-expr_list=
        |   | +-xxx#2 := Literal(type=STRING, value='xxx')
        |   | +-a#3 := Literal(type=INT64, value=15)
        |   +-input_scan=
        |     +-SingleRowScan
        +-join_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-Cast(INT32 -> INT64)
            | +-ColumnRef(type=INT32, column=$join_left.a#4)
            +-ColumnRef(type=INT64, column=$subquery1.a#3)
==

# Output table from SELECT AS STRUCT is a value table.
select as struct 123 x
--
QueryStmt
+-output_column_list=
| +-$make_struct.$struct#2 AS "$struct" [STRUCT<x INT64>]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$make_struct.$struct#2]
    +-expr_list=
    | +-$struct#2 :=
    |   +-MakeStruct
    |     +-type=STRUCT<x INT64>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=$query.x#1)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$query.x#1]
        +-expr_list=
        | +-x#1 := Literal(type=INT64, value=123)
        +-input_scan=
          +-SingleRowScan
==

# Output table from SELECT AS PROTO is a value table.
select as "zetasql_test__.KeyValueStruct" 17 value, 'k' key
--
QueryStmt
+-output_column_list=
| +-$make_proto.$proto#3 AS "$proto" [PROTO<zetasql_test__.KeyValueStruct>]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$make_proto.$proto#3]
    +-expr_list=
    | +-$proto#3 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KeyValueStruct>
    |     +-field_list=
    |       +-value := ColumnRef(type=INT64, column=$query.value#1)
    |       +-key := ColumnRef(type=STRING, column=$query.key#2)
    +-input_scan=
      +-ProjectScan
        +-column_list=$query.[value#1, key#2]
        +-expr_list=
        | +-value#1 := Literal(type=INT64, value=17)
        | +-key#2 := Literal(type=STRING, value='k')
        +-input_scan=
          +-SingleRowScan
==

# Table subquery is a value table if it has AS STRUCT.
# Note diff with normal query: the STRUCT subquery is wrapped with MakeStruct.
# Implicit column/field names will work in either case.
select t, x, t.x from (select {{|as struct}} 123 x) t
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.t#3 AS t [STRUCT<x INT64>]
| +-t.x#1 AS x [INT64]
| +-t.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.t#3, t.x#1, t.x#1]
    +-expr_list=
    | +-t#3 :=
    |   +-MakeStruct
    |     +-type=STRUCT<x INT64>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=t.x#1)
    +-input_scan=
      +-ProjectScan
        +-column_list=[t.x#1]
        +-expr_list=
        | +-x#1 := Literal(type=INT64, value=123)
        +-input_scan=
          +-SingleRowScan
--
ALTERNATION GROUP: as struct
--
QueryStmt
+-output_column_list=
| +-$make_struct.$struct#2 AS t [STRUCT<x INT64>]
| +-$query.x#3 AS x [INT64]
| +-$query.x#4 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$make_struct.$struct#2, $query.x#3, $query.x#4]
    +-expr_list=
    | +-x#3 :=
    | | +-GetStructField
    | |   +-type=INT64
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<x INT64>, column=$make_struct.$struct#2)
    | |   +-field_idx=0
    | +-x#4 :=
    |   +-GetStructField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<x INT64>, column=$make_struct.$struct#2)
    |     +-field_idx=0
    +-input_scan=
      +-ProjectScan
        +-column_list=[$make_struct.$struct#2]
        +-expr_list=
        | +-$struct#2 :=
        |   +-MakeStruct
        |     +-type=STRUCT<x INT64>
        |     +-field_list=
        |       +-ColumnRef(type=INT64, column=t.x#1)
        +-input_scan=
          +-ProjectScan
            +-column_list=[t.x#1]
            +-expr_list=
            | +-x#1 := Literal(type=INT64, value=123)
            +-input_scan=
              +-SingleRowScan
==

# Table subquery is a value table if it has AS ProtoName.
# Note diff with normal query: the PROTO subquery is wrapped with MakeProto.
# Also, the non-AS query gets an implicitly constructed struct when
# referencing the subquery range variable.
# Implicit column/field names will work in either case.
select t, key, t.key
from (select {{|as "zetasql_test__.KeyValueStruct"}} 17 value, 'k' key) t
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.t#4 AS t [STRUCT<value INT64, key STRING>]
| +-t.key#2 AS key [STRING]
| +-t.key#2 AS key [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.t#4, t.key#2, t.key#2]
    +-expr_list=
    | +-t#4 :=
    |   +-MakeStruct
    |     +-type=STRUCT<value INT64, key STRING>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=t.value#1)
    |       +-ColumnRef(type=STRING, column=t.key#2)
    +-input_scan=
      +-ProjectScan
        +-column_list=t.[value#1, key#2]
        +-expr_list=
        | +-value#1 := Literal(type=INT64, value=17)
        | +-key#2 := Literal(type=STRING, value='k')
        +-input_scan=
          +-SingleRowScan
--
ALTERNATION GROUP: as "zetasql_test__.KeyValueStruct"
--
QueryStmt
+-output_column_list=
| +-$make_proto.$proto#3 AS t [PROTO<zetasql_test__.KeyValueStruct>]
| +-$query.key#4 AS key [STRING]
| +-$query.key#5 AS key [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$make_proto.$proto#3, $query.key#4, $query.key#5]
    +-expr_list=
    | +-key#4 :=
    | | +-GetProtoField
    | |   +-type=STRING
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.KeyValueStruct>, column=$make_proto.$proto#3)
    | |   +-field_descriptor=key
    | |   +-default_value=NULL
    | +-key#5 :=
    |   +-GetProtoField
    |     +-type=STRING
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KeyValueStruct>, column=$make_proto.$proto#3)
    |     +-field_descriptor=key
    |     +-default_value=NULL
    +-input_scan=
      +-ProjectScan
        +-column_list=[$make_proto.$proto#3]
        +-expr_list=
        | +-$proto#3 :=
        |   +-MakeProto
        |     +-type=PROTO<zetasql_test__.KeyValueStruct>
        |     +-field_list=
        |       +-value := ColumnRef(type=INT64, column=t.value#1)
        |       +-key := ColumnRef(type=STRING, column=t.key#2)
        +-input_scan=
          +-ProjectScan
            +-column_list=t.[value#1, key#2]
            +-expr_list=
            | +-value#1 := Literal(type=INT64, value=17)
            | +-key#2 := Literal(type=STRING, value='k')
            +-input_scan=
              +-SingleRowScan
==

# We can do UNION ALL on struct value tables.  Other set operations are not
# supported because they require types that support grouping (structs do not).
select as struct 1 a, 2 b
union all
select as struct 3 a, 4 b
union all
select as struct 3 a, 4 b
--
QueryStmt
+-output_column_list=
| +-$union_all.$struct#10 AS "$struct" [STRUCT<a INT64, b INT64>]
+-is_value_table=TRUE
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$struct#10]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$make_struct.$struct#3]
      | |   +-expr_list=
      | |   | +-$struct#3 :=
      | |   |   +-MakeStruct
      | |   |     +-type=STRUCT<a INT64, b INT64>
      | |   |     +-field_list=
      | |   |       +-ColumnRef(type=INT64, column=$union_all1.a#1)
      | |   |       +-ColumnRef(type=INT64, column=$union_all1.b#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=$union_all1.[a#1, b#2]
      | |       +-expr_list=
      | |       | +-a#1 := Literal(type=INT64, value=1)
      | |       | +-b#2 := Literal(type=INT64, value=2)
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$make_struct.$struct#3]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$make_struct.$struct#6]
      | |   +-expr_list=
      | |   | +-$struct#6 :=
      | |   |   +-MakeStruct
      | |   |     +-type=STRUCT<a INT64, b INT64>
      | |   |     +-field_list=
      | |   |       +-ColumnRef(type=INT64, column=$union_all2.a#4)
      | |   |       +-ColumnRef(type=INT64, column=$union_all2.b#5)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=$union_all2.[a#4, b#5]
      | |       +-expr_list=
      | |       | +-a#4 := Literal(type=INT64, value=3)
      | |       | +-b#5 := Literal(type=INT64, value=4)
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$make_struct.$struct#6]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$make_struct.$struct#9]
        |   +-expr_list=
        |   | +-$struct#9 :=
        |   |   +-MakeStruct
        |   |     +-type=STRUCT<a INT64, b INT64>
        |   |     +-field_list=
        |   |       +-ColumnRef(type=INT64, column=$union_all3.a#7)
        |   |       +-ColumnRef(type=INT64, column=$union_all3.b#8)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=$union_all3.[a#7, b#8]
        |       +-expr_list=
        |       | +-a#7 := Literal(type=INT64, value=3)
        |       | +-b#8 := Literal(type=INT64, value=4)
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$make_struct.$struct#9]
==

select as struct 1 a, 2 b
union all
select as struct 3 c, 4
--
QueryStmt
+-output_column_list=
| +-$union_all.$struct#7 AS "$struct" [STRUCT<a INT64, b INT64>]
+-is_value_table=TRUE
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$struct#7]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$make_struct.$struct#3]
      | |   +-expr_list=
      | |   | +-$struct#3 :=
      | |   |   +-MakeStruct
      | |   |     +-type=STRUCT<a INT64, b INT64>
      | |   |     +-field_list=
      | |   |       +-ColumnRef(type=INT64, column=$union_all1.a#1)
      | |   |       +-ColumnRef(type=INT64, column=$union_all1.b#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=$union_all1.[a#1, b#2]
      | |       +-expr_list=
      | |       | +-a#1 := Literal(type=INT64, value=1)
      | |       | +-b#2 := Literal(type=INT64, value=2)
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$make_struct.$struct#3]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2_cast.$struct#8]
        |   +-expr_list=
        |   | +-$struct#8 :=
        |   |   +-Cast(STRUCT<c INT64, INT64> -> STRUCT<a INT64, b INT64>)
        |   |     +-ColumnRef(type=STRUCT<c INT64, INT64>, column=$make_struct.$struct#6)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$make_struct.$struct#6]
        |       +-expr_list=
        |       | +-$struct#6 :=
        |       |   +-MakeStruct
        |       |     +-type=STRUCT<c INT64, INT64>
        |       |     +-field_list=
        |       |       +-ColumnRef(type=INT64, column=$union_all2.c#4)
        |       |       +-ColumnRef(type=INT64, column=$union_all2.$col2#5)
        |       +-input_scan=
        |         +-ProjectScan
        |           +-column_list=$union_all2.[c#4, $col2#5]
        |           +-expr_list=
        |           | +-c#4 := Literal(type=INT64, value=3)
        |           | +-$col2#5 := Literal(type=INT64, value=4)
        |           +-input_scan=
        |             +-SingleRowScan
        +-output_column_list=[$union_all2_cast.$struct#8]
==

select as struct 1,2,3
union all
select as struct 1,2
--
ERROR: Column 1 in UNION ALL has incompatible types: STRUCT<INT64, INT64, INT64>, STRUCT<INT64, INT64> [at 3:1]
select as struct 1,2
^
==

# We can union all proto value tables, even with different sets of fields set.
# We still get a value table after doing limit and offset.
select as "zetasql_test__.KeyValueStruct" 17 value, 'k' key
union all
select as "zetasql_test__.KeyValueStruct" 'abc' key from TestTable
limit 5 offset 3
--
QueryStmt
+-output_column_list=
| +-$union_all.$proto#9 AS "$proto" [PROTO<zetasql_test__.KeyValueStruct>]
+-is_value_table=TRUE
+-query=
  +-LimitOffsetScan
    +-column_list=[$union_all.$proto#9]
    +-input_scan=
    | +-SetOperationScan
    |   +-column_list=[$union_all.$proto#9]
    |   +-op_type=UNION_ALL
    |   +-input_item_list=
    |     +-SetOperationItem
    |     | +-scan=
    |     | | +-ProjectScan
    |     | |   +-column_list=[$make_proto.$proto#3]
    |     | |   +-expr_list=
    |     | |   | +-$proto#3 :=
    |     | |   |   +-MakeProto
    |     | |   |     +-type=PROTO<zetasql_test__.KeyValueStruct>
    |     | |   |     +-field_list=
    |     | |   |       +-value := ColumnRef(type=INT64, column=$union_all1.value#1)
    |     | |   |       +-key := ColumnRef(type=STRING, column=$union_all1.key#2)
    |     | |   +-input_scan=
    |     | |     +-ProjectScan
    |     | |       +-column_list=$union_all1.[value#1, key#2]
    |     | |       +-expr_list=
    |     | |       | +-value#1 := Literal(type=INT64, value=17)
    |     | |       | +-key#2 := Literal(type=STRING, value='k')
    |     | |       +-input_scan=
    |     | |         +-SingleRowScan
    |     | +-output_column_list=[$make_proto.$proto#3]
    |     +-SetOperationItem
    |       +-scan=
    |       | +-ProjectScan
    |       |   +-column_list=[$make_proto.$proto#8]
    |       |   +-expr_list=
    |       |   | +-$proto#8 :=
    |       |   |   +-MakeProto
    |       |   |     +-type=PROTO<zetasql_test__.KeyValueStruct>
    |       |   |     +-field_list=
    |       |   |       +-key := ColumnRef(type=STRING, column=$union_all2.key#7)
    |       |   +-input_scan=
    |       |     +-ProjectScan
    |       |       +-column_list=[$union_all2.key#7]
    |       |       +-expr_list=
    |       |       | +-key#7 := Literal(type=STRING, value='abc')
    |       |       +-input_scan=
    |       |         +-TableScan(table=TestTable)
    |       +-output_column_list=[$make_proto.$proto#8]
    +-limit=
    | +-Literal(type=INT64, value=5)
    +-offset=
      +-Literal(type=INT64, value=3)
==

# We can't do other set operations because equality is not defined on protos.
select as "zetasql_test__.KeyValueStruct" 17 value, 'k' key
intersect distinct
select as "zetasql_test__.KeyValueStruct" 'abc' key
--
ERROR: Column 1 in INTERSECT DISTINCT has type that does not support set operation comparisons: PROTO [at 3:1]
select as "zetasql_test__.KeyValueStruct" 'abc' key
^
==

# We can't do other set operations because equality is not defined on protos.
select as "zetasql_test__.KeyValueStruct" 17 value, 'k' key
union distinct
select as "zetasql_test__.KeyValueStruct" 'abc' key
--
ERROR: Column 1 in UNION DISTINCT has type that does not support set operation comparisons: PROTO [at 3:1]
select as "zetasql_test__.KeyValueStruct" 'abc' key
^
==

# Referencing fields from a value table in where and order by.
# TODO: This plan has two Project nodes in sequence feeding the
# ORDER BY, can we do better (generate a single Project)?
select date
from KitchenSinkValueTable k
where float_val > k.int32_val
order by bytes_val, k.bool_val
--
QueryStmt
+-output_column_list=
| +-$query.date#2 AS date [DATE]
+-query=
  +-OrderByScan
    +-column_list=[$query.date#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[KitchenSinkValueTable.value#1, $query.date#2, $orderby.$orderbycol1#3, $orderby.$orderbycol2#4]
    |   +-expr_list=
    |   | +-$orderbycol1#3 :=
    |   | | +-GetProtoField
    |   | |   +-type=BYTES
    |   | |   +-expr=
    |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   | |   +-field_descriptor=bytes_val
    |   | |   +-default_value=b""
    |   | +-$orderbycol2#4 :=
    |   |   +-GetProtoField
    |   |     +-type=BOOL
    |   |     +-expr=
    |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |     +-field_descriptor=bool_val
    |   |     +-default_value=false
    |   +-input_scan=
    |     +-ProjectScan
    |       +-column_list=[KitchenSinkValueTable.value#1, $query.date#2]
    |       +-expr_list=
    |       | +-date#2 :=
    |       |   +-GetProtoField
    |       |     +-type=DATE
    |       |     +-expr=
    |       |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |       |     +-field_descriptor=date
    |       |     +-default_value=1970-01-01
    |       |     +-format=DATE
    |       +-input_scan=
    |         +-FilterScan
    |           +-column_list=[KitchenSinkValueTable.value#1]
    |           +-input_scan=
    |           | +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0], alias='k')
    |           +-filter_expr=
    |             +-FunctionCall(ZetaSQL:$greater(DOUBLE, DOUBLE) -> BOOL)
    |               +-Cast(FLOAT -> DOUBLE)
    |               | +-GetProtoField
    |               |   +-type=FLOAT
    |               |   +-expr=
    |               |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |               |   +-field_descriptor=float_val
    |               |   +-default_value=0
    |               +-Cast(INT32 -> DOUBLE)
    |                 +-GetProtoField
    |                   +-type=INT32
    |                   +-expr=
    |                   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |                   +-field_descriptor=int32_val
    |                   +-default_value=77
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=BYTES, column=$orderby.$orderbycol1#3)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=BOOL, column=$orderby.$orderbycol2#4)
==

# Using scalar value table in where and order by.
select i
from Int32ValueTable i
where i > 0
order by i desc
--
QueryStmt
+-output_column_list=
| +-Int32ValueTable.value#1 AS i [INT32]
+-query=
  +-OrderByScan
    +-column_list=[Int32ValueTable.value#1]
    +-is_ordered=TRUE
    +-input_scan=
    | +-FilterScan
    |   +-column_list=[Int32ValueTable.value#1]
    |   +-input_scan=
    |   | +-TableScan(column_list=[Int32ValueTable.value#1], table=Int32ValueTable, column_index_list=[0], alias='i')
    |   +-filter_expr=
    |     +-FunctionCall(ZetaSQL:$greater(INT32, INT32) -> BOOL)
    |       +-ColumnRef(type=INT32, column=Int32ValueTable.value#1)
    |       +-Literal(type=INT32, value=0)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
        | +-ColumnRef(type=INT32, column=Int32ValueTable.value#1)
        +-is_descending=TRUE
==

# We can't do an order by on value tables after a set operation because
# we aren't resolving field names in order by there.
# TODO Maybe this should work.
select as "zetasql_test__.KeyValueStruct" 17 value, 'k' key
union all
select as "zetasql_test__.KeyValueStruct" 'abc' key from TestTable
order by key
--
ERROR: Unrecognized name: key [at 4:10]
order by key
         ^
==

# Complex query with several operators.  MakeProto happens at the very end.
# We still get a value table out.
# NOTE: KeyValueStruct is annotated with (zetasql.is_struct)=true, but
# that annotation is not processed after the named type lookup from the Catalog
# returns us a ProtoType.  TODO We may want to consider changing that.
select distinct
   as "zetasql_test__.KeyValueStruct" key, min(value1) as value
from (select key, value as value1 from KeyValue)
where key<10
group by key
having count(value1)<5
order by 1
limit 50
--
QueryStmt
+-output_column_list=
| +-$make_proto.$proto#8 AS "$proto" [PROTO<zetasql_test__.KeyValueStruct>]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$make_proto.$proto#8]
    +-is_ordered=TRUE
    +-expr_list=
    | +-$proto#8 :=
    |   +-MakeProto
    |     +-type=PROTO<zetasql_test__.KeyValueStruct>
    |     +-field_list=
    |       +-key :=
    |       | +-Cast(INT64 -> STRING)
    |       |   +-ColumnRef(type=INT64, column=$distinct.key#6)
    |       +-value :=
    |         +-Cast(STRING -> INT64)
    |           +-ColumnRef(type=STRING, column=$distinct.value#7)
    +-input_scan=
      +-LimitOffsetScan
        +-column_list=$distinct.[key#6, value#7]
        +-is_ordered=TRUE
        +-input_scan=
        | +-OrderByScan
        |   +-column_list=$distinct.[key#6, value#7]
        |   +-is_ordered=TRUE
        |   +-input_scan=
        |   | +-AggregateScan
        |   |   +-column_list=$distinct.[key#6, value#7]
        |   |   +-input_scan=
        |   |   | +-FilterScan
        |   |   |   +-column_list=[$groupby.key#4, $aggregate.value#3, $aggregate.$agg2#5]
        |   |   |   +-input_scan=
        |   |   |   | +-AggregateScan
        |   |   |   |   +-column_list=[$groupby.key#4, $aggregate.value#3, $aggregate.$agg2#5]
        |   |   |   |   +-input_scan=
        |   |   |   |   | +-FilterScan
        |   |   |   |   |   +-column_list=KeyValue.[Key#1, Value#2]
        |   |   |   |   |   +-input_scan=
        |   |   |   |   |   | +-ProjectScan
        |   |   |   |   |   |   +-column_list=KeyValue.[Key#1, Value#2]
        |   |   |   |   |   |   +-input_scan=
        |   |   |   |   |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   |   |   |   |   +-filter_expr=
        |   |   |   |   |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |   |   |   |   |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |   |   |   |       +-Literal(type=INT64, value=10)
        |   |   |   |   +-group_by_list=
        |   |   |   |   | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |   |   |   +-aggregate_list=
        |   |   |   |     +-value#3 :=
        |   |   |   |     | +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
        |   |   |   |     |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |   |   |   |     +-$agg2#5 :=
        |   |   |   |       +-AggregateFunctionCall(ZetaSQL:count(STRING) -> INT64)
        |   |   |   |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |   |   |   +-filter_expr=
        |   |   |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |   |   |       +-ColumnRef(type=INT64, column=$aggregate.$agg2#5)
        |   |   |       +-Literal(type=INT64, value=5)
        |   |   +-group_by_list=
        |   |     +-key#6 := ColumnRef(type=INT64, column=$groupby.key#4)
        |   |     +-value#7 := ColumnRef(type=STRING, column=$aggregate.value#3)
        |   +-order_by_item_list=
        |     +-OrderByItem
        |       +-column_ref=
        |         +-ColumnRef(type=INT64, column=$distinct.key#6)
        +-limit=
          +-Literal(type=INT64, value=50)
==

select as struct 1 a, 2 b
union all
select 1 a, 2 b
--
ERROR: Queries in UNION ALL have mismatched column count; query 1 is value table with 1 column, query 2 has 2 columns [at 3:1]
select 1 a, 2 b
^
==

select 1 a, 2 b
intersect distinct
select as struct 1 a, 2 b
--
ERROR: Queries in INTERSECT DISTINCT have mismatched column count; query 1 has 2 columns, query 2 is value table with 1 column [at 3:1]
select as struct 1 a, 2 b
^
==

select as "zetasql_test__.KeyValueStruct" 'a' key
union all
select as struct 'b' key
--
ERROR: Column 1 in UNION ALL has incompatible types: zetasql_test__.KeyValueStruct, STRUCT<key STRING> [at 3:1]
select as struct 'b' key
^
==

# Same as previous query, but we have a SELECT AS STRUCT which exactly matches
# the annotated struct type for the proto KeyValueStruct.  The is_struct
# annotation is currently ignored for named type lookups like this.
select as "zetasql_test__.KeyValueStruct" 'a' key, 123 value
union all
select as struct 'b' key, 123 value
--
ERROR: Column 1 in UNION ALL has incompatible types: zetasql_test__.KeyValueStruct, STRUCT<key STRING, value INT64> [at 3:1]
select as struct 'b' key, 123 value
^
==

select int32_val1
from TestExtraValueTable k
group by int32_val1
order by int32_val1
--
QueryStmt
+-output_column_list=
| +-$groupby.int32_val1#5 AS int32_val1 [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.int32_val1#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.int32_val1#5]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[TestExtraValueTable.value#1, $pre_groupby.int32_val1#4]
    |   |   +-expr_list=
    |   |   | +-int32_val1#4 :=
    |   |   |   +-GetProtoField
    |   |   |     +-type=INT32
    |   |   |     +-expr=
    |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |   |   |     +-field_descriptor=int32_val1
    |   |   |     +-default_value=0
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias='k')
    |   +-group_by_list=
    |     +-int32_val1#5 := ColumnRef(type=INT32, column=$pre_groupby.int32_val1#4)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$groupby.int32_val1#5)
==

# Use or do not use 'k' table alias in SELECT, GROUP BY, HAVING, and
# ORDER BY.  They all should work.
select {{k.|}}int32_val1
from TestExtraValueTable k
group by {{k.|}}int32_val1
having {{k.|}}int32_val1 > 0
order by {{k.|}}int32_val1
--
QueryStmt
+-output_column_list=
| +-$groupby.int32_val1#5 AS int32_val1 [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.int32_val1#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-FilterScan
    |   +-column_list=[$groupby.int32_val1#5]
    |   +-input_scan=
    |   | +-AggregateScan
    |   |   +-column_list=[$groupby.int32_val1#5]
    |   |   +-input_scan=
    |   |   | +-ProjectScan
    |   |   |   +-column_list=[TestExtraValueTable.value#1, $pre_groupby.int32_val1#4]
    |   |   |   +-expr_list=
    |   |   |   | +-int32_val1#4 :=
    |   |   |   |   +-GetProtoField
    |   |   |   |     +-type=INT32
    |   |   |   |     +-expr=
    |   |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |   |   |   |     +-field_descriptor=int32_val1
    |   |   |   |     +-default_value=0
    |   |   |   +-input_scan=
    |   |   |     +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias='k')
    |   |   +-group_by_list=
    |   |     +-int32_val1#5 := ColumnRef(type=INT32, column=$pre_groupby.int32_val1#4)
    |   +-filter_expr=
    |     +-FunctionCall(ZetaSQL:$greater(INT32, INT32) -> BOOL)
    |       +-ColumnRef(type=INT32, column=$groupby.int32_val1#5)
    |       +-Literal(type=INT32, value=0)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$groupby.int32_val1#5)
==

# Tests for b/19181915
select cast(int32_val1 as double) from TestExtraValueTable group by int32_val1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-Cast(INT32 -> DOUBLE)
    |     +-ColumnRef(type=INT32, column=$groupby.int32_val1#4)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.int32_val1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        +-group_by_list=
          +-int32_val1#4 :=
            +-GetProtoField
              +-type=INT32
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
              +-field_descriptor=int32_val1
              +-default_value=0
==

select sum(int32_val1)
from TestExtraValueTable
group by int32_val2
having int32_val2 > 1
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.int32_val2#5, $aggregate.$agg1#4]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.int32_val2#5, $aggregate.$agg1#4]
        |   +-input_scan=
        |   | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        |   +-group_by_list=
        |   | +-int32_val2#5 :=
        |   |   +-GetProtoField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
        |   |     +-field_descriptor=int32_val2
        |   |     +-default_value=0
        |   +-aggregate_list=
        |     +-$agg1#4 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-Cast(INT32 -> INT64)
        |           +-GetProtoField
        |             +-type=INT32
        |             +-expr=
        |             | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
        |             +-field_descriptor=int32_val1
        |             +-default_value=0
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$greater(INT32, INT32) -> BOOL)
            +-ColumnRef(type=INT32, column=$groupby.int32_val2#5)
            +-Literal(type=INT32, value=1)
==

select sum(int32_val1)
from TestExtraValueTable
where int32_val1 > 5
group by int32_val1
having sum(int32_val1) > 5 and int32_val1 < 10;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.int32_val1#5, $aggregate.$agg1#4, $aggregate.$agg2#6]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.int32_val1#5, $aggregate.$agg1#4, $aggregate.$agg2#6]
        |   +-input_scan=
        |   | +-FilterScan
        |   |   +-column_list=[TestExtraValueTable.value#1]
        |   |   +-input_scan=
        |   |   | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        |   |   +-filter_expr=
        |   |     +-FunctionCall(ZetaSQL:$greater(INT32, INT32) -> BOOL)
        |   |       +-GetProtoField
        |   |       | +-type=INT32
        |   |       | +-expr=
        |   |       | | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
        |   |       | +-field_descriptor=int32_val1
        |   |       | +-default_value=0
        |   |       +-Literal(type=INT32, value=5)
        |   +-group_by_list=
        |   | +-int32_val1#5 :=
        |   |   +-GetProtoField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
        |   |     +-field_descriptor=int32_val1
        |   |     +-default_value=0
        |   +-aggregate_list=
        |     +-$agg1#4 :=
        |     | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |     |   +-Cast(INT32 -> INT64)
        |     |     +-GetProtoField
        |     |       +-type=INT32
        |     |       +-expr=
        |     |       | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
        |     |       +-field_descriptor=int32_val1
        |     |       +-default_value=0
        |     +-$agg2#6 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-Cast(INT32 -> INT64)
        |           +-GetProtoField
        |             +-type=INT32
        |             +-expr=
        |             | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
        |             +-field_descriptor=int32_val1
        |             +-default_value=0
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
            +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            | +-ColumnRef(type=INT64, column=$aggregate.$agg2#6)
            | +-Literal(type=INT64, value=5)
            +-FunctionCall(ZetaSQL:$less(INT32, INT32) -> BOOL)
              +-ColumnRef(type=INT32, column=$groupby.int32_val1#5)
              +-Literal(type=INT32, value=10)
==

select int32_val1 as foo, count(int32_val2)
from TestExtraValueTable
GROUP BY foo
order by int32_val1
--
QueryStmt
+-output_column_list=
| +-$groupby.foo#6 AS foo [INT32]
| +-$aggregate.$agg1#4 AS "$col2" [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.foo#6, $aggregate.$agg1#4]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.foo#6, $aggregate.$agg1#4]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[TestExtraValueTable.value#1, $pre_groupby.foo#5]
    |   |   +-expr_list=
    |   |   | +-foo#5 :=
    |   |   |   +-GetProtoField
    |   |   |     +-type=INT32
    |   |   |     +-expr=
    |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |   |   |     +-field_descriptor=int32_val1
    |   |   |     +-default_value=0
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
    |   +-group_by_list=
    |   | +-foo#6 := ColumnRef(type=INT32, column=$pre_groupby.foo#5)
    |   +-aggregate_list=
    |     +-$agg1#4 :=
    |       +-AggregateFunctionCall(ZetaSQL:count(INT32) -> INT64)
    |         +-GetProtoField
    |           +-type=INT32
    |           +-expr=
    |           | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |           +-field_descriptor=int32_val2
    |           +-default_value=0
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$groupby.foo#6)
==

select max(int32_val2)
from TestExtraValueTable
WHERE int32_val1 > 1000000
  and int32_val1 < 1500000
group by int32_val1
order by int32_val1
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [INT32]
+-query=
  +-OrderByScan
    +-column_list=[$aggregate.$agg1#4]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.int32_val1#5, $aggregate.$agg1#4]
    |   +-input_scan=
    |   | +-FilterScan
    |   |   +-column_list=[TestExtraValueTable.value#1]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
    |   |   +-filter_expr=
    |   |     +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
    |   |       +-FunctionCall(ZetaSQL:$greater(INT32, INT32) -> BOOL)
    |   |       | +-GetProtoField
    |   |       | | +-type=INT32
    |   |       | | +-expr=
    |   |       | | | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |   |       | | +-field_descriptor=int32_val1
    |   |       | | +-default_value=0
    |   |       | +-Literal(type=INT32, value=1000000)
    |   |       +-FunctionCall(ZetaSQL:$less(INT32, INT32) -> BOOL)
    |   |         +-GetProtoField
    |   |         | +-type=INT32
    |   |         | +-expr=
    |   |         | | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |   |         | +-field_descriptor=int32_val1
    |   |         | +-default_value=0
    |   |         +-Literal(type=INT32, value=1500000)
    |   +-group_by_list=
    |   | +-int32_val1#5 :=
    |   |   +-GetProtoField
    |   |     +-type=INT32
    |   |     +-expr=
    |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |   |     +-field_descriptor=int32_val1
    |   |     +-default_value=0
    |   +-aggregate_list=
    |     +-$agg1#4 :=
    |       +-AggregateFunctionCall(ZetaSQL:max(INT32) -> INT32)
    |         +-GetProtoField
    |           +-type=INT32
    |           +-expr=
    |           | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |           +-field_descriptor=int32_val2
    |           +-default_value=0
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT32, column=$groupby.int32_val1#5)
==

select int32_val2, int32_val1
from TestExtraValueTable
group by 1, 2
--
QueryStmt
+-output_column_list=
| +-$groupby.int32_val2#4 AS int32_val2 [INT32]
| +-$groupby.int32_val1#5 AS int32_val1 [INT32]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[int32_val2#4, int32_val1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[int32_val2#4, int32_val1#5]
        +-input_scan=
        | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        +-group_by_list=
          +-int32_val2#4 :=
          | +-GetProtoField
          |   +-type=INT32
          |   +-expr=
          |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
          |   +-field_descriptor=int32_val2
          |   +-default_value=0
          +-int32_val1#5 :=
            +-GetProtoField
              +-type=INT32
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
              +-field_descriptor=int32_val1
              +-default_value=0
==

select int32_val1+1, int32_val1+int32_val1
from TestExtraValueTable
group by int32_val1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [INT64]
| +-$query.$col2#6 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-Cast(INT32 -> INT64)
    | |   | +-ColumnRef(type=INT32, column=$groupby.int32_val1#4)
    | |   +-Literal(type=INT64, value=1)
    | +-$col2#6 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Cast(INT32 -> INT64)
    |     | +-ColumnRef(type=INT32, column=$groupby.int32_val1#4)
    |     +-Cast(INT32 -> INT64)
    |       +-ColumnRef(type=INT32, column=$groupby.int32_val1#4)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.int32_val1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        +-group_by_list=
          +-int32_val1#4 :=
            +-GetProtoField
              +-type=INT32
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
              +-field_descriptor=int32_val1
              +-default_value=0
==

select int32_val1+1, int32_val1, int32_val1 k, int32_val1+2 as k2
from TestExtraValueTable
group by k;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [INT64]
| +-$groupby.k#4 AS int32_val1 [INT32]
| +-$groupby.k#4 AS k [INT32]
| +-$query.k2#6 AS k2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5, $groupby.k#4, $groupby.k#4, $query.k2#6]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-Cast(INT32 -> INT64)
    | |   | +-ColumnRef(type=INT32, column=$groupby.k#4)
    | |   +-Literal(type=INT64, value=1)
    | +-k2#6 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Cast(INT32 -> INT64)
    |     | +-ColumnRef(type=INT32, column=$groupby.k#4)
    |     +-Literal(type=INT64, value=2)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.k#4]
        +-input_scan=
        | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        +-group_by_list=
          +-k#4 :=
            +-GetProtoField
              +-type=INT32
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
              +-field_descriptor=int32_val1
              +-default_value=0
==

select int32_val1+1, int32_val1, int32_val1 k, int32_val1+2 as k2
from TestExtraValueTable
group by 2;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [INT64]
| +-$groupby.int32_val1#4 AS int32_val1 [INT32]
| +-$groupby.int32_val1#4 AS k [INT32]
| +-$query.k2#6 AS k2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5, $groupby.int32_val1#4, $groupby.int32_val1#4, $query.k2#6]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-Cast(INT32 -> INT64)
    | |   | +-ColumnRef(type=INT32, column=$groupby.int32_val1#4)
    | |   +-Literal(type=INT64, value=1)
    | +-k2#6 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Cast(INT32 -> INT64)
    |     | +-ColumnRef(type=INT32, column=$groupby.int32_val1#4)
    |     +-Literal(type=INT64, value=2)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.int32_val1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        +-group_by_list=
          +-int32_val1#4 :=
            +-GetProtoField
              +-type=INT32
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
              +-field_descriptor=int32_val1
              +-default_value=0
==

select cast(int32_val1 as double)
from TestExtraValueTable
group by int32_val1;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-Cast(INT32 -> DOUBLE)
    |     +-ColumnRef(type=INT32, column=$groupby.int32_val1#4)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.int32_val1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        +-group_by_list=
          +-int32_val1#4 :=
            +-GetProtoField
              +-type=INT32
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
              +-field_descriptor=int32_val1
              +-default_value=0
==

select int32_val1 + count(int32_val2)
from TestExtraValueTable
group by int32_val1;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Cast(INT32 -> INT64)
    |     | +-ColumnRef(type=INT32, column=$groupby.int32_val1#5)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#4)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.int32_val1#5, $aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        +-group_by_list=
        | +-int32_val1#5 :=
        |   +-GetProtoField
        |     +-type=INT32
        |     +-expr=
        |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
        |     +-field_descriptor=int32_val1
        |     +-default_value=0
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:count(INT32) -> INT64)
              +-GetProtoField
                +-type=INT32
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
                +-field_descriptor=int32_val2
                +-default_value=0
==

select cast(int32_val1 as double)
from TestExtraValueTable
group by int32_val2;
--
ERROR: SELECT list expression references column int32_val1 which is neither grouped nor aggregated [at 1:13]
select cast(int32_val1 as double)
            ^
==

select int64_key_1, nested_value.nested_int64
from KitchenSinkValueTable
group by int64_key_1, nested_value.nested_int64
having int64_key_1 > 0
   and nested_value.nested_int64 > 2
   and sum(int32_val) > 4
order by int64_key_1, nested_value.nested_int64, sum(int32_val)
--
QueryStmt
+-output_column_list=
| +-$groupby.int64_key_1#4 AS int64_key_1 [INT64]
| +-$groupby.nested_int64#5 AS nested_int64 [INT64]
+-query=
  +-OrderByScan
    +-column_list=$groupby.[int64_key_1#4, nested_int64#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-FilterScan
    |   +-column_list=[$groupby.int64_key_1#4, $groupby.nested_int64#5, $aggregate.$agg1#6, $aggregate.$agg2#7]
    |   +-input_scan=
    |   | +-AggregateScan
    |   |   +-column_list=[$groupby.int64_key_1#4, $groupby.nested_int64#5, $aggregate.$agg1#6, $aggregate.$agg2#7]
    |   |   +-input_scan=
    |   |   | +-ProjectScan
    |   |   |   +-column_list=[KitchenSinkValueTable.value#1, $pre_groupby.int64_key_1#2, $pre_groupby.nested_int64#3]
    |   |   |   +-expr_list=
    |   |   |   | +-int64_key_1#2 :=
    |   |   |   | | +-GetProtoField
    |   |   |   | |   +-type=INT64
    |   |   |   | |   +-expr=
    |   |   |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |   |   | |   +-field_descriptor=int64_key_1
    |   |   |   | +-nested_int64#3 :=
    |   |   |   |   +-GetProtoField
    |   |   |   |     +-type=INT64
    |   |   |   |     +-expr=
    |   |   |   |     | +-GetProtoField
    |   |   |   |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |   |   |   |     |   +-expr=
    |   |   |   |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |   |   |     |   +-field_descriptor=nested_value
    |   |   |   |     |   +-default_value=NULL
    |   |   |   |     +-field_descriptor=nested_int64
    |   |   |   |     +-default_value=88
    |   |   |   +-input_scan=
    |   |   |     +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0])
    |   |   +-group_by_list=
    |   |   | +-int64_key_1#4 := ColumnRef(type=INT64, column=$pre_groupby.int64_key_1#2)
    |   |   | +-nested_int64#5 := ColumnRef(type=INT64, column=$pre_groupby.nested_int64#3)
    |   |   +-aggregate_list=
    |   |     +-$agg1#6 :=
    |   |     | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |   |     |   +-Cast(INT32 -> INT64)
    |   |     |     +-GetProtoField
    |   |     |       +-type=INT32
    |   |     |       +-expr=
    |   |     |       | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |     |       +-field_descriptor=int32_val
    |   |     |       +-default_value=77
    |   |     +-$agg2#7 :=
    |   |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |   |         +-Cast(INT32 -> INT64)
    |   |           +-GetProtoField
    |   |             +-type=INT32
    |   |             +-expr=
    |   |             | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |             +-field_descriptor=int32_val
    |   |             +-default_value=77
    |   +-filter_expr=
    |     +-FunctionCall(ZetaSQL:$and(BOOL, repeated(2) BOOL) -> BOOL)
    |       +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |       | +-ColumnRef(type=INT64, column=$groupby.int64_key_1#4)
    |       | +-Literal(type=INT64, value=0)
    |       +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |       | +-ColumnRef(type=INT64, column=$groupby.nested_int64#5)
    |       | +-Literal(type=INT64, value=2)
    |       +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |         +-ColumnRef(type=INT64, column=$aggregate.$agg1#6)
    |         +-Literal(type=INT64, value=4)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.int64_key_1#4)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.nested_int64#5)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$aggregate.$agg2#7)
==

# The path expression can be referenced inside expressions in the
# SELECT, HAVING, and ORDER BY.
select nested_value.nested_int64 + 1
from KitchenSinkValueTable
group by nested_value.nested_int64
having nested_value.nested_int64 > 2
order by nested_value.nested_int64 - 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS "$col1" [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$query.$col1#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.nested_int64#2, $query.$col1#3, $orderby.$orderbycol1#4]
    |   +-expr_list=
    |   | +-$orderbycol1#4 :=
    |   |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=$groupby.nested_int64#2)
    |   |     +-Literal(type=INT64, value=1)
    |   +-input_scan=
    |     +-FilterScan
    |       +-column_list=[$groupby.nested_int64#2, $query.$col1#3]
    |       +-input_scan=
    |       | +-ProjectScan
    |       |   +-column_list=[$groupby.nested_int64#2, $query.$col1#3]
    |       |   +-expr_list=
    |       |   | +-$col1#3 :=
    |       |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       |   |     +-ColumnRef(type=INT64, column=$groupby.nested_int64#2)
    |       |   |     +-Literal(type=INT64, value=1)
    |       |   +-input_scan=
    |       |     +-AggregateScan
    |       |       +-column_list=[$groupby.nested_int64#2]
    |       |       +-input_scan=
    |       |       | +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0])
    |       |       +-group_by_list=
    |       |         +-nested_int64#2 :=
    |       |           +-GetProtoField
    |       |             +-type=INT64
    |       |             +-expr=
    |       |             | +-GetProtoField
    |       |             |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |       |             |   +-expr=
    |       |             |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |       |             |   +-field_descriptor=nested_value
    |       |             |   +-default_value=NULL
    |       |             +-field_descriptor=nested_int64
    |       |             +-default_value=88
    |       +-filter_expr=
    |         +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |           +-ColumnRef(type=INT64, column=$groupby.nested_int64#2)
    |           +-Literal(type=INT64, value=2)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
==

select int64_key_1, k.int64_key_2, nested_value.nested_int64,
       k.nested_value.nested_int64
from KitchenSinkValueTable k
group by int64_key_1, k.int64_key_2, nested_value.nested_int64,
         k.nested_value.nested_int64
having int64_key_1 > 0
   and k.int64_key_2 > 1
   and nested_value.nested_int64 > 2
   and k.nested_value.nested_int64 > 3
   and sum(int32_val) > 4
   and count(k.uint32_val) > 5
order by int64_key_1, k.int64_key_2, nested_value.nested_int64,
         k.nested_value.nested_int64, sum(int32_val), count(k.uint32_val)
--
QueryStmt
+-output_column_list=
| +-$groupby.int64_key_1#6 AS int64_key_1 [INT64]
| +-$groupby.int64_key_2#7 AS int64_key_2 [INT64]
| +-$groupby.nested_int64#8 AS nested_int64 [INT64]
| +-$groupby.nested_int64#8 AS nested_int64 [INT64]
+-query=
  +-OrderByScan
    +-column_list=$groupby.[int64_key_1#6, int64_key_2#7, nested_int64#8, nested_int64#8]
    +-is_ordered=TRUE
    +-input_scan=
    | +-FilterScan
    |   +-column_list=[$groupby.int64_key_1#6, $groupby.int64_key_2#7, $groupby.nested_int64#8, $aggregate.$agg1#9, $aggregate.$agg2#10, $aggregate.$agg3#11, $aggregate.$agg4#12]
    |   +-input_scan=
    |   | +-AggregateScan
    |   |   +-column_list=[$groupby.int64_key_1#6, $groupby.int64_key_2#7, $groupby.nested_int64#8, $aggregate.$agg1#9, $aggregate.$agg2#10, $aggregate.$agg3#11, $aggregate.$agg4#12]
    |   |   +-input_scan=
    |   |   | +-ProjectScan
    |   |   |   +-column_list=[KitchenSinkValueTable.value#1, $pre_groupby.int64_key_1#2, $pre_groupby.int64_key_2#3, $pre_groupby.nested_int64#4, $pre_groupby.nested_int64#5]
    |   |   |   +-expr_list=
    |   |   |   | +-int64_key_1#2 :=
    |   |   |   | | +-GetProtoField
    |   |   |   | |   +-type=INT64
    |   |   |   | |   +-expr=
    |   |   |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |   |   | |   +-field_descriptor=int64_key_1
    |   |   |   | +-int64_key_2#3 :=
    |   |   |   | | +-GetProtoField
    |   |   |   | |   +-type=INT64
    |   |   |   | |   +-expr=
    |   |   |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |   |   | |   +-field_descriptor=int64_key_2
    |   |   |   | +-nested_int64#4 :=
    |   |   |   | | +-GetProtoField
    |   |   |   | |   +-type=INT64
    |   |   |   | |   +-expr=
    |   |   |   | |   | +-GetProtoField
    |   |   |   | |   |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |   |   |   | |   |   +-expr=
    |   |   |   | |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |   |   | |   |   +-field_descriptor=nested_value
    |   |   |   | |   |   +-default_value=NULL
    |   |   |   | |   +-field_descriptor=nested_int64
    |   |   |   | |   +-default_value=88
    |   |   |   | +-nested_int64#5 :=
    |   |   |   |   +-GetProtoField
    |   |   |   |     +-type=INT64
    |   |   |   |     +-expr=
    |   |   |   |     | +-GetProtoField
    |   |   |   |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |   |   |   |     |   +-expr=
    |   |   |   |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |   |   |     |   +-field_descriptor=nested_value
    |   |   |   |     |   +-default_value=NULL
    |   |   |   |     +-field_descriptor=nested_int64
    |   |   |   |     +-default_value=88
    |   |   |   +-input_scan=
    |   |   |     +-TableScan(column_list=[KitchenSinkValueTable.value#1], table=KitchenSinkValueTable, column_index_list=[0], alias='k')
    |   |   +-group_by_list=
    |   |   | +-int64_key_1#6 := ColumnRef(type=INT64, column=$pre_groupby.int64_key_1#2)
    |   |   | +-int64_key_2#7 := ColumnRef(type=INT64, column=$pre_groupby.int64_key_2#3)
    |   |   | +-nested_int64#8 := ColumnRef(type=INT64, column=$pre_groupby.nested_int64#4)
    |   |   +-aggregate_list=
    |   |     +-$agg1#9 :=
    |   |     | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |   |     |   +-Cast(INT32 -> INT64)
    |   |     |     +-GetProtoField
    |   |     |       +-type=INT32
    |   |     |       +-expr=
    |   |     |       | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |     |       +-field_descriptor=int32_val
    |   |     |       +-default_value=77
    |   |     +-$agg2#10 :=
    |   |     | +-AggregateFunctionCall(ZetaSQL:count(UINT32) -> INT64)
    |   |     |   +-GetProtoField
    |   |     |     +-type=UINT32
    |   |     |     +-expr=
    |   |     |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |     |     +-field_descriptor=uint32_val
    |   |     |     +-default_value=777
    |   |     +-$agg3#11 :=
    |   |     | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |   |     |   +-Cast(INT32 -> INT64)
    |   |     |     +-GetProtoField
    |   |     |       +-type=INT32
    |   |     |       +-expr=
    |   |     |       | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |     |       +-field_descriptor=int32_val
    |   |     |       +-default_value=77
    |   |     +-$agg4#12 :=
    |   |       +-AggregateFunctionCall(ZetaSQL:count(UINT32) -> INT64)
    |   |         +-GetProtoField
    |   |           +-type=UINT32
    |   |           +-expr=
    |   |           | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkValueTable.value#1)
    |   |           +-field_descriptor=uint32_val
    |   |           +-default_value=777
    |   +-filter_expr=
    |     +-FunctionCall(ZetaSQL:$and(BOOL, repeated(5) BOOL) -> BOOL)
    |       +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |       | +-ColumnRef(type=INT64, column=$groupby.int64_key_1#6)
    |       | +-Literal(type=INT64, value=0)
    |       +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |       | +-ColumnRef(type=INT64, column=$groupby.int64_key_2#7)
    |       | +-Literal(type=INT64, value=1)
    |       +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |       | +-ColumnRef(type=INT64, column=$groupby.nested_int64#8)
    |       | +-Literal(type=INT64, value=2)
    |       +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |       | +-ColumnRef(type=INT64, column=$groupby.nested_int64#8)
    |       | +-Literal(type=INT64, value=3)
    |       +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |       | +-ColumnRef(type=INT64, column=$aggregate.$agg1#9)
    |       | +-Literal(type=INT64, value=4)
    |       +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |         +-ColumnRef(type=INT64, column=$aggregate.$agg2#10)
    |         +-Literal(type=INT64, value=5)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.int64_key_1#6)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.int64_key_2#7)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.nested_int64#8)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$groupby.nested_int64#8)
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$aggregate.$agg3#11)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$aggregate.$agg4#12)
==

select nested_value.nested_int64
from KitchenSinkValueTable
group by nested_value
--
ERROR: Grouping by expressions of type PROTO is not allowed [at 3:10]
group by nested_value
         ^
==

select nested_value
from KitchenSinkValueTable
group by nested_value.nested_int64
--
ERROR: Cannot GROUP BY field references from SELECT list alias nested_value [at 3:10]
group by nested_value.nested_int64
         ^
==

[language_features={{V_1_2_GROUP_BY_STRUCT|}}]
select f
from TestNestedStructValueTable
group by f
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$groupby.f#2 AS f [STRUCT<c INT32, d STRUCT<a INT32, b STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.f#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.f#2]
        +-input_scan=
        | +-TableScan(column_list=[TestNestedStructValueTable.value#1], table=TestNestedStructValueTable, column_index_list=[0])
        +-group_by_list=
          +-f#2 :=
            +-GetStructField
              +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
              +-expr=
              | +-ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=TestNestedStructValueTable.value#1)
              +-field_idx=1
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 3:10]
group by f
         ^
==

[language_features={{V_1_2_GROUP_BY_STRUCT|}}]
select f
from TestNestedStructValueTable as f
group by f

--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$groupby.f#2 AS f [STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.f#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.f#2]
        +-input_scan=
        | +-TableScan(column_list=[TestNestedStructValueTable.value#1], table=TestNestedStructValueTable, column_index_list=[0], alias='f')
        +-group_by_list=
          +-f#2 := ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=TestNestedStructValueTable.value#1)
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 3:10]
group by f
         ^
==

[language_features={{V_1_2_GROUP_BY_STRUCT|}}]
select TestNestedStructValueTable
from TestNestedStructValueTable
group by TestNestedStructValueTable
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$groupby.TestNestedStructValueTable#2 AS TestNestedStructValueTable [STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.TestNestedStructValueTable#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.TestNestedStructValueTable#2]
        +-input_scan=
        | +-TableScan(column_list=[TestNestedStructValueTable.value#1], table=TestNestedStructValueTable, column_index_list=[0])
        +-group_by_list=
          +-TestNestedStructValueTable#2 := ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=TestNestedStructValueTable.value#1)
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 3:10]
group by TestNestedStructValueTable
         ^
==

[language_features={{V_1_2_GROUP_BY_STRUCT|}}]
select f.d
from TestNestedStructValueTable
group by f.d
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$groupby.d#2 AS d [STRUCT<a INT32, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.d#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.d#2]
        +-input_scan=
        | +-TableScan(column_list=[TestNestedStructValueTable.value#1], table=TestNestedStructValueTable, column_index_list=[0])
        +-group_by_list=
          +-d#2 :=
            +-GetStructField
              +-type=STRUCT<a INT32, b STRING>
              +-expr=
              | +-GetStructField
              |   +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
              |   +-expr=
              |   | +-ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=TestNestedStructValueTable.value#1)
              |   +-field_idx=1
              +-field_idx=1
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 3:10]
group by f.d
         ^
==

select f.d.b
from TestNestedStructValueTable
group by f.d.b
--
QueryStmt
+-output_column_list=
| +-$groupby.b#2 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.b#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.b#2]
        +-input_scan=
        | +-TableScan(column_list=[TestNestedStructValueTable.value#1], table=TestNestedStructValueTable, column_index_list=[0])
        +-group_by_list=
          +-b#2 :=
            +-GetStructField
              +-type=STRING
              +-expr=
              | +-GetStructField
              |   +-type=STRUCT<a INT32, b STRING>
              |   +-expr=
              |   | +-GetStructField
              |   |   +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
              |   |   +-expr=
              |   |   | +-ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=TestNestedStructValueTable.value#1)
              |   |   +-field_idx=1
              |   +-field_idx=1
              +-field_idx=1
==

select concat({{T.|}}f.d.b, "a")
from TestNestedStructValueTable T
group by {{T.|}}f.d.b
having {{T.|}}f.d.b = 'foo'
order by concat({{T.|}}f.d.b, "b")
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS "$col1" [STRING]
+-query=
  +-OrderByScan
    +-column_list=[$query.$col1#3]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.b#2, $query.$col1#3, $orderby.$orderbycol1#4]
    |   +-expr_list=
    |   | +-$orderbycol1#4 :=
    |   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |   |     +-ColumnRef(type=STRING, column=$groupby.b#2)
    |   |     +-Literal(type=STRING, value='b')
    |   +-input_scan=
    |     +-FilterScan
    |       +-column_list=[$groupby.b#2, $query.$col1#3]
    |       +-input_scan=
    |       | +-ProjectScan
    |       |   +-column_list=[$groupby.b#2, $query.$col1#3]
    |       |   +-expr_list=
    |       |   | +-$col1#3 :=
    |       |   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |       |   |     +-ColumnRef(type=STRING, column=$groupby.b#2)
    |       |   |     +-Literal(type=STRING, value='a')
    |       |   +-input_scan=
    |       |     +-AggregateScan
    |       |       +-column_list=[$groupby.b#2]
    |       |       +-input_scan=
    |       |       | +-TableScan(column_list=[TestNestedStructValueTable.value#1], table=TestNestedStructValueTable, column_index_list=[0], alias='T')
    |       |       +-group_by_list=
    |       |         +-b#2 :=
    |       |           +-GetStructField
    |       |             +-type=STRING
    |       |             +-expr=
    |       |             | +-GetStructField
    |       |             |   +-type=STRUCT<a INT32, b STRING>
    |       |             |   +-expr=
    |       |             |   | +-GetStructField
    |       |             |   |   +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
    |       |             |   |   +-expr=
    |       |             |   |   | +-ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=TestNestedStructValueTable.value#1)
    |       |             |   |   +-field_idx=1
    |       |             |   +-field_idx=1
    |       |             +-field_idx=1
    |       +-filter_expr=
    |         +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |           +-ColumnRef(type=STRING, column=$groupby.b#2)
    |           +-Literal(type=STRING, value='foo')
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=STRING, column=$orderby.$orderbycol1#4)
==

select f.d
from TestNestedStructValueTable
group by f.d.b
--
ERROR: SELECT list expression references f.d which is neither grouped nor aggregated [at 1:8]
select f.d
       ^
==

# Test reference fields within group by struct
[language_features=V_1_2_GROUP_BY_STRUCT]
select f.d.b
from TestNestedStructValueTable
group by f.d
--
QueryStmt
+-output_column_list=
| +-$query.b#3 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.b#3]
    +-expr_list=
    | +-b#3 :=
    |   +-GetStructField
    |     +-type=STRING
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$groupby.d#2)
    |     +-field_idx=1
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.d#2]
        +-input_scan=
        | +-TableScan(column_list=[TestNestedStructValueTable.value#1], table=TestNestedStructValueTable, column_index_list=[0])
        +-group_by_list=
          +-d#2 :=
            +-GetStructField
              +-type=STRUCT<a INT32, b STRING>
              +-expr=
              | +-GetStructField
              |   +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
              |   +-expr=
              |   | +-ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=TestNestedStructValueTable.value#1)
              |   +-field_idx=1
              +-field_idx=1
==

# Test reference fields NOT within group by struct, should be invalid
[language_features=V_1_2_GROUP_BY_STRUCT]
select e from TestNestedStructValueTable group by f.d
--
ERROR: SELECT list expression references column e which is neither grouped nor aggregated [at 1:8]
select e from TestNestedStructValueTable group by f.d
       ^
==

# Test reference sibling of the group by struct.
[language_features=V_1_2_GROUP_BY_STRUCT]
select f.c from TestNestedStructValueTable group by f.d
--
ERROR: SELECT list expression references f.c which is neither grouped nor aggregated [at 1:8]
select f.c from TestNestedStructValueTable group by f.d
       ^
