select {{KeyValue.|}}key from KeyValue where true group by {{KeyValue.|}}key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[KeyValue.Key#1]
        |   +-input_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |   +-filter_expr=
        |     +-Literal(type=BOOL, value=true)
        +-group_by_list=
          +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

select Key from KeyValue group by
--
ERROR: Syntax error: Unexpected end of statement [at 1:34]
select Key from KeyValue group by
                                 ^
==

# Grouping by a non-integer literal is not allowed.
select Key from KeyValue group by true
--
ERROR: Cannot GROUP BY literal values [at 1:35]
select Key from KeyValue group by true
                                  ^
==

select Key from KeyValue group by -1.0
--
ERROR: Cannot GROUP BY literal values [at 1:35]
select Key from KeyValue group by -1.0
                                  ^
==

select 1 from KeyValue group by key+1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=INT64, value=1)
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-$groupbycol1#3 :=
            +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=1)
==

# Grouping by complex expressions
[no_enable_literal_replacement]
select key+1 from KeyValue group by key+1
--
QueryStmt
+-output_column_list=
| +-$groupby.$groupbycol1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.$groupbycol1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.$groupbycol1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-$groupbycol1#3 :=
            +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=1)
==

# CAST in GROUP BY expression
select CAST(value AS INT64) from KeyValue group by cast(value as int64)
--
QueryStmt
+-output_column_list=
| +-$groupby.$groupbycol1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.$groupbycol1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.$groupbycol1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
        +-group_by_list=
          +-$groupbycol1#3 :=
            +-Cast(STRING -> INT64)
              +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# Parameters in GROUP BY expression
select substr(value, @test_param_int32)
from KeyValue
group by substr(value, @test_param_int32)
--
QueryStmt
+-output_column_list=
| +-$groupby.$groupbycol1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.$groupbycol1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.$groupbycol1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
        +-group_by_list=
          +-$groupbycol1#3 :=
            +-FunctionCall(ZetaSQL:substr(STRING, INT64, optional(0) INT64) -> STRING)
              +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              +-Cast(INT32 -> INT64)
                +-Parameter(type=INT32, name="test_param_int32")
==

# Different parameters in GROUP BY expression
select substr(@test_param_string, key)
from KeyValue
group by substr(@test_param_MixEdCaSe, key)
--
ERROR: SELECT list expression references column key which is neither grouped nor aggregated [at 1:35]
select substr(@test_param_string, key)
                                  ^
==

# Different order of expressions in GROUP BY than in SELECT list
[no_enable_literal_replacement]
select key / 10, regexp_extract(value, 'foo')
from KeyValue
group by regexp_extract(value, 'foo'), key / 10
--
QueryStmt
+-output_column_list=
| +-$groupby.$groupbycol2#4 AS "$col1" [DOUBLE]
| +-$groupby.$groupbycol1#3 AS "$col2" [STRING]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[$groupbycol2#4, $groupbycol1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[$groupbycol1#3, $groupbycol2#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-group_by_list=
          +-$groupbycol1#3 :=
          | +-FunctionCall(ZetaSQL:regexp_extract(STRING, STRING) -> STRING)
          |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
          |   +-Literal(type=STRING, value='foo')
          +-$groupbycol2#4 :=
            +-FunctionCall(ZetaSQL:$divide(DOUBLE, DOUBLE) -> DOUBLE)
              +-Cast(INT64 -> DOUBLE)
              | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=DOUBLE, value=10)
==

[no_enable_literal_replacement]
select concat(cast(key as string), '.', value)
from KeyValue
group by Concat(CAST(key as STRING), ".", value)
--
QueryStmt
+-output_column_list=
| +-$groupby.$groupbycol1#3 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.$groupbycol1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.$groupbycol1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-group_by_list=
          +-$groupbycol1#3 :=
            +-FunctionCall(ZetaSQL:concat(STRING, repeated(2) STRING) -> STRING)
              +-Cast(INT64 -> STRING)
              | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=STRING, value='.')
              +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# has_bool_val and Bool_val are different even though they refer to the same
# field of the same proto and have the same type
select 5
from TestTable
group by KitchenSink.has_bool_val, KitchenSink.Bool_val
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 := Literal(type=INT64, value=5)
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-group_by_list=
          +-has_bool_val#4 :=
          | +-GetProtoField
          |   +-type=BOOL
          |   +-expr=
          |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |   +-field_descriptor=bool_val
          |   +-get_has_bit=TRUE
          +-Bool_val#5 :=
            +-GetProtoField
              +-type=BOOL
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              +-field_descriptor=bool_val
              +-default_value=false
==

# Volatile function
select key * rand()
from KeyValue
group by key * rand()
--
ERROR: SELECT list expression references column key which is neither grouped nor aggregated [at 1:8]
select key * rand()
       ^
==

# Struct fields
[no_enable_literal_replacement]
select s.x + 1, string_agg(s.y)
from (select struct<x int64, y string>(1, 'foo') s)
group by s.x+1
--
QueryStmt
+-output_column_list=
| +-$groupby.$groupbycol1#3 AS "$col1" [INT64]
| +-$aggregate.$agg1#2 AS "$col2" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.$groupbycol1#3, $aggregate.$agg1#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.$groupbycol1#3, $aggregate.$agg1#2]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$subquery1.s#1]
        |   +-expr_list=
        |   | +-s#1 := Literal(type=STRUCT<x INT64, y STRING>, value={x:1, y:'foo'}, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-group_by_list=
        | +-$groupbycol1#3 :=
        |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |     +-GetStructField
        |     | +-type=INT64
        |     | +-expr=
        |     | | +-ColumnRef(type=STRUCT<x INT64, y STRING>, column=$subquery1.s#1)
        |     | +-field_idx=0
        |     +-Literal(type=INT64, value=1)
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
              +-GetStructField
                +-type=STRING
                +-expr=
                | +-ColumnRef(type=STRUCT<x INT64, y STRING>, column=$subquery1.s#1)
                +-field_idx=1
==

# Grouping by complex expressions which don't match SELECT list
select key+1 from KeyValue group by key+2
--
ERROR: SELECT list expression references column key which is neither grouped nor aggregated [at 1:8]
select key+1 from KeyValue group by key+2
       ^
==

select key+0 from KeyValue group by key+0.0
--
ERROR: SELECT list expression references column key which is neither grouped nor aggregated [at 1:8]
select key+0 from KeyValue group by key+0.0
       ^
==

select key+1 from KeyValue group by key-1
--
ERROR: SELECT list expression references column key which is neither grouped nor aggregated [at 1:8]
select key+1 from KeyValue group by key-1
       ^
==

select cast(key as string) from KeyValue group by cast(value as string)
--
ERROR: SELECT list expression references column key which is neither grouped nor aggregated [at 1:13]
select cast(key as string) from KeyValue group by cast(value as string)
            ^
==

SELECT 1
FROM KeyValue
GROUP BY key+1=1
HAVING key+1=1
--
ERROR: HAVING clause expression references column key which is neither grouped nor aggregated [at 4:8]
HAVING key+1=1
       ^
==

SELECT 1
FROM KeyValue
GROUP BY key+1
HAVING key+1 > 0
--
ERROR: HAVING clause expression references column key which is neither grouped nor aggregated [at 4:8]
HAVING key+1 > 0
       ^
==

SELECT 1
FROM KeyValue
GROUP BY key+1
ORDER BY key+1
--
ERROR: ORDER BY clause expression references column key which is neither grouped nor aggregated [at 4:10]
ORDER BY key+1
         ^
==

[language_features=ANALYTIC_FUNCTIONS]
SELECT sum(key+1) OVER ()
FROM KeyValue
GROUP BY key+1
--
ERROR: SELECT list expression references column key which is neither grouped nor aggregated [at 1:12]
SELECT sum(key+1) OVER ()
           ^
==

# We recognize that all of these are the same column as in the GROUP BY.
select kv1.key, key, KEY from KeyValue kv1 group by kv1.key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
| +-$groupby.key#3 AS key [INT64]
| +-$groupby.key#3 AS KEY [INT64]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[key#3, key#3, key#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias='kv1')
        +-group_by_list=
          +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

select KeyValue.key from KeyValue group by key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

select count(*) from KeyValue kv1, KeyValue kv2 GROUP BY kv1.key;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[KeyValue.Key#1]
        |   +-left_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias='kv1')
        |   +-right_scan=
        |     +-TableScan(table=KeyValue, alias='kv2')
        +-group_by_list=
        | +-key#6 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-aggregate_list=
          +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

# GROUP BY 'key' resolves to the (implicit) SELECT list alias 'key', so
# it unambiguously references kv1.key even though kv2 also contains column key.
select kv1.key from KeyValue kv1, KeyValue kv2 GROUP BY key;
--
QueryStmt
+-output_column_list=
| +-$groupby.key#5 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#5]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[KeyValue.Key#1]
        |   +-left_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias='kv1')
        |   +-right_scan=
        |     +-TableScan(table=KeyValue, alias='kv2')
        +-group_by_list=
          +-key#5 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# GROUP BY an explicit alias works as well.
select kv1.key foo from KeyValue kv1, KeyValue kv2 GROUP BY foo;
--
QueryStmt
+-output_column_list=
| +-$groupby.foo#5 AS foo [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.foo#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.foo#5]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[KeyValue.Key#1]
        |   +-left_scan=
        |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias='kv1')
        |   +-right_scan=
        |     +-TableScan(table=KeyValue, alias='kv2')
        +-group_by_list=
          +-foo#5 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# Generated aliases are ambiguous if they show up multiple times.
select kv1.key, kv2.key from KeyValue kv1, KeyValue kv2 GROUP BY key;
--
ERROR: Name key in GROUP BY clause is ambiguous; it may refer to multiple columns in the SELECT-list [at 1:66]
select kv1.key, kv2.key from KeyValue kv1, KeyValue kv2 GROUP BY key;
                                                                 ^
==

select key, value from KeyValue group by 1, 2, 3
--
ERROR: GROUP BY is out of SELECT column number range: 3 [at 1:48]
select key, value from KeyValue group by 1, 2, 3
                                               ^
==

select key, value from KeyValue group by 0
--
ERROR: GROUP BY is out of SELECT column number range: 0 [at 1:42]
select key, value from KeyValue group by 0
                                         ^
==

select key, value from KeyValue group by -1
--
ERROR: GROUP BY is out of SELECT column number range: -1 [at 1:42]
select key, value from KeyValue group by -1
                                         ^
==

select 'a' from KeyValue group by -1
--
ERROR: GROUP BY is out of SELECT column number range: -1 [at 1:35]
select 'a' from KeyValue group by -1
                                  ^
==

# Expression in group by is not evaluated during analyze, hence we don't report
# error of index out of column number range.
select 'a' from KeyValue group by 1+2
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=STRING, value='a')
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-group_by_list=
          +-$groupbycol1#3 :=
            +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
              +-Literal(type=INT64, value=1)
              +-Literal(type=INT64, value=2)
==

select 'a' from KeyValue group by - -1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=STRING, value='a')
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-group_by_list=
          +-$groupbycol1#3 :=
            +-FunctionCall(ZetaSQL:$unary_minus(INT64) -> INT64)
              +-Literal(type=INT64, value=-1)
==

select 'a' from KeyValue group by cast(1 as int64)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=STRING, value='a')
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-group_by_list=
          +-$groupbycol1#3 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
==

# Can group by a subquery.
select 'a' from KeyValue group by (select count(*) from TestTable)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8]
    +-expr_list=
    | +-$col1#8 := Literal(type=STRING, value='a')
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-group_by_list=
          +-$groupbycol1#7 :=
            +-SubqueryExpr
              +-type=INT64
              +-subquery_type=SCALAR
              +-subquery=
                +-ProjectScan
                  +-column_list=[$aggregate.$agg1#6]
                  +-input_scan=
                    +-AggregateScan
                      +-column_list=[$aggregate.$agg1#6]
                      +-input_scan=
                      | +-TableScan(table=TestTable)
                      +-aggregate_list=
                        +-$agg1#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

select key, value from KeyValue group by 3
--
ERROR: GROUP BY is out of SELECT column number range: 3 [at 1:42]
select key, value from KeyValue group by 3
                                         ^
==

select key, value from KeyValue group by 1,2
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
| +-$groupby.value#4 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[key#3, value#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[key#3, value#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-group_by_list=
          +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
          +-value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2)
==

# We don't recognize those expressions are actually duplicates.
select 1 from KeyValue group by key+1, key+2, key+1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 := Literal(type=INT64, value=1)
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-$groupbycol1#3 :=
          | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          |   +-Literal(type=INT64, value=1)
          +-$groupbycol2#4 :=
          | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          |   +-Literal(type=INT64, value=2)
          +-$groupbycol3#5 :=
            +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=1)
==

select Key, KitchenSink.date from TestTable group by 1,2
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#4 AS Key [INT32]
| +-$groupby.date#5 AS date [DATE]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[Key#4, date#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[Key#4, date#5]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
          +-Key#4 := ColumnRef(type=INT32, column=TestTable.key#1)
          +-date#5 :=
            +-GetProtoField
              +-type=DATE
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              +-field_descriptor=date
              +-default_value=1970-01-01
              +-format=DATE
==

# Group by keys can show up multiple times in the SQL, but only go in the
# resolved AST once.
select key, value from KeyValue group by 2,key,key,2,1,value,value,1,2
--
QueryStmt
+-output_column_list=
| +-$groupby.key#4 AS key [INT64]
| +-$groupby.value#3 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[key#4, value#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[value#3, key#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-group_by_list=
          +-value#3 := ColumnRef(type=STRING, column=KeyValue.Value#2)
          +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

select Key kkkKKK from KeyValue group by KKKkkk
--
QueryStmt
+-output_column_list=
| +-$groupby.kkkKKK#3 AS kkkKKK [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.kkkKKK#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.kkkKKK#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-kkkKKK#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

select Key kkkKKK from KeyValue group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#3 AS kkkKKK [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

select key, value from KeyValue group by 1
--
ERROR: SELECT list expression references column value which is neither grouped nor aggregated [at 1:13]
select key, value from KeyValue group by 1
            ^
==

select key, 10 from KeyValue group by 1
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
| +-$query.$col2#4 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#3, $query.$col2#4]
    +-expr_list=
    | +-$col2#4 := Literal(type=INT64, value=10)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

select key, 10 as ten from KeyValue group by 1
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
| +-$query.ten#4 AS ten [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#3, $query.ten#4]
    +-expr_list=
    | +-ten#4 := Literal(type=INT64, value=10)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

select key, key+1, key+2 as k2, 10, 11 as eleven
from KeyValue
group by key, 2, k2, 4, eleven
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
| +-$groupby.$col2#4 AS "$col2" [INT64]
| +-$groupby.k2#5 AS k2 [INT64]
| +-$groupby.$col4#6 AS "$col4" [INT64]
| +-$groupby.eleven#7 AS eleven [INT64]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[key#3, $col2#4, k2#5, $col4#6, eleven#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[key#3, $col2#4, k2#5, $col4#6, eleven#7]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
          +-$col2#4 :=
          | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          |   +-Literal(type=INT64, value=1)
          +-k2#5 :=
          | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          |   +-Literal(type=INT64, value=2)
          +-$col4#6 := Literal(type=INT64, value=10)
          +-eleven#7 := Literal(type=INT64, value=11)
==

# We can group by "k1" because it's exactly an alias - it doesn't get
# treated like an expression.  "k2"+1 does get treated as an expression,
# and k2 is not visible to use in an expression.
# The "k1" alias case is a special case similar to GROUP BY 1.
select key+1 as k1, key+2 as k2 from KeyValue group by k1, k2+1
--
ERROR: Unrecognized name: k2 [at 1:60]
select key+1 as k1, key+2 as k2 from KeyValue group by k1, k2+1
                                                           ^
==

# GROUP BY key matches the alias as well as a column from KeyValue, and
# resolves to the alias.
select key+1 as key from KeyValue group by key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-key#3 :=
            +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=1)
==

select key as c, value as c from KeyValue group by c
--
ERROR: Name c in GROUP BY clause is ambiguous; it may refer to multiple columns in the SELECT-list [at 1:52]
select key as c, value as c from KeyValue group by c
                                                   ^
==

select c1, c3 from (select 123 c1, 456 c2, 789 c3) group by c1, 2
--
QueryStmt
+-output_column_list=
| +-$groupby.c1#4 AS c1 [INT64]
| +-$groupby.c3#5 AS c3 [INT64]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[c1#4, c3#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[c1#4, c3#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$subquery1.[c1#1, c2#2, c3#3]
        |   +-expr_list=
        |   | +-c1#1 := Literal(type=INT64, value=123)
        |   | +-c2#2 := Literal(type=INT64, value=456)
        |   | +-c3#3 := Literal(type=INT64, value=789)
        |   +-input_scan=
        |     +-SingleRowScan
        +-group_by_list=
          +-c1#4 := ColumnRef(type=INT64, column=$subquery1.c1#1)
          +-c3#5 := ColumnRef(type=INT64, column=$subquery1.c3#3)
==

select c1, value, 123 from
(select key c1, value, true boolval from KeyValue group by 1,2,3)
where boolval
--
QueryStmt
+-output_column_list=
| +-$groupby.c1#3 AS c1 [INT64]
| +-$groupby.value#4 AS value [STRING]
| +-$query.$col3#6 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.c1#3, $groupby.value#4, $query.$col3#6]
    +-expr_list=
    | +-$col3#6 := Literal(type=INT64, value=123)
    +-input_scan=
      +-FilterScan
        +-column_list=$groupby.[c1#3, value#4, boolval#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$groupby.[c1#3, value#4, boolval#5]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=$groupby.[c1#3, value#4, boolval#5]
        |       +-input_scan=
        |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |       +-group_by_list=
        |         +-c1#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        |         +-value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2)
        |         +-boolval#5 := Literal(type=BOOL, value=true)
        +-filter_expr=
          +-ColumnRef(type=BOOL, column=$groupby.boolval#5)
==

# Column names that aren't grouped by don't escape the subquery.
# We could give a more helpful error message though...
select value from (select key from KeyValue group by 1)
--
ERROR: Unrecognized name: value [at 1:8]
select value from (select key from KeyValue group by 1)
       ^
==

# Group by an expression with no alias using GROUP BY 1.
select c3 from (select 22, 33 c3 from KeyValue group by 1,2)
--
QueryStmt
+-output_column_list=
| +-$groupby.c3#4 AS c3 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.c3#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=$groupby.[$col1#3, c3#4]
        +-input_scan=
          +-AggregateScan
            +-column_list=$groupby.[$col1#3, c3#4]
            +-input_scan=
            | +-TableScan(table=KeyValue)
            +-group_by_list=
              +-$col1#3 := Literal(type=INT64, value=22)
              +-c3#4 := Literal(type=INT64, value=33)
==

select key+1, key+key from KeyValue group by key
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [INT64]
| +-$query.$col2#5 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#4, $col2#5]
    +-expr_list=
    | +-$col1#4 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-ColumnRef(type=INT64, column=$groupby.key#3)
    | |   +-Literal(type=INT64, value=1)
    | +-$col2#5 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-ColumnRef(type=INT64, column=$groupby.key#3)
    |     +-ColumnRef(type=INT64, column=$groupby.key#3)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# All instances of "key" get rewritten to the same aggregate column.
select key+1, key, key k, key+2 as k2 from KeyValue group by k
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [INT64]
| +-$groupby.k#3 AS key [INT64]
| +-$groupby.k#3 AS k [INT64]
| +-$query.k2#5 AS k2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4, $groupby.k#3, $groupby.k#3, $query.k2#5]
    +-expr_list=
    | +-$col1#4 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-ColumnRef(type=INT64, column=$groupby.k#3)
    | |   +-Literal(type=INT64, value=1)
    | +-k2#5 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-ColumnRef(type=INT64, column=$groupby.k#3)
    |     +-Literal(type=INT64, value=2)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.k#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-k#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# All instances of "key" get rewritten to the same aggregate column.
select key+1, key, key k, key+2 as k2 from KeyValue group by 2
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [INT64]
| +-$groupby.key#3 AS key [INT64]
| +-$groupby.key#3 AS k [INT64]
| +-$query.k2#5 AS k2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4, $groupby.key#3, $groupby.key#3, $query.k2#5]
    +-expr_list=
    | +-$col1#4 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-ColumnRef(type=INT64, column=$groupby.key#3)
    | |   +-Literal(type=INT64, value=1)
    | +-k2#5 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-ColumnRef(type=INT64, column=$groupby.key#3)
    |     +-Literal(type=INT64, value=2)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

select key+1 as k from KeyValue group by k
--
QueryStmt
+-output_column_list=
| +-$groupby.k#3 AS k [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.k#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.k#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-k#3 :=
            +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=1)
==

select key+1 as k from KeyValue group by key, k
--
QueryStmt
+-output_column_list=
| +-$groupby.k#4 AS k [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.k#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.k#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
          +-k#4 :=
            +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=1)
==

# Test for b/17560376, GROUP BY and SELECT path expressions.
select count(*), KitchenSink.int32_val as foo,
       CASE WHEN KitchenSink.int32_val > 1 THEN 10 ELSE 20 END
from TestTable
group by 2
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [INT64]
| +-$groupby.foo#5 AS foo [INT32]
| +-$query.$col3#6 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4, $groupby.foo#5, $query.$col3#6]
    +-expr_list=
    | +-$col3#6 :=
    |   +-FunctionCall(ZetaSQL:$case_no_value(repeated(1) BOOL, repeated(1) INT64, INT64) -> INT64)
    |     +-FunctionCall(ZetaSQL:$greater(INT32, INT32) -> BOOL)
    |     | +-ColumnRef(type=INT32, column=$groupby.foo#5)
    |     | +-Literal(type=INT32, value=1)
    |     +-Literal(type=INT64, value=10)
    |     +-Literal(type=INT64, value=20)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.foo#5, $aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-group_by_list=
        | +-foo#5 :=
        |   +-GetProtoField
        |     +-type=INT32
        |     +-expr=
        |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |     +-field_descriptor=int32_val
        |     +-default_value=77
        +-aggregate_list=
          +-$agg1#4 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

select count(*), count(value) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
| +-$aggregate.$agg2#4 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#3, $agg2#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#3, $agg2#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
          +-$agg2#4 :=
            +-AggregateFunctionCall(ZetaSQL:count(STRING) -> INT64)
              +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

select cast(sum(count(*)) as int64) from KeyValue
--
ERROR: Aggregations of aggregations are not allowed [at 1:13]
select cast(sum(count(*)) as int64) from KeyValue
            ^
==

select cast(count(*) as double) from KeyValue group by value
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-Cast(INT64 -> DOUBLE)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#3)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
        +-group_by_list=
        | +-value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-aggregate_list=
          +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

select cast(key as double) from KeyValue group by value
--
ERROR: SELECT list expression references column key which is neither grouped nor aggregated [at 1:13]
select cast(key as double) from KeyValue group by value
            ^
==

select cast(key as double) from KeyValue group by key
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-Cast(INT64 -> DOUBLE)
    |     +-ColumnRef(type=INT64, column=$groupby.key#3)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# Expressions inside and outside aggregation functions.
select 1+sum(2+key)+count(*) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     | +-Literal(type=INT64, value=1)
    |     | +-ColumnRef(type=INT64, column=$aggregate.$agg1#3)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#4)
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#3, $agg2#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
          |     +-Literal(type=INT64, value=2)
          |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          +-$agg2#4 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

select key + count(value)
from KeyValue
group by key;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-ColumnRef(type=INT64, column=$groupby.key#4)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#3)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#4, $aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-group_by_list=
        | +-key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:count(STRING) -> INT64)
              +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

select sum(1+sum(key)) from KeyValue
--
ERROR: Aggregations of aggregations are not allowed [at 1:8]
select sum(1+sum(key)) from KeyValue
       ^
==

select value, sum(key), count(*) from KeyValue group by value
--
QueryStmt
+-output_column_list=
| +-$groupby.value#5 AS value [STRING]
| +-$aggregate.$agg1#3 AS "$col2" [INT64]
| +-$aggregate.$agg2#4 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.value#5, $aggregate.$agg1#3, $aggregate.$agg2#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.value#5, $aggregate.$agg1#3, $aggregate.$agg2#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-group_by_list=
        | +-value#5 := ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-aggregate_list=
          +-$agg1#3 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          +-$agg2#4 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

select key,count(*) from KeyValue
--
ERROR: SELECT list expression references column key which is neither grouped nor aggregated [at 1:8]
select key,count(*) from KeyValue
       ^
==

select 1+key,sum(key) from KeyValue
--
ERROR: SELECT list expression references column key which is neither grouped nor aggregated [at 1:10]
select 1+key,sum(key) from KeyValue
         ^
==

select count(*)
from (select count(*) cnt, sum(key), sum(1+key) as sk from KeyValue)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#6 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#6]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#6]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$aggregate.[cnt#3, $agg2#4, sk#5]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=$aggregate.[cnt#3, $agg2#4, sk#5]
        |       +-input_scan=
        |       | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |       +-aggregate_list=
        |         +-cnt#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |         +-$agg2#4 :=
        |         | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |         +-sk#5 :=
        |           +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |             +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |               +-Literal(type=INT64, value=1)
        |               +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-aggregate_list=
          +-$agg1#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

# Project-list columns with aggregation cannot be used in group by.
select count(*) c from KeyValue group by 1
--
ERROR: Column 1 contains an aggregation function, which is not allowed in GROUP BY [at 1:42]
select count(*) c from KeyValue group by 1
                                         ^
==

# Project-list columns with aggregation cannot be used in group by.
select 1+sum(key) kZz from KeyValue group by kzZ
--
ERROR: Column kzZ contains an aggregation function, which is not allowed in GROUP BY [at 1:46]
select 1+sum(key) kZz from KeyValue group by kzZ
                                             ^
==

select value from KeyValue where sum(key)=1
--
ERROR: Aggregate function SUM not allowed in WHERE clause [at 1:34]
select value from KeyValue where sum(key)=1
                                 ^
==

select 1 from KeyValue group by sum(key)
--
ERROR: Aggregate function SUM not allowed in GROUP BY [at 1:33]
select 1 from KeyValue group by sum(key)
                                ^
==

# Aggregations are not allowed in the FROM clause, so this instead parses as a
# table-valued function.
[language_features=TABLE_VALUED_FUNCTIONS]
select 1 from KeyValue kv, sum(kv)
--
ERROR: Table-valued function not found: sum [at 1:28]
select 1 from KeyValue kv, sum(kv)
                           ^
==

# Aggregations are not allowed in the FROM clause, so this instead parses as a
# table-valued function.
[language_features=TABLE_VALUED_FUNCTIONS]
select 1 from KeyValue kv, sum(kv) s
--
ERROR: Table-valued function not found: sum [at 1:28]
select 1 from KeyValue kv, sum(kv) s
                           ^
==

# If a function call like this can ever parse in the from clause,
# it should be illegal to do aggregation there.
select 1 from KeyValue kv, sum(kv).field f
--
ERROR: Syntax error: Expected end of input but got "." [at 1:35]
select 1 from KeyValue kv, sum(kv).field f
                                  ^
==

select key k1, key k2 from KeyValue group by 1,2
--
QueryStmt
+-output_column_list=
| +-$groupby.k1#3 AS k1 [INT64]
| +-$groupby.k1#3 AS k2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[k1#3, k1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.k1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-k1#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# Complicated example with subqueries
select count(*), sum(c1) + sum(sum_key) multisum, value
from
  (select count(*) c1 from KeyValue) subq1,
  (select value, sum(key) sum_key from KeyValue group by value) subq2
where c1=sum_key
group by 3
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#8 AS "$col1" [INT64]
| +-$query.multisum#12 AS multisum [INT64]
| +-$groupby.value#11 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#8, $query.multisum#12, $groupby.value#11]
    +-expr_list=
    | +-multisum#12 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#9)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg3#10)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.value#11, $aggregate.$agg1#8, $aggregate.$agg2#9, $aggregate.$agg3#10]
        +-input_scan=
        | +-FilterScan
        |   +-column_list=[$aggregate.c1#3, $groupby.value#7, $aggregate.sum_key#6]
        |   +-input_scan=
        |   | +-JoinScan
        |   |   +-column_list=[$aggregate.c1#3, $groupby.value#7, $aggregate.sum_key#6]
        |   |   +-left_scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$aggregate.c1#3]
        |   |   |   +-input_scan=
        |   |   |     +-AggregateScan
        |   |   |       +-column_list=[$aggregate.c1#3]
        |   |   |       +-input_scan=
        |   |   |       | +-TableScan(table=KeyValue)
        |   |   |       +-aggregate_list=
        |   |   |         +-c1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   |   +-right_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[$groupby.value#7, $aggregate.sum_key#6]
        |   |       +-input_scan=
        |   |         +-AggregateScan
        |   |           +-column_list=[$groupby.value#7, $aggregate.sum_key#6]
        |   |           +-input_scan=
        |   |           | +-TableScan(column_list=KeyValue.[Key#4, Value#5], table=KeyValue, column_index_list=[0, 1])
        |   |           +-group_by_list=
        |   |           | +-value#7 := ColumnRef(type=STRING, column=KeyValue.Value#5)
        |   |           +-aggregate_list=
        |   |             +-sum_key#6 :=
        |   |               +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |   |                 +-ColumnRef(type=INT64, column=KeyValue.Key#4)
        |   +-filter_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$aggregate.c1#3)
        |       +-ColumnRef(type=INT64, column=$aggregate.sum_key#6)
        +-group_by_list=
        | +-value#11 := ColumnRef(type=STRING, column=$groupby.value#7)
        +-aggregate_list=
          +-$agg1#8 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
          +-$agg2#9 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=$aggregate.c1#3)
          +-$agg3#10 :=
            +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=$aggregate.sum_key#6)
==

# Test count on various types.
select
  count(*),
  count(KitchenSink.double_val),
  count(KitchenSink.repeated_double_val),
  count(KitchenSink.test_enum),
  count(KitchenSink.nested_value)
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [INT64]
| +-$aggregate.$agg2#5 AS "$col2" [INT64]
| +-$aggregate.$agg3#6 AS "$col3" [INT64]
| +-$aggregate.$agg4#7 AS "$col4" [INT64]
| +-$aggregate.$agg5#8 AS "$col5" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#4, $agg2#5, $agg3#6, $agg4#7, $agg5#8]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#4, $agg2#5, $agg3#6, $agg4#7, $agg5#8]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-aggregate_list=
          +-$agg1#4 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
          +-$agg2#5 :=
          | +-AggregateFunctionCall(ZetaSQL:count(DOUBLE) -> INT64)
          |   +-GetProtoField
          |     +-type=DOUBLE
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=double_val
          |     +-default_value=0
          +-$agg3#6 :=
          | +-AggregateFunctionCall(ZetaSQL:count(ARRAY<DOUBLE>) -> INT64)
          |   +-GetProtoField
          |     +-type=ARRAY<DOUBLE>
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=repeated_double_val
          |     +-default_value=[]
          +-$agg4#7 :=
          | +-AggregateFunctionCall(ZetaSQL:count(ENUM<zetasql_test__.TestEnum>) -> INT64)
          |   +-GetProtoField
          |     +-type=ENUM<zetasql_test__.TestEnum>
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=test_enum
          |     +-default_value=TESTENUM0
          +-$agg5#8 :=
            +-AggregateFunctionCall(ZetaSQL:count(PROTO<zetasql_test__.KitchenSinkPB.Nested>) -> INT64)
              +-GetProtoField
                +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=nested_value
                +-default_value=NULL
==

# Test any_value on various types.
select
  any_value(KitchenSink.bytes_val),
  any_value(KitchenSink.repeated_double_val),
  any_value(KitchenSink.test_enum),
  any_value(KitchenSink.nested_value),
  any_value(KitchenSink.repeated_holder)
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [BYTES]
| +-$aggregate.$agg2#5 AS "$col2" [ARRAY<DOUBLE>]
| +-$aggregate.$agg3#6 AS "$col3" [ENUM<zetasql_test__.TestEnum>]
| +-$aggregate.$agg4#7 AS "$col4" [PROTO<zetasql_test__.KitchenSinkPB.Nested>]
| +-$aggregate.$agg5#8 AS "$col5" [ARRAY<PROTO<zetasql_test__.RepeatedHolderPB>>]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#4, $agg2#5, $agg3#6, $agg4#7, $agg5#8]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#4, $agg2#5, $agg3#6, $agg4#7, $agg5#8]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-aggregate_list=
          +-$agg1#4 :=
          | +-AggregateFunctionCall(ZetaSQL:any_value(BYTES) -> BYTES)
          |   +-GetProtoField
          |     +-type=BYTES
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=bytes_val
          |     +-default_value=b""
          +-$agg2#5 :=
          | +-AggregateFunctionCall(ZetaSQL:any_value(ARRAY<DOUBLE>) -> ARRAY<DOUBLE>)
          |   +-GetProtoField
          |     +-type=ARRAY<DOUBLE>
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=repeated_double_val
          |     +-default_value=[]
          +-$agg3#6 :=
          | +-AggregateFunctionCall(ZetaSQL:any_value(ENUM<zetasql_test__.TestEnum>) -> ENUM<zetasql_test__.TestEnum>)
          |   +-GetProtoField
          |     +-type=ENUM<zetasql_test__.TestEnum>
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=test_enum
          |     +-default_value=TESTENUM0
          +-$agg4#7 :=
          | +-AggregateFunctionCall(ZetaSQL:any_value(PROTO<zetasql_test__.KitchenSinkPB.Nested>) -> PROTO<zetasql_test__.KitchenSinkPB.Nested>)
          |   +-GetProtoField
          |     +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=nested_value
          |     +-default_value=NULL
          +-$agg5#8 :=
            +-AggregateFunctionCall(ZetaSQL:any_value(ARRAY<PROTO<zetasql_test__.RepeatedHolderPB>>) -> ARRAY<PROTO<zetasql_test__.RepeatedHolderPB>>)
              +-GetProtoField
                +-type=ARRAY<PROTO<zetasql_test__.RepeatedHolderPB>>
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=repeated_holder
                +-default_value=[]
==

# Test assorted other aggregation functions.
select
  sum(KitchenSink.int64_val),
  sum(KitchenSink.double_val),
  avg(KitchenSink.int64_val),
  avg(KitchenSink.double_val),
  min(KitchenSink.int64_val),
  min(KitchenSink.double_val),
  min(KitchenSink.string_val),
  min(KitchenSink.test_enum),
  max(KitchenSink.int64_val),
  max(KitchenSink.double_val),
  max(KitchenSink.string_val),
  max(KitchenSink.test_enum),
  string_agg(KitchenSink.string_val),
  string_agg(KitchenSink.bytes_val),
  bit_and_bq(KitchenSink.int32_val),
  bit_and_bq(KitchenSink.int64_val),
  bit_and_bq(KitchenSink.uint32_val),
  bit_and_bq(KitchenSink.uint64_val),
  bit_or_bq(KitchenSink.int32_val),
  bit_or_bq(KitchenSink.int64_val),
  bit_or_bq(KitchenSink.uint32_val),
  bit_or_bq(KitchenSink.uint64_val),
  bit_xor_bq(KitchenSink.int32_val),
  bit_xor_bq(KitchenSink.int64_val),
  bit_xor_bq(KitchenSink.uint32_val),
  bit_xor_bq(KitchenSink.uint64_val),
  logical_and(KitchenSink.bool_val),
  logical_or(KitchenSink.bool_val)
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [INT64]
| +-$aggregate.$agg2#5 AS "$col2" [DOUBLE]
| +-$aggregate.$agg3#6 AS "$col3" [DOUBLE]
| +-$aggregate.$agg4#7 AS "$col4" [DOUBLE]
| +-$aggregate.$agg5#8 AS "$col5" [INT64]
| +-$aggregate.$agg6#9 AS "$col6" [DOUBLE]
| +-$aggregate.$agg7#10 AS "$col7" [STRING]
| +-$aggregate.$agg8#11 AS "$col8" [ENUM<zetasql_test__.TestEnum>]
| +-$aggregate.$agg9#12 AS "$col9" [INT64]
| +-$aggregate.$agg10#13 AS "$col10" [DOUBLE]
| +-$aggregate.$agg11#14 AS "$col11" [STRING]
| +-$aggregate.$agg12#15 AS "$col12" [ENUM<zetasql_test__.TestEnum>]
| +-$aggregate.$agg13#16 AS "$col13" [STRING]
| +-$aggregate.$agg14#17 AS "$col14" [BYTES]
| +-$aggregate.$agg15#18 AS "$col15" [INT32]
| +-$aggregate.$agg16#19 AS "$col16" [INT64]
| +-$aggregate.$agg17#20 AS "$col17" [UINT32]
| +-$aggregate.$agg18#21 AS "$col18" [UINT64]
| +-$aggregate.$agg19#22 AS "$col19" [INT32]
| +-$aggregate.$agg20#23 AS "$col20" [INT64]
| +-$aggregate.$agg21#24 AS "$col21" [UINT32]
| +-$aggregate.$agg22#25 AS "$col22" [UINT64]
| +-$aggregate.$agg23#26 AS "$col23" [INT32]
| +-$aggregate.$agg24#27 AS "$col24" [INT64]
| +-$aggregate.$agg25#28 AS "$col25" [UINT32]
| +-$aggregate.$agg26#29 AS "$col26" [UINT64]
| +-$aggregate.$agg27#30 AS "$col27" [BOOL]
| +-$aggregate.$agg28#31 AS "$col28" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#4, $agg2#5, $agg3#6, $agg4#7, $agg5#8, $agg6#9, $agg7#10, $agg8#11, $agg9#12, $agg10#13, $agg11#14, $agg12#15, $agg13#16, $agg14#17, $agg15#18, $agg16#19, $agg17#20, $agg18#21, $agg19#22, $agg20#23, $agg21#24, $agg22#25, $agg23#26, $agg24#27, $agg25#28, $agg26#29, $agg27#30, $agg28#31]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#4, $agg2#5, $agg3#6, $agg4#7, $agg5#8, $agg6#9, $agg7#10, $agg8#11, $agg9#12, $agg10#13, $agg11#14, $agg12#15, $agg13#16, $agg14#17, $agg15#18, $agg16#19, $agg17#20, $agg18#21, $agg19#22, $agg20#23, $agg21#24, $agg22#25, $agg23#26, $agg24#27, $agg25#28, $agg26#29, $agg27#30, $agg28#31]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-aggregate_list=
          +-$agg1#4 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-GetProtoField
          |     +-type=INT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int64_val
          |     +-default_value=0
          +-$agg2#5 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
          |   +-GetProtoField
          |     +-type=DOUBLE
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=double_val
          |     +-default_value=0
          +-$agg3#6 :=
          | +-AggregateFunctionCall(ZetaSQL:avg(INT64) -> DOUBLE)
          |   +-GetProtoField
          |     +-type=INT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int64_val
          |     +-default_value=0
          +-$agg4#7 :=
          | +-AggregateFunctionCall(ZetaSQL:avg(DOUBLE) -> DOUBLE)
          |   +-GetProtoField
          |     +-type=DOUBLE
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=double_val
          |     +-default_value=0
          +-$agg5#8 :=
          | +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
          |   +-GetProtoField
          |     +-type=INT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int64_val
          |     +-default_value=0
          +-$agg6#9 :=
          | +-AggregateFunctionCall(ZetaSQL:min(DOUBLE) -> DOUBLE)
          |   +-GetProtoField
          |     +-type=DOUBLE
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=double_val
          |     +-default_value=0
          +-$agg7#10 :=
          | +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
          |   +-GetProtoField
          |     +-type=STRING
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=string_val
          |     +-default_value='default_name'
          +-$agg8#11 :=
          | +-AggregateFunctionCall(ZetaSQL:min(ENUM<zetasql_test__.TestEnum>) -> ENUM<zetasql_test__.TestEnum>)
          |   +-GetProtoField
          |     +-type=ENUM<zetasql_test__.TestEnum>
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=test_enum
          |     +-default_value=TESTENUM0
          +-$agg9#12 :=
          | +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
          |   +-GetProtoField
          |     +-type=INT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int64_val
          |     +-default_value=0
          +-$agg10#13 :=
          | +-AggregateFunctionCall(ZetaSQL:max(DOUBLE) -> DOUBLE)
          |   +-GetProtoField
          |     +-type=DOUBLE
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=double_val
          |     +-default_value=0
          +-$agg11#14 :=
          | +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
          |   +-GetProtoField
          |     +-type=STRING
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=string_val
          |     +-default_value='default_name'
          +-$agg12#15 :=
          | +-AggregateFunctionCall(ZetaSQL:max(ENUM<zetasql_test__.TestEnum>) -> ENUM<zetasql_test__.TestEnum>)
          |   +-GetProtoField
          |     +-type=ENUM<zetasql_test__.TestEnum>
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=test_enum
          |     +-default_value=TESTENUM0
          +-$agg13#16 :=
          | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
          |   +-GetProtoField
          |     +-type=STRING
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=string_val
          |     +-default_value='default_name'
          +-$agg14#17 :=
          | +-AggregateFunctionCall(ZetaSQL:string_agg(BYTES) -> BYTES)
          |   +-GetProtoField
          |     +-type=BYTES
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=bytes_val
          |     +-default_value=b""
          +-$agg15#18 :=
          | +-AggregateFunctionCall(ZetaSQL:bit_and_bq(INT32) -> INT32)
          |   +-GetProtoField
          |     +-type=INT32
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int32_val
          |     +-default_value=77
          +-$agg16#19 :=
          | +-AggregateFunctionCall(ZetaSQL:bit_and_bq(INT64) -> INT64)
          |   +-GetProtoField
          |     +-type=INT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int64_val
          |     +-default_value=0
          +-$agg17#20 :=
          | +-AggregateFunctionCall(ZetaSQL:bit_and_bq(UINT32) -> UINT32)
          |   +-GetProtoField
          |     +-type=UINT32
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=uint32_val
          |     +-default_value=777
          +-$agg18#21 :=
          | +-AggregateFunctionCall(ZetaSQL:bit_and_bq(UINT64) -> UINT64)
          |   +-GetProtoField
          |     +-type=UINT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=uint64_val
          |     +-default_value=0
          +-$agg19#22 :=
          | +-AggregateFunctionCall(ZetaSQL:bit_or_bq(INT32) -> INT32)
          |   +-GetProtoField
          |     +-type=INT32
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int32_val
          |     +-default_value=77
          +-$agg20#23 :=
          | +-AggregateFunctionCall(ZetaSQL:bit_or_bq(INT64) -> INT64)
          |   +-GetProtoField
          |     +-type=INT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int64_val
          |     +-default_value=0
          +-$agg21#24 :=
          | +-AggregateFunctionCall(ZetaSQL:bit_or_bq(UINT32) -> UINT32)
          |   +-GetProtoField
          |     +-type=UINT32
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=uint32_val
          |     +-default_value=777
          +-$agg22#25 :=
          | +-AggregateFunctionCall(ZetaSQL:bit_or_bq(UINT64) -> UINT64)
          |   +-GetProtoField
          |     +-type=UINT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=uint64_val
          |     +-default_value=0
          +-$agg23#26 :=
          | +-AggregateFunctionCall(ZetaSQL:bit_xor_bq(INT32) -> INT32)
          |   +-GetProtoField
          |     +-type=INT32
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int32_val
          |     +-default_value=77
          +-$agg24#27 :=
          | +-AggregateFunctionCall(ZetaSQL:bit_xor_bq(INT64) -> INT64)
          |   +-GetProtoField
          |     +-type=INT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=int64_val
          |     +-default_value=0
          +-$agg25#28 :=
          | +-AggregateFunctionCall(ZetaSQL:bit_xor_bq(UINT32) -> UINT32)
          |   +-GetProtoField
          |     +-type=UINT32
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=uint32_val
          |     +-default_value=777
          +-$agg26#29 :=
          | +-AggregateFunctionCall(ZetaSQL:bit_xor_bq(UINT64) -> UINT64)
          |   +-GetProtoField
          |     +-type=UINT64
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=uint64_val
          |     +-default_value=0
          +-$agg27#30 :=
          | +-AggregateFunctionCall(ZetaSQL:logical_and(BOOL) -> BOOL)
          |   +-GetProtoField
          |     +-type=BOOL
          |     +-expr=
          |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     +-field_descriptor=bool_val
          |     +-default_value=false
          +-$agg28#31 :=
            +-AggregateFunctionCall(ZetaSQL:logical_or(BOOL) -> BOOL)
              +-GetProtoField
                +-type=BOOL
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=bool_val
                +-default_value=false
==

select sum(KitchenSink.string_val) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
              +-Cast(STRING -> DOUBLE)
                +-GetProtoField
                  +-type=STRING
                  +-expr=
                  | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                  +-field_descriptor=string_val
                  +-default_value='default_name'
==

# Note that int32_val is widened to INT64 before doing the SUM in order to
# match the function signature.
select sum(KitchenSink.int32_val) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
              +-Cast(INT32 -> INT64)
                +-GetProtoField
                  +-type=INT32
                  +-expr=
                  | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                  +-field_descriptor=int32_val
                  +-default_value=77
==

select COunt(key), coUnT(*) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
| +-$aggregate.$agg2#4 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#3, $agg2#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#3, $agg2#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
          | +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          +-$agg2#4 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

select concat(*) from KeyValue
--
ERROR: Argument * can only be used in COUNT(*) [at 1:15]
select concat(*) from KeyValue
              ^
==

select sum(*) from KeyValue
--
ERROR: Argument * can only be used in COUNT(*) [at 1:12]
select sum(*) from KeyValue
           ^
==

select count(*, 1) from KeyValue
--
ERROR: Argument * can only be used in COUNT(*) [at 1:14]
select count(*, 1) from KeyValue
             ^
==

select count(distinct *) from KeyValue
--
ERROR: COUNT(*) cannot be used with DISTINCT [at 1:8]
select count(distinct *) from KeyValue
       ^
==

select count(distinct) from KeyValue
--
ERROR: Number of arguments does not match for aggregate function COUNT. Supported signature: COUNT(ANY) [at 1:8]
select count(distinct) from KeyValue
       ^
==

select count(*)
--
ERROR: SELECT without FROM clause cannot use aggregation [at 1:1]
select count(*)
^
==

select sum(5)
--
ERROR: SELECT without FROM clause cannot use aggregation [at 1:1]
select sum(5)
^
==

select count(*) from (select 1)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$subquery1.$col1#1]
        |   +-expr_list=
        |   | +-$col1#1 := Literal(type=INT64, value=1)
        |   +-input_scan=
        |     +-SingleRowScan
        +-aggregate_list=
          +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

select count(*), count(distinct key), sum(distinct key) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
| +-$aggregate.$agg2#4 AS "$col2" [INT64]
| +-$aggregate.$agg3#5 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#3, $agg2#4, $agg3#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#3, $agg2#4, $agg3#5]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
          +-$agg2#4 :=
          | +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          |   +-distinct=TRUE
          +-$agg3#5 :=
            +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-distinct=TRUE
==

select value, 1+sum(distinct key*key), sum(distinct key), sum(key),
       count(distinct key) * count(key)
from KeyValue group by value
--
QueryStmt
+-output_column_list=
| +-$groupby.value#8 AS value [STRING]
| +-$query.$col2#9 AS "$col2" [INT64]
| +-$aggregate.$agg2#4 AS "$col3" [INT64]
| +-$aggregate.$agg3#5 AS "$col4" [INT64]
| +-$query.$col5#10 AS "$col5" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.value#8, $query.$col2#9, $aggregate.$agg2#4, $aggregate.$agg3#5, $query.$col5#10]
    +-expr_list=
    | +-$col2#9 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-Literal(type=INT64, value=1)
    | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1#3)
    | +-$col5#10 :=
    |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg4#6)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg5#7)
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.value#8, $aggregate.$agg1#3, $aggregate.$agg2#4, $aggregate.$agg3#5, $aggregate.$agg4#6, $aggregate.$agg5#7]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-group_by_list=
        | +-value#8 := ColumnRef(type=STRING, column=KeyValue.Value#2)
        +-aggregate_list=
          +-$agg1#3 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
          |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          |   +-distinct=TRUE
          +-$agg2#4 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          |   +-distinct=TRUE
          +-$agg3#5 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          +-$agg4#6 :=
          | +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          |   +-distinct=TRUE
          +-$agg5#7 :=
            +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
==

select array_agg(Key)
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
==

select Key, array_agg(KitchenSink.date)
from TestTable
group by Key
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#5 AS Key [INT32]
| +-$aggregate.$agg1#4 AS "$col2" [ARRAY<DATE>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.Key#5, $aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.Key#5, $aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-Key#5 := ColumnRef(type=INT32, column=TestTable.key#1)
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(DATE) -> ARRAY<DATE>)
              +-GetProtoField
                +-type=DATE
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=date
                +-default_value=1970-01-01
                +-format=DATE
==

select Key, array_agg(KitchenSink.repeated_double_val)
from TestTable
group by Key
--
ERROR: The argument to ARRAY_AGG must not be an array type but was ARRAY<DOUBLE> [at 1:13]
select Key, array_agg(KitchenSink.repeated_double_val)
            ^
==

select keys, k
from (select array_agg(key) as keys from KeyValue) subq,
     subq.keys as k
--
QueryStmt
+-output_column_list=
| +-$aggregate.keys#3 AS keys [ARRAY<INT64>]
| +-$array.k#4 AS k [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.keys#3, $array.k#4]
    +-input_scan=
      +-ArrayScan
        +-column_list=[$aggregate.keys#3, $array.k#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.keys#3]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.keys#3]
        |       +-input_scan=
        |       | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        |       +-aggregate_list=
        |         +-keys#3 :=
        |           +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
        |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-array_expr=
        | +-ColumnRef(type=ARRAY<INT64>, column=$aggregate.keys#3)
        +-element_column=$array.k#4
==

select key, string_agg(value, 'a'), string_agg(cast(value as bytes), b'b')
from KeyValue group by key
--
QueryStmt
+-output_column_list=
| +-$groupby.key#5 AS key [INT64]
| +-$aggregate.$agg1#3 AS "$col2" [STRING]
| +-$aggregate.$agg2#4 AS "$col3" [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#5, $aggregate.$agg1#3, $aggregate.$agg2#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#5, $aggregate.$agg1#3, $aggregate.$agg2#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-group_by_list=
        | +-key#5 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-aggregate_list=
          +-$agg1#3 :=
          | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING, STRING) -> STRING)
          |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
          |   +-Literal(type=STRING, value='a')
          +-$agg2#4 :=
            +-AggregateFunctionCall(ZetaSQL:string_agg(BYTES, BYTES) -> BYTES)
              +-Cast(STRING -> BYTES)
              | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              +-Literal(type=BYTES, value=b"b")
==

select key, string_agg(value, null)
from KeyValue group by key
--
ERROR: Argument 2 to STRING_AGG must be non-NULL [at 1:31]
select key, string_agg(value, null)
                              ^
==

# The cast of NULL is treated as a literal NULL for the error check.
select key, string_agg(value, cast(null as string))
from KeyValue group by key
--
ERROR: Argument 2 to STRING_AGG must be non-NULL [at 1:31]
select key, string_agg(value, cast(null as string))
                              ^
==

select key, string_agg(cast(value as bytes), null)
from KeyValue group by key
--
ERROR: Argument 2 to STRING_AGG must be non-NULL [at 1:46]
select key, string_agg(cast(value as bytes), null)
                                             ^
==

select string_agg(value, @test_param_string),
       string_agg(cast(value as bytes), @test_param_bytes)
from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [STRING]
| +-$aggregate.$agg2#4 AS "$col2" [BYTES]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#3, $agg2#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#3, $agg2#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#3 :=
          | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING, STRING) -> STRING)
          |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
          |   +-Parameter(type=STRING, name="test_param_string")
          +-$agg2#4 :=
            +-AggregateFunctionCall(ZetaSQL:string_agg(BYTES, BYTES) -> BYTES)
              +-Cast(STRING -> BYTES)
              | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              +-Parameter(type=BYTES, name="test_param_bytes")
==

select string_agg(value, @test_param_int32)
from KeyValue
--
ERROR: No matching signature for aggregate function STRING_AGG for argument types: STRING, INT32. Supported signatures: STRING_AGG(STRING); STRING_AGG(STRING, STRING); STRING_AGG(BYTES); STRING_AGG(BYTES, BYTES) [at 1:8]
select string_agg(value, @test_param_int32)
       ^
==

# string_agg(string, bytes) is not supported
SELECT string_agg(value, b'foo') from KeyValue;
--
ERROR: No matching signature for aggregate function STRING_AGG for argument types: STRING, BYTES. Supported signatures: STRING_AGG(STRING); STRING_AGG(STRING, STRING); STRING_AGG(BYTES); STRING_AGG(BYTES, BYTES) [at 1:8]
SELECT string_agg(value, b'foo') from KeyValue;
       ^
==

# string_agg(bytes, string) is not supported
SELECT string_agg(cast(value as bytes), 'foo') from KeyValue;
--
ERROR: No matching signature for aggregate function STRING_AGG for argument types: BYTES, STRING. Supported signatures: STRING_AGG(STRING); STRING_AGG(STRING, STRING); STRING_AGG(BYTES); STRING_AGG(BYTES, BYTES) [at 1:8]
SELECT string_agg(cast(value as bytes), 'foo') from KeyValue;
       ^
==

select key, string_agg(value, value) from KeyValue group by key
--
ERROR: Argument 2 to STRING_AGG must be a literal or query parameter [at 1:31]
select key, string_agg(value, value) from KeyValue group by key
                              ^
==

select key, string_agg(cast(value as bytes), cast(value as bytes))
from KeyValue group by key
--
ERROR: Argument 2 to STRING_AGG must be a literal or query parameter [at 1:46]
select key, string_agg(cast(value as bytes), cast(value as bytes))
                                             ^
==

select min(KitchenSink) from TestTable;
--
ERROR: MIN is not defined for arguments of type PROTO<zetasql_test__.KitchenSinkPB> [at 1:8]
select min(KitchenSink) from TestTable;
       ^
==

select Key, Max(nested_date)
from (select Key, array_agg(KitchenSink.date) nested_date
      from TestTable
      group by Key)
group by Key;
--
ERROR: MAX is not defined for arguments of type ARRAY<DATE> [at 1:13]
select Key, Max(nested_date)
            ^
==

select array_agg(NULL) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-Literal(type=INT64, value=NULL)
==

select array_agg(cast(NULL as array<int64>)) from KeyValue
--
ERROR: The argument to ARRAY_AGG must not be an array type but was ARRAY<INT64> [at 1:8]
select array_agg(cast(NULL as array<int64>)) from KeyValue
       ^
==

# Test that post-aggregation rewrites work with expression subqueries.
# This is for code coverage in ValidateAndRewriteExprPostAggregation.
select count(*), (select 1) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [INT64]
| +-$query.$col2#7 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4, $query.$col2#7]
    +-expr_list=
    | +-$col2#7 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#6]
    |         +-expr_list=
    |         | +-$col1#6 := Literal(type=INT64, value=1)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-aggregate_list=
          +-$agg1#4 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

# This is for code coverage in ValidateAndRewriteExprPostAggregation, to make
# sure traversals of all expression types are handled.
select count(*),
      (select count(*) from (select 1)),
      (select as STRUCT 1 a, 2 b).b,
      (select as "zetasql_test__.KitchenSinkPB"
              7 int64_key_1, 9 int64_key_2).int64_key_2
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [INT64]
| +-$query.$col2#15 AS "$col2" [INT64]
| +-$query.b#19 AS b [INT64]
| +-$query.int64_key_2#23 AS int64_key_2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4, $query.$col2#15, $query.b#19, $query.int64_key_2#23]
    +-expr_list=
    | +-$col2#15 :=
    | | +-SubqueryExpr
    | |   +-type=INT64
    | |   +-subquery_type=SCALAR
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[$aggregate.$agg1#14]
    | |       +-input_scan=
    | |         +-AggregateScan
    | |           +-column_list=[$aggregate.$agg1#14]
    | |           +-input_scan=
    | |           | +-ProjectScan
    | |           |   +-column_list=[$subquery2.$col1#13]
    | |           |   +-expr_list=
    | |           |   | +-$col1#13 := Literal(type=INT64, value=1)
    | |           |   +-input_scan=
    | |           |     +-SingleRowScan
    | |           +-aggregate_list=
    | |             +-$agg1#14 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    | +-b#19 :=
    | | +-GetStructField
    | |   +-type=INT64
    | |   +-expr=
    | |   | +-SubqueryExpr
    | |   |   +-type=STRUCT<a INT64, b INT64>
    | |   |   +-subquery_type=SCALAR
    | |   |   +-subquery=
    | |   |     +-ProjectScan
    | |   |       +-column_list=[$make_struct.$struct#18]
    | |   |       +-expr_list=
    | |   |       | +-$struct#18 :=
    | |   |       |   +-MakeStruct
    | |   |       |     +-type=STRUCT<a INT64, b INT64>
    | |   |       |     +-field_list=
    | |   |       |       +-ColumnRef(type=INT64, column=$expr_subquery.a#16)
    | |   |       |       +-ColumnRef(type=INT64, column=$expr_subquery.b#17)
    | |   |       +-input_scan=
    | |   |         +-ProjectScan
    | |   |           +-column_list=$expr_subquery.[a#16, b#17]
    | |   |           +-expr_list=
    | |   |           | +-a#16 := Literal(type=INT64, value=1)
    | |   |           | +-b#17 := Literal(type=INT64, value=2)
    | |   |           +-input_scan=
    | |   |             +-SingleRowScan
    | |   +-field_idx=1
    | +-int64_key_2#23 :=
    |   +-GetProtoField
    |     +-type=INT64
    |     +-expr=
    |     | +-SubqueryExpr
    |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     |   +-subquery_type=SCALAR
    |     |   +-subquery=
    |     |     +-ProjectScan
    |     |       +-column_list=[$make_proto.$proto#22]
    |     |       +-expr_list=
    |     |       | +-$proto#22 :=
    |     |       |   +-MakeProto
    |     |       |     +-type=PROTO<zetasql_test__.KitchenSinkPB>
    |     |       |     +-field_list=
    |     |       |       +-int64_key_1 := ColumnRef(type=INT64, column=$expr_subquery.int64_key_1#20)
    |     |       |       +-int64_key_2 := ColumnRef(type=INT64, column=$expr_subquery.int64_key_2#21)
    |     |       +-input_scan=
    |     |         +-ProjectScan
    |     |           +-column_list=$expr_subquery.[int64_key_1#20, int64_key_2#21]
    |     |           +-expr_list=
    |     |           | +-int64_key_1#20 := Literal(type=INT64, value=7)
    |     |           | +-int64_key_2#21 := Literal(type=INT64, value=9)
    |     |           +-input_scan=
    |     |             +-SingleRowScan
    |     +-field_descriptor=int64_key_2
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-aggregate_list=
          +-$agg1#4 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

select (select count(*) c, 1 a) from KeyValue
--
ERROR: SELECT without FROM clause cannot use aggregation [at 1:9]
select (select count(*) c, 1 a) from KeyValue
        ^
==

# Grouping by all the supported types.
Select "bool",
       "int32",
       "int64",
       "uint32",
       "uint64",
       "float",
       "double",
       "string",
       "bytes",
       "date",
       timestamp,
       TestEnum
FROM SimpleTypes cross join ComplexTypes
group by 1,2,3,4,5,6,7,8,9,10,11,12;
--
QueryStmt
+-output_column_list=
| +-$groupby.bool#25 AS bool [BOOL]
| +-$groupby.int32#26 AS int32 [INT32]
| +-$groupby.int64#27 AS int64 [INT64]
| +-$groupby.uint32#28 AS uint32 [UINT32]
| +-$groupby.uint64#29 AS uint64 [UINT64]
| +-$groupby.float#30 AS float [FLOAT]
| +-$groupby.double#31 AS double [DOUBLE]
| +-$groupby.string#32 AS string [STRING]
| +-$groupby.bytes#33 AS bytes [BYTES]
| +-$groupby.date#34 AS date [DATE]
| +-$groupby.timestamp#35 AS timestamp [TIMESTAMP]
| +-$groupby.TestEnum#36 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[bool#25, int32#26, int64#27, uint32#28, uint64#29, float#30, double#31, string#32, bytes#33, date#34, timestamp#35, TestEnum#36]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[bool#25, int32#26, int64#27, uint32#28, uint64#29, float#30, double#31, string#32, bytes#33, date#34, timestamp#35, TestEnum#36]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[SimpleTypes.int32#1, SimpleTypes.int64#2, SimpleTypes.uint32#3, SimpleTypes.uint64#4, SimpleTypes.string#5, SimpleTypes.bytes#6, SimpleTypes.bool#7, SimpleTypes.float#8, SimpleTypes.double#9, SimpleTypes.date#10, SimpleTypes.timestamp#15, ComplexTypes.TestEnum#20]
        |   +-left_scan=
        |   | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14])
        |   +-right_scan=
        |     +-TableScan(column_list=[ComplexTypes.TestEnum#20], table=ComplexTypes, column_index_list=[1])
        +-group_by_list=
          +-bool#25 := ColumnRef(type=BOOL, column=SimpleTypes.bool#7)
          +-int32#26 := ColumnRef(type=INT32, column=SimpleTypes.int32#1)
          +-int64#27 := ColumnRef(type=INT64, column=SimpleTypes.int64#2)
          +-uint32#28 := ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
          +-uint64#29 := ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
          +-float#30 := ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
          +-double#31 := ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
          +-string#32 := ColumnRef(type=STRING, column=SimpleTypes.string#5)
          +-bytes#33 := ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
          +-date#34 := ColumnRef(type=DATE, column=SimpleTypes.date#10)
          +-timestamp#35 := ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
          +-TestEnum#36 := ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#20)
==

select KitchenSink from ComplexTypes group by KitchenSink;
--
ERROR: Grouping by expressions of type PROTO is not allowed [at 1:47]
select KitchenSink from ComplexTypes group by KitchenSink;
                                              ^
==

select KitchenSink from ComplexTypes group by 1;
--
ERROR: Grouping by expressions of type PROTO is not allowed [at 1:47]
select KitchenSink from ComplexTypes group by 1;
                                              ^
==

# GROUP BY <array> does not work if the language feature is turned off.
select Int32Array from ComplexTypes group by 1;
--
ERROR: Grouping by expressions of type ARRAY is not allowed [at 1:46]
select Int32Array from ComplexTypes group by 1;
                                             ^
==

# Test GROUP BY <array> with the supported types.
[language_features=V_1_2_GROUP_BY_ARRAY]
select 10 from ArrayTypes group by
    Int32Array,
    Int64Array,
    UInt32Array,
    UInt64Array,
    StringArray,
    BytesArray,
    BoolArray,
    FloatArray,
    DoubleArray,
    DateArray,
    TimestampSecondsArray,
    TimestampMillisArray,
    TimestampMicrosArray,
    TimestampArray;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#32 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#32]
    +-expr_list=
    | +-$col1#32 := Literal(type=INT64, value=10)
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(column_list=ArrayTypes.[Int32Array#1, Int64Array#2, UInt32Array#3, UInt64Array#4, StringArray#5, BytesArray#6, BoolArray#7, FloatArray#8, DoubleArray#9, DateArray#10, TimestampSecondsArray#11, TimestampMillisArray#12, TimestampMicrosArray#13, TimestampArray#14], table=ArrayTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])
        +-group_by_list=
          +-Int32Array#18 := ColumnRef(type=ARRAY<INT32>, column=ArrayTypes.Int32Array#1)
          +-Int64Array#19 := ColumnRef(type=ARRAY<INT64>, column=ArrayTypes.Int64Array#2)
          +-UInt32Array#20 := ColumnRef(type=ARRAY<UINT32>, column=ArrayTypes.UInt32Array#3)
          +-UInt64Array#21 := ColumnRef(type=ARRAY<UINT64>, column=ArrayTypes.UInt64Array#4)
          +-StringArray#22 := ColumnRef(type=ARRAY<STRING>, column=ArrayTypes.StringArray#5)
          +-BytesArray#23 := ColumnRef(type=ARRAY<BYTES>, column=ArrayTypes.BytesArray#6)
          +-BoolArray#24 := ColumnRef(type=ARRAY<BOOL>, column=ArrayTypes.BoolArray#7)
          +-FloatArray#25 := ColumnRef(type=ARRAY<FLOAT>, column=ArrayTypes.FloatArray#8)
          +-DoubleArray#26 := ColumnRef(type=ARRAY<DOUBLE>, column=ArrayTypes.DoubleArray#9)
          +-DateArray#27 := ColumnRef(type=ARRAY<DATE>, column=ArrayTypes.DateArray#10)
          +-TimestampSecondsArray#28 := ColumnRef(type=ARRAY<TIMESTAMP>, column=ArrayTypes.TimestampSecondsArray#11)
          +-TimestampMillisArray#29 := ColumnRef(type=ARRAY<TIMESTAMP>, column=ArrayTypes.TimestampMillisArray#12)
          +-TimestampMicrosArray#30 := ColumnRef(type=ARRAY<TIMESTAMP>, column=ArrayTypes.TimestampMicrosArray#13)
          +-TimestampArray#31 := ColumnRef(type=ARRAY<TIMESTAMP>, column=ArrayTypes.TimestampArray#14)
==

# Test GROUP BY <array> with an unsupported type.
[language_features=V_1_2_GROUP_BY_ARRAY]
select 10 from ArrayTypes group by ProtoArray
--
ERROR: Grouping by expressions of type ARRAY containing PROTO is not allowed [at 1:36]
select 10 from ArrayTypes group by ProtoArray
                                   ^
==

# Test GROUP BY <array> for an array of structs.
[language_features={{V_1_2_GROUP_BY_ARRAY|V_1_2_GROUP_BY_STRUCT,V_1_2_GROUP_BY_ARRAY}}]
select 10 from ArrayTypes group by StructArray
--
ALTERNATION GROUP: V_1_2_GROUP_BY_ARRAY
--
ERROR: Grouping by expressions of type ARRAY containing STRUCT is not allowed [at 1:36]
select 10 from ArrayTypes group by StructArray
                                   ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT,V_1_2_GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 := Literal(type=INT64, value=10)
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(column_list=[ArrayTypes.StructArray#16], table=ArrayTypes, column_index_list=[15])
        +-group_by_list=
          +-StructArray#18 := ColumnRef(type=ARRAY<STRUCT<a INT32, b STRING>>, column=ArrayTypes.StructArray#16)
==

# Test GROUP BY <array> for an array of structs containing a proto.
[language_features={{|V_1_2_GROUP_BY_STRUCT,V_1_2_GROUP_BY_ARRAY}}]
select a
from (select [(cast('int32_val1: 1' as zetasql_test__.TestExtraPB))] as a)
group by a
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type ARRAY is not allowed [at 3:10]
group by a
         ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT,V_1_2_GROUP_BY_ARRAY
--
ERROR: Grouping by expressions of type ARRAY containing PROTO is not allowed [at 3:10]
group by a
         ^
==

[language_features={{V_1_2_GROUP_BY_STRUCT|}}]
select TestStruct from ComplexTypes group by 1;
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$groupby.TestStruct#7 AS TestStruct [STRUCT<c INT32, d STRUCT<a INT32, b STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.TestStruct#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.TestStruct#7]
        +-input_scan=
        | +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4])
        +-group_by_list=
          +-TestStruct#7 := ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 1:46]
select TestStruct from ComplexTypes group by 1;
                                             ^
==

# Note the duplicate aggregate column being produced.
select sum("int64"), sum("int64")
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS "$col1" [INT64]
| +-$aggregate.$agg2#20 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#19, $agg2#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#19, $agg2#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#19 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
          +-$agg2#20 :=
            +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)

==

select count(distinct bool),
       count(distinct int32),
       count(distinct int64),
       count(distinct uint32),
       count(distinct uint64),
       count(distinct float),
       count(distinct double),
       count(distinct string),
       count(distinct bytes),
       count(distinct date),
       count(distinct timestamp),
       count(distinct TestEnum)
from SimpleTypes, ComplexTypes;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#25 AS "$col1" [INT64]
| +-$aggregate.$agg2#26 AS "$col2" [INT64]
| +-$aggregate.$agg3#27 AS "$col3" [INT64]
| +-$aggregate.$agg4#28 AS "$col4" [INT64]
| +-$aggregate.$agg5#29 AS "$col5" [INT64]
| +-$aggregate.$agg6#30 AS "$col6" [INT64]
| +-$aggregate.$agg7#31 AS "$col7" [INT64]
| +-$aggregate.$agg8#32 AS "$col8" [INT64]
| +-$aggregate.$agg9#33 AS "$col9" [INT64]
| +-$aggregate.$agg10#34 AS "$col10" [INT64]
| +-$aggregate.$agg11#35 AS "$col11" [INT64]
| +-$aggregate.$agg12#36 AS "$col12" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#25, $agg2#26, $agg3#27, $agg4#28, $agg5#29, $agg6#30, $agg7#31, $agg8#32, $agg9#33, $agg10#34, $agg11#35, $agg12#36]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#25, $agg2#26, $agg3#27, $agg4#28, $agg5#29, $agg6#30, $agg7#31, $agg8#32, $agg9#33, $agg10#34, $agg11#35, $agg12#36]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[SimpleTypes.int32#1, SimpleTypes.int64#2, SimpleTypes.uint32#3, SimpleTypes.uint64#4, SimpleTypes.string#5, SimpleTypes.bytes#6, SimpleTypes.bool#7, SimpleTypes.float#8, SimpleTypes.double#9, SimpleTypes.date#10, SimpleTypes.timestamp#15, ComplexTypes.TestEnum#20]
        |   +-left_scan=
        |   | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp#15], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 14])
        |   +-right_scan=
        |     +-TableScan(column_list=[ComplexTypes.TestEnum#20], table=ComplexTypes, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#25 :=
          | +-AggregateFunctionCall(ZetaSQL:count(BOOL) -> INT64)
          |   +-ColumnRef(type=BOOL, column=SimpleTypes.bool#7)
          |   +-distinct=TRUE
          +-$agg2#26 :=
          | +-AggregateFunctionCall(ZetaSQL:count(INT32) -> INT64)
          |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
          |   +-distinct=TRUE
          +-$agg3#27 :=
          | +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
          |   +-distinct=TRUE
          +-$agg4#28 :=
          | +-AggregateFunctionCall(ZetaSQL:count(UINT32) -> INT64)
          |   +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
          |   +-distinct=TRUE
          +-$agg5#29 :=
          | +-AggregateFunctionCall(ZetaSQL:count(UINT64) -> INT64)
          |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
          |   +-distinct=TRUE
          +-$agg6#30 :=
          | +-AggregateFunctionCall(ZetaSQL:count(FLOAT) -> INT64)
          |   +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
          |   +-distinct=TRUE
          +-$agg7#31 :=
          | +-AggregateFunctionCall(ZetaSQL:count(DOUBLE) -> INT64)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
          |   +-distinct=TRUE
          +-$agg8#32 :=
          | +-AggregateFunctionCall(ZetaSQL:count(STRING) -> INT64)
          |   +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
          |   +-distinct=TRUE
          +-$agg9#33 :=
          | +-AggregateFunctionCall(ZetaSQL:count(BYTES) -> INT64)
          |   +-ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
          |   +-distinct=TRUE
          +-$agg10#34 :=
          | +-AggregateFunctionCall(ZetaSQL:count(DATE) -> INT64)
          |   +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
          |   +-distinct=TRUE
          +-$agg11#35 :=
          | +-AggregateFunctionCall(ZetaSQL:count(TIMESTAMP) -> INT64)
          |   +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
          |   +-distinct=TRUE
          +-$agg12#36 :=
            +-AggregateFunctionCall(ZetaSQL:count(ENUM<zetasql_test__.TestEnum>) -> INT64)
              +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=ComplexTypes.TestEnum#20)
              +-distinct=TRUE
==

select count(distinct KitchenSink) from ComplexTypes;
--
ERROR: Aggregate functions with DISTINCT cannot be used with arguments of type PROTO [at 1:8]
select count(distinct KitchenSink) from ComplexTypes;
       ^
==

select count(distinct Int32Array) from ComplexTypes;
--
ERROR: Aggregate functions with DISTINCT cannot be used with arguments of type ARRAY [at 1:8]
select count(distinct Int32Array) from ComplexTypes;
       ^
==

[language_features={{V_1_2_GROUP_BY_STRUCT|}}]
select count(distinct TestStruct) from ComplexTypes;
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#7 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#7]
        +-input_scan=
        | +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#7 :=
            +-AggregateFunctionCall(ZetaSQL:count(STRUCT<c INT32, d STRUCT<a INT32, b STRING>>) -> INT64)
              +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
              +-distinct=TRUE
--
ALTERNATION GROUP: <empty>
--
ERROR: Aggregate functions with DISTINCT cannot be used with arguments of type STRUCT [at 1:8]
select count(distinct TestStruct) from ComplexTypes;
       ^
==

# GROUP BY proto field references, one and two levels deep.
select KitchenSink.date, KitchenSink.nested_value.nested_int64
from TestTable
group by KitchenSink.date, KitchenSink.nested_value.nested_int64;
--
QueryStmt
+-output_column_list=
| +-$groupby.date#4 AS date [DATE]
| +-$groupby.nested_int64#5 AS nested_int64 [INT64]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[date#4, nested_int64#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[date#4, nested_int64#5]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-group_by_list=
          +-date#4 :=
          | +-GetProtoField
          |   +-type=DATE
          |   +-expr=
          |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |   +-field_descriptor=date
          |   +-default_value=1970-01-01
          |   +-format=DATE
          +-nested_int64#5 :=
            +-GetProtoField
              +-type=INT64
              +-expr=
              | +-GetProtoField
              |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
              |   +-expr=
              |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              |   +-field_descriptor=nested_value
              |   +-default_value=NULL
              +-field_descriptor=nested_int64
              +-default_value=88
==

select KitchenSink.nested_value.nested_int64 + 1
from TestTable
group by KitchenSink.nested_value.nested_int64
having KitchenSink.nested_value.nested_int64 > 0
order by KitchenSink.nested_value.nested_int64 +2
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$query.$col1#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.nested_int64#4, $query.$col1#5, $orderby.$orderbycol1#6]
    |   +-expr_list=
    |   | +-$orderbycol1#6 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=$groupby.nested_int64#4)
    |   |     +-Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-FilterScan
    |       +-column_list=[$groupby.nested_int64#4, $query.$col1#5]
    |       +-input_scan=
    |       | +-ProjectScan
    |       |   +-column_list=[$groupby.nested_int64#4, $query.$col1#5]
    |       |   +-expr_list=
    |       |   | +-$col1#5 :=
    |       |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       |   |     +-ColumnRef(type=INT64, column=$groupby.nested_int64#4)
    |       |   |     +-Literal(type=INT64, value=1)
    |       |   +-input_scan=
    |       |     +-AggregateScan
    |       |       +-column_list=[$groupby.nested_int64#4]
    |       |       +-input_scan=
    |       |       | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
    |       |       +-group_by_list=
    |       |         +-nested_int64#4 :=
    |       |           +-GetProtoField
    |       |             +-type=INT64
    |       |             +-expr=
    |       |             | +-GetProtoField
    |       |             |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |       |             |   +-expr=
    |       |             |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |       |             |   +-field_descriptor=nested_value
    |       |             |   +-default_value=NULL
    |       |             +-field_descriptor=nested_int64
    |       |             +-default_value=88
    |       +-filter_expr=
    |         +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |           +-ColumnRef(type=INT64, column=$groupby.nested_int64#4)
    |           +-Literal(type=INT64, value=0)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#6)
==

# Grouping by path expressions that start with and without range variables,
# then using them in the SELECT, HAVING, and ORDER BY should generally
# work.
select {{T.|}}KitchenSink.nested_value.nested_int64 + 1
from TestTable T
group by {{T.|}}KitchenSink.nested_value.nested_int64
having {{T.|}}KitchenSink.nested_value.nested_int64 > 0
order by {{T.|}}KitchenSink.nested_value.nested_int64 + 2
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$query.$col1#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.nested_int64#4, $query.$col1#5, $orderby.$orderbycol1#6]
    |   +-expr_list=
    |   | +-$orderbycol1#6 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=$groupby.nested_int64#4)
    |   |     +-Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-FilterScan
    |       +-column_list=[$groupby.nested_int64#4, $query.$col1#5]
    |       +-input_scan=
    |       | +-ProjectScan
    |       |   +-column_list=[$groupby.nested_int64#4, $query.$col1#5]
    |       |   +-expr_list=
    |       |   | +-$col1#5 :=
    |       |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       |   |     +-ColumnRef(type=INT64, column=$groupby.nested_int64#4)
    |       |   |     +-Literal(type=INT64, value=1)
    |       |   +-input_scan=
    |       |     +-AggregateScan
    |       |       +-column_list=[$groupby.nested_int64#4]
    |       |       +-input_scan=
    |       |       | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias='T')
    |       |       +-group_by_list=
    |       |         +-nested_int64#4 :=
    |       |           +-GetProtoField
    |       |             +-type=INT64
    |       |             +-expr=
    |       |             | +-GetProtoField
    |       |             |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |       |             |   +-expr=
    |       |             |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |       |             |   +-field_descriptor=nested_value
    |       |             |   +-default_value=NULL
    |       |             +-field_descriptor=nested_int64
    |       |             +-default_value=88
    |       +-filter_expr=
    |         +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |           +-ColumnRef(type=INT64, column=$groupby.nested_int64#4)
    |           +-Literal(type=INT64, value=0)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#6)
==

select {{T.|}}KitchenSink.nested_value.nested_int64, count(n)
from TestTable T, T.KitchenSink.repeated_double_val n
group by {{T.|}}KitchenSink.nested_value.nested_int64
having {{T.|}}KitchenSink.nested_value.nested_int64 > 0
order by {{T.|}}KitchenSink.nested_value.nested_int64 + 2
--
QueryStmt
+-output_column_list=
| +-$groupby.nested_int64#7 AS nested_int64 [INT64]
| +-$aggregate.$agg1#5 AS "$col2" [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.nested_int64#7, $aggregate.$agg1#5]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.nested_int64#7, $aggregate.$agg1#5, $orderby.$orderbycol1#8]
    |   +-expr_list=
    |   | +-$orderbycol1#8 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=$groupby.nested_int64#7)
    |   |     +-Literal(type=INT64, value=2)
    |   +-input_scan=
    |     +-FilterScan
    |       +-column_list=[$groupby.nested_int64#7, $aggregate.$agg1#5]
    |       +-input_scan=
    |       | +-AggregateScan
    |       |   +-column_list=[$groupby.nested_int64#7, $aggregate.$agg1#5]
    |       |   +-input_scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[TestTable.KitchenSink#3, $array.n#4, $pre_groupby.nested_int64#6]
    |       |   |   +-expr_list=
    |       |   |   | +-nested_int64#6 :=
    |       |   |   |   +-GetProtoField
    |       |   |   |     +-type=INT64
    |       |   |   |     +-expr=
    |       |   |   |     | +-GetProtoField
    |       |   |   |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
    |       |   |   |     |   +-expr=
    |       |   |   |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |       |   |   |     |   +-field_descriptor=nested_value
    |       |   |   |     |   +-default_value=NULL
    |       |   |   |     +-field_descriptor=nested_int64
    |       |   |   |     +-default_value=88
    |       |   |   +-input_scan=
    |       |   |     +-ArrayScan
    |       |   |       +-column_list=[TestTable.KitchenSink#3, $array.n#4]
    |       |   |       +-input_scan=
    |       |   |       | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias='T')
    |       |   |       +-array_expr=
    |       |   |       | +-GetProtoField
    |       |   |       |   +-type=ARRAY<DOUBLE>
    |       |   |       |   +-expr=
    |       |   |       |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |       |   |       |   +-field_descriptor=repeated_double_val
    |       |   |       |   +-default_value=[]
    |       |   |       +-element_column=$array.n#4
    |       |   +-group_by_list=
    |       |   | +-nested_int64#7 := ColumnRef(type=INT64, column=$pre_groupby.nested_int64#6)
    |       |   +-aggregate_list=
    |       |     +-$agg1#5 :=
    |       |       +-AggregateFunctionCall(ZetaSQL:count(DOUBLE) -> INT64)
    |       |         +-ColumnRef(type=DOUBLE, column=$array.n#4)
    |       +-filter_expr=
    |         +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |           +-ColumnRef(type=INT64, column=$groupby.nested_int64#7)
    |           +-Literal(type=INT64, value=0)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#8)
==

# Accessing 'n' is not valid after grouping.
select {{T.|}}KitchenSink.nested_value.nested_int64, n
from TestTable T, T.KitchenSink.repeated_double_val n
group by {{T.|}}KitchenSink.nested_value.nested_int64
--
ALTERNATION GROUPS:
    T.,T.
    T.,
--
ERROR: SELECT list expression references table alias n which is neither grouped nor aggregated [at 1:49]
select T.KitchenSink.nested_value.nested_int64, n
                                                ^
--
ALTERNATION GROUPS:
    T.
    <empty>
--
ERROR: SELECT list expression references table alias n which is neither grouped nor aggregated [at 1:47]
select KitchenSink.nested_value.nested_int64, n
                                              ^
==

# GROUP BY struct field reference.
select sq.a
from (select as struct key as a, value as b from KeyValue) as sq
group by sq.a
--
QueryStmt
+-output_column_list=
| +-$groupby.a#4 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.a#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.a#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$make_struct.$struct#3]
        |   +-expr_list=
        |   | +-$struct#3 :=
        |   |   +-MakeStruct
        |   |     +-type=STRUCT<a INT64, b STRING>
        |   |     +-field_list=
        |   |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=KeyValue.[Key#1, Value#2]
        |       +-input_scan=
        |         +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-group_by_list=
          +-a#4 :=
            +-GetStructField
              +-type=INT64
              +-expr=
              | +-ColumnRef(type=STRUCT<a INT64, b STRING>, column=$make_struct.$struct#3)
              +-field_idx=0
==

# GROUP BY literal struct field reference.
select sq.a
from (select as struct 1 as a, 2 as b) as sq
group by sq.a
--
QueryStmt
+-output_column_list=
| +-$groupby.a#4 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.a#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.a#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$make_struct.$struct#3]
        |   +-expr_list=
        |   | +-$struct#3 :=
        |   |   +-MakeStruct
        |   |     +-type=STRUCT<a INT64, b INT64>
        |   |     +-field_list=
        |   |       +-ColumnRef(type=INT64, column=sq.a#1)
        |   |       +-ColumnRef(type=INT64, column=sq.b#2)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=sq.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=INT64, value=2)
        |       +-input_scan=
        |         +-SingleRowScan
        +-group_by_list=
          +-a#4 :=
            +-GetStructField
              +-type=INT64
              +-expr=
              | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3)
              +-field_idx=0
==

# GROUP BY nested literal struct field reference.
select sq.x.a, sq.y.d
from (select as struct (select as struct 1 as a, 2 as b) as x,
                       (select as struct 1 as c, 2 as d) as y) as sq
group by sq.x.a, sq.y.d
--
QueryStmt
+-output_column_list=
| +-$groupby.a#10 AS a [INT64]
| +-$groupby.d#11 AS d [INT64]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[a#10, d#11]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[a#10, d#11]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$make_struct.$struct#9]
        |   +-expr_list=
        |   | +-$struct#9 :=
        |   |   +-MakeStruct
        |   |     +-type=STRUCT<x STRUCT<a INT64, b INT64>, y STRUCT<c INT64, d INT64>>
        |   |     +-field_list=
        |   |       +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=sq.x#7)
        |   |       +-ColumnRef(type=STRUCT<c INT64, d INT64>, column=sq.y#8)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=sq.[x#7, y#8]
        |       +-expr_list=
        |       | +-x#7 :=
        |       | | +-SubqueryExpr
        |       | |   +-type=STRUCT<a INT64, b INT64>
        |       | |   +-subquery_type=SCALAR
        |       | |   +-subquery=
        |       | |     +-ProjectScan
        |       | |       +-column_list=[$make_struct.$struct#3]
        |       | |       +-expr_list=
        |       | |       | +-$struct#3 :=
        |       | |       |   +-MakeStruct
        |       | |       |     +-type=STRUCT<a INT64, b INT64>
        |       | |       |     +-field_list=
        |       | |       |       +-ColumnRef(type=INT64, column=$expr_subquery.a#1)
        |       | |       |       +-ColumnRef(type=INT64, column=$expr_subquery.b#2)
        |       | |       +-input_scan=
        |       | |         +-ProjectScan
        |       | |           +-column_list=$expr_subquery.[a#1, b#2]
        |       | |           +-expr_list=
        |       | |           | +-a#1 := Literal(type=INT64, value=1)
        |       | |           | +-b#2 := Literal(type=INT64, value=2)
        |       | |           +-input_scan=
        |       | |             +-SingleRowScan
        |       | +-y#8 :=
        |       |   +-SubqueryExpr
        |       |     +-type=STRUCT<c INT64, d INT64>
        |       |     +-subquery_type=SCALAR
        |       |     +-subquery=
        |       |       +-ProjectScan
        |       |         +-column_list=[$make_struct.$struct#6]
        |       |         +-expr_list=
        |       |         | +-$struct#6 :=
        |       |         |   +-MakeStruct
        |       |         |     +-type=STRUCT<c INT64, d INT64>
        |       |         |     +-field_list=
        |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.c#4)
        |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.d#5)
        |       |         +-input_scan=
        |       |           +-ProjectScan
        |       |             +-column_list=$expr_subquery.[c#4, d#5]
        |       |             +-expr_list=
        |       |             | +-c#4 := Literal(type=INT64, value=1)
        |       |             | +-d#5 := Literal(type=INT64, value=2)
        |       |             +-input_scan=
        |       |               +-SingleRowScan
        |       +-input_scan=
        |         +-SingleRowScan
        +-group_by_list=
          +-a#10 :=
          | +-GetStructField
          |   +-type=INT64
          |   +-expr=
          |   | +-GetStructField
          |   |   +-type=STRUCT<a INT64, b INT64>
          |   |   +-expr=
          |   |   | +-ColumnRef(type=STRUCT<x STRUCT<a INT64, b INT64>, y STRUCT<c INT64, d INT64>>, column=$make_struct.$struct#9)
          |   |   +-field_idx=0
          |   +-field_idx=0
          +-d#11 :=
            +-GetStructField
              +-type=INT64
              +-expr=
              | +-GetStructField
              |   +-type=STRUCT<c INT64, d INT64>
              |   +-expr=
              |   | +-ColumnRef(type=STRUCT<x STRUCT<a INT64, b INT64>, y STRUCT<c INT64, d INT64>>, column=$make_struct.$struct#9)
              |   +-field_idx=1
              +-field_idx=1
==


# The 'foo' reference in GROUP BY resolves to the SELECT list alias, not the
# FROM clause range variable.
select foo.a AS a1, foo.b AS foo
FROM (SELECT 1 AS a, 2 AS b) AS foo
GROUP BY a1, foo;
--
QueryStmt
+-output_column_list=
| +-$groupby.a1#3 AS a1 [INT64]
| +-$groupby.foo#4 AS foo [INT64]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[a1#3, foo#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[a1#3, foo#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=foo.[a#1, b#2]
        |   +-expr_list=
        |   | +-a#1 := Literal(type=INT64, value=1)
        |   | +-b#2 := Literal(type=INT64, value=2)
        |   +-input_scan=
        |     +-SingleRowScan
        +-group_by_list=
          +-a1#3 := ColumnRef(type=INT64, column=foo.a#1)
          +-foo#4 := ColumnRef(type=INT64, column=foo.b#2)
==

# The 'foo' reference in GROUP BY resolves to the SELECT list alias, which
# does not have field b.
select foo.a AS a1, foo.b AS foo
FROM (SELECT 1 AS a, 2 AS b) AS foo
GROUP BY foo.b;
--
ERROR: Cannot GROUP BY field references from SELECT list alias foo [at 3:10]
GROUP BY foo.b;
         ^
==

# The 'foo2' reference in GROUP BY resolves to the SELECT list alias, and
# 'foo2' does have a field 'b'.  However, field references from SELECT
# list aliases are not currently allowed in the GROUP BY.  This query
# is not valid anyway since 'foo' appears in the SELECT list but cannot
# be in the GROUP BY because it is a STRUCT and we do not allow GROUP BY
# STRUCT.
select foo as foo2
FROM (select as struct 1 as a, 2 as b) foo
GROUP BY foo2.b;
--
ERROR: Cannot GROUP BY field references from SELECT list alias foo2 [at 3:10]
GROUP BY foo2.b;
         ^
==

select foo as foo
FROM (select as struct 1 as a, 2 as b) foo
GROUP BY foo.b;
--
ERROR: Cannot GROUP BY field references from SELECT list alias foo [at 3:10]
GROUP BY foo.b;
         ^
==

# TODO: when V_1_2_GROUP_BY_STRUCT is set, this should be valid. Note
# that because fixing this requires some complex analysis, we decide not to
# fix this now.
[language_features={{V_1_2_GROUP_BY_STRUCT|}}]
select foo as foo2
FROM (select as struct 1 as a, 2 as b) foo
GROUP BY foo2, foo2.a, foo2.b;
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
ERROR: Cannot GROUP BY field references from SELECT list alias foo2 [at 3:16]
GROUP BY foo2, foo2.a, foo2.b;
               ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 3:10]
GROUP BY foo2, foo2.a, foo2.b;
         ^
==

[language_features={{V_1_2_GROUP_BY_STRUCT|}}]
select TestStruct as ts
FROM ComplexTypes kv
GROUP BY ts, ts.d, ts.c;
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
ERROR: Cannot GROUP BY field references from SELECT list alias ts [at 3:14]
GROUP BY ts, ts.d, ts.c;
             ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 3:10]
GROUP BY ts, ts.d, ts.c;
         ^
==

[language_features=V_1_2_GROUP_BY_STRUCT]
select vt as vt2
FROM  TestStructValueTable vt
GROUP BY vt2, vt2.a, vt2.b;
--
ERROR: Cannot GROUP BY field references from SELECT list alias vt2 [at 3:15]
GROUP BY vt2, vt2.a, vt2.b;
              ^
==

[language_features={{V_1_2_GROUP_BY_STRUCT|}}]
select foo as foo2
FROM (select as struct 1 as a, 2 as b) foo
GROUP BY foo2, foo.a, foo.b;

--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$groupby.foo2#4 AS foo2 [STRUCT<a INT64, b INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.foo2#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.foo2#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$make_struct.$struct#3]
        |   +-expr_list=
        |   | +-$struct#3 :=
        |   |   +-MakeStruct
        |   |     +-type=STRUCT<a INT64, b INT64>
        |   |     +-field_list=
        |   |       +-ColumnRef(type=INT64, column=foo.a#1)
        |   |       +-ColumnRef(type=INT64, column=foo.b#2)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=foo.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=INT64, value=2)
        |       +-input_scan=
        |         +-SingleRowScan
        +-group_by_list=
          +-foo2#4 := ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3)
          +-a#5 :=
          | +-GetStructField
          |   +-type=INT64
          |   +-expr=
          |   | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3)
          |   +-field_idx=0
          +-b#6 :=
            +-GetStructField
              +-type=INT64
              +-expr=
              | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3)
              +-field_idx=1
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 3:10]
GROUP BY foo2, foo.a, foo.b;
         ^
==

[language_features={{V_1_2_GROUP_BY_STRUCT|}}]
select foo.a AS a1, foo.b AS foo_b
FROM (SELECT as struct 1 AS a, 2 AS b) AS foo
GROUP BY foo
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$query.a1#5 AS a1 [INT64]
| +-$query.foo_b#6 AS foo_b [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[a1#5, foo_b#6]
    +-expr_list=
    | +-a1#5 :=
    | | +-GetStructField
    | |   +-type=INT64
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$groupby.foo#4)
    | |   +-field_idx=0
    | +-foo_b#6 :=
    |   +-GetStructField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$groupby.foo#4)
    |     +-field_idx=1
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.foo#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$make_struct.$struct#3]
        |   +-expr_list=
        |   | +-$struct#3 :=
        |   |   +-MakeStruct
        |   |     +-type=STRUCT<a INT64, b INT64>
        |   |     +-field_list=
        |   |       +-ColumnRef(type=INT64, column=foo.a#1)
        |   |       +-ColumnRef(type=INT64, column=foo.b#2)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=foo.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=INT64, value=2)
        |       +-input_scan=
        |         +-SingleRowScan
        +-group_by_list=
          +-foo#4 := ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3)
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 3:10]
GROUP BY foo
         ^
==

[language_features={{V_1_2_GROUP_BY_STRUCT|}}]
select foo AS foo2, foo.a as foo_a, foo.b AS foo_b
FROM (SELECT as struct 1 AS a, 2 AS b) AS foo
GROUP BY foo2
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$groupby.foo2#4 AS foo2 [STRUCT<a INT64, b INT64>]
| +-$query.foo_a#5 AS foo_a [INT64]
| +-$query.foo_b#6 AS foo_b [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.foo2#4, $query.foo_a#5, $query.foo_b#6]
    +-expr_list=
    | +-foo_a#5 :=
    | | +-GetStructField
    | |   +-type=INT64
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$groupby.foo2#4)
    | |   +-field_idx=0
    | +-foo_b#6 :=
    |   +-GetStructField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$groupby.foo2#4)
    |     +-field_idx=1
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.foo2#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$make_struct.$struct#3]
        |   +-expr_list=
        |   | +-$struct#3 :=
        |   |   +-MakeStruct
        |   |     +-type=STRUCT<a INT64, b INT64>
        |   |     +-field_list=
        |   |       +-ColumnRef(type=INT64, column=foo.a#1)
        |   |       +-ColumnRef(type=INT64, column=foo.b#2)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=foo.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=INT64, value=2)
        |       +-input_scan=
        |         +-SingleRowScan
        +-group_by_list=
          +-foo2#4 := ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3)
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 3:10]
GROUP BY foo2
         ^
==

# GROUP BY path expression that is a mix of struct and proto.
select sq.a.nested_value.nested_int64
from (select as struct KitchenSink as a from TestTable) as sq
group by sq.a.nested_value.nested_int64
--
QueryStmt
+-output_column_list=
| +-$groupby.nested_int64#5 AS nested_int64 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.nested_int64#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.nested_int64#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$make_struct.$struct#4]
        |   +-expr_list=
        |   | +-$struct#4 :=
        |   |   +-MakeStruct
        |   |     +-type=STRUCT<a PROTO<zetasql_test__.KitchenSinkPB>>
        |   |     +-field_list=
        |   |       +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[TestTable.KitchenSink#3]
        |       +-input_scan=
        |         +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-group_by_list=
          +-nested_int64#5 :=
            +-GetProtoField
              +-type=INT64
              +-expr=
              | +-GetProtoField
              |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
              |   +-expr=
              |   | +-GetStructField
              |   |   +-type=PROTO<zetasql_test__.KitchenSinkPB>
              |   |   +-expr=
              |   |   | +-ColumnRef(type=STRUCT<a PROTO<zetasql_test__.KitchenSinkPB>>, column=$make_struct.$struct#4)
              |   |   +-field_idx=0
              |   +-field_descriptor=nested_value
              |   +-default_value=NULL
              +-field_descriptor=nested_int64
              +-default_value=88
==

# Invalid, the SELECT list path expression is a subset of the
# GROUP BY path expression.
select KitchenSink.nested_value
from TestTable
group by KitchenSink.nested_value.nested_int64
--
ERROR: SELECT list expression references KitchenSink.nested_value which is neither grouped nor aggregated [at 1:8]
select KitchenSink.nested_value
       ^
==

select KitchenSink.nested_value.nested_int64,
       KitchenSink.nested_value.nested_int64
from TestTable
group by KitchenSink.nested_value.nested_int64
--
QueryStmt
+-output_column_list=
| +-$groupby.nested_int64#4 AS nested_int64 [INT64]
| +-$groupby.nested_int64#4 AS nested_int64 [INT64]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[nested_int64#4, nested_int64#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.nested_int64#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-group_by_list=
          +-nested_int64#4 :=
            +-GetProtoField
              +-type=INT64
              +-expr=
              | +-GetProtoField
              |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
              |   +-expr=
              |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              |   +-field_descriptor=nested_value
              |   +-default_value=NULL
              +-field_descriptor=nested_int64
              +-default_value=88
==

# KitchenSink is both a SELECT list alias and a column in TestTable, but
# the GROUP BY reference resolves to the alias so it is not ambiguous.
# However, it is also not valid because grouping by path expressions
# starting from SELECT list aliases is not currently allowed.
select KitchenSink.nested_value.nested_int64,
       (select as struct
          (select as struct 1 as nested_int64, 2 as b) as nested_value,
          (select as struct 1 as c, 2 as d) as y) as KitchenSink
from TestTable
group by KitchenSink.nested_value.nested_int64
--
ERROR: Cannot GROUP BY field references from SELECT list alias KitchenSink [at 6:10]
group by KitchenSink.nested_value.nested_int64
         ^
==

select foo.a AS a1, foo.b AS a2
FROM (SELECT 1 AS a, 2 AS b) AS foo
GROUP BY foo.a, foo.b;
--
QueryStmt
+-output_column_list=
| +-$groupby.a#3 AS a1 [INT64]
| +-$groupby.b#4 AS a2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[a#3, b#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[a#3, b#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=foo.[a#1, b#2]
        |   +-expr_list=
        |   | +-a#1 := Literal(type=INT64, value=1)
        |   | +-b#2 := Literal(type=INT64, value=2)
        |   +-input_scan=
        |     +-SingleRowScan
        +-group_by_list=
          +-a#3 := ColumnRef(type=INT64, column=foo.a#1)
          +-b#4 := ColumnRef(type=INT64, column=foo.b#2)
==

# Test GROUP BY with star and dot-star.
select *
FROM KeyValue
GROUP BY 1, 2
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#3 AS Key [INT64]
| +-$groupby.Value#4 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[Key#3, Value#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[Key#3, Value#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-group_by_list=
          +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
          +-Value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2)
==

select *
FROM KeyValue
GROUP BY 2
--
ERROR: Star expansion expression references column Key which is neither grouped nor aggregated [at 1:8]
select *
       ^
==

select *
FROM KeyValue
GROUP BY 1, 2, 3
--
ERROR: GROUP BY is out of SELECT column number range: 3 [at 3:16]
GROUP BY 1, 2, 3
               ^
==

select *
FROM KeyValue
GROUP BY key, value
--
QueryStmt
+-output_column_list=
| +-$groupby.Key#3 AS Key [INT64]
| +-$groupby.Value#4 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[Key#3, Value#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[Key#3, Value#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-group_by_list=
          +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
          +-Value#4 := ColumnRef(type=STRING, column=KeyValue.Value#2)
==

select kv.*
from (select as struct key a, value b from keyvalue) kv
group by 1, 2
--
QueryStmt
+-output_column_list=
| +-$groupby.a#4 AS a [INT64]
| +-$groupby.b#5 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[a#4, b#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[a#4, b#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$make_struct.$struct#3]
        |   +-expr_list=
        |   | +-$struct#3 :=
        |   |   +-MakeStruct
        |   |     +-type=STRUCT<a INT64, b STRING>
        |   |     +-field_list=
        |   |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=KeyValue.[Key#1, Value#2]
        |       +-input_scan=
        |         +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-group_by_list=
          +-a#4 :=
          | +-GetStructField
          |   +-type=INT64
          |   +-expr=
          |   | +-ColumnRef(type=STRUCT<a INT64, b STRING>, column=$make_struct.$struct#3)
          |   +-field_idx=0
          +-b#5 :=
            +-GetStructField
              +-type=STRING
              +-expr=
              | +-ColumnRef(type=STRUCT<a INT64, b STRING>, column=$make_struct.$struct#3)
              +-field_idx=1
==

select kv.*
from (select as struct key a, value b from keyvalue) kv
group by 1
--
ERROR: Star expansion expression references column b which is neither grouped nor aggregated [at 1:8]
select kv.*
       ^
==

select kv.*
from (select as struct key a, value b from keyvalue) kv
group by 1, 2, 3
--
ERROR: GROUP BY is out of SELECT column number range: 3 [at 3:16]
group by 1, 2, 3
               ^
==

select kv.*
from (select as struct key a, value b from keyvalue) kv
group by a, b
--
QueryStmt
+-output_column_list=
| +-$groupby.a#4 AS a [INT64]
| +-$groupby.b#5 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[a#4, b#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[a#4, b#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$make_struct.$struct#3]
        |   +-expr_list=
        |   | +-$struct#3 :=
        |   |   +-MakeStruct
        |   |     +-type=STRUCT<a INT64, b STRING>
        |   |     +-field_list=
        |   |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=KeyValue.[Key#1, Value#2]
        |       +-input_scan=
        |         +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-group_by_list=
          +-a#4 :=
          | +-GetStructField
          |   +-type=INT64
          |   +-expr=
          |   | +-ColumnRef(type=STRUCT<a INT64, b STRING>, column=$make_struct.$struct#3)
          |   +-field_idx=0
          +-b#5 :=
            +-GetStructField
              +-type=STRING
              +-expr=
              | +-ColumnRef(type=STRUCT<a INT64, b STRING>, column=$make_struct.$struct#3)
              +-field_idx=1
==

# TODO: The unparser chokes when producing expressions that
# reference the anonymous columns that come out of the dot-star expression.
[no_run_unparser]
select any_value(structval).*
from (select (1, 1) as structval
      union all
      select (2, 2) as structval)
--
QueryStmt
+-output_column_list=
| +-$query.$field1#5 AS "$field1" [INT64]
| +-$query.$field2#6 AS "$field2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$field1#5, $field2#6]
    +-expr_list=
    | +-$field1#5 :=
    | | +-GetStructField
    | |   +-type=INT64
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<INT64, INT64>, column=$aggregate.$agg1#4)
    | |   +-field_idx=0
    | +-$field2#6 :=
    |   +-GetStructField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<INT64, INT64>, column=$aggregate.$agg1#4)
    |     +-field_idx=1
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-SetOperationScan
        |   +-column_list=[$union_all.structval#3]
        |   +-op_type=UNION_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=[$union_all1.structval#1]
        |     | |   +-expr_list=
        |     | |   | +-structval#1 := Literal(type=STRUCT<INT64, INT64>, value={1, 1})
        |     | |   +-input_scan=
        |     | |     +-SingleRowScan
        |     | +-output_column_list=[$union_all1.structval#1]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=[$union_all2.structval#2]
        |       |   +-expr_list=
        |       |   | +-structval#2 := Literal(type=STRUCT<INT64, INT64>, value={2, 2})
        |       |   +-input_scan=
        |       |     +-SingleRowScan
        |       +-output_column_list=[$union_all2.structval#2]
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:any_value(STRUCT<INT64, INT64>) -> STRUCT<INT64, INT64>)
              +-ColumnRef(type=STRUCT<INT64, INT64>, column=$union_all.structval#3)
==

select {{max|min|avg|count|sum}}() from KeyValue;
--
ALTERNATION GROUP: max
--
ERROR: Number of arguments does not match for aggregate function MAX. Supported signature: MAX(ANY) [at 1:8]
select max() from KeyValue;
       ^
--
ALTERNATION GROUP: min
--
ERROR: Number of arguments does not match for aggregate function MIN. Supported signature: MIN(ANY) [at 1:8]
select min() from KeyValue;
       ^
--
ALTERNATION GROUP: avg
--
ERROR: No matching signature for aggregate function AVG with no arguments. Supported signatures: AVG(INT64); AVG(UINT64); AVG(DOUBLE) [at 1:8]
select avg() from KeyValue;
       ^
--
ALTERNATION GROUP: count
--
ERROR: Number of arguments does not match for aggregate function COUNT. Supported signature: COUNT(ANY) [at 1:8]
select count() from KeyValue;
       ^
--
ALTERNATION GROUP: sum
--
ERROR: No matching signature for aggregate function SUM with no arguments. Supported signatures: SUM(INT64); SUM(UINT64); SUM(DOUBLE) [at 1:8]
select sum() from KeyValue;
       ^
==

[language_features={{DISALLOW_GROUP_BY_FLOAT|}}]
select count(distinct int64), count(distinct float) from SimpleTypes
--
ALTERNATION GROUP: DISALLOW_GROUP_BY_FLOAT
--
ERROR: Aggregate functions with DISTINCT cannot be used with arguments of type FLOAT [at 1:31]
select count(distinct int64), count(distinct float) from SimpleTypes
                              ^
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS "$col1" [INT64]
| +-$aggregate.$agg2#20 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#19, $agg2#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#19, $agg2#20]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, float#8], table=SimpleTypes, column_index_list=[1, 7])
        +-aggregate_list=
          +-$agg1#19 :=
          | +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
          |   +-distinct=TRUE
          +-$agg2#20 :=
            +-AggregateFunctionCall(ZetaSQL:count(FLOAT) -> INT64)
              +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
              +-distinct=TRUE
==

[language_features={{DISALLOW_GROUP_BY_FLOAT|}}]
select double, count(*) from SimpleTypes group by double
--
ALTERNATION GROUP: DISALLOW_GROUP_BY_FLOAT
--
ERROR: Grouping by expressions of type DOUBLE is not allowed [at 1:51]
select double, count(*) from SimpleTypes group by double
                                                  ^
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$groupby.double#20 AS double [DOUBLE]
| +-$aggregate.$agg1#19 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.double#20, $aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.double#20, $aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.double#9], table=SimpleTypes, column_index_list=[8])
        +-group_by_list=
        | +-double#20 := ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
        +-aggregate_list=
          +-$agg1#19 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

select count(*), count(CAST(NULL AS STRUCT<a INT32>)) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
| +-$aggregate.$agg2#4 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#3, $agg2#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#3, $agg2#4]
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-aggregate_list=
          +-$agg1#3 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
          +-$agg2#4 :=
            +-AggregateFunctionCall(ZetaSQL:count(STRUCT<a INT32>) -> INT64)
              +-Literal(type=STRUCT<a INT32>, value=NULL, has_explicit_type=TRUE)
==

SELECT DISTINCT MOD(int64, 10) int64_col,
       CAST(MAX(int64+1) AS UINT64) uint64_col
FROM SimpleTypes
GROUP BY {{1|int64_col}}
ORDER BY {{1|int64_col}}, {{2|uint64_col}}
--
QueryStmt
+-output_column_list=
| +-$distinct.int64_col#23 AS int64_col [INT64]
| +-$distinct.uint64_col#24 AS uint64_col [UINT64]
+-query=
  +-OrderByScan
    +-column_list=$distinct.[int64_col#23, uint64_col#24]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=$distinct.[int64_col#23, uint64_col#24]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$groupby.int64_col#21, $aggregate.$agg1#19, $query.uint64_col#22]
    |   |   +-expr_list=
    |   |   | +-uint64_col#22 :=
    |   |   |   +-Cast(INT64 -> UINT64)
    |   |   |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#19)
    |   |   +-input_scan=
    |   |     +-AggregateScan
    |   |       +-column_list=[$groupby.int64_col#21, $aggregate.$agg1#19]
    |   |       +-input_scan=
    |   |       | +-ProjectScan
    |   |       |   +-column_list=[SimpleTypes.int64#2, $pre_groupby.int64_col#20]
    |   |       |   +-expr_list=
    |   |       |   | +-int64_col#20 :=
    |   |       |   |   +-FunctionCall(ZetaSQL:mod(INT64, INT64) -> INT64)
    |   |       |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    |   |       |   |     +-Literal(type=INT64, value=10)
    |   |       |   +-input_scan=
    |   |       |     +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
    |   |       +-group_by_list=
    |   |       | +-int64_col#21 := ColumnRef(type=INT64, column=$pre_groupby.int64_col#20)
    |   |       +-aggregate_list=
    |   |         +-$agg1#19 :=
    |   |           +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |   |             +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |               +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    |   |               +-Literal(type=INT64, value=1)
    |   +-group_by_list=
    |     +-int64_col#23 := ColumnRef(type=INT64, column=$groupby.int64_col#21)
    |     +-uint64_col#24 := ColumnRef(type=UINT64, column=$query.uint64_col#22)
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      |   +-ColumnRef(type=INT64, column=$distinct.int64_col#23)
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=UINT64, column=$distinct.uint64_col#24)
==

# Aggregate of a correlated column reference.
select (select as struct c, any_value(b)
        from (select 3 as c)
        group by c)
from (select as struct 1 as a, 2 as b) foo
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS "$col1" [STRUCT<c INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8]
    +-expr_list=
    | +-$col1#8 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<c INT64, INT64>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#7]
    |         +-expr_list=
    |         | +-$struct#7 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<c INT64, INT64>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=$groupby.c#6)
    |         |       +-ColumnRef(type=INT64, column=$aggregate.$agg1#5)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$groupby.c#6, $aggregate.$agg1#5]
    |             +-input_scan=
    |               +-AggregateScan
    |                 +-column_list=[$groupby.c#6, $aggregate.$agg1#5]
    |                 +-input_scan=
    |                 | +-ProjectScan
    |                 |   +-column_list=[$subquery1.c#4]
    |                 |   +-expr_list=
    |                 |   | +-c#4 := Literal(type=INT64, value=3)
    |                 |   +-input_scan=
    |                 |     +-SingleRowScan
    |                 +-group_by_list=
    |                 | +-c#6 := ColumnRef(type=INT64, column=$subquery1.c#4)
    |                 +-aggregate_list=
    |                   +-$agg1#5 :=
    |                     +-AggregateFunctionCall(ZetaSQL:any_value(INT64) -> INT64)
    |                       +-GetStructField
    |                         +-type=INT64
    |                         +-expr=
    |                         | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3, is_correlated=TRUE)
    |                         +-field_idx=1
    +-input_scan=
      +-ProjectScan
        +-column_list=[$make_struct.$struct#3]
        +-expr_list=
        | +-$struct#3 :=
        |   +-MakeStruct
        |     +-type=STRUCT<a INT64, b INT64>
        |     +-field_list=
        |       +-ColumnRef(type=INT64, column=foo.a#1)
        |       +-ColumnRef(type=INT64, column=foo.b#2)
        +-input_scan=
          +-ProjectScan
            +-column_list=foo.[a#1, b#2]
            +-expr_list=
            | +-a#1 := Literal(type=INT64, value=1)
            | +-b#2 := Literal(type=INT64, value=2)
            +-input_scan=
              +-SingleRowScan
==

# GROUP BY a correlated column reference
select (select as struct c, a
        from (select 3 as c)
        group by {{2|a}}, c)
from (select as struct 1 as a, 2 as b) foo
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS "$col1" [STRUCT<c INT64, a INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8]
    +-expr_list=
    | +-$col1#8 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<c INT64, a INT64>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#7]
    |         +-expr_list=
    |         | +-$struct#7 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<c INT64, a INT64>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=$groupby.c#6)
    |         |       +-ColumnRef(type=INT64, column=$groupby.a#5)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=$groupby.[c#6, a#5]
    |             +-input_scan=
    |               +-AggregateScan
    |                 +-column_list=$groupby.[a#5, c#6]
    |                 +-input_scan=
    |                 | +-ProjectScan
    |                 |   +-column_list=[$subquery1.c#4]
    |                 |   +-expr_list=
    |                 |   | +-c#4 := Literal(type=INT64, value=3)
    |                 |   +-input_scan=
    |                 |     +-SingleRowScan
    |                 +-group_by_list=
    |                   +-a#5 :=
    |                   | +-GetStructField
    |                   |   +-type=INT64
    |                   |   +-expr=
    |                   |   | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3, is_correlated=TRUE)
    |                   |   +-field_idx=0
    |                   +-c#6 := ColumnRef(type=INT64, column=$subquery1.c#4)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$make_struct.$struct#3]
        +-expr_list=
        | +-$struct#3 :=
        |   +-MakeStruct
        |     +-type=STRUCT<a INT64, b INT64>
        |     +-field_list=
        |       +-ColumnRef(type=INT64, column=foo.a#1)
        |       +-ColumnRef(type=INT64, column=foo.b#2)
        +-input_scan=
          +-ProjectScan
            +-column_list=foo.[a#1, b#2]
            +-expr_list=
            | +-a#1 := Literal(type=INT64, value=1)
            | +-b#2 := Literal(type=INT64, value=2)
            +-input_scan=
              +-SingleRowScan
==

# TODO: In non-correlated queries, grouping by ordinal vs.
# alias vs. column reference all resolve the same way.  But for
# correlated column path expressions, if we GROUP BY foo.a and
# also have foo.a in the SELECT list then we do not currently detect
# equivalence and end up with GetStructField expressions twice in
# the subquery - once before grouping and once for the project for
# the SELECT list.  We should detect equivalence and have all of
# these behave the same way.
#
# GROUP BY a correlated column path expression reference
select (select as struct c, foo.a as foo_a
        from (select 3 as c)
        group by {{2|foo_a|foo.a}}, c)
from (select as struct 1 as a, 2 as b) foo
--
ALTERNATION GROUPS:
    2
    foo_a
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS "$col1" [STRUCT<c INT64, foo_a INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8]
    +-expr_list=
    | +-$col1#8 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<c INT64, foo_a INT64>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#7]
    |         +-expr_list=
    |         | +-$struct#7 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<c INT64, foo_a INT64>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=$groupby.c#6)
    |         |       +-ColumnRef(type=INT64, column=$groupby.foo_a#5)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=$groupby.[c#6, foo_a#5]
    |             +-input_scan=
    |               +-AggregateScan
    |                 +-column_list=$groupby.[foo_a#5, c#6]
    |                 +-input_scan=
    |                 | +-ProjectScan
    |                 |   +-column_list=[$subquery1.c#4]
    |                 |   +-expr_list=
    |                 |   | +-c#4 := Literal(type=INT64, value=3)
    |                 |   +-input_scan=
    |                 |     +-SingleRowScan
    |                 +-group_by_list=
    |                   +-foo_a#5 :=
    |                   | +-GetStructField
    |                   |   +-type=INT64
    |                   |   +-expr=
    |                   |   | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3, is_correlated=TRUE)
    |                   |   +-field_idx=0
    |                   +-c#6 := ColumnRef(type=INT64, column=$subquery1.c#4)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$make_struct.$struct#3]
        +-expr_list=
        | +-$struct#3 :=
        |   +-MakeStruct
        |     +-type=STRUCT<a INT64, b INT64>
        |     +-field_list=
        |       +-ColumnRef(type=INT64, column=foo.a#1)
        |       +-ColumnRef(type=INT64, column=foo.b#2)
        +-input_scan=
          +-ProjectScan
            +-column_list=foo.[a#1, b#2]
            +-expr_list=
            | +-a#1 := Literal(type=INT64, value=1)
            | +-b#2 := Literal(type=INT64, value=2)
            +-input_scan=
              +-SingleRowScan
--
ALTERNATION GROUP: foo.a
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS "$col1" [STRUCT<c INT64, foo_a INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<c INT64, foo_a INT64>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#8]
    |         +-expr_list=
    |         | +-$struct#8 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<c INT64, foo_a INT64>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=$groupby.c#6)
    |         |       +-ColumnRef(type=INT64, column=$expr_subquery.foo_a#7)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$groupby.c#6, $expr_subquery.foo_a#7]
    |             +-expr_list=
    |             | +-foo_a#7 :=
    |             |   +-GetStructField
    |             |     +-type=INT64
    |             |     +-expr=
    |             |     | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3, is_correlated=TRUE)
    |             |     +-field_idx=0
    |             +-input_scan=
    |               +-AggregateScan
    |                 +-column_list=[$groupby.c#6]
    |                 +-input_scan=
    |                 | +-ProjectScan
    |                 |   +-column_list=[$subquery1.c#4]
    |                 |   +-expr_list=
    |                 |   | +-c#4 := Literal(type=INT64, value=3)
    |                 |   +-input_scan=
    |                 |     +-SingleRowScan
    |                 +-group_by_list=
    |                   +-a#5 :=
    |                   | +-GetStructField
    |                   |   +-type=INT64
    |                   |   +-expr=
    |                   |   | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$make_struct.$struct#3, is_correlated=TRUE)
    |                   |   +-field_idx=0
    |                   +-c#6 := ColumnRef(type=INT64, column=$subquery1.c#4)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$make_struct.$struct#3]
        +-expr_list=
        | +-$struct#3 :=
        |   +-MakeStruct
        |     +-type=STRUCT<a INT64, b INT64>
        |     +-field_list=
        |       +-ColumnRef(type=INT64, column=foo.a#1)
        |       +-ColumnRef(type=INT64, column=foo.b#2)
        +-input_scan=
          +-ProjectScan
            +-column_list=foo.[a#1, b#2]
            +-expr_list=
            | +-a#1 := Literal(type=INT64, value=1)
            | +-b#2 := Literal(type=INT64, value=2)
            +-input_scan=
              +-SingleRowScan
==

# GROUP BY and DISTINCT with correlated column reference
select (select DISTINCT as struct c, a
        from (select 3 as c)
        group by {{2|a}}, c)
from (select 1 as a, 2 as b) foo
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS "$col1" [STRUCT<c INT64, a INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<c INT64, a INT64>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=foo.a#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#8]
    |         +-expr_list=
    |         | +-$struct#8 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<c INT64, a INT64>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=$distinct.c#6)
    |         |       +-ColumnRef(type=INT64, column=$distinct.a#7)
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=$distinct.[c#6, a#7]
    |             +-input_scan=
    |             | +-AggregateScan
    |             |   +-column_list=$groupby.[a#4, c#5]
    |             |   +-input_scan=
    |             |   | +-ProjectScan
    |             |   |   +-column_list=[$subquery1.c#3]
    |             |   |   +-expr_list=
    |             |   |   | +-c#3 := Literal(type=INT64, value=3)
    |             |   |   +-input_scan=
    |             |   |     +-SingleRowScan
    |             |   +-group_by_list=
    |             |     +-a#4 := ColumnRef(type=INT64, column=foo.a#1, is_correlated=TRUE)
    |             |     +-c#5 := ColumnRef(type=INT64, column=$subquery1.c#3)
    |             +-group_by_list=
    |               +-c#6 := ColumnRef(type=INT64, column=$groupby.c#5)
    |               +-a#7 := ColumnRef(type=INT64, column=$groupby.a#4)
    +-input_scan=
      +-ProjectScan
        +-column_list=foo.[a#1, b#2]
        +-expr_list=
        | +-a#1 := Literal(type=INT64, value=1)
        | +-b#2 := Literal(type=INT64, value=2)
        +-input_scan=
          +-SingleRowScan
==

# GROUP BY and DISTINCT and ORDER BY with correlated column reference
select (select DISTINCT as struct c, a
        from (select 3 as c)
        group by 2, c
        order by 1, {{2|a}})
from (select 1 as a, 2 as b) foo
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS "$col1" [STRUCT<c INT64, a INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=STRUCT<c INT64, a INT64>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=foo.a#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#8]
    |         +-expr_list=
    |         | +-$struct#8 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<c INT64, a INT64>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=$distinct.c#6)
    |         |       +-ColumnRef(type=INT64, column=$distinct.a#7)
    |         +-input_scan=
    |           +-OrderByScan
    |             +-column_list=$distinct.[c#6, a#7]
    |             +-is_ordered=TRUE
    |             +-input_scan=
    |             | +-AggregateScan
    |             |   +-column_list=$distinct.[c#6, a#7]
    |             |   +-input_scan=
    |             |   | +-AggregateScan
    |             |   |   +-column_list=$groupby.[a#4, c#5]
    |             |   |   +-input_scan=
    |             |   |   | +-ProjectScan
    |             |   |   |   +-column_list=[$subquery1.c#3]
    |             |   |   |   +-expr_list=
    |             |   |   |   | +-c#3 := Literal(type=INT64, value=3)
    |             |   |   |   +-input_scan=
    |             |   |   |     +-SingleRowScan
    |             |   |   +-group_by_list=
    |             |   |     +-a#4 := ColumnRef(type=INT64, column=foo.a#1, is_correlated=TRUE)
    |             |   |     +-c#5 := ColumnRef(type=INT64, column=$subquery1.c#3)
    |             |   +-group_by_list=
    |             |     +-c#6 := ColumnRef(type=INT64, column=$groupby.c#5)
    |             |     +-a#7 := ColumnRef(type=INT64, column=$groupby.a#4)
    |             +-order_by_item_list=
    |               +-OrderByItem
    |               | +-column_ref=
    |               |   +-ColumnRef(type=INT64, column=$distinct.c#6)
    |               +-OrderByItem
    |                 +-column_ref=
    |                   +-ColumnRef(type=INT64, column=$distinct.a#7)
    +-input_scan=
      +-ProjectScan
        +-column_list=foo.[a#1, b#2]
        +-expr_list=
        | +-a#1 := Literal(type=INT64, value=1)
        | +-b#2 := Literal(type=INT64, value=2)
        +-input_scan=
          +-SingleRowScan
==

# This was originally b/23384094 that produced a ResolvedAST internal error.
# We now detect the scenario in the resolver and produce a more reasonable
# error message.
SELECT t1.a,
       sum(t1.b),
       t2
FROM (select 1 as a, 2 as b) as t1,
     (select 3 as x, 4 as y) as t2
GROUP BY 1;
--
ERROR: SELECT list expression references table alias t2 which is neither grouped nor aggregated [at 3:8]
       t2
       ^
==

# Same query as the previous, but adding AS STRUCT in the t2 subquery.
# This effectively pushes the struct construction into the subquery.
SELECT t1.a,
       sum(t1.b),
       t2
FROM (select 1 as a, 2 as b) as t1,
     (select AS STRUCT 3 as x, 4 as y) as t2
GROUP BY 1;
--
ERROR: SELECT list expression references table alias t2 which is neither grouped nor aggregated [at 3:8]
       t2
       ^
==

# Additional test case from b/23384094 (with normal table).
SELECT KeyValue as kv
FROM KeyValue
GROUP BY {{KeyValue.|}}key
--
ERROR: SELECT list expression references table alias KeyValue which is neither grouped nor aggregated [at 1:8]
SELECT KeyValue as kv
       ^
==

# Similar to the previous test case, but we GROUP BY all the fields of
# the range variable.  This worked in a previous incarnation, but in
# general is not correct - if the range variable is for a proto value
# table then the range variable reference should carry through the
# full proto value unchanged, which is not equivalent to grouping
# by the fields and re-constituting the proto from them.  So this is
# now an error.
SELECT KeyValue as kv
FROM KeyValue
GROUP BY {{KeyValue.|}}key, {{KeyValue.|}}value
--
ERROR: SELECT list expression references table alias KeyValue which is neither grouped nor aggregated [at 1:8]
SELECT KeyValue as kv
       ^
==

# Additional test case from b/23384094 (with value table).
SELECT TestStructValueTable as col1
FROM TestStructValueTable
GROUP BY {{TestStructValueTable.|}}b
--
ERROR: SELECT list expression references table alias TestStructValueTable which is neither grouped nor aggregated [at 1:8]
SELECT TestStructValueTable as col1
       ^
==

# Statistical aggregation functions
select
  corr(double, float), covar_pop(float, double), covar_samp(double, float),
  stddev_pop(double), stddev_samp(float), stddev(double),
  var_pop(float), var_samp(double), variance(float)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#20 AS "$col2" [DOUBLE]
| +-$aggregate.$agg3#21 AS "$col3" [DOUBLE]
| +-$aggregate.$agg4#22 AS "$col4" [DOUBLE]
| +-$aggregate.$agg5#23 AS "$col5" [DOUBLE]
| +-$aggregate.$agg6#24 AS "$col6" [DOUBLE]
| +-$aggregate.$agg7#25 AS "$col7" [DOUBLE]
| +-$aggregate.$agg8#26 AS "$col8" [DOUBLE]
| +-$aggregate.$agg9#27 AS "$col9" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#19, $agg2#20, $agg3#21, $agg4#22, $agg5#23, $agg6#24, $agg7#25, $agg8#26, $agg9#27]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#19, $agg2#20, $agg3#21, $agg4#22, $agg5#23, $agg6#24, $agg7#25, $agg8#26, $agg9#27]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[float#8, double#9], table=SimpleTypes, column_index_list=[7, 8])
        +-aggregate_list=
          +-$agg1#19 :=
          | +-AggregateFunctionCall(ZetaSQL:corr(DOUBLE, DOUBLE) -> DOUBLE)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
          |   +-Cast(FLOAT -> DOUBLE)
          |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
          +-$agg2#20 :=
          | +-AggregateFunctionCall(ZetaSQL:covar_pop(DOUBLE, DOUBLE) -> DOUBLE)
          |   +-Cast(FLOAT -> DOUBLE)
          |   | +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
          +-$agg3#21 :=
          | +-AggregateFunctionCall(ZetaSQL:covar_samp(DOUBLE, DOUBLE) -> DOUBLE)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
          |   +-Cast(FLOAT -> DOUBLE)
          |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
          +-$agg4#22 :=
          | +-AggregateFunctionCall(ZetaSQL:stddev_pop(DOUBLE) -> DOUBLE)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
          +-$agg5#23 :=
          | +-AggregateFunctionCall(ZetaSQL:stddev_samp(DOUBLE) -> DOUBLE)
          |   +-Cast(FLOAT -> DOUBLE)
          |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
          +-$agg6#24 :=
          | +-AggregateFunctionCall(ZetaSQL:stddev_samp(DOUBLE) -> DOUBLE)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
          +-$agg7#25 :=
          | +-AggregateFunctionCall(ZetaSQL:var_pop(DOUBLE) -> DOUBLE)
          |   +-Cast(FLOAT -> DOUBLE)
          |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
          +-$agg8#26 :=
          | +-AggregateFunctionCall(ZetaSQL:var_samp(DOUBLE) -> DOUBLE)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
          +-$agg9#27 :=
            +-AggregateFunctionCall(ZetaSQL:var_samp(DOUBLE) -> DOUBLE)
              +-Cast(FLOAT -> DOUBLE)
                +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)

==

# Statistical aggregation functions numeric type signature
# Binary functions
[language_features=NUMERIC_TYPE]
select
  corr(numeric, numeric), covar_pop(numeric, numeric), covar_samp(numeric, numeric)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#20 AS "$col2" [DOUBLE]
| +-$aggregate.$agg3#21 AS "$col3" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#19, $agg2#20, $agg3#21]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#19, $agg2#20, $agg3#21]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.numeric#16], table=SimpleTypes, column_index_list=[15])
        +-aggregate_list=
          +-$agg1#19 :=
          | +-AggregateFunctionCall(ZetaSQL:corr(NUMERIC, NUMERIC) -> DOUBLE)
          |   +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
          |   +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
          +-$agg2#20 :=
          | +-AggregateFunctionCall(ZetaSQL:covar_pop(NUMERIC, NUMERIC) -> DOUBLE)
          |   +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
          |   +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
          +-$agg3#21 :=
            +-AggregateFunctionCall(ZetaSQL:covar_samp(NUMERIC, NUMERIC) -> DOUBLE)
              +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
              +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
==

# Statistical aggregation functions numeric type signature
# Unary functions
[language_features=NUMERIC_TYPE]
select
  stddev_pop(numeric), stddev_samp(numeric), stddev(numeric),
  var_pop(numeric), var_samp(numeric), variance(numeric)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#20 AS "$col2" [DOUBLE]
| +-$aggregate.$agg3#21 AS "$col3" [DOUBLE]
| +-$aggregate.$agg4#22 AS "$col4" [DOUBLE]
| +-$aggregate.$agg5#23 AS "$col5" [DOUBLE]
| +-$aggregate.$agg6#24 AS "$col6" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#19, $agg2#20, $agg3#21, $agg4#22, $agg5#23, $agg6#24]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#19, $agg2#20, $agg3#21, $agg4#22, $agg5#23, $agg6#24]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.numeric#16], table=SimpleTypes, column_index_list=[15])
        +-aggregate_list=
          +-$agg1#19 :=
          | +-AggregateFunctionCall(ZetaSQL:stddev_pop(NUMERIC) -> DOUBLE)
          |   +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
          +-$agg2#20 :=
          | +-AggregateFunctionCall(ZetaSQL:stddev_samp(NUMERIC) -> DOUBLE)
          |   +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
          +-$agg3#21 :=
          | +-AggregateFunctionCall(ZetaSQL:stddev_samp(NUMERIC) -> DOUBLE)
          |   +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
          +-$agg4#22 :=
          | +-AggregateFunctionCall(ZetaSQL:var_pop(NUMERIC) -> DOUBLE)
          |   +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
          +-$agg5#23 :=
          | +-AggregateFunctionCall(ZetaSQL:var_samp(NUMERIC) -> DOUBLE)
          |   +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
          +-$agg6#24 :=
            +-AggregateFunctionCall(ZetaSQL:var_samp(NUMERIC) -> DOUBLE)
              +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
==

select corr(distinct double, double)
from SimpleTypes
--
ERROR: DISTINCT is not allowed for function CORR [at 1:8]
select corr(distinct double, double)
       ^
==

select covar_pop(distinct double, float)
from SimpleTypes
--
ERROR: DISTINCT is not allowed for function COVAR_POP [at 1:8]
select covar_pop(distinct double, float)
       ^
==

select covar_samp(distinct float, double)
from SimpleTypes
--
ERROR: DISTINCT is not allowed for function COVAR_SAMP [at 1:8]
select covar_samp(distinct float, double)
       ^

==

select sort_count(distinct) as c from TestTable;
--
ERROR: DISTINCT function call with no arguments is not allowed [at 1:8]
select sort_count(distinct) as c from TestTable;
       ^
==

# array_concat_agg queries

select array_concat_agg(x)
from (select [1, 2] x union all select [] x) foo;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-SetOperationScan
        |   +-column_list=[$union_all.x#3]
        |   +-op_type=UNION_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=[$union_all1.x#1]
        |     | |   +-expr_list=
        |     | |   | +-x#1 := Literal(type=ARRAY<INT64>, value=[1, 2])
        |     | |   +-input_scan=
        |     | |     +-SingleRowScan
        |     | +-output_column_list=[$union_all1.x#1]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=[$union_all2.x#2]
        |       |   +-expr_list=
        |       |   | +-x#2 := Literal(type=ARRAY<INT64>, value=[])
        |       |   +-input_scan=
        |       |     +-SingleRowScan
        |       +-output_column_list=[$union_all2.x#2]
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:array_concat_agg(ARRAY<INT64>) -> ARRAY<INT64>)
              +-ColumnRef(type=ARRAY<INT64>, column=$union_all.x#3)

==

select array_concat_agg(x)
from (select ['a', "b"] x union all select [] x) foo;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS "$col1" [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-SetOperationScan
        |   +-column_list=[$union_all.x#3]
        |   +-op_type=UNION_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=[$union_all1.x#1]
        |     | |   +-expr_list=
        |     | |   | +-x#1 := Literal(type=ARRAY<STRING>, value=['a', "b"])
        |     | |   +-input_scan=
        |     | |     +-SingleRowScan
        |     | +-output_column_list=[$union_all1.x#1]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=[$union_all2_cast.x#4]
        |       |   +-expr_list=
        |       |   | +-x#4 := Literal(type=ARRAY<STRING>, value=[])
        |       |   +-input_scan=
        |       |     +-ProjectScan
        |       |       +-column_list=[$union_all2.x#2]
        |       |       +-expr_list=
        |       |       | +-x#2 := Literal(type=ARRAY<INT64>, value=[])
        |       |       +-input_scan=
        |       |         +-SingleRowScan
        |       +-output_column_list=[$union_all2_cast.x#4]
        +-aggregate_list=
          +-$agg1#5 :=
            +-AggregateFunctionCall(ZetaSQL:array_concat_agg(ARRAY<STRING>) -> ARRAY<STRING>)
              +-ColumnRef(type=ARRAY<STRING>, column=$union_all.x#3)
==

select w, array_concat_agg(x)
from (select 1 as w, [1, null] as x union all select 2 as w, [null, 2] as x
      union all select 1 as w, [3] as x) foo
group by w;
--
QueryStmt
+-output_column_list=
| +-$groupby.w#10 AS w [INT64]
| +-$aggregate.$agg1#9 AS "$col2" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.w#10, $aggregate.$agg1#9]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.w#10, $aggregate.$agg1#9]
        +-input_scan=
        | +-SetOperationScan
        |   +-column_list=$union_all.[w#7, x#8]
        |   +-op_type=UNION_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=$union_all1.[w#1, x#2]
        |     | |   +-expr_list=
        |     | |   | +-w#1 := Literal(type=INT64, value=1)
        |     | |   | +-x#2 := Literal(type=ARRAY<INT64>, value=[1, NULL])
        |     | |   +-input_scan=
        |     | |     +-SingleRowScan
        |     | +-output_column_list=$union_all1.[w#1, x#2]
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=$union_all2.[w#3, x#4]
        |     | |   +-expr_list=
        |     | |   | +-w#3 := Literal(type=INT64, value=2)
        |     | |   | +-x#4 := Literal(type=ARRAY<INT64>, value=[NULL, 2])
        |     | |   +-input_scan=
        |     | |     +-SingleRowScan
        |     | +-output_column_list=$union_all2.[w#3, x#4]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=$union_all3.[w#5, x#6]
        |       |   +-expr_list=
        |       |   | +-w#5 := Literal(type=INT64, value=1)
        |       |   | +-x#6 := Literal(type=ARRAY<INT64>, value=[3])
        |       |   +-input_scan=
        |       |     +-SingleRowScan
        |       +-output_column_list=$union_all3.[w#5, x#6]
        +-group_by_list=
        | +-w#10 := ColumnRef(type=INT64, column=$union_all.w#7)
        +-aggregate_list=
          +-$agg1#9 :=
            +-AggregateFunctionCall(ZetaSQL:array_concat_agg(ARRAY<INT64>) -> ARRAY<INT64>)
              +-ColumnRef(type=ARRAY<INT64>, column=$union_all.x#8)
==

select array_concat_agg(distinct x)
from (select [1, 2] x union all select [] x) foo;
--
ERROR: Aggregate functions with DISTINCT cannot be used with arguments of type ARRAY [at 1:8]
select array_concat_agg(distinct x)
       ^
==

select array_concat_agg(x)
from (select 'a' as x union all select 'b' as x) foo;
--
ERROR: The argument to ARRAY_CONCAT (or ARRAY_CONCAT_AGG) must be an array type but was STRING [at 1:8]
select array_concat_agg(x)
       ^
==

select KitchenSink.int32_val as foo,
       countif(KitchenSink.int32_val > 0) as cntif,
       count(KitchenSink.int32_val) as cnt
from TestTable
group by 1
--
QueryStmt
+-output_column_list=
| +-$groupby.foo#6 AS foo [INT32]
| +-$aggregate.cntif#4 AS cntif [INT64]
| +-$aggregate.cnt#5 AS cnt [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.foo#6, $aggregate.cntif#4, $aggregate.cnt#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.foo#6, $aggregate.cntif#4, $aggregate.cnt#5]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-group_by_list=
        | +-foo#6 :=
        |   +-GetProtoField
        |     +-type=INT32
        |     +-expr=
        |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |     +-field_descriptor=int32_val
        |     +-default_value=77
        +-aggregate_list=
          +-cntif#4 :=
          | +-AggregateFunctionCall(ZetaSQL:countif(BOOL) -> INT64)
          |   +-FunctionCall(ZetaSQL:$greater(INT32, INT32) -> BOOL)
          |     +-GetProtoField
          |     | +-type=INT32
          |     | +-expr=
          |     | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
          |     | +-field_descriptor=int32_val
          |     | +-default_value=77
          |     +-Literal(type=INT32, value=0)
          +-cnt#5 :=
            +-AggregateFunctionCall(ZetaSQL:count(INT32) -> INT64)
              +-GetProtoField
                +-type=INT32
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=int32_val
                +-default_value=77
==

select countif(KitchenSink.string_val) as cntif
from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.cntif#4 AS cntif [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.cntif#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.cntif#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-aggregate_list=
          +-cntif#4 :=
            +-AggregateFunctionCall(ZetaSQL:countif(BOOL) -> INT64)
              +-Cast(STRING -> BOOL)
                +-GetProtoField
                  +-type=STRING
                  +-expr=
                  | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                  +-field_descriptor=string_val
                  +-default_value='default_name'
==

[language_features={{V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE|}}]
select array_agg(Key ignore nulls) from KeyValue
--
ALTERNATION GROUP: V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-null_handling_modifier=IGNORE_NULLS
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in aggregate functions are not supported [at 1:8]
select array_agg(Key ignore nulls) from KeyValue
       ^
==

[language_features={{V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE|}}]
select array_agg(Key respect nulls) from KeyValue
--
ALTERNATION GROUP: V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-null_handling_modifier=RESPECT_NULLS
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in aggregate functions are not supported [at 1:8]
select array_agg(Key respect nulls) from KeyValue
       ^
==

[language_features={{V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE|}}]
select array_agg(Key) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
==

[language_features={{V_1_1_LIMIT_IN_AGGREGATE|}}]
select array_agg(Key limit 10)
from TestTable
--
ALTERNATION GROUP: V_1_1_LIMIT_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-limit=
                +-Literal(type=INT64, value=10)
--
ALTERNATION GROUP: <empty>
--
ERROR: LIMIT in aggregate function arguments is not supported [at 1:22]
select array_agg(Key limit 10)
                     ^
==

[language_features={{V_1_1_LIMIT_IN_AGGREGATE|}}]
select array_agg(distinct Key limit 10)
from TestTable
--
ALTERNATION GROUP: V_1_1_LIMIT_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-distinct=TRUE
              +-limit=
                +-Literal(type=INT64, value=10)
--
ALTERNATION GROUP: <empty>
--
ERROR: LIMIT in aggregate function arguments is not supported [at 1:31]
select array_agg(distinct Key limit 10)
                              ^
==

[language_features={{V_1_1_LIMIT_IN_AGGREGATE|}}]
select array_agg(Key limit 10 offset 5)
from TestTable
--
ALTERNATION GROUP: V_1_1_LIMIT_IN_AGGREGATE
--
ERROR: Aggregate function ARRAY_AGG does not support OFFSET in arguments [at 1:38]
select array_agg(Key limit 10 offset 5)
                                     ^
--
ALTERNATION GROUP: <empty>
--
ERROR: LIMIT in aggregate function arguments is not supported [at 1:22]
select array_agg(Key limit 10 offset 5)
                     ^
==

[language_features={{V_1_1_LIMIT_IN_AGGREGATE|}}]
select count(Key limit 10)
from TestTable
--
ALTERNATION GROUP: V_1_1_LIMIT_IN_AGGREGATE
--
ERROR: Aggregate function COUNT does not support LIMIT in arguments [at 1:18]
select count(Key limit 10)
                 ^
--
ALTERNATION GROUP: <empty>
--
ERROR: LIMIT in aggregate function arguments is not supported [at 1:18]
select count(Key limit 10)
                 ^
==

[language_features={{V_1_1_LIMIT_IN_AGGREGATE|}}]
select sqrt(KitchenSink.int64_val limit 10) from TestTable;
--
ERROR: LIMIT in arguments is not supported on scalar functions [at 1:35]
select sqrt(KitchenSink.int64_val limit 10) from TestTable;
                                  ^
==

[language_features={{V_1_1_LIMIT_IN_AGGREGATE|}}]
select array_agg(Key limit @test_param_int32)
from TestTable
--
ALTERNATION GROUP: V_1_1_LIMIT_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-limit=
                +-Cast(INT32 -> INT64)
                  +-Parameter(type=INT32, name="test_param_int32")
--
ALTERNATION GROUP: <empty>
--
ERROR: LIMIT in aggregate function arguments is not supported [at 1:22]
select array_agg(Key limit @test_param_int32)
                     ^
==

[language_features={{V_1_1_LIMIT_IN_AGGREGATE|}}]
select array_agg(Key limit KitchenSink.int32_val)
from TestTable
--
ERROR: Syntax error: Unexpected identifier "KitchenSink" [at 1:28]
select array_agg(Key limit KitchenSink.int32_val)
                           ^
==

[language_features={{V_1_1_LIMIT_IN_AGGREGATE|}}]
select array_agg(Key limit 1 + 2)
from TestTable
--
ERROR: Syntax error: Expected ")" but got "+" [at 1:30]
select array_agg(Key limit 1 + 2)
                             ^
==

[language_features={{V_1_1_HAVING_IN_AGGREGATE|}}]
select max(key having max value)
from KeyValue
--
ALTERNATION GROUP: V_1_1_HAVING_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-having_modifier=
                +-AggregateHavingModifier
                  +-kind=MAX
                  +-having_expr=
                    +-ColumnRef(type=STRING, column=KeyValue.Value#2)
--
ALTERNATION GROUP: <empty>
--
ERROR: HAVING modifier in aggregate function is not supported [at 1:16]
select max(key having max value)
               ^
==

[language_features={{V_1_1_HAVING_IN_AGGREGATE|}}]
select max(key having min value)
from KeyValue
--
ALTERNATION GROUP: V_1_1_HAVING_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-having_modifier=
                +-AggregateHavingModifier
                  +-kind=MIN
                  +-having_expr=
                    +-ColumnRef(type=STRING, column=KeyValue.Value#2)
--
ALTERNATION GROUP: <empty>
--
ERROR: HAVING modifier in aggregate function is not supported [at 1:16]
select max(key having min value)
               ^
==

[language_features={{V_1_1_HAVING_IN_AGGREGATE|}}]
select count(key having max 1)
from KeyValue
--
ALTERNATION GROUP: V_1_1_HAVING_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-having_modifier=
                +-AggregateHavingModifier
                  +-kind=MAX
                  +-having_expr=
                    +-Literal(type=INT64, value=1)
--
ALTERNATION GROUP: <empty>
--
ERROR: HAVING modifier in aggregate function is not supported [at 1:18]
select count(key having max 1)
                 ^
==

[language_features=V_1_1_HAVING_IN_AGGREGATE]
select count(distinct key having max 1)
from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-distinct=TRUE
              +-having_modifier=
                +-AggregateHavingModifier
                  +-kind=MAX
                  +-having_expr=
                    +-Literal(type=INT64, value=1)
==

[language_features={{V_1_1_HAVING_IN_AGGREGATE|}}]
select max(1 having max value)
from KeyValue
--
ALTERNATION GROUP: V_1_1_HAVING_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
              +-Literal(type=INT64, value=1)
              +-having_modifier=
                +-AggregateHavingModifier
                  +-kind=MAX
                  +-having_expr=
                    +-ColumnRef(type=STRING, column=KeyValue.Value#2)
--
ALTERNATION GROUP: <empty>
--
ERROR: HAVING modifier in aggregate function is not supported [at 1:14]
select max(1 having max value)
             ^
==

[language_features=V_1_1_HAVING_IN_AGGREGATE,V_1_1_LIMIT_IN_AGGREGATE,V_1_1_ORDER_BY_IN_AGGREGATE]
select array_agg(key having max value order by key limit 1)
from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-having_modifier=
              | +-AggregateHavingModifier
              |   +-kind=MAX
              |   +-having_expr=
              |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              +-order_by_item_list=
              | +-OrderByItem
              |   +-column_ref=
              |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-limit=
                +-Literal(type=INT64, value=1)
==

[language_features=V_1_1_HAVING_IN_AGGREGATE]
select array_agg(key having max count(value))
from KeyValue
--
ERROR: Aggregations of aggregations are not allowed [at 1:8]
select array_agg(key having max count(value))
       ^
==

[language_features=V_1_1_HAVING_IN_AGGREGATE,ANALYTIC_FUNCTIONS]
select array_agg(key having max rank() over (partition by value order by value))
from KeyValue
--
ERROR: Analytic functions cannot be arguments to aggregate functions [at 1:8]
select array_agg(key having max rank() over (partition by value order by value))
       ^
==

[language_features=V_1_1_HAVING_IN_AGGREGATE]
select array_agg(key having max (value, 'nonorderable'))
from KeyValue
--
ERROR: HAVING modifier does not support expressions of type STRUCT<STRING, STRING> [at 1:22]
select array_agg(key having max (value, 'nonorderable'))
                     ^
==

[language_features=V_1_1_HAVING_IN_AGGREGATE]
select count(* having max value)
from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
              +-having_modifier=
                +-AggregateHavingModifier
                  +-kind=MAX
                  +-having_expr=
                    +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

[language_features=V_1_1_HAVING_IN_AGGREGATE]
select sort_count(having max value)
from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(sample_functions:sort_count() -> INT64)
              +-having_modifier=
                +-AggregateHavingModifier
                  +-kind=MAX
                  +-having_expr=
                    +-ColumnRef(type=STRING, column=KeyValue.Value#2)
==

[language_features=V_1_1_HAVING_IN_AGGREGATE]
select sqrt(2 having max value)
from KeyValue
--
ERROR: HAVING MAX and HAVING MIN are not supported on scalar functions [at 1:15]
select sqrt(2 having max value)
              ^
==

[language_features={{DISALLOW_GROUP_BY_FLOAT,V_1_1_HAVING_IN_AGGREGATE|V_1_1_HAVING_IN_AGGREGATE}}]
select count(1 having max 0.1)
from KeyValue
--
ALTERNATION GROUP: DISALLOW_GROUP_BY_FLOAT,V_1_1_HAVING_IN_AGGREGATE
--
ERROR: HAVING modifier does not support expressions of type DOUBLE [at 1:16]
select count(1 having max 0.1)
               ^
--
ALTERNATION GROUP: V_1_1_HAVING_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
              +-Literal(type=INT64, value=1)
              +-having_modifier=
                +-AggregateHavingModifier
                  +-kind=MAX
                  +-having_expr=
                    +-Literal(type=DOUBLE, value=0.1)
==

select sqrt(1 {{ignore|respect}} nulls) from KeyValue
--
ALTERNATION GROUP: ignore
--
ERROR: IGNORE NULLS and RESPECT NULLS are not supported on scalar functions [at 1:8]
select sqrt(1 ignore nulls) from KeyValue
       ^
--
ALTERNATION GROUP: respect
--
ERROR: IGNORE NULLS and RESPECT NULLS are not supported on scalar functions [at 1:8]
select sqrt(1 respect nulls) from KeyValue
       ^
==

[language_features={{|V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE}}]
select sum(1 {{ignore|respect}} nulls) from KeyValue
--
ALTERNATION GROUP: ignore
--
ERROR: IGNORE NULLS and RESPECT NULLS in aggregate functions are not supported [at 1:8]
select sum(1 ignore nulls) from KeyValue
       ^
--
ALTERNATION GROUP: respect
--
ERROR: IGNORE NULLS and RESPECT NULLS in aggregate functions are not supported [at 1:8]
select sum(1 respect nulls) from KeyValue
       ^
--
ALTERNATION GROUP: V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE,ignore
--
ERROR: IGNORE NULLS and RESPECT NULLS are not allowed for aggregate function sum [at 1:8]
select sum(1 ignore nulls) from KeyValue
       ^
--
ALTERNATION GROUP: V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE,respect
--
ERROR: IGNORE NULLS and RESPECT NULLS are not allowed for aggregate function sum [at 1:8]
select sum(1 respect nulls) from KeyValue
       ^
==

[language_features={{|V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE}}]
select afn_null_handling(1 {{ignore|respect}} nulls) from KeyValue
--
ALTERNATION GROUP: ignore
--
ERROR: IGNORE NULLS and RESPECT NULLS in aggregate functions are not supported [at 1:8]
select afn_null_handling(1 ignore nulls) from KeyValue
       ^
--
ALTERNATION GROUP: respect
--
ERROR: IGNORE NULLS and RESPECT NULLS in aggregate functions are not supported [at 1:8]
select afn_null_handling(1 respect nulls) from KeyValue
       ^
--
ALTERNATION GROUP: V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE,ignore
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(sample_functions:afn_null_handling(INT64) -> INT64)
              +-Literal(type=INT64, value=1)
              +-null_handling_modifier=IGNORE_NULLS
--
ALTERNATION GROUP: V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE,respect
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(sample_functions:afn_null_handling(INT64) -> INT64)
              +-Literal(type=INT64, value=1)
              +-null_handling_modifier=RESPECT_NULLS
==

[language_features=V_1_1_ORDER_BY_IN_AGGREGATE,V_1_1_LIMIT_IN_AGGREGATE,V_1_1_HAVING_IN_AGGREGATE,V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE]
select afn_null_handling(distinct key {{ignore|respect}} nulls
                         having {{max|min}} value order by key limit 2)
from KeyValue
--
ALTERNATION GROUP: ignore,max
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(sample_functions:afn_null_handling(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-distinct=TRUE
              +-null_handling_modifier=IGNORE_NULLS
              +-having_modifier=
              | +-AggregateHavingModifier
              |   +-kind=MAX
              |   +-having_expr=
              |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              +-order_by_item_list=
              | +-OrderByItem
              |   +-column_ref=
              |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-limit=
                +-Literal(type=INT64, value=2)
--
ALTERNATION GROUP: ignore,min
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(sample_functions:afn_null_handling(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-distinct=TRUE
              +-null_handling_modifier=IGNORE_NULLS
              +-having_modifier=
              | +-AggregateHavingModifier
              |   +-kind=MIN
              |   +-having_expr=
              |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              +-order_by_item_list=
              | +-OrderByItem
              |   +-column_ref=
              |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-limit=
                +-Literal(type=INT64, value=2)
--
ALTERNATION GROUP: respect,max
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(sample_functions:afn_null_handling(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-distinct=TRUE
              +-null_handling_modifier=RESPECT_NULLS
              +-having_modifier=
              | +-AggregateHavingModifier
              |   +-kind=MAX
              |   +-having_expr=
              |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              +-order_by_item_list=
              | +-OrderByItem
              |   +-column_ref=
              |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-limit=
                +-Literal(type=INT64, value=2)
--
ALTERNATION GROUP: respect,min
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(sample_functions:afn_null_handling(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-distinct=TRUE
              +-null_handling_modifier=RESPECT_NULLS
              +-having_modifier=
              | +-AggregateHavingModifier
              |   +-kind=MIN
              |   +-having_expr=
              |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              +-order_by_item_list=
              | +-OrderByItem
              |   +-column_ref=
              |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-limit=
                +-Literal(type=INT64, value=2)

==

[language_features={{V_1_2_GROUP_BY_STRUCT|V_1_2_GROUP_BY_STRUCT,DISALLOW_GROUP_BY_FLOAT|}}]
SELECT t
FROM (SELECT AS STRUCT 1 a, 1.2121 b) t
GROUP BY t
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$groupby.t#4 AS t [STRUCT<a INT64, b DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.t#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.t#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$make_struct.$struct#3]
        |   +-expr_list=
        |   | +-$struct#3 :=
        |   |   +-MakeStruct
        |   |     +-type=STRUCT<a INT64, b DOUBLE>
        |   |     +-field_list=
        |   |       +-ColumnRef(type=INT64, column=t.a#1)
        |   |       +-ColumnRef(type=DOUBLE, column=t.b#2)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=t.[a#1, b#2]
        |       +-expr_list=
        |       | +-a#1 := Literal(type=INT64, value=1)
        |       | +-b#2 := Literal(type=DOUBLE, value=1.2121)
        |       +-input_scan=
        |         +-SingleRowScan
        +-group_by_list=
          +-t#4 := ColumnRef(type=STRUCT<a INT64, b DOUBLE>, column=$make_struct.$struct#3)
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT,DISALLOW_GROUP_BY_FLOAT
--
ERROR: Grouping by expressions of type STRUCT containing DOUBLE is not allowed [at 3:10]
GROUP BY t
         ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 3:10]
GROUP BY t
         ^
==

[language_features={{V_1_2_GROUP_BY_STRUCT|}}]
SELECT t
FROM (SELECT AS STRUCT 1 a, [1] b) t
GROUP BY t

--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
ERROR: Grouping by expressions of type STRUCT containing ARRAY is not allowed [at 3:10]
GROUP BY t
         ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 3:10]
GROUP BY t
         ^
==

[language_features={{V_1_2_GROUP_BY_STRUCT|}}]
select as struct (Key, KitchenSink) from TestTable group by 1
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
ERROR: Grouping by expressions of type STRUCT containing PROTO is not allowed [at 1:61]
select as struct (Key, KitchenSink) from TestTable group by 1
                                                            ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Grouping by expressions of type STRUCT is not allowed [at 1:61]
select as struct (Key, KitchenSink) from TestTable group by 1
                                                            ^
==

# Error - struct contains a floating point which with DISALLOW_GROUP_BY_FLOAT
# flag, does not support GROUP BY.
[language_features={{V_1_2_GROUP_BY_STRUCT|V_1_2_GROUP_BY_STRUCT,DISALLOW_GROUP_BY_FLOAT}}]
SELECT {{T.|}}a.b.c.d.e
FROM (SELECT STRUCT (STRUCT (STRUCT (STRUCT (1.0 as e) as d) as c) as b) as a) T
GROUP BY T.a;
--
ALTERNATION GROUPS:
    V_1_2_GROUP_BY_STRUCT,T.
    V_1_2_GROUP_BY_STRUCT,
--
QueryStmt
+-output_column_list=
| +-$query.e#3 AS e [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.e#3]
    +-expr_list=
    | +-e#3 :=
    |   +-GetStructField
    |     +-type=DOUBLE
    |     +-expr=
    |     | +-GetStructField
    |     |   +-type=STRUCT<e DOUBLE>
    |     |   +-expr=
    |     |   | +-GetStructField
    |     |   |   +-type=STRUCT<d STRUCT<e DOUBLE>>
    |     |   |   +-expr=
    |     |   |   | +-GetStructField
    |     |   |   |   +-type=STRUCT<c STRUCT<d STRUCT<e DOUBLE>>>
    |     |   |   |   +-expr=
    |     |   |   |   | +-ColumnRef(type=STRUCT<b STRUCT<c STRUCT<d STRUCT<e DOUBLE>>>>, column=$groupby.a#2)
    |     |   |   |   +-field_idx=0
    |     |   |   +-field_idx=0
    |     |   +-field_idx=0
    |     +-field_idx=0
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.a#2]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[T.a#1]
        |   +-expr_list=
        |   | +-a#1 := Literal(type=STRUCT<b STRUCT<c STRUCT<d STRUCT<e DOUBLE>>>>, value={b:{c:{d:{e:1}}}})
        |   +-input_scan=
        |     +-SingleRowScan
        +-group_by_list=
          +-a#2 := ColumnRef(type=STRUCT<b STRUCT<c STRUCT<d STRUCT<e DOUBLE>>>>, column=T.a#1)
--
ALTERNATION GROUPS:
    V_1_2_GROUP_BY_STRUCT,DISALLOW_GROUP_BY_FLOAT,T.
    V_1_2_GROUP_BY_STRUCT,DISALLOW_GROUP_BY_FLOAT,
--
ERROR: Grouping by expressions of type STRUCT containing DOUBLE is not allowed [at 3:10]
GROUP BY T.a;
         ^
==

# Error - struct contains an array, which does not support group by.
[language_features=V_1_2_GROUP_BY_STRUCT]
SELECT {{T.|}}a.b.c.d.e
FROM (SELECT STRUCT (STRUCT (STRUCT (STRUCT ([1] as e) as d) as c) as b) as a) T
GROUP BY T.a;
--
ERROR: Grouping by expressions of type STRUCT containing ARRAY is not allowed [at 3:10]
GROUP BY T.a;
         ^
==

[language_features=V_1_2_GROUP_BY_STRUCT]
SELECT TestStruct.d.a, TestStruct.c
FROM ComplexTypes ct
GROUP BY TestStruct, TestStruct.d, TestStruct.d.a
--
QueryStmt
+-output_column_list=
| +-$query.a#10 AS a [INT32]
| +-$query.c#11 AS c [INT32]
+-query=
  +-ProjectScan
    +-column_list=$query.[a#10, c#11]
    +-expr_list=
    | +-a#10 :=
    | | +-GetStructField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-GetStructField
    | |   |   +-type=STRUCT<a INT32, b STRING>
    | |   |   +-expr=
    | |   |   | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=$groupby.TestStruct#7)
    | |   |   +-field_idx=1
    | |   +-field_idx=0
    | +-c#11 :=
    |   +-GetStructField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=$groupby.TestStruct#7)
    |     +-field_idx=0
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.TestStruct#7]
        +-input_scan=
        | +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4], alias='ct')
        +-group_by_list=
          +-TestStruct#7 := ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
          +-d#8 :=
          | +-GetStructField
          |   +-type=STRUCT<a INT32, b STRING>
          |   +-expr=
          |   | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
          |   +-field_idx=1
          +-a#9 :=
            +-GetStructField
              +-type=INT32
              +-expr=
              | +-GetStructField
              |   +-type=STRUCT<a INT32, b STRING>
              |   +-expr=
              |   | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
              |   +-field_idx=1
              +-field_idx=0
==

# TODO: this should be valid. Fix it.
[language_features=V_1_2_GROUP_BY_STRUCT]
SELECT TestStruct.d.*
FROM ComplexTypes
GROUP BY TestStruct.d
--
ERROR: Star expansion expression references column a which is neither grouped nor aggregated [at 1:8]
SELECT TestStruct.d.*
       ^
==

# TestStruct.c is resolved to the second TestStruct in GROUP BY.
[language_features=V_1_2_GROUP_BY_STRUCT]
SELECT TestStruct.d as TestStruct, TestStruct.c, TestStruct.d, TestStruct.d.a
FROM ComplexTypes ct
GROUP BY TestStruct, ct.TestStruct
--
QueryStmt
+-output_column_list=
| +-$groupby.TestStruct#7 AS TestStruct [STRUCT<a INT32, b STRING>]
| +-$query.c#9 AS c [INT32]
| +-$query.d#10 AS d [STRUCT<a INT32, b STRING>]
| +-$query.a#11 AS a [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.TestStruct#7, $query.c#9, $query.d#10, $query.a#11]
    +-expr_list=
    | +-c#9 :=
    | | +-GetStructField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=$groupby.TestStruct#8)
    | |   +-field_idx=0
    | +-d#10 :=
    | | +-GetStructField
    | |   +-type=STRUCT<a INT32, b STRING>
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=$groupby.TestStruct#8)
    | |   +-field_idx=1
    | +-a#11 :=
    |   +-GetStructField
    |     +-type=INT32
    |     +-expr=
    |     | +-GetStructField
    |     |   +-type=STRUCT<a INT32, b STRING>
    |     |   +-expr=
    |     |   | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=$groupby.TestStruct#8)
    |     |   +-field_idx=1
    |     +-field_idx=0
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[TestStruct#7, TestStruct#8]
        +-input_scan=
        | +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4], alias='ct')
        +-group_by_list=
          +-TestStruct#7 :=
          | +-GetStructField
          |   +-type=STRUCT<a INT32, b STRING>
          |   +-expr=
          |   | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
          |   +-field_idx=1
          +-TestStruct#8 := ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
==

[language_features=V_1_2_GROUP_BY_STRUCT]
select foo.bar as foo2, foo.bar.a, foo.bar.b
from (select struct<baz int32, bar struct<a int32, b int32>>(1, (2, 3)) as foo) as T
group by foo2;
--
QueryStmt
+-output_column_list=
| +-$groupby.foo2#2 AS foo2 [STRUCT<a INT32, b INT32>]
| +-$query.a#3 AS a [INT32]
| +-$query.b#4 AS b [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.foo2#2, $query.a#3, $query.b#4]
    +-expr_list=
    | +-a#3 :=
    | | +-GetStructField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<a INT32, b INT32>, column=$groupby.foo2#2)
    | |   +-field_idx=0
    | +-b#4 :=
    |   +-GetStructField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b INT32>, column=$groupby.foo2#2)
    |     +-field_idx=1
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.foo2#2]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[T.foo#1]
        |   +-expr_list=
        |   | +-foo#1 := Literal(type=STRUCT<baz INT32, bar STRUCT<a INT32, b INT32>>, value={baz:1, bar:{a:2, b:3}}, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-group_by_list=
          +-foo2#2 :=
            +-GetStructField
              +-type=STRUCT<a INT32, b INT32>
              +-expr=
              | +-ColumnRef(type=STRUCT<baz INT32, bar STRUCT<a INT32, b INT32>>, column=T.foo#1)
              +-field_idx=1
==

[language_features=V_1_2_GROUP_BY_STRUCT]
SELECT {{T.|}}a.b.c, {{T.|}}a.b.c.d, {{T.|}}a.b.c.d.e
FROM (SELECT STRUCT (STRUCT (STRUCT (STRUCT (1 as e) as d) as c) as b) as a) T
GROUP BY {{T.|}}a.b.c;
--
QueryStmt
+-output_column_list=
| +-$groupby.c#2 AS c [STRUCT<d STRUCT<e INT64>>]
| +-$query.d#3 AS d [STRUCT<e INT64>]
| +-$query.e#4 AS e [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.c#2, $query.d#3, $query.e#4]
    +-expr_list=
    | +-d#3 :=
    | | +-GetStructField
    | |   +-type=STRUCT<e INT64>
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<d STRUCT<e INT64>>, column=$groupby.c#2)
    | |   +-field_idx=0
    | +-e#4 :=
    |   +-GetStructField
    |     +-type=INT64
    |     +-expr=
    |     | +-GetStructField
    |     |   +-type=STRUCT<e INT64>
    |     |   +-expr=
    |     |   | +-ColumnRef(type=STRUCT<d STRUCT<e INT64>>, column=$groupby.c#2)
    |     |   +-field_idx=0
    |     +-field_idx=0
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.c#2]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[T.a#1]
        |   +-expr_list=
        |   | +-a#1 := Literal(type=STRUCT<b STRUCT<c STRUCT<d STRUCT<e INT64>>>>, value={b:{c:{d:{e:1}}}})
        |   +-input_scan=
        |     +-SingleRowScan
        +-group_by_list=
          +-c#2 :=
            +-GetStructField
              +-type=STRUCT<d STRUCT<e INT64>>
              +-expr=
              | +-GetStructField
              |   +-type=STRUCT<c STRUCT<d STRUCT<e INT64>>>
              |   +-expr=
              |   | +-ColumnRef(type=STRUCT<b STRUCT<c STRUCT<d STRUCT<e INT64>>>>, column=T.a#1)
              |   +-field_idx=0
              +-field_idx=0
==

[language_features=V_1_2_GROUP_BY_STRUCT]
SELECT {{T.|}}a.b.c as foo, {{T.|}}a.b.c.d, {{T.|}}a.b.c.d.e
FROM (SELECT STRUCT (STRUCT (STRUCT (STRUCT (1 as e) as d) as c) as b) as a) T
GROUP BY foo;
--
QueryStmt
+-output_column_list=
| +-$groupby.foo#2 AS foo [STRUCT<d STRUCT<e INT64>>]
| +-$query.d#3 AS d [STRUCT<e INT64>]
| +-$query.e#4 AS e [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.foo#2, $query.d#3, $query.e#4]
    +-expr_list=
    | +-d#3 :=
    | | +-GetStructField
    | |   +-type=STRUCT<e INT64>
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<d STRUCT<e INT64>>, column=$groupby.foo#2)
    | |   +-field_idx=0
    | +-e#4 :=
    |   +-GetStructField
    |     +-type=INT64
    |     +-expr=
    |     | +-GetStructField
    |     |   +-type=STRUCT<e INT64>
    |     |   +-expr=
    |     |   | +-ColumnRef(type=STRUCT<d STRUCT<e INT64>>, column=$groupby.foo#2)
    |     |   +-field_idx=0
    |     +-field_idx=0
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.foo#2]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[T.a#1]
        |   +-expr_list=
        |   | +-a#1 := Literal(type=STRUCT<b STRUCT<c STRUCT<d STRUCT<e INT64>>>>, value={b:{c:{d:{e:1}}}})
        |   +-input_scan=
        |     +-SingleRowScan
        +-group_by_list=
          +-foo#2 :=
            +-GetStructField
              +-type=STRUCT<d STRUCT<e INT64>>
              +-expr=
              | +-GetStructField
              |   +-type=STRUCT<c STRUCT<d STRUCT<e INT64>>>
              |   +-expr=
              |   | +-ColumnRef(type=STRUCT<b STRUCT<c STRUCT<d STRUCT<e INT64>>>>, column=T.a#1)
              |   +-field_idx=0
              +-field_idx=0
==

[language_features=V_1_2_GROUP_BY_STRUCT]
SELECT distinct {{T.|}}a.b.c.d.e
FROM (SELECT STRUCT (STRUCT (STRUCT (STRUCT (1 as e) as d) as c) as b) as a) T
GROUP BY {{T.|}}a.b;
--
QueryStmt
+-output_column_list=
| +-$distinct.e#4 AS e [INT64]
+-query=
  +-AggregateScan
    +-column_list=[$distinct.e#4]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[$groupby.b#2, $query.e#3]
    |   +-expr_list=
    |   | +-e#3 :=
    |   |   +-GetStructField
    |   |     +-type=INT64
    |   |     +-expr=
    |   |     | +-GetStructField
    |   |     |   +-type=STRUCT<e INT64>
    |   |     |   +-expr=
    |   |     |   | +-GetStructField
    |   |     |   |   +-type=STRUCT<d STRUCT<e INT64>>
    |   |     |   |   +-expr=
    |   |     |   |   | +-ColumnRef(type=STRUCT<c STRUCT<d STRUCT<e INT64>>>, column=$groupby.b#2)
    |   |     |   |   +-field_idx=0
    |   |     |   +-field_idx=0
    |   |     +-field_idx=0
    |   +-input_scan=
    |     +-AggregateScan
    |       +-column_list=[$groupby.b#2]
    |       +-input_scan=
    |       | +-ProjectScan
    |       |   +-column_list=[T.a#1]
    |       |   +-expr_list=
    |       |   | +-a#1 := Literal(type=STRUCT<b STRUCT<c STRUCT<d STRUCT<e INT64>>>>, value={b:{c:{d:{e:1}}}})
    |       |   +-input_scan=
    |       |     +-SingleRowScan
    |       +-group_by_list=
    |         +-b#2 :=
    |           +-GetStructField
    |             +-type=STRUCT<c STRUCT<d STRUCT<e INT64>>>
    |             +-expr=
    |             | +-ColumnRef(type=STRUCT<b STRUCT<c STRUCT<d STRUCT<e INT64>>>>, column=T.a#1)
    |             +-field_idx=0
    +-group_by_list=
      +-e#4 := ColumnRef(type=INT64, column=$query.e#3)
==

[language_features=V_1_2_GROUP_BY_STRUCT]
SELECT {{ct.|}}TestStruct, {{ct.|}}TestStruct.d
FROM ComplexTypes ct
GROUP BY {{ct.TestStruct|TestStruct|1}}
--
QueryStmt
+-output_column_list=
| +-$groupby.TestStruct#7 AS TestStruct [STRUCT<c INT32, d STRUCT<a INT32, b STRING>>]
| +-$query.d#8 AS d [STRUCT<a INT32, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.TestStruct#7, $query.d#8]
    +-expr_list=
    | +-d#8 :=
    |   +-GetStructField
    |     +-type=STRUCT<a INT32, b STRING>
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=$groupby.TestStruct#7)
    |     +-field_idx=1
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.TestStruct#7]
        +-input_scan=
        | +-TableScan(column_list=[ComplexTypes.TestStruct#5], table=ComplexTypes, column_index_list=[4], alias='ct')
        +-group_by_list=
          +-TestStruct#7 := ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=ComplexTypes.TestStruct#5)
==

# TODO We should make both cases work.
[language_features=V_1_2_GROUP_BY_STRUCT]
SELECT t as foo, t.key
FROM SimpleTypesWithStruct as t
group by {{1|t|foo}}
--
ALTERNATION GROUPS:
    1
    foo
--
ERROR: SELECT list expression references t.key which is neither grouped nor aggregated [at 1:18]
SELECT t as foo, t.key
                 ^
--
ALTERNATION GROUP: t
--
ERROR: SELECT list expression references table alias t which is neither grouped nor aggregated [at 1:8]
SELECT t as foo, t.key
       ^
==

# The alternation differs in the group by field name.
[language_features=V_1_2_GROUP_BY_STRUCT]
SELECT vt as foo, vt.a
FROM TestStructValueTable vt
GROUP BY {{1|vt|foo}}
--
ALTERNATION GROUPS:
    1
    foo
--
QueryStmt
+-output_column_list=
| +-$groupby.foo#2 AS foo [STRUCT<a INT32, b STRING>]
| +-$query.a#3 AS a [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.foo#2, $query.a#3]
    +-expr_list=
    | +-a#3 :=
    |   +-GetStructField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$groupby.foo#2)
    |     +-field_idx=0
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.foo#2]
        +-input_scan=
        | +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0], alias='vt')
        +-group_by_list=
          +-foo#2 := ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
--
ALTERNATION GROUP: vt
--
QueryStmt
+-output_column_list=
| +-$groupby.vt#2 AS foo [STRUCT<a INT32, b STRING>]
| +-$query.a#3 AS a [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.vt#2, $query.a#3]
    +-expr_list=
    | +-a#3 :=
    |   +-GetStructField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$groupby.vt#2)
    |     +-field_idx=0
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.vt#2]
        +-input_scan=
        | +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0], alias='vt')
        +-group_by_list=
          +-vt#2 := ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructValueTable.value#1)
==

# MIN is supported for ARRAYs only if array ordering is enabled.
[language_features={{|V_1_3_ARRAY_ORDERING}}]
SELECT MIN(x) FROM (SELECT [1] x);
--
ALTERNATION GROUP: <empty>
--
ERROR: MIN is not defined for arguments of type ARRAY<INT64> [at 1:8]
SELECT MIN(x) FROM (SELECT [1] x);
       ^
--
ALTERNATION GROUP: V_1_3_ARRAY_ORDERING
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$subquery1.x#1]
        |   +-expr_list=
        |   | +-x#1 := Literal(type=ARRAY<INT64>, value=[1])
        |   +-input_scan=
        |     +-SingleRowScan
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall(ZetaSQL:min(ARRAY<INT64>) -> ARRAY<INT64>)
              +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.x#1)
==

[language_features=V_1_1_HAVING_IN_AGGREGATE{{|,V_1_3_ARRAY_ORDERING}}]
select count(key having max x)
from (select 'a' key, [1] x);
--
ERROR: HAVING modifier does not support expressions of type ARRAY<INT64> [at 1:18]
select count(key having max x)
                 ^
==

[language_features=V_1_1_HAVING_IN_AGGREGATE{{|,V_1_3_ARRAY_ORDERING}}]
select count(key having min x)
from (select 'a' key, [1] x);
--
ERROR: HAVING modifier does not support expressions of type ARRAY<INT64> [at 1:18]
select count(key having min x)
                 ^
==

# Test case related to b/112194178.
#
# Note that SUM(b) in the HAVING clause resolves to the SELECT list alias 'b',
# which is effectively SUM(x.a+1).  This contradicts the SQL standard, which
# resolves the HAVING clause as SUM(x.b).
WITH x as (select 1 a, 2 b)
SELECT a+1 as b, sum(b)
FROM x
GROUP BY a
HAVING sum(b) > 5;
--
QueryStmt
+-output_column_list=
| +-$query.b#8 AS b [INT64]
| +-$aggregate.$agg1#5 AS "$col2" [INT64]
+-query=
  +-WithScan
    +-column_list=[$query.b#8, $aggregate.$agg1#5]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="x"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=x.[a#1, b#2]
    |       +-expr_list=
    |       | +-a#1 := Literal(type=INT64, value=1)
    |       | +-b#2 := Literal(type=INT64, value=2)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$query.b#8, $aggregate.$agg1#5]
        +-input_scan=
          +-FilterScan
            +-column_list=[$aggregate.$agg1#5, $groupby.a#7, $query.b#8, $aggregate.$agg2#9]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[$aggregate.$agg1#5, $groupby.a#7, $query.b#8, $aggregate.$agg2#9]
            |   +-expr_list=
            |   | +-b#8 :=
            |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=$groupby.a#7)
            |   |     +-Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-AggregateScan
            |       +-column_list=[$groupby.a#7, $aggregate.$agg1#5, $aggregate.$agg2#9]
            |       +-input_scan=
            |       | +-ProjectScan
            |       |   +-column_list=[x.a#3, x.b#4, $pre_groupby.b#6]
            |       |   +-expr_list=
            |       |   | +-b#6 :=
            |       |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
            |       |   |     +-ColumnRef(type=INT64, column=x.a#3)
            |       |   |     +-Literal(type=INT64, value=1)
            |       |   +-input_scan=
            |       |     +-WithRefScan(column_list=x.[a#3, b#4], with_query_name="x")
            |       +-group_by_list=
            |       | +-a#7 := ColumnRef(type=INT64, column=x.a#3)
            |       +-aggregate_list=
            |         +-$agg1#5 :=
            |         | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
            |         |   +-ColumnRef(type=INT64, column=x.b#4)
            |         +-$agg2#9 :=
            |           +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
            |             +-ColumnRef(type=INT64, column=$pre_groupby.b#6)
            +-filter_expr=
              +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
                +-ColumnRef(type=INT64, column=$aggregate.$agg2#9)
                +-Literal(type=INT64, value=5)
==

# Test case related to b/112108147 (but does not reproduce it).
[no_run_unparser]
with t as (select struct(1, 2, 3) as a, 4 as b)
select a.*, count(*) from t group by 1,2,3 order by 4 limit 3;
--
QueryStmt
+-output_column_list=
| +-$groupby.$field1#6 AS "$field1" [INT64]
| +-$groupby.$field2#7 AS "$field2" [INT64]
| +-$groupby.$field3#8 AS "$field3" [INT64]
| +-$aggregate.$agg1#5 AS "$col2" [INT64]
+-query=
  +-WithScan
    +-column_list=[$groupby.$field1#6, $groupby.$field2#7, $groupby.$field3#8, $aggregate.$agg1#5]
    +-is_ordered=TRUE
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t.[a#1, b#2]
    |       +-expr_list=
    |       | +-a#1 := Literal(type=STRUCT<INT64, INT64, INT64>, value={1, 2, 3})
    |       | +-b#2 := Literal(type=INT64, value=4)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-LimitOffsetScan
        +-column_list=[$groupby.$field1#6, $groupby.$field2#7, $groupby.$field3#8, $aggregate.$agg1#5]
        +-is_ordered=TRUE
        +-input_scan=
        | +-OrderByScan
        |   +-column_list=[$groupby.$field1#6, $groupby.$field2#7, $groupby.$field3#8, $aggregate.$agg1#5]
        |   +-is_ordered=TRUE
        |   +-input_scan=
        |   | +-AggregateScan
        |   |   +-column_list=[$groupby.$field1#6, $groupby.$field2#7, $groupby.$field3#8, $aggregate.$agg1#5]
        |   |   +-input_scan=
        |   |   | +-WithRefScan(column_list=t.[a#3, b#4], with_query_name="t")
        |   |   +-group_by_list=
        |   |   | +-$field1#6 :=
        |   |   | | +-GetStructField
        |   |   | |   +-type=INT64
        |   |   | |   +-expr=
        |   |   | |   | +-ColumnRef(type=STRUCT<INT64, INT64, INT64>, column=t.a#3)
        |   |   | |   +-field_idx=0
        |   |   | +-$field2#7 :=
        |   |   | | +-GetStructField
        |   |   | |   +-type=INT64
        |   |   | |   +-expr=
        |   |   | |   | +-ColumnRef(type=STRUCT<INT64, INT64, INT64>, column=t.a#3)
        |   |   | |   +-field_idx=1
        |   |   | +-$field3#8 :=
        |   |   |   +-GetStructField
        |   |   |     +-type=INT64
        |   |   |     +-expr=
        |   |   |     | +-ColumnRef(type=STRUCT<INT64, INT64, INT64>, column=t.a#3)
        |   |   |     +-field_idx=2
        |   |   +-aggregate_list=
        |   |     +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-order_by_item_list=
        |     +-OrderByItem
        |       +-column_ref=
        |         +-ColumnRef(type=INT64, column=$aggregate.$agg1#5)
        +-limit=
          +-Literal(type=INT64, value=3)
==

# Test case related to b/112108147 (but does not reproduce it).
[language_features=V_1_2_GROUP_BY_ARRAY]
select TestProto.*, count(*)
from ComplexTypes
group by 1,2,3
order by 4;
--
QueryStmt
+-output_column_list=
| +-$groupby.int32_val1#11 AS int32_val1 [INT32]
| +-$groupby.int32_val2#12 AS int32_val2 [INT32]
| +-$groupby.str_value#13 AS str_value [ARRAY<STRING>]
| +-$aggregate.$agg1#7 AS "$col2" [INT64]
+-query=
  +-OrderByScan
    +-column_list=[$groupby.int32_val1#11, $groupby.int32_val2#12, $groupby.str_value#13, $aggregate.$agg1#7]
    +-is_ordered=TRUE
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.int32_val1#11, $groupby.int32_val2#12, $groupby.str_value#13, $aggregate.$agg1#7]
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[ComplexTypes.TestProto#6, $pre_groupby.int32_val1#8, $pre_groupby.int32_val2#9, $pre_groupby.str_value#10]
    |   |   +-expr_list=
    |   |   | +-int32_val1#8 :=
    |   |   | | +-GetProtoField
    |   |   | |   +-type=INT32
    |   |   | |   +-expr=
    |   |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=ComplexTypes.TestProto#6)
    |   |   | |   +-field_descriptor=int32_val1
    |   |   | |   +-default_value=0
    |   |   | +-int32_val2#9 :=
    |   |   | | +-GetProtoField
    |   |   | |   +-type=INT32
    |   |   | |   +-expr=
    |   |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=ComplexTypes.TestProto#6)
    |   |   | |   +-field_descriptor=int32_val2
    |   |   | |   +-default_value=0
    |   |   | +-str_value#10 :=
    |   |   |   +-GetProtoField
    |   |   |     +-type=ARRAY<STRING>
    |   |   |     +-expr=
    |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=ComplexTypes.TestProto#6)
    |   |   |     +-field_descriptor=str_value
    |   |   |     +-default_value=[]
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[ComplexTypes.TestProto#6], table=ComplexTypes, column_index_list=[5])
    |   +-group_by_list=
    |   | +-int32_val1#11 := ColumnRef(type=INT32, column=$pre_groupby.int32_val1#8)
    |   | +-int32_val2#12 := ColumnRef(type=INT32, column=$pre_groupby.int32_val2#9)
    |   | +-str_value#13 := ColumnRef(type=ARRAY<STRING>, column=$pre_groupby.str_value#10)
    |   +-aggregate_list=
    |     +-$agg1#7 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    +-order_by_item_list=
      +-OrderByItem
        +-column_ref=
          +-ColumnRef(type=INT64, column=$aggregate.$agg1#7)
==

# Aggregates with an ambiguous alias
select key, sum(1) as a, count(*) as a
from KeyValue
group by key;
--
QueryStmt
+-output_column_list=
| +-$groupby.key#5 AS key [INT64]
| +-$aggregate.a#3 AS a [INT64]
| +-$aggregate.a#4 AS a [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.key#5, $aggregate.a#3, $aggregate.a#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.key#5, $aggregate.a#3, $aggregate.a#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
        | +-key#5 := ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-aggregate_list=
          +-a#3 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
          |   +-Literal(type=INT64, value=1)
          +-a#4 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)

==

# Aggregates on JSON value
[language_features=JSON_TYPE]
SELECT Count(*), JSON_VALUE(json_col.c)
FROM JsonTable
GROUP BY JSON_VALUE(json_col.c)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [INT64]
| +-$groupby.$groupbycol1#3 AS "$col2" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2, $groupby.$groupbycol1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.$groupbycol1#3, $aggregate.$agg1#2]
        +-input_scan=
        | +-TableScan(column_list=[JSONTable.json_col#1], table=JSONTable, column_index_list=[0])
        +-group_by_list=
        | +-$groupbycol1#3 :=
        |   +-FunctionCall(ZetaSQL:json_value(JSON, optional(1) STRING) -> STRING)
        |     +-GetJsonField
        |     | +-type=JSON
        |     | +-expr=
        |     | | +-ColumnRef(type=JSON, column=JSONTable.json_col#1)
        |     | +-field_name="c"
        |     +-Literal(type=STRING, value='$')
        +-aggregate_list=
          +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

# Aggregates on JSON values that are not equal
[language_features=JSON_TYPE]
SELECT Count(*), JSON_VALUE(json_col.c)
FROM JsonTable
GROUP BY JSON_VALUE(json_col.d)
--
ERROR: SELECT list expression references json_col.c which is neither grouped nor aggregated [at 1:29]
SELECT Count(*), JSON_VALUE(json_col.c)
                            ^
==

# Aggregates on JSON values that are not equal cases
[language_features=JSON_TYPE]
SELECT Count(*), JSON_VALUE(json_col.c)
FROM JsonTable
GROUP BY JSON_VALUE(json_col.C)
--
ERROR: SELECT list expression references json_col.c which is neither grouped nor aggregated [at 1:29]
SELECT Count(*), JSON_VALUE(json_col.c)
                            ^

==

[language_features=V_1_3_PROTO_DEFAULT_IF_NULL]
SELECT
  PROTO_DEFAULT_IF_NULL(KitchenSink.int32_val)
FROM TestTable
GROUP BY PROTO_DEFAULT_IF_NULL(KitchenSink.int32_val)
--
QueryStmt
+-output_column_list=
| +-$groupby.$groupbycol1#4 AS "$col1" [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.$groupbycol1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.$groupbycol1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-group_by_list=
          +-$groupbycol1#4 :=
            +-GetProtoField
              +-type=INT32
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              +-field_descriptor=int32_val
              +-default_value=77
              +-return_default_value_when_unset=TRUE
==

[language_features=V_1_3_PROTO_DEFAULT_IF_NULL,V_1_1_ORDER_BY_IN_AGGREGATE]
SELECT
  ARRAY_AGG(
    DISTINCT PROTO_DEFAULT_IF_NULL(KitchenSink.int32_val)
    ORDER BY PROTO_DEFAULT_IF_NULL(KitchenSink.int32_val))
FROM TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS "$col1" [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.KitchenSink#3, $orderby.$orderbycol1#4]
        |   +-expr_list=
        |   | +-$orderbycol1#4 :=
        |   |   +-GetProtoField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |     +-field_descriptor=int32_val
        |   |     +-default_value=77
        |   |     +-return_default_value_when_unset=TRUE
        |   +-input_scan=
        |     +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-aggregate_list=
          +-$agg1#5 :=
            +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
              +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#4)
              +-distinct=TRUE
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                    +-ColumnRef(type=INT32, column=$orderby.$orderbycol1#4)
