# Specify WITH DIFFERENTIAL_PRIVACY but no FROM clause
[default language_features=DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,NUMERIC_TYPE,JSON_TYPE]
select with differential_privacy sum();
--
ERROR: SELECT without FROM clause cannot specify WITH DIFFERENTIAL_PRIVACY [at 1:1]
select with differential_privacy sum();
^
==

# Reject non-* aggregate functions
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy (int64)
from SimpleTypes;
--
ERROR: SELECT WITH DIFFERENTIAL_PRIVACY queries require GROUP BY or aggregation, but neither was present [at 1:34]
select with differential_privacy (int64)
                                 ^
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select WITH DIFFERENTIAL_PRIVACY sum(int64), max(int64)
from SimpleTypesWithAnonymizationUid;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
| +-$aggregate.$agg2#14 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          |   +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
          |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
          +-$agg2#14 :=
            +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)

Rewrite ERROR: Unsupported function in SELECT WITH DIFFERENTIAL_PRIVACY select list: MAX
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select {{with differential_privacy|with differential_privacy options ()}} count(*)
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(int64)
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy sum(int64)
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy avg(int64)
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
              +-Cast(INT64 -> DOUBLE)
              | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:avg(DOUBLE) -> DOUBLE)
        |         +-Cast(INT64 -> DOUBLE)
        |           +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
        | |   +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy avg(numeric)
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[11])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(NUMERIC, optional(1) STRUCT<NUMERIC, NUMERIC> contribution_bounds_per_group) -> NUMERIC)
              +-ColumnRef(type=NUMERIC, column=SimpleTypesWithAnonymizationUid.numeric#12)
              +-Literal(type=STRUCT<NUMERIC, NUMERIC>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[numeric#12, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[11, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:avg(NUMERIC) -> NUMERIC)
        |         +-ColumnRef(type=NUMERIC, column=SimpleTypesWithAnonymizationUid.numeric#12)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(NUMERIC, optional(1) STRUCT<NUMERIC, NUMERIC> contribution_bounds_per_group) -> NUMERIC)
        | |   +-ColumnRef(type=NUMERIC, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=STRUCT<NUMERIC, NUMERIC>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy int32,
                          count(*, contribution_bounds_per_group => (0,1)),
                          count(string, contribution_bounds_per_group => (0,10)),
                          sum(int64, contribution_bounds_per_group => (10,100))
from SimpleTypesWithAnonymizationUid
group by int32;
--
QueryStmt
+-output_column_list=
| +-$groupby.int32#16 AS int32 [INT32]
| +-$aggregate.$agg1#13 AS "$col2" [INT64]
| +-$aggregate.$agg2#14 AS "$col3" [INT64]
| +-$aggregate.$agg3#15 AS "$col4" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.int32#16, $aggregate.$agg1#13, $aggregate.$agg2#14, $aggregate.$agg3#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32#16, $aggregate.$agg1#13, $aggregate.$agg2#14, $aggregate.$agg3#15]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, string#5], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 4])
        +-group_by_list=
        | +-int32#16 := ColumnRef(type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        +-aggregate_list=
          +-$agg1#13 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
          +-$agg2#14 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(STRING, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          |   +-ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)
          |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
          +-$agg3#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={10, 100})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.int32#16 AS int32 [INT32]
| +-$aggregate.$agg1#13 AS "$col2" [INT64]
| +-$aggregate.$agg2#14 AS "$col3" [INT64]
| +-$aggregate.$agg3#15 AS "$col4" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.int32#16, $aggregate.$agg1#13, $aggregate.$agg2#14, $aggregate.$agg3#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32#16, $aggregate.$agg1#13, $aggregate.$agg2#14, $aggregate.$agg3#15]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#19, $aggregate.$agg2_partial#21, $aggregate.$agg3_partial#23, $groupby.int32_partial#24, $group_by.$uid#25]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, string#5, uid#17], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 4, 10])
        |   +-group_by_list=
        |   | +-int32_partial#24 := ColumnRef(type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        |   | +-$uid#25 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#17)
        |   +-aggregate_list=
        |     +-$agg1_partial#19 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |     +-$agg2_partial#21 :=
        |     | +-AggregateFunctionCall(ZetaSQL:count(STRING) -> INT64)
        |     |   +-ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)
        |     +-$agg3_partial#23 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-group_by_list=
        | +-int32#16 := ColumnRef(type=INT32, column=$groupby.int32_partial#24)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#19)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        | +-$agg2#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg2_partial#21)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
        | +-$agg3#15 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg3_partial#23)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={10, 100})
        | +-$group_selection_threshold_col#30 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#30)
==

# Tests for options, which defines a small set of valid option
# names.
select with differential_privacy options()
       count(*, contribution_bounds_per_group => (0,100))
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
==

select with differential_privacy options(delta=0)
       count(*, contribution_bounds_per_group => (0,100))
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
        | +-$agg1#13 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        +-option_list=
          +-delta := Literal(type=DOUBLE, value=0)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy options(delta=0, epsilon=0, max_groups_contributed=0, k_threshold=0)
       count(*, contribution_bounds_per_group => (0,100))
from SimpleTypesWithAnonymizationUid;
--
ERROR: Unknown differential privacy option: k_threshold [at 1:88]
...delta=0, epsilon=0, max_groups_contributed=0, k_threshold=0)
                                                 ^
==

# Invalid option name
select with differential_privacy options(foo=0)
       count(*, contribution_bounds_per_group => (0,100))
from SimpleTypesWithAnonymizationUid;
--
ERROR: Unknown differential privacy option: foo [at 1:42]
select with differential_privacy options(foo=0)
                                         ^
==

# Invalid option name (qualified option names not allowed)
select with differential_privacy options(f1.epsilon=0)
       count(*, contribution_bounds_per_group => (0,100))
from SimpleTypesWithAnonymizationUid;
--
ERROR: Syntax error: Expected "=" but got "." [at 1:44]
select with differential_privacy options(f1.epsilon=0)
                                           ^
==

# Invalid option name, along with a valid option
select with differential_privacy options(delta=0, foo=0)
       count(*, contribution_bounds_per_group => (0,100))
from SimpleTypesWithAnonymizationUid;
--
ERROR: Unknown differential privacy option: foo [at 1:51]
select with differential_privacy options(delta=0, foo=0)
                                                  ^
==

select with differential_privacy options(
    {{delta|epsilon|max_groups_contributed|k_threshold}}=@test_param_int64)
       count(*, contribution_bounds_per_group => (0,100))
from SimpleTypesWithAnonymizationUid;
--
ALTERNATION GROUP: delta
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
        | +-$agg1#13 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        +-option_list=
          +-delta :=
            +-Cast(INT64 -> DOUBLE)
              +-Parameter(type=INT64, name='test_param_int64')
--
ALTERNATION GROUP: epsilon
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
        | +-$agg1#13 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        +-option_list=
          +-epsilon :=
            +-Cast(INT64 -> DOUBLE)
              +-Parameter(type=INT64, name='test_param_int64')
--
ALTERNATION GROUP: max_groups_contributed
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
        | +-$agg1#13 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        +-option_list=
          +-max_groups_contributed := Parameter(type=INT64, name='test_param_int64')
--
ALTERNATION GROUP: k_threshold
--
ERROR: Unknown differential privacy option: k_threshold [at 2:5]
    k_threshold=@test_param_int64)
    ^
==

select with differential_privacy options(
    {{delta|epsilon|max_groups_contributed|k_threshold}}=@test_param_double)
       count(*, contribution_bounds_per_group => (0,100))
from SimpleTypesWithAnonymizationUid;
--
ALTERNATION GROUP: delta
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
        | +-$agg1#13 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        +-option_list=
          +-delta := Parameter(type=DOUBLE, name='test_param_double')
--
ALTERNATION GROUP: epsilon
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
        | +-$agg1#13 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        +-option_list=
          +-epsilon := Parameter(type=DOUBLE, name='test_param_double')
--
ALTERNATION GROUP: max_groups_contributed
--
ERROR: Differential privacy option max_groups_contributed value has type DOUBLE which cannot be coerced to expected type INT64 [at 2:28]
    max_groups_contributed=@test_param_double)
                           ^
--
ALTERNATION GROUP: k_threshold
--
ERROR: Unknown differential privacy option: k_threshold [at 2:5]
    k_threshold=@test_param_double)
    ^
==

select with differential_privacy options({{delta|epsilon|max_groups_contributed|k_threshold}}=1+2)
       count(*, contribution_bounds_per_group => (0,100))
from SimpleTypesWithAnonymizationUid;
--
ALTERNATION GROUP: delta
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
        | +-$agg1#13 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        +-option_list=
          +-delta :=
            +-Cast(INT64 -> DOUBLE)
              +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                +-Literal(type=INT64, value=1)
                +-Literal(type=INT64, value=2)
--
ALTERNATION GROUP: epsilon
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
        | +-$agg1#13 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        +-option_list=
          +-epsilon :=
            +-Cast(INT64 -> DOUBLE)
              +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                +-Literal(type=INT64, value=1)
                +-Literal(type=INT64, value=2)
--
ALTERNATION GROUP: max_groups_contributed
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
        | +-$agg1#13 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        +-option_list=
          +-max_groups_contributed :=
            +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
              +-Literal(type=INT64, value=1)
              +-Literal(type=INT64, value=2)
--
ALTERNATION GROUP: k_threshold
--
ERROR: Unknown differential privacy option: k_threshold [at 1:42]
select with differential_privacy options(k_threshold=1+2)
                                         ^
==

# Non-constant expressions for options fails.  Because these are options,
# we need to parenthesize 'int64' so it's not treated like a raw string and
# is treated like an expression instead.  In this case, analysis still fails
# because resolving options expressions uses an empty NameScope.
select with differential_privacy options(epsilon=(int64))
       count(*, contribution_bounds_per_group => (0,100))
from SimpleTypesWithAnonymizationUid;
--
ERROR: Unrecognized name: int64 [at 1:51]
select with differential_privacy options(epsilon=(int64))
                                                  ^
==

# Reject queries not over private tables
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from SimpleTypes;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-100
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(parse_location=89-100, table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from SimpleTypes;

Rewrite ERROR: A SELECT WITH DIFFERENTIAL_PRIVACY query must query data with a specified privacy unit column [at 1:1]
select with differential_privacy count(*, contribution_bounds_per_group => (0...
^
==

# Reject queries when the $uid column type is not group-able
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from ProtoAnonymizationUid;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-110
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-TableScan(parse_location=89-110, table=ProtoAnonymizationUid)
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from ProtoAnonymizationUid;

Rewrite ERROR: User id columns must support grouping, instead got type PROTO [at 2:6]
from ProtoAnonymizationUid;
     ^
==

# Valid simple WITH DIFFERENTIAL_PRIVACY query
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(int64, contribution_bounds_per_group => (0,10))
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

# WITH DIFFERENTIAL_PRIVACY syntax can only be used with grouping/aggregation
select with differential_privacy string
from SimpleTypesWithAnonymizationUid
group by string;
--
QueryStmt
+-output_column_list=
| +-$groupby.string#13 AS string [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.string#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.string#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.string#5], table=SimpleTypesWithAnonymizationUid, column_index_list=[4])
        +-group_by_list=
          +-string#13 := ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)
==

# WITH DIFFERENTIAL_PRIVACY syntax can only be used with grouping/aggregation
select with differential_privacy int64
from SimpleTypesWithAnonymizationUid;
--
ERROR: SELECT WITH DIFFERENTIAL_PRIVACY queries require GROUP BY or aggregation, but neither was present [at 1:34]
select with differential_privacy int64
                                 ^
==

# WITH DIFFERENTIAL_PRIVACY syntax can only be used with grouping/aggregation
select with differential_privacy int64
from SimpleTypesWithAnonymizationUid
group by int64;
--
QueryStmt
+-output_column_list=
| +-$groupby.int64#13 AS int64 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.int64#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int64#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-group_by_list=
          +-int64#13 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
==

# WITH DIFFERENTIAL_PRIVACY syntax can only be used with grouping/aggregation
select with differential_privacy count(int64, contribution_bounds_per_group => (0,10)), string, int64
from SimpleTypesWithAnonymizationUid
group by string;
--
ERROR: SELECT list expression references column int64 which is neither grouped nor aggregated [at 1:97]
...contribution_bounds_per_group => (0,10)), string, int64
                                                     ^
==

# Valid anonymization with GROUP BY
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(int64, contribution_bounds_per_group => (0,10)), string
from SimpleTypesWithAnonymizationUid
group by string;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
| +-$groupby.string#14 AS string [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13, $groupby.string#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.string#14, $aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, string#5], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 4])
        +-group_by_list=
        | +-string#14 := ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
| +-$groupby.string#14 AS string [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13, $groupby.string#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.string#14, $aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#17, $groupby.string_partial#18, $group_by.$uid#19]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, string#5, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 4, 10])
        |   +-group_by_list=
        |   | +-string_partial#18 := ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)
        |   | +-$uid#19 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#17 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-group_by_list=
        | +-string#14 := ColumnRef(type=STRING, column=$groupby.string_partial#18)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#17)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
        | +-$group_selection_threshold_col#22 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#22)
==

# Valid anonymization with only GROUP BY
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy int64, string
from SimpleTypesWithAnonymizationUid
group by int64, string;
--
QueryStmt
+-output_column_list=
| +-$groupby.int64#13 AS int64 [INT64]
| +-$groupby.string#14 AS string [STRING]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[int64#13, string#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$groupby.[int64#13, string#14]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, string#5], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 4])
        +-group_by_list=
          +-int64#13 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
          +-string#14 := ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.int64#13 AS int64 [INT64]
| +-$groupby.string#14 AS string [STRING]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[int64#13, string#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$groupby.[int64#13, string#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.int64_partial#16, $groupby.string_partial#17, $group_by.$uid#18]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, string#5, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 4, 10])
        |   +-group_by_list=
        |     +-int64_partial#16 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |     +-string_partial#17 := ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)
        |     +-$uid#18 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        +-group_by_list=
        | +-int64#13 := ColumnRef(type=INT64, column=$groupby.int64_partial#16)
        | +-string#14 := ColumnRef(type=STRING, column=$groupby.string_partial#17)
        +-aggregate_list=
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

# Non-trivial computed column
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy 1 + count(int64, contribution_bounds_per_group => (0,10))
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#14 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#14]
    +-expr_list=
    | +-$col1#14 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Literal(type=INT64, value=1)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#13)
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#14 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#14]
    +-expr_list=
    | +-$col1#14 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Literal(type=INT64, value=1)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#13)
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#17, $group_by.$uid#18]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#18 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#17 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#17)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
        | +-$group_selection_threshold_col#21 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#21)
==

# Non-trivial computed column
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy int32 + count(int64, contribution_bounds_per_group => (0,10))
from SimpleTypesWithAnonymizationUid
group by int32;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#15 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#15]
    +-expr_list=
    | +-$col1#15 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Cast(INT32 -> INT64)
    |     | +-ColumnRef(type=INT32, column=$groupby.int32#14)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#13)
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32#14, $aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1])
        +-group_by_list=
        | +-int32#14 := ColumnRef(type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#15 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#15]
    +-expr_list=
    | +-$col1#15 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Cast(INT32 -> INT64)
    |     | +-ColumnRef(type=INT32, column=$groupby.int32#14)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#13)
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32#14, $aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $groupby.int32_partial#19, $group_by.$uid#20]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uid#16], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 10])
        |   +-group_by_list=
        |   | +-int32_partial#19 := ColumnRef(type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        |   | +-$uid#20 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#16)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-group_by_list=
        | +-int32#14 := ColumnRef(type=INT32, column=$groupby.int32_partial#19)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
        | +-$group_selection_threshold_col#23 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#23)
==

# Nested projection without $uid column
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(int64, contribution_bounds_per_group => (0,10))
from (select int64 from SimpleTypesWithAnonymizationUid {{a|}});
--
ALTERNATION GROUP: a
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2]
        |   +-input_scan=
        |     +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1], alias='a')
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'a.uid'
--
ALTERNATION GROUP: <empty>
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2]
        |   +-input_scan=
        |     +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid'
==

# Repeated nested projection clears uid column qualifier
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(int64, contribution_bounds_per_group => (0,10))
from (select int64 from (
      select a.int64, a.uid from SimpleTypesWithAnonymizationUid a));
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2]
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11]
        |       +-input_scan=
        |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10], alias='a')
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid'
==

# Updated qualifers in repeated nested projection aren't handled correctly
# TODO: figure out how we can respect re-aliased qualifiers
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(int64, contribution_bounds_per_group => (0,10))
from (select b.int64 from (
      select a.int64, a.uid from SimpleTypesWithAnonymizationUid a) b);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2]
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11]
        |       +-input_scan=
        |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10], alias='a')
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid'
==

# Nested projection with $uid column
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(int64, contribution_bounds_per_group => (0,10))
from (select int64, uid from SimpleTypesWithAnonymizationUid);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11]
        |   +-input_scan=
        |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#15, $group_by.$uid#16]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#16 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |   +-aggregate_list=
        |     +-$agg1_partial#15 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#15)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
        | +-$group_selection_threshold_col#19 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#19)
==

# Reject nested aggregation functions
select with differential_privacy sum(count(int64, contribution_bounds_per_group => (0,10)))
from SimpleTypesWithAnonymizationUid;
--
ERROR: Aggregations of aggregations are not allowed [at 1:34]
select with differential_privacy sum(count(int64, contribution_bounds_per_gro...
                                 ^
==

# Support basic nested aggregation scans
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with DIFFERENTIAL_PRIVACY count(*, contribution_bounds_per_group => (0,100))
from (
  SELECT count(*), uid
  from SimpleTypesWithAnonymizationUid
  group by uid);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#13, $groupby.uid#14]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.uid#14, $aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       +-group_by_list=
        |       | +-uid#14 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       +-aggregate_list=
        |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#17, $group_by.$uid#18]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#13, $groupby.uid#14]
        |   |   +-input_scan=
        |   |     +-AggregateScan
        |   |       +-column_list=[$groupby.uid#14, $aggregate.$agg1#13]
        |   |       +-input_scan=
        |   |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |       +-group_by_list=
        |   |       | +-uid#14 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |   |       +-aggregate_list=
        |   |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-group_by_list=
        |   | +-$uid#18 := ColumnRef(type=INT64, column=$groupby.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#17 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#15 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#17)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$group_selection_threshold_col#21 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#21)
==

# Reject nested aggregation scans that don't group by $uid
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from (SELECT count(*) from SimpleTypesWithAnonymizationUid a);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#14 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-145
    +-column_list=[$aggregate.$agg1#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#14]
        +-input_scan=
        | +-ProjectScan
        |   +-parse_location=90-144
        |   +-column_list=[$aggregate.$agg1#13]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-TableScan(parse_location=111-142, table=SimpleTypesWithAnonymizationUid, alias='a')
        |       +-aggregate_list=
        |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=97-102)
        +-aggregate_list=
          +-$agg1#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (SELECT count(*) from SimpleTypesWithAnonymizationUid a);

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'a.uid' [at 2:7]
from (SELECT count(*) from SimpleTypesWithAnonymizationUid a);
      ^
==

# Reject nested aggregation scans that don't project the grouped by $uid
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from (
  SELECT count(*)
  from SimpleTypesWithAnonymizationUid{{ a|}}
  group by uid);
--
ALTERNATION GROUP:  a
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-165
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-ProjectScan
        |   +-parse_location=93-164
        |   +-column_list=[$aggregate.$agg1#13]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-TableScan(parse_location=116-147, column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias='a')
        |       +-group_by_list=
        |       | +-uid#14 := ColumnRef(parse_location=161-164, type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       +-aggregate_list=
        |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=100-105)
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (
  SELECT count(*)
  from SimpleTypesWithAnonymizationUid a
  group by uid);

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'a.uid' [at 3:3]
  SELECT count(*)
  ^
--
ALTERNATION GROUP: <empty>
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-163
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-ProjectScan
        |   +-parse_location=93-162
        |   +-column_list=[$aggregate.$agg1#13]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-TableScan(parse_location=116-147, column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       +-group_by_list=
        |       | +-uid#14 := ColumnRef(parse_location=159-162, type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       +-aggregate_list=
        |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=100-105)
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (
  SELECT count(*)
  from SimpleTypesWithAnonymizationUid
  group by uid);

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid' [at 3:3]
  SELECT count(*)
  ^
==

# Projecting, aliasing, grouping don't interfere with explicitly grouping by
# $uid in nested aggregation
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from (
    SELECT count(*), y
    from (
      select x, y
      from (
        select uid as x, uid as y
        from SimpleTypesWithAnonymizationUid)
      group by x, y)
    group by y)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#16 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#16]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#16]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#14, $groupby.y#15]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.y#15, $aggregate.$agg1#14]
        |       +-input_scan=
        |       | +-ProjectScan
        |       |   +-column_list=$groupby.[x#13, x#13]
        |       |   +-input_scan=
        |       |     +-AggregateScan
        |       |       +-column_list=[$groupby.x#13]
        |       |       +-input_scan=
        |       |       | +-ProjectScan
        |       |       |   +-column_list=SimpleTypesWithAnonymizationUid.[uid#11, uid#11]
        |       |       |   +-input_scan=
        |       |       |     +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       |       +-group_by_list=
        |       |         +-x#13 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       +-group_by_list=
        |       | +-y#15 := ColumnRef(type=INT64, column=$groupby.x#13)
        |       +-aggregate_list=
        |         +-$agg1#14 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
          +-$agg1#16 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#16 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#16]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#16]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $group_by.$uid#19]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#14, $groupby.y#15]
        |   |   +-input_scan=
        |   |     +-AggregateScan
        |   |       +-column_list=[$groupby.y#15, $aggregate.$agg1#14]
        |   |       +-input_scan=
        |   |       | +-ProjectScan
        |   |       |   +-column_list=$groupby.[x#13, x#13]
        |   |       |   +-input_scan=
        |   |       |     +-AggregateScan
        |   |       |       +-column_list=[$groupby.x#13]
        |   |       |       +-input_scan=
        |   |       |       | +-ProjectScan
        |   |       |       |   +-column_list=SimpleTypesWithAnonymizationUid.[uid#11, uid#11]
        |   |       |       |   +-input_scan=
        |   |       |       |     +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |       |       +-group_by_list=
        |   |       |         +-x#13 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |   |       +-group_by_list=
        |   |       | +-y#15 := ColumnRef(type=INT64, column=$groupby.x#13)
        |   |       +-aggregate_list=
        |   |         +-$agg1#14 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-group_by_list=
        |   | +-$uid#19 := ColumnRef(type=INT64, column=$groupby.y#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#16 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$group_selection_threshold_col#22 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#22)
==

# Reject mutated group by $uid column in nested aggregation
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from
  (SELECT count(*), 10+uid as x
   from SimpleTypesWithAnonymizationUid{{ a|}}
   group by x)
--
ALTERNATION GROUP:  a
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-177
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-ProjectScan
        |   +-parse_location=92-176
        |   +-column_list=[$aggregate.$agg1#13, $groupby.x#14]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.x#14, $aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-TableScan(parse_location=129-160, column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias='a')
        |       +-group_by_list=
        |       | +-x#14 :=
        |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       |     +-Literal(parse_location=109-111, type=INT64, value=10)
        |       |     +-ColumnRef(parse_location=112-115, type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       +-aggregate_list=
        |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=99-104)
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from
  (SELECT count(*), @_p1_INT64+uid as x
   from SimpleTypesWithAnonymizationUid a
   group by x)

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'a.uid' [at 3:4]
  (SELECT count(*), 10+uid as x
   ^
--
ALTERNATION GROUP: <empty>
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-175
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-ProjectScan
        |   +-parse_location=92-174
        |   +-column_list=[$aggregate.$agg1#13, $groupby.x#14]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.x#14, $aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-TableScan(parse_location=129-160, column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       +-group_by_list=
        |       | +-x#14 :=
        |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       |     +-Literal(parse_location=109-111, type=INT64, value=10)
        |       |     +-ColumnRef(parse_location=112-115, type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       +-aggregate_list=
        |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=99-104)
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from
  (SELECT count(*), @_p1_INT64+uid as x
   from SimpleTypesWithAnonymizationUid
   group by x)

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid' [at 3:4]
  (SELECT count(*), 10+uid as x
   ^
==

# Valid query using all supported per-user scan types
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from (
  select a.int64, (select 1) as b
  from (
      SELECT count(*) as int64, uid
      from SimpleTypesWithAnonymizationUid
      group by uid) a,
    SimpleTypes b
  where a.int64 > 0 order by a.int64 limit 10);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#35 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#35]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#35]
        +-input_scan=
        | +-LimitOffsetScan
        |   +-column_list=[$aggregate.int64#13, $subquery1.b#34]
        |   +-input_scan=
        |   | +-OrderByScan
        |   |   +-column_list=[$aggregate.int64#13, $subquery1.b#34]
        |   |   +-is_ordered=TRUE
        |   |   +-input_scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$aggregate.int64#13, $groupby.uid#14, $subquery1.b#34]
        |   |   |   +-expr_list=
        |   |   |   | +-b#34 :=
        |   |   |   |   +-SubqueryExpr
        |   |   |   |     +-type=INT64
        |   |   |   |     +-subquery_type=SCALAR
        |   |   |   |     +-subquery=
        |   |   |   |       +-ProjectScan
        |   |   |   |         +-column_list=[$expr_subquery.$col1#33]
        |   |   |   |         +-expr_list=
        |   |   |   |         | +-$col1#33 := Literal(type=INT64, value=1)
        |   |   |   |         +-input_scan=
        |   |   |   |           +-SingleRowScan
        |   |   |   +-input_scan=
        |   |   |     +-FilterScan
        |   |   |       +-column_list=[$aggregate.int64#13, $groupby.uid#14]
        |   |   |       +-input_scan=
        |   |   |       | +-JoinScan
        |   |   |       |   +-column_list=[$aggregate.int64#13, $groupby.uid#14]
        |   |   |       |   +-left_scan=
        |   |   |       |   | +-ProjectScan
        |   |   |       |   |   +-column_list=[$aggregate.int64#13, $groupby.uid#14]
        |   |   |       |   |   +-input_scan=
        |   |   |       |   |     +-AggregateScan
        |   |   |       |   |       +-column_list=[$groupby.uid#14, $aggregate.int64#13]
        |   |   |       |   |       +-input_scan=
        |   |   |       |   |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |   |       |   |       +-group_by_list=
        |   |   |       |   |       | +-uid#14 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |   |   |       |   |       +-aggregate_list=
        |   |   |       |   |         +-int64#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   |   |       |   +-right_scan=
        |   |   |       |     +-TableScan(table=SimpleTypes, alias='b')
        |   |   |       +-filter_expr=
        |   |   |         +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |   |   |           +-ColumnRef(type=INT64, column=$aggregate.int64#13)
        |   |   |           +-Literal(type=INT64, value=0)
        |   |   +-order_by_item_list=
        |   |     +-OrderByItem
        |   |       +-column_ref=
        |   |         +-ColumnRef(type=INT64, column=$aggregate.int64#13)
        |   +-limit=
        |     +-Literal(type=INT64, value=10)
        +-aggregate_list=
          +-$agg1#35 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#35 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#35]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#35]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#37, $group_by.$uid#38]
        |   +-input_scan=
        |   | +-LimitOffsetScan
        |   |   +-column_list=[$aggregate.int64#13, $subquery1.b#34, $groupby.uid#14]
        |   |   +-input_scan=
        |   |   | +-OrderByScan
        |   |   |   +-column_list=[$aggregate.int64#13, $subquery1.b#34, $groupby.uid#14]
        |   |   |   +-is_ordered=TRUE
        |   |   |   +-input_scan=
        |   |   |   | +-ProjectScan
        |   |   |   |   +-column_list=[$aggregate.int64#13, $groupby.uid#14, $subquery1.b#34]
        |   |   |   |   +-expr_list=
        |   |   |   |   | +-b#34 :=
        |   |   |   |   |   +-SubqueryExpr
        |   |   |   |   |     +-type=INT64
        |   |   |   |   |     +-subquery_type=SCALAR
        |   |   |   |   |     +-subquery=
        |   |   |   |   |       +-ProjectScan
        |   |   |   |   |         +-column_list=[$expr_subquery.$col1#33]
        |   |   |   |   |         +-expr_list=
        |   |   |   |   |         | +-$col1#33 := Literal(type=INT64, value=1)
        |   |   |   |   |         +-input_scan=
        |   |   |   |   |           +-SingleRowScan
        |   |   |   |   +-input_scan=
        |   |   |   |     +-FilterScan
        |   |   |   |       +-column_list=[$aggregate.int64#13, $groupby.uid#14]
        |   |   |   |       +-input_scan=
        |   |   |   |       | +-JoinScan
        |   |   |   |       |   +-column_list=[$aggregate.int64#13, $groupby.uid#14]
        |   |   |   |       |   +-left_scan=
        |   |   |   |       |   | +-ProjectScan
        |   |   |   |       |   |   +-column_list=[$aggregate.int64#13, $groupby.uid#14]
        |   |   |   |       |   |   +-input_scan=
        |   |   |   |       |   |     +-AggregateScan
        |   |   |   |       |   |       +-column_list=[$groupby.uid#14, $aggregate.int64#13]
        |   |   |   |       |   |       +-input_scan=
        |   |   |   |       |   |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |   |   |       |   |       +-group_by_list=
        |   |   |   |       |   |       | +-uid#14 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |   |   |   |       |   |       +-aggregate_list=
        |   |   |   |       |   |         +-int64#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   |   |   |       |   +-right_scan=
        |   |   |   |       |     +-TableScan(table=SimpleTypes, alias='b')
        |   |   |   |       +-filter_expr=
        |   |   |   |         +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |   |   |   |           +-ColumnRef(type=INT64, column=$aggregate.int64#13)
        |   |   |   |           +-Literal(type=INT64, value=0)
        |   |   |   +-order_by_item_list=
        |   |   |     +-OrderByItem
        |   |   |       +-column_ref=
        |   |   |         +-ColumnRef(type=INT64, column=$aggregate.int64#13)
        |   |   +-limit=
        |   |     +-Literal(type=INT64, value=10)
        |   +-group_by_list=
        |   | +-$uid#38 := ColumnRef(type=INT64, column=$groupby.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#37 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#35 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#37)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$group_selection_threshold_col#41 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#41)
==

# Outer scan can use join, aggregation, etc. with no issues
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT count(*) from (
  select with differential_privacy count(string, contribution_bounds_per_group => (0,100))
  from SimpleTypesWithAnonymizationUid)
cross join SimpleTypes;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#32 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#32]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#32]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[$aggregate.$agg1#13]
        |   +-left_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#13]
        |   |   +-input_scan=
        |   |     +-DifferentialPrivacyAggregateScan
        |   |       +-column_list=[$aggregate.$agg1#13]
        |   |       +-input_scan=
        |   |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.string#5], table=SimpleTypesWithAnonymizationUid, column_index_list=[4])
        |   |       +-aggregate_list=
        |   |         +-$agg1#13 :=
        |   |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(STRING, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |   |             +-ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)
        |   |             +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        |   +-right_scan=
        |     +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#32 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#32 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#32]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#32]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[$aggregate.$agg1#13]
        |   +-left_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#13]
        |   |   +-input_scan=
        |   |     +-DifferentialPrivacyAggregateScan
        |   |       +-column_list=[$aggregate.$agg1#13]
        |   |       +-input_scan=
        |   |       | +-AggregateScan
        |   |       |   +-column_list=[$aggregate.$agg1_partial#35, $group_by.$uid#36]
        |   |       |   +-input_scan=
        |   |       |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[string#5, uid#33], table=SimpleTypesWithAnonymizationUid, column_index_list=[4, 10])
        |   |       |   +-group_by_list=
        |   |       |   | +-$uid#36 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#33)
        |   |       |   +-aggregate_list=
        |   |       |     +-$agg1_partial#35 :=
        |   |       |       +-AggregateFunctionCall(ZetaSQL:count(STRING) -> INT64)
        |   |       |         +-ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)
        |   |       +-aggregate_list=
        |   |       | +-$agg1#13 :=
        |   |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |   |       | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#35)
        |   |       | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        |   |       | +-$group_selection_threshold_col#39 :=
        |   |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |   |       |     +-Literal(type=INT64, value=1)
        |   |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        |   |       +-group_selection_threshold_expr=
        |   |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#39)
        |   +-right_scan=
        |     +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#32 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==

# Reject parameter privacy_budget_weight
select with differential_privacy count(string, contribution_bounds_per_group => (0,100), @test_param_double)
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator COUNT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRING, STRUCT<INT64, INT64>, DOUBLE. Supported signatures: COUNT(T2, [contribution_bounds_per_group => STRUCT<INT64, INT64>]); COUNT(T2, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="JSON"*/, [contribution_bounds_per_group => STRUCT<INT64, INT64>]); COUNT(T2, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="PROTO"*/, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) [at 1:34]
select with differential_privacy count(string, contribution_bounds_per_group ...
                                 ^
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy
  count(string, contribution_bounds_per_group => (0,100)),
  count(*, contribution_bounds_per_group => (0,1))
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
| +-$aggregate.$agg2#14 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.string#5], table=SimpleTypesWithAnonymizationUid, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#13 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(STRING, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          |   +-ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)
          |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
          +-$agg2#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
| +-$aggregate.$agg2#14 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#17, $aggregate.$agg2_partial#19, $group_by.$uid#20]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[string#5, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[4, 10])
        |   +-group_by_list=
        |   | +-$uid#20 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#17 :=
        |     | +-AggregateFunctionCall(ZetaSQL:count(STRING) -> INT64)
        |     |   +-ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)
        |     +-$agg2_partial#19 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#17)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$agg2#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg2_partial#19)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        | +-$group_selection_threshold_col#24 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#24)
==

# Reject DISTINCT
select with differential_privacy distinct count(int64, contribution_bounds_per_group => (0,10))
from SimpleTypesWithAnonymizationUid;
--
ERROR: SELECT WITH DIFFERENTIAL_PRIVACY does not support DISTINCT [at 1:1]
select with differential_privacy distinct count(int64, contribution_bounds_pe...
^
==

# Allow AS STRUCT syntax
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy as struct count(int64, contribution_bounds_per_group => (0,10))
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$make_struct.$struct#14 AS "$struct" [STRUCT<INT64>]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$make_struct.$struct#14]
    +-expr_list=
    | +-$struct#14 :=
    |   +-MakeStruct
    |     +-type=STRUCT<INT64>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=$aggregate.$agg1#13)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.$agg1#13]
            +-input_scan=
            | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
            +-aggregate_list=
              +-$agg1#13 :=
                +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                  +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
                  +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$make_struct.$struct#14 AS "$struct" [STRUCT<INT64>]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$make_struct.$struct#14]
    +-expr_list=
    | +-$struct#14 :=
    |   +-MakeStruct
    |     +-type=STRUCT<INT64>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=$aggregate.$agg1#13)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$aggregate.$agg1#13]
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$aggregate.$agg1_partial#17, $group_by.$uid#18]
            |   +-input_scan=
            |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
            |   +-group_by_list=
            |   | +-$uid#18 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
            |   +-aggregate_list=
            |     +-$agg1_partial#17 :=
            |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
            |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
            +-aggregate_list=
            | +-$agg1#13 :=
            | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#17)
            | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
            | +-$group_selection_threshold_col#21 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-Literal(type=INT64, value=1)
            |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#21)
==

# Anonymize node saves hint list
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select @{hint_a=1} with DIFFERENTIAL_PRIVACY string
from SimpleTypesWithAnonymizationUid
group @{hint_b=2} by string;
--
QueryStmt
+-output_column_list=
| +-$groupby.string#13 AS string [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.string#13]
    +-hint_list=
    | +-hint_a := Literal(type=INT64, value=1)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$groupby.string#13]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$groupby.string#13]
            +-hint_list=
            | +-hint_b := Literal(type=INT64, value=2)
            +-input_scan=
            | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.string#5], table=SimpleTypesWithAnonymizationUid, column_index_list=[4])
            +-group_by_list=
              +-string#13 := ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.string#13 AS string [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.string#13]
    +-hint_list=
    | +-hint_a := Literal(type=INT64, value=1)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$groupby.string#13]
        +-input_scan=
          +-DifferentialPrivacyAggregateScan
            +-column_list=[$groupby.string#13]
            +-hint_list=
            | +-hint_b := Literal(type=INT64, value=2)
            +-input_scan=
            | +-AggregateScan
            |   +-column_list=[$groupby.string_partial#15, $group_by.$uid#16]
            |   +-input_scan=
            |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[string#5, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[4, 10])
            |   +-group_by_list=
            |     +-string_partial#15 := ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)
            |     +-$uid#16 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
            +-group_by_list=
            | +-string#13 := ColumnRef(type=STRING, column=$groupby.string_partial#15)
            +-aggregate_list=
            | +-$group_selection_threshold_col#18 :=
            |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
            |     +-Literal(type=INT64, value=1)
            |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
            +-group_selection_threshold_expr=
              +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#18)
==

# Computed column arguments are respected
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(int64 + int32, contribution_bounds_per_group => (0,1))
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
              | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              | +-Cast(INT32 -> INT64)
              |   +-ColumnRef(type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |         +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |           +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |           +-Cast(INT32 -> INT64)
        |             +-ColumnRef(type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

# Output computed columns are respected
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*, contribution_bounds_per_group => (0,1)) + int64
from SimpleTypesWithAnonymizationUid
group by int64;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#15 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#15]
    +-expr_list=
    | +-$col1#15 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#13)
    |     +-ColumnRef(type=INT64, column=$groupby.int64#14)
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int64#14, $aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-group_by_list=
        | +-int64#14 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#15 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#15]
    +-expr_list=
    | +-$col1#15 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#13)
    |     +-ColumnRef(type=INT64, column=$groupby.int64#14)
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int64#14, $aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $groupby.int64_partial#19, $group_by.$uid#20]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#16], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-int64_partial#19 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |   | +-$uid#20 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#16)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-group_by_list=
        | +-int64#14 := ColumnRef(type=INT64, column=$groupby.int64_partial#19)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        | +-$group_selection_threshold_col#23 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#23)
==

# Support ArrayScan
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*)
from ArrayWithAnonymizationUid t, t.int64_array a
group by a;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[ArrayWithAnonymizationUid.int64_array#1, $array.a#4]
        |   +-input_scan=
        |   | +-TableScan(column_list=[ArrayWithAnonymizationUid.int64_array#1], table=ArrayWithAnonymizationUid, column_index_list=[0], alias='t')
        |   +-array_expr=
        |   | +-ColumnRef(type=ARRAY<INT64>, column=ArrayWithAnonymizationUid.int64_array#1)
        |   +-element_column=$array.a#4
        +-group_by_list=
        | +-a#6 := ColumnRef(type=INT64, column=$array.a#4)
        +-aggregate_list=
          +-$agg1#5 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#9, $groupby.a_partial#10, $group_by.$uid#11]
        |   +-input_scan=
        |   | +-ArrayScan
        |   |   +-column_list=[ArrayWithAnonymizationUid.int64_array#1, $array.a#4, ArrayWithAnonymizationUid.uid#7]
        |   |   +-input_scan=
        |   |   | +-TableScan(column_list=ArrayWithAnonymizationUid.[int64_array#1, uid#7], table=ArrayWithAnonymizationUid, column_index_list=[0, 2], alias='t')
        |   |   +-array_expr=
        |   |   | +-ColumnRef(type=ARRAY<INT64>, column=ArrayWithAnonymizationUid.int64_array#1)
        |   |   +-element_column=$array.a#4
        |   +-group_by_list=
        |   | +-a_partial#10 := ColumnRef(type=INT64, column=$array.a#4)
        |   | +-$uid#11 := ColumnRef(type=INT64, column=ArrayWithAnonymizationUid.uid#7)
        |   +-aggregate_list=
        |     +-$agg1_partial#9 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-group_by_list=
        | +-a#6 := ColumnRef(type=INT64, column=$groupby.a_partial#10)
        +-aggregate_list=
        | +-$agg1#5 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#9)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#14 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#14)
==

# Support ArrayScan with join_expr
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*)
from ArrayWithAnonymizationUid t inner join unnest(t.int64_array) a on true;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[ArrayWithAnonymizationUid.int64_array#1]
        |   +-input_scan=
        |   | +-TableScan(column_list=[ArrayWithAnonymizationUid.int64_array#1], table=ArrayWithAnonymizationUid, column_index_list=[0], alias='t')
        |   +-array_expr=
        |   | +-ColumnRef(type=ARRAY<INT64>, column=ArrayWithAnonymizationUid.int64_array#1)
        |   +-element_column=$array.a#4
        |   +-join_expr=
        |     +-Literal(type=BOOL, value=true)
        +-aggregate_list=
          +-$agg1#5 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#5]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#8, $group_by.$uid#9]
        |   +-input_scan=
        |   | +-ArrayScan
        |   |   +-column_list=ArrayWithAnonymizationUid.[int64_array#1, uid#6]
        |   |   +-input_scan=
        |   |   | +-TableScan(column_list=ArrayWithAnonymizationUid.[int64_array#1, uid#6], table=ArrayWithAnonymizationUid, column_index_list=[0, 2], alias='t')
        |   |   +-array_expr=
        |   |   | +-ColumnRef(type=ARRAY<INT64>, column=ArrayWithAnonymizationUid.int64_array#1)
        |   |   +-element_column=$array.a#4
        |   |   +-join_expr=
        |   |     +-Literal(type=BOOL, value=true)
        |   +-group_by_list=
        |   | +-$uid#9 := ColumnRef(type=INT64, column=ArrayWithAnonymizationUid.uid#6)
        |   +-aggregate_list=
        |     +-$agg1_partial#8 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#5 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#8)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#12 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#12)
==

# Reject AnalyticScan
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,ANALYTIC_FUNCTIONS]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from (
  select rank() over (order by int64) from SimpleTypesWithAnonymizationUid);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-166
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-ProjectScan
        |   +-parse_location=93-165
        |   +-column_list=[$analytic.$analytic1#14]
        |   +-input_scan=
        |     +-AnalyticScan
        |       +-column_list=[SimpleTypesWithAnonymizationUid.int64#2, $analytic.$analytic1#14]
        |       +-input_scan=
        |       | +-TableScan(parse_location=134-165, column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        |       +-function_group_list=
        |         +-AnalyticFunctionGroup
        |           +-order_by=
        |           | +-WindowOrdering
        |           |   +-order_by_item_list=
        |           |     +-OrderByItem
        |           |       +-column_ref=
        |           |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |           +-analytic_function_list=
        |             +-$analytic1#14 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (
  select rank() over (order by int64) from SimpleTypesWithAnonymizationUid);

Rewrite ERROR: Unsupported scan type inside of SELECT WITH DIFFERENTIAL_PRIVACY from clause: ResolvedAnalyticScan [at 3:3]
  select rank() over (order by int64) from SimpleTypesWithAnonymizationUid);
  ^
==

# Support SampleScan
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,TABLESAMPLE]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from SimpleTypesWithAnonymizationUid
tablesample reservoir (1 rows);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-151
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-SampleScan
        |   +-input_scan=
        |   | +-TableScan(parse_location=89-120, table=SimpleTypesWithAnonymizationUid)
        |   +-method='reservoir'
        |   +-size=
        |   | +-Literal(parse_location=144-145, type=INT64, value=1)
        |   +-unit=ROWS
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from SimpleTypesWithAnonymizationUid
tablesample reservoir (@_p1_INT64 rows);

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-151
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-SampleScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.uid#14]
        |   |   +-input_scan=
        |   |   | +-TableScan(parse_location=89-120, column_list=[SimpleTypesWithAnonymizationUid.uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |   +-method='reservoir'
        |   |   +-size=
        |   |   | +-Literal(parse_location=144-145, type=INT64, value=1)
        |   |   +-unit=ROWS
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

# Support SampleScan
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,TABLESAMPLE]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from SimpleTypesWithAnonymizationUid
tablesample system (cast(@test_param_uint64 as int64) rows) repeatable(10);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-195
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-SampleScan
        |   +-input_scan=
        |   | +-TableScan(parse_location=89-120, table=SimpleTypesWithAnonymizationUid)
        |   +-method='system'
        |   +-size=
        |   | +-Cast(UINT64 -> INT64)
        |   |   +-parse_location=168-173
        |   |   +-Parameter(parse_location=146-164, type=UINT64, name="test_param_uint64")
        |   +-unit=ROWS
        |   +-repeatable_argument=
        |     +-Literal(parse_location=192-194, type=INT64, value=10)
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from SimpleTypesWithAnonymizationUid
tablesample system (cast(@test_param_uint64 as int64) rows) repeatable(@_p1_INT64);

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-195
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-SampleScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.uid#14]
        |   |   +-input_scan=
        |   |   | +-TableScan(parse_location=89-120, column_list=[SimpleTypesWithAnonymizationUid.uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |   +-method='system'
        |   |   +-size=
        |   |   | +-Cast(UINT64 -> INT64)
        |   |   |   +-parse_location=168-173
        |   |   |   +-Parameter(parse_location=146-164, type=UINT64, name="test_param_uint64")
        |   |   +-unit=ROWS
        |   |   +-repeatable_argument=
        |   |     +-Literal(parse_location=192-194, type=INT64, value=10)
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

# Support SampleScan
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,TABLESAMPLE]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from SimpleTypesWithAnonymizationUid
tablesample some_random (1 percent) repeatable(@test_param_int32);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-186
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-SampleScan
        |   +-input_scan=
        |   | +-TableScan(parse_location=89-120, table=SimpleTypesWithAnonymizationUid)
        |   +-method='some_random'
        |   +-size=
        |   | +-Literal(parse_location=146-147, type=INT64, value=1)
        |   +-unit=PERCENT
        |   +-repeatable_argument=
        |     +-Cast(INT32 -> INT64)
        |       +-Parameter(parse_location=168-185, type=INT32, name="test_param_int32")
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from SimpleTypesWithAnonymizationUid
tablesample some_random (@_p1_INT64 percent) repeatable(@test_param_int32);

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-186
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-SampleScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.uid#14]
        |   |   +-input_scan=
        |   |   | +-TableScan(parse_location=89-120, column_list=[SimpleTypesWithAnonymizationUid.uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |   +-method='some_random'
        |   |   +-size=
        |   |   | +-Literal(parse_location=146-147, type=INT64, value=1)
        |   |   +-unit=PERCENT
        |   |   +-repeatable_argument=
        |   |     +-Cast(INT32 -> INT64)
        |   |       +-Parameter(parse_location=168-185, type=INT32, name="test_param_int32")
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

# Support SampleScan
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,TABLESAMPLE,STRATIFIED_RESERVOIR_TABLESAMPLE]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from (select * from SimpleTypesWithAnonymizationUid
      tablesample reservoir (10 rows partition by int32)) tablesample system (1 percent);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-224
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-SampleScan
        |   +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-parse_location=90-192
        |   |   +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |   |   +-input_scan=
        |   |     +-SampleScan
        |   |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |   |       +-input_scan=
        |   |       | +-TableScan(parse_location=104-135, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |   |       +-method='reservoir'
        |   |       +-size=
        |   |       | +-Literal(parse_location=165-167, type=INT64, value=10)
        |   |       +-unit=ROWS
        |   |       +-partition_by_list=
        |   |         +-ColumnRef(parse_location=186-191, type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        |   +-method='system'
        |   +-size=
        |   | +-Literal(parse_location=214-215, type=INT64, value=1)
        |   +-unit=PERCENT
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from SimpleTypesWithAnonymizationUid
      tablesample reservoir (@_p1_INT64 rows partition by int32)) tablesample system (@_p2_INT64 percent);

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-224
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#15, $group_by.$uid#16]
        |   +-input_scan=
        |   | +-SampleScan
        |   |   +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |   |   +-input_scan=
        |   |   | +-ProjectScan
        |   |   |   +-parse_location=90-192
        |   |   |   +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |   |   |   +-input_scan=
        |   |   |     +-SampleScan
        |   |   |       +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |   |   |       +-input_scan=
        |   |   |       | +-TableScan(parse_location=104-135, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |   |   |       +-method='reservoir'
        |   |   |       +-size=
        |   |   |       | +-Literal(parse_location=165-167, type=INT64, value=10)
        |   |   |       +-unit=ROWS
        |   |   |       +-partition_by_list=
        |   |   |         +-ColumnRef(parse_location=186-191, type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        |   |   +-method='system'
        |   |   +-size=
        |   |   | +-Literal(parse_location=214-215, type=INT64, value=1)
        |   |   +-unit=PERCENT
        |   +-group_by_list=
        |   | +-$uid#16 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |   +-aggregate_list=
        |     +-$agg1_partial#15 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#15)
        | |   +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$group_selection_threshold_col#19 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#19)
==

# Support SampleScan
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,TABLESAMPLE]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100)), weight
from SimpleTypesWithAnonymizationUid
tablesample reservoir (100 rows) with weight
group by weight;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#14 AS "$col1" [INT64]
| +-$groupby.weight#15 AS weight [DOUBLE]
+-query=
  +-ProjectScan
    +-parse_location=0-189
    +-column_list=[$aggregate.$agg1#14, $groupby.weight#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.weight#15, $aggregate.$agg1#14]
        +-input_scan=
        | +-SampleScan
        |   +-column_list=[$sample_weight.weight#13]
        |   +-input_scan=
        |   | +-TableScan(parse_location=97-128, table=SimpleTypesWithAnonymizationUid)
        |   +-method='reservoir'
        |   +-size=
        |   | +-Literal(parse_location=152-155, type=INT64, value=100)
        |   +-unit=ROWS
        |   +-weight_column=
        |     +-ColumnHolder(column=$sample_weight.weight#13)
        +-group_by_list=
        | +-weight#15 := ColumnRef(type=DOUBLE, column=$sample_weight.weight#13)
        +-aggregate_list=
          +-$agg1#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT), weight
from SimpleTypesWithAnonymizationUid
tablesample reservoir (@_p1_INT64 rows) with weight
group by weight;

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#14 AS "$col1" [INT64]
| +-$groupby.weight#15 AS weight [DOUBLE]
+-query=
  +-ProjectScan
    +-parse_location=0-189
    +-column_list=[$aggregate.$agg1#14, $groupby.weight#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.weight#15, $aggregate.$agg1#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $groupby.weight_partial#19, $group_by.$uid#20]
        |   +-input_scan=
        |   | +-SampleScan
        |   |   +-column_list=[$sample_weight.weight#13, SimpleTypesWithAnonymizationUid.uid#16]
        |   |   +-input_scan=
        |   |   | +-TableScan(parse_location=97-128, column_list=[SimpleTypesWithAnonymizationUid.uid#16], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |   +-method='reservoir'
        |   |   +-size=
        |   |   | +-Literal(parse_location=152-155, type=INT64, value=100)
        |   |   +-unit=ROWS
        |   |   +-weight_column=
        |   |     +-ColumnHolder(column=$sample_weight.weight#13)
        |   +-group_by_list=
        |   | +-weight_partial#19 := ColumnRef(type=DOUBLE, column=$sample_weight.weight#13)
        |   | +-$uid#20 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#16)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-group_by_list=
        | +-weight#15 := ColumnRef(type=DOUBLE, column=$groupby.weight_partial#19)
        +-aggregate_list=
        | +-$agg1#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$group_selection_threshold_col#23 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#23)
==

# For per-user aggregation we inject SUM(1, contribution_bounds_per_group => (0,1)).
# This test and the next shows what the plan looks like if that aggregate
# expression is actually in the query.  The injected expression is not
# exactly the same as the query's expression.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select WITH DIFFERENTIAL_PRIVACY sum(1, contribution_bounds_per_group => (0,1))
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=INT64, value=1)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-Literal(type=INT64, value=1)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select WITH DIFFERENTIAL_PRIVACY int64, count(*), sum(1, contribution_bounds_per_group => (0,1))
from SimpleTypesWithAnonymizationUid
group by int64;
--
QueryStmt
+-output_column_list=
| +-$groupby.int64#15 AS int64 [INT64]
| +-$aggregate.$agg1#13 AS "$col2" [INT64]
| +-$aggregate.$agg2#14 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.int64#15, $aggregate.$agg1#13, $aggregate.$agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int64#15, $aggregate.$agg1#13, $aggregate.$agg2#14]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-group_by_list=
        | +-int64#15 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
          +-$agg1#13 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
          +-$agg2#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=INT64, value=1)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.int64#15 AS int64 [INT64]
| +-$aggregate.$agg1#13 AS "$col2" [INT64]
| +-$aggregate.$agg2#14 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.int64#15, $aggregate.$agg1#13, $aggregate.$agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int64#15, $aggregate.$agg1#13, $aggregate.$agg2#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $aggregate.$agg2_partial#20, $groupby.int64_partial#21, $group_by.$uid#22]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#16], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-int64_partial#21 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |   | +-$uid#22 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#16)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |     +-$agg2_partial#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-Literal(type=INT64, value=1)
        +-group_by_list=
        | +-int64#15 := ColumnRef(type=INT64, column=$groupby.int64_partial#21)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$agg2#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg2_partial#20)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        | +-$group_selection_threshold_col#26 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#26)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from SimpleTypesWithAnonymizationUid
UNION {{ALL|DISTINCT}}
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from SimpleTypesWithAnonymizationUid
--
ALTERNATION GROUP: ALL
--
QueryStmt
+-output_column_list=
| +-$union_all.count#27 AS count [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.count#27]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.count#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.count#13]
      | |       +-input_scan=
      | |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
      | |       +-aggregate_list=
      | |         +-count#13 :=
      | |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | +-output_column_list=[$aggregate.count#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.count#26]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$aggregate.count#26]
        |       +-input_scan=
        |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |       +-aggregate_list=
        |         +-count#26 :=
        |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        +-output_column_list=[$aggregate.count#26]

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$union_all.count#27 AS count [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.count#27]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.count#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.count#13]
      | |       +-input_scan=
      | |       | +-AggregateScan
      | |       |   +-column_list=[$aggregate.count_partial#30, $group_by.$uid#31]
      | |       |   +-input_scan=
      | |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#28], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
      | |       |   +-group_by_list=
      | |       |   | +-$uid#31 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#28)
      | |       |   +-aggregate_list=
      | |       |     +-count_partial#30 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
      | |       +-aggregate_list=
      | |       | +-count#13 :=
      | |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#30)
      | |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | |       | +-$group_selection_threshold_col#34 :=
      | |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       |     +-Literal(type=INT64, value=1)
      | |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
      | |       +-group_selection_threshold_expr=
      | |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#34)
      | +-output_column_list=[$aggregate.count#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.count#26]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$aggregate.count#26]
        |       +-input_scan=
        |       | +-AggregateScan
        |       |   +-column_list=[$aggregate.count_partial#37, $group_by.$uid#38]
        |       |   +-input_scan=
        |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#35], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       |   +-group_by_list=
        |       |   | +-$uid#38 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#35)
        |       |   +-aggregate_list=
        |       |     +-count_partial#37 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |       +-aggregate_list=
        |       | +-count#26 :=
        |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#37)
        |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        |       | +-$group_selection_threshold_col#41 :=
        |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       |     +-Literal(type=INT64, value=1)
        |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        |       +-group_selection_threshold_expr=
        |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#41)
        +-output_column_list=[$aggregate.count#26]
--
ALTERNATION GROUP: DISTINCT
--
QueryStmt
+-output_column_list=
| +-$union_distinct.count#27 AS count [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_distinct.count#27]
    +-op_type=UNION_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.count#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.count#13]
      | |       +-input_scan=
      | |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
      | |       +-aggregate_list=
      | |         +-count#13 :=
      | |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | +-output_column_list=[$aggregate.count#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.count#26]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$aggregate.count#26]
        |       +-input_scan=
        |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |       +-aggregate_list=
        |         +-count#26 :=
        |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        +-output_column_list=[$aggregate.count#26]

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$union_distinct.count#27 AS count [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_distinct.count#27]
    +-op_type=UNION_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.count#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.count#13]
      | |       +-input_scan=
      | |       | +-AggregateScan
      | |       |   +-column_list=[$aggregate.count_partial#30, $group_by.$uid#31]
      | |       |   +-input_scan=
      | |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#28], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
      | |       |   +-group_by_list=
      | |       |   | +-$uid#31 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#28)
      | |       |   +-aggregate_list=
      | |       |     +-count_partial#30 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
      | |       +-aggregate_list=
      | |       | +-count#13 :=
      | |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#30)
      | |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | |       | +-$group_selection_threshold_col#34 :=
      | |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       |     +-Literal(type=INT64, value=1)
      | |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
      | |       +-group_selection_threshold_expr=
      | |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#34)
      | +-output_column_list=[$aggregate.count#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.count#26]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$aggregate.count#26]
        |       +-input_scan=
        |       | +-AggregateScan
        |       |   +-column_list=[$aggregate.count_partial#37, $group_by.$uid#38]
        |       |   +-input_scan=
        |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#35], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       |   +-group_by_list=
        |       |   | +-$uid#38 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#35)
        |       |   +-aggregate_list=
        |       |     +-count_partial#37 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |       +-aggregate_list=
        |       | +-count#26 :=
        |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#37)
        |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        |       | +-$group_selection_threshold_col#41 :=
        |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       |     +-Literal(type=INT64, value=1)
        |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        |       +-group_selection_threshold_expr=
        |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#41)
        +-output_column_list=[$aggregate.count#26]
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from SimpleTypesWithAnonymizationUid
INTERSECT {{ALL|DISTINCT}}
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from SimpleTypesWithAnonymizationUid
--
ALTERNATION GROUP: ALL
--
QueryStmt
+-output_column_list=
| +-$intersect_all.count#27 AS count [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$intersect_all.count#27]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.count#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.count#13]
      | |       +-input_scan=
      | |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
      | |       +-aggregate_list=
      | |         +-count#13 :=
      | |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | +-output_column_list=[$aggregate.count#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.count#26]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$aggregate.count#26]
        |       +-input_scan=
        |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |       +-aggregate_list=
        |         +-count#26 :=
        |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        +-output_column_list=[$aggregate.count#26]

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$intersect_all.count#27 AS count [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$intersect_all.count#27]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.count#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.count#13]
      | |       +-input_scan=
      | |       | +-AggregateScan
      | |       |   +-column_list=[$aggregate.count_partial#30, $group_by.$uid#31]
      | |       |   +-input_scan=
      | |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#28], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
      | |       |   +-group_by_list=
      | |       |   | +-$uid#31 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#28)
      | |       |   +-aggregate_list=
      | |       |     +-count_partial#30 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
      | |       +-aggregate_list=
      | |       | +-count#13 :=
      | |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#30)
      | |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | |       | +-$group_selection_threshold_col#34 :=
      | |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       |     +-Literal(type=INT64, value=1)
      | |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
      | |       +-group_selection_threshold_expr=
      | |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#34)
      | +-output_column_list=[$aggregate.count#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.count#26]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$aggregate.count#26]
        |       +-input_scan=
        |       | +-AggregateScan
        |       |   +-column_list=[$aggregate.count_partial#37, $group_by.$uid#38]
        |       |   +-input_scan=
        |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#35], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       |   +-group_by_list=
        |       |   | +-$uid#38 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#35)
        |       |   +-aggregate_list=
        |       |     +-count_partial#37 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |       +-aggregate_list=
        |       | +-count#26 :=
        |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#37)
        |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        |       | +-$group_selection_threshold_col#41 :=
        |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       |     +-Literal(type=INT64, value=1)
        |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        |       +-group_selection_threshold_expr=
        |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#41)
        +-output_column_list=[$aggregate.count#26]
--
ALTERNATION GROUP: DISTINCT
--
QueryStmt
+-output_column_list=
| +-$intersect_distinct.count#27 AS count [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$intersect_distinct.count#27]
    +-op_type=INTERSECT_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.count#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.count#13]
      | |       +-input_scan=
      | |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
      | |       +-aggregate_list=
      | |         +-count#13 :=
      | |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | +-output_column_list=[$aggregate.count#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.count#26]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$aggregate.count#26]
        |       +-input_scan=
        |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |       +-aggregate_list=
        |         +-count#26 :=
        |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        +-output_column_list=[$aggregate.count#26]

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$intersect_distinct.count#27 AS count [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$intersect_distinct.count#27]
    +-op_type=INTERSECT_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.count#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.count#13]
      | |       +-input_scan=
      | |       | +-AggregateScan
      | |       |   +-column_list=[$aggregate.count_partial#30, $group_by.$uid#31]
      | |       |   +-input_scan=
      | |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#28], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
      | |       |   +-group_by_list=
      | |       |   | +-$uid#31 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#28)
      | |       |   +-aggregate_list=
      | |       |     +-count_partial#30 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
      | |       +-aggregate_list=
      | |       | +-count#13 :=
      | |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#30)
      | |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | |       | +-$group_selection_threshold_col#34 :=
      | |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       |     +-Literal(type=INT64, value=1)
      | |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
      | |       +-group_selection_threshold_expr=
      | |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#34)
      | +-output_column_list=[$aggregate.count#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.count#26]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$aggregate.count#26]
        |       +-input_scan=
        |       | +-AggregateScan
        |       |   +-column_list=[$aggregate.count_partial#37, $group_by.$uid#38]
        |       |   +-input_scan=
        |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#35], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       |   +-group_by_list=
        |       |   | +-$uid#38 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#35)
        |       |   +-aggregate_list=
        |       |     +-count_partial#37 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |       +-aggregate_list=
        |       | +-count#26 :=
        |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#37)
        |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        |       | +-$group_selection_threshold_col#41 :=
        |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       |     +-Literal(type=INT64, value=1)
        |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        |       +-group_selection_threshold_expr=
        |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#41)
        +-output_column_list=[$aggregate.count#26]
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from SimpleTypesWithAnonymizationUid
EXCEPT {{ALL|DISTINCT}}
SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
from SimpleTypesWithAnonymizationUid
--
ALTERNATION GROUP: ALL
--
QueryStmt
+-output_column_list=
| +-$except_all.count#27 AS count [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$except_all.count#27]
    +-op_type=EXCEPT_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.count#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.count#13]
      | |       +-input_scan=
      | |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
      | |       +-aggregate_list=
      | |         +-count#13 :=
      | |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | +-output_column_list=[$aggregate.count#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.count#26]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$aggregate.count#26]
        |       +-input_scan=
        |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |       +-aggregate_list=
        |         +-count#26 :=
        |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        +-output_column_list=[$aggregate.count#26]

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$except_all.count#27 AS count [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$except_all.count#27]
    +-op_type=EXCEPT_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.count#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.count#13]
      | |       +-input_scan=
      | |       | +-AggregateScan
      | |       |   +-column_list=[$aggregate.count_partial#30, $group_by.$uid#31]
      | |       |   +-input_scan=
      | |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#28], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
      | |       |   +-group_by_list=
      | |       |   | +-$uid#31 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#28)
      | |       |   +-aggregate_list=
      | |       |     +-count_partial#30 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
      | |       +-aggregate_list=
      | |       | +-count#13 :=
      | |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#30)
      | |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | |       | +-$group_selection_threshold_col#34 :=
      | |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       |     +-Literal(type=INT64, value=1)
      | |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
      | |       +-group_selection_threshold_expr=
      | |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#34)
      | +-output_column_list=[$aggregate.count#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.count#26]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$aggregate.count#26]
        |       +-input_scan=
        |       | +-AggregateScan
        |       |   +-column_list=[$aggregate.count_partial#37, $group_by.$uid#38]
        |       |   +-input_scan=
        |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#35], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       |   +-group_by_list=
        |       |   | +-$uid#38 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#35)
        |       |   +-aggregate_list=
        |       |     +-count_partial#37 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |       +-aggregate_list=
        |       | +-count#26 :=
        |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#37)
        |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        |       | +-$group_selection_threshold_col#41 :=
        |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       |     +-Literal(type=INT64, value=1)
        |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        |       +-group_selection_threshold_expr=
        |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#41)
        +-output_column_list=[$aggregate.count#26]
--
ALTERNATION GROUP: DISTINCT
--
QueryStmt
+-output_column_list=
| +-$except_distinct.count#27 AS count [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$except_distinct.count#27]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.count#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.count#13]
      | |       +-input_scan=
      | |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
      | |       +-aggregate_list=
      | |         +-count#13 :=
      | |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | +-output_column_list=[$aggregate.count#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.count#26]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$aggregate.count#26]
        |       +-input_scan=
        |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |       +-aggregate_list=
        |         +-count#26 :=
        |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        +-output_column_list=[$aggregate.count#26]

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$except_distinct.count#27 AS count [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$except_distinct.count#27]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.count#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.count#13]
      | |       +-input_scan=
      | |       | +-AggregateScan
      | |       |   +-column_list=[$aggregate.count_partial#30, $group_by.$uid#31]
      | |       |   +-input_scan=
      | |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#28], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
      | |       |   +-group_by_list=
      | |       |   | +-$uid#31 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#28)
      | |       |   +-aggregate_list=
      | |       |     +-count_partial#30 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
      | |       +-aggregate_list=
      | |       | +-count#13 :=
      | |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#30)
      | |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | |       | +-$group_selection_threshold_col#34 :=
      | |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       |     +-Literal(type=INT64, value=1)
      | |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
      | |       +-group_selection_threshold_expr=
      | |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#34)
      | +-output_column_list=[$aggregate.count#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.count#26]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$aggregate.count#26]
        |       +-input_scan=
        |       | +-AggregateScan
        |       |   +-column_list=[$aggregate.count_partial#37, $group_by.$uid#38]
        |       |   +-input_scan=
        |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#35], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       |   +-group_by_list=
        |       |   | +-$uid#38 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#35)
        |       |   +-aggregate_list=
        |       |     +-count_partial#37 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |       +-aggregate_list=
        |       | +-count#26 :=
        |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#37)
        |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        |       | +-$group_selection_threshold_col#41 :=
        |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       |     +-Literal(type=INT64, value=1)
        |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        |       +-group_selection_threshold_expr=
        |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#41)
        +-output_column_list=[$aggregate.count#26]
==

# Anonymization in the WITH clause
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
WITH t as (SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
           from SimpleTypesWithAnonymizationUid)
SELECT * from t;
--
QueryStmt
+-output_column_list=
| +-t.count#14 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[t.count#14]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[$aggregate.count#13]
    |       +-input_scan=
    |         +-DifferentialPrivacyAggregateScan
    |           +-column_list=[$aggregate.count#13]
    |           +-input_scan=
    |           | +-TableScan(table=SimpleTypesWithAnonymizationUid)
    |           +-aggregate_list=
    |             +-count#13 :=
    |               +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    |                 +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
    +-query=
      +-ProjectScan
        +-column_list=[t.count#14]
        +-input_scan=
          +-WithRefScan(column_list=[t.count#14], with_query_name='t')

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-t.count#14 AS count [INT64]
+-query=
  +-WithScan
    +-column_list=[t.count#14]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[$aggregate.count#13]
    |       +-input_scan=
    |         +-DifferentialPrivacyAggregateScan
    |           +-column_list=[$aggregate.count#13]
    |           +-input_scan=
    |           | +-AggregateScan
    |           |   +-column_list=[$aggregate.count_partial#17, $group_by.$uid#18]
    |           |   +-input_scan=
    |           |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
    |           |   +-group_by_list=
    |           |   | +-$uid#18 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
    |           |   +-aggregate_list=
    |           |     +-count_partial#17 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
    |           +-aggregate_list=
    |           | +-count#13 :=
    |           | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    |           | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#17)
    |           | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
    |           | +-$group_selection_threshold_col#21 :=
    |           |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
    |           |     +-Literal(type=INT64, value=1)
    |           |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
    |           +-group_selection_threshold_expr=
    |             +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#21)
    +-query=
      +-ProjectScan
        +-column_list=[t.count#14]
        +-input_scan=
          +-WithRefScan(column_list=[t.count#14], with_query_name='t')
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT *
FROM UNNEST(ARRAY(SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
                  from SimpleTypesWithAnonymizationUid));
--
QueryStmt
+-output_column_list=
| +-$array.$unnest1#14 AS "$unnest1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$array.$unnest1#14]
    +-input_scan=
      +-ArrayScan
        +-column_list=[$array.$unnest1#14]
        +-array_expr=
        | +-SubqueryExpr
        |   +-type=ARRAY<INT64>
        |   +-subquery_type=ARRAY
        |   +-subquery=
        |     +-ProjectScan
        |       +-column_list=[$aggregate.count#13]
        |       +-input_scan=
        |         +-DifferentialPrivacyAggregateScan
        |           +-column_list=[$aggregate.count#13]
        |           +-input_scan=
        |           | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |           +-aggregate_list=
        |             +-count#13 :=
        |               +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |                 +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        +-element_column=$array.$unnest1#14

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$array.$unnest1#14 AS "$unnest1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$array.$unnest1#14]
    +-input_scan=
      +-ArrayScan
        +-column_list=[$array.$unnest1#14]
        +-array_expr=
        | +-SubqueryExpr
        |   +-type=ARRAY<INT64>
        |   +-subquery_type=ARRAY
        |   +-subquery=
        |     +-ProjectScan
        |       +-column_list=[$aggregate.count#13]
        |       +-input_scan=
        |         +-DifferentialPrivacyAggregateScan
        |           +-column_list=[$aggregate.count#13]
        |           +-input_scan=
        |           | +-AggregateScan
        |           |   +-column_list=[$aggregate.count_partial#17, $group_by.$uid#18]
        |           |   +-input_scan=
        |           |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |           |   +-group_by_list=
        |           |   | +-$uid#18 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        |           |   +-aggregate_list=
        |           |     +-count_partial#17 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |           +-aggregate_list=
        |           | +-count#13 :=
        |           | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |           | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#17)
        |           | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        |           | +-$group_selection_threshold_col#21 :=
        |           |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |           |     +-Literal(type=INT64, value=1)
        |           |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        |           +-group_selection_threshold_expr=
        |             +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#21)
        +-element_column=$array.$unnest1#14
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT *
FROM UNNEST([1]) as u
WHERE EXISTS (SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
                  from SimpleTypesWithAnonymizationUid);
--
QueryStmt
+-output_column_list=
| +-$array.u#1 AS u [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$array.u#1]
    +-input_scan=
      +-FilterScan
        +-column_list=[$array.u#1]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[$array.u#1]
        |   +-array_expr=
        |   | +-Literal(type=ARRAY<INT64>, value=[1])
        |   +-element_column=$array.u#1
        +-filter_expr=
          +-SubqueryExpr
            +-type=BOOL
            +-subquery_type=EXISTS
            +-subquery=
              +-ProjectScan
                +-column_list=[$aggregate.count#14]
                +-input_scan=
                  +-DifferentialPrivacyAggregateScan
                    +-column_list=[$aggregate.count#14]
                    +-input_scan=
                    | +-TableScan(table=SimpleTypesWithAnonymizationUid)
                    +-aggregate_list=
                      +-count#14 :=
                        +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                          +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$array.u#1 AS u [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$array.u#1]
    +-input_scan=
      +-FilterScan
        +-column_list=[$array.u#1]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[$array.u#1]
        |   +-array_expr=
        |   | +-Literal(type=ARRAY<INT64>, value=[1])
        |   +-element_column=$array.u#1
        +-filter_expr=
          +-SubqueryExpr
            +-type=BOOL
            +-subquery_type=EXISTS
            +-subquery=
              +-ProjectScan
                +-column_list=[$aggregate.count#14]
                +-input_scan=
                  +-DifferentialPrivacyAggregateScan
                    +-column_list=[$aggregate.count#14]
                    +-input_scan=
                    | +-AggregateScan
                    |   +-column_list=[$aggregate.count_partial#17, $group_by.$uid#18]
                    |   +-input_scan=
                    |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
                    |   +-group_by_list=
                    |   | +-$uid#18 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
                    |   +-aggregate_list=
                    |     +-count_partial#17 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
                    +-aggregate_list=
                    | +-count#14 :=
                    | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                    | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#17)
                    | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
                    | +-$group_selection_threshold_col#21 :=
                    |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                    |     +-Literal(type=INT64, value=1)
                    |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
                    +-group_selection_threshold_expr=
                      +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#21)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT *
FROM UNNEST([1]) as u
WHERE u IN (SELECT WITH DIFFERENTIAL_PRIVACY count(*) as count
            from SimpleTypesWithAnonymizationUid);
--
QueryStmt
+-output_column_list=
| +-$array.u#1 AS u [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$array.u#1]
    +-input_scan=
      +-FilterScan
        +-column_list=[$array.u#1]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[$array.u#1]
        |   +-array_expr=
        |   | +-Literal(type=ARRAY<INT64>, value=[1])
        |   +-element_column=$array.u#1
        +-filter_expr=
          +-SubqueryExpr
            +-type=BOOL
            +-subquery_type=IN
            +-in_expr=
            | +-ColumnRef(type=INT64, column=$array.u#1)
            +-subquery=
              +-ProjectScan
                +-column_list=[$aggregate.count#14]
                +-input_scan=
                  +-DifferentialPrivacyAggregateScan
                    +-column_list=[$aggregate.count#14]
                    +-input_scan=
                    | +-TableScan(table=SimpleTypesWithAnonymizationUid)
                    +-aggregate_list=
                      +-count#14 :=
                        +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                          +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$array.u#1 AS u [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$array.u#1]
    +-input_scan=
      +-FilterScan
        +-column_list=[$array.u#1]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[$array.u#1]
        |   +-array_expr=
        |   | +-Literal(type=ARRAY<INT64>, value=[1])
        |   +-element_column=$array.u#1
        +-filter_expr=
          +-SubqueryExpr
            +-type=BOOL
            +-subquery_type=IN
            +-in_expr=
            | +-ColumnRef(type=INT64, column=$array.u#1)
            +-subquery=
              +-ProjectScan
                +-column_list=[$aggregate.count#14]
                +-input_scan=
                  +-DifferentialPrivacyAggregateScan
                    +-column_list=[$aggregate.count#14]
                    +-input_scan=
                    | +-AggregateScan
                    |   +-column_list=[$aggregate.count_partial#17, $group_by.$uid#18]
                    |   +-input_scan=
                    |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
                    |   +-group_by_list=
                    |   | +-$uid#18 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
                    |   +-aggregate_list=
                    |     +-count_partial#17 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
                    +-aggregate_list=
                    | +-count#14 :=
                    | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                    | |   +-ColumnRef(type=INT64, column=$aggregate.count_partial#17)
                    | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
                    | +-$group_selection_threshold_col#21 :=
                    |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
                    |     +-Literal(type=INT64, value=1)
                    |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
                    +-group_selection_threshold_expr=
                      +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#21)
==

# Anonymized query against a PROTO value table that does not explicitly
# select any columns.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY count(*)
FROM KitchenSinkWithUidValueTable;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-TableScan(table=KitchenSinkWithUidValueTable)
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#6, $group_by.$uid#7]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$table_scan.$value#3, $project.$string_val#4]
        |   |   +-expr_list=
        |   |   | +-$string_val#4 :=
        |   |   |   +-GetProtoField
        |   |   |     +-type=STRING
        |   |   |     +-expr=
        |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=$table_scan.$value#3)
        |   |   |     +-field_descriptor=string_val
        |   |   |     +-default_value='default_name'
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[$table_scan.$value#3], table=KitchenSinkWithUidValueTable, column_index_list=[0])
        |   +-group_by_list=
        |   | +-$uid#7 := ColumnRef(type=STRING, column=$project.$string_val#4)
        |   +-aggregate_list=
        |     +-$agg1_partial#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#2 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#6)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#10 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#10)
==

# Anonymized query against a PROTO value table that explicitly references
# non-userid columns (the userid column is 'string_val').
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY int32_val, SUM(int64_val)
FROM KitchenSinkWithUidValueTable
GROUP BY int32_val;
--
QueryStmt
+-output_column_list=
| +-$groupby.int32_val#3 AS int32_val [INT32]
| +-$aggregate.$agg1#2 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.int32_val#3, $aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32_val#3, $aggregate.$agg1#2]
        +-input_scan=
        | +-TableScan(column_list=[KitchenSinkWithUidValueTable.value#1], table=KitchenSinkWithUidValueTable, column_index_list=[0])
        +-group_by_list=
        | +-int32_val#3 :=
        |   +-GetProtoField
        |     +-type=INT32
        |     +-expr=
        |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
        |     +-field_descriptor=int32_val
        |     +-default_value=77
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-GetProtoField
              | +-type=INT64
              | +-expr=
              | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
              | +-field_descriptor=int64_val
              | +-default_value=0
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.int32_val#3 AS int32_val [INT32]
| +-$aggregate.$agg1#2 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.int32_val#3, $aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32_val#3, $aggregate.$agg1#2]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#6, $groupby.int32_val_partial#7, $group_by.$uid#8]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KitchenSinkWithUidValueTable.value#1, $project.$string_val#4]
        |   |   +-expr_list=
        |   |   | +-$string_val#4 :=
        |   |   |   +-GetProtoField
        |   |   |     +-type=STRING
        |   |   |     +-expr=
        |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
        |   |   |     +-field_descriptor=string_val
        |   |   |     +-default_value='default_name'
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[KitchenSinkWithUidValueTable.value#1], table=KitchenSinkWithUidValueTable, column_index_list=[0])
        |   +-group_by_list=
        |   | +-int32_val_partial#7 :=
        |   | | +-GetProtoField
        |   | |   +-type=INT32
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
        |   | |   +-field_descriptor=int32_val
        |   | |   +-default_value=77
        |   | +-$uid#8 := ColumnRef(type=STRING, column=$project.$string_val#4)
        |   +-aggregate_list=
        |     +-$agg1_partial#6 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-GetProtoField
        |           +-type=INT64
        |           +-expr=
        |           | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
        |           +-field_descriptor=int64_val
        |           +-default_value=0
        +-group_by_list=
        | +-int32_val#3 := ColumnRef(type=INT32, column=$groupby.int32_val_partial#7)
        +-aggregate_list=
        | +-$agg1#2 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#6)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#11 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#11)
==

# Anonymized query against a PROTO value table that explicitly references
# userid and non-userid columns (the userid column is 'string_val').
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY int64_val, COUNT(string_val)
FROM KitchenSinkWithUidValueTable
GROUP BY int64_val;
--
QueryStmt
+-output_column_list=
| +-$groupby.int64_val#3 AS int64_val [INT64]
| +-$aggregate.$agg1#2 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.int64_val#3, $aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int64_val#3, $aggregate.$agg1#2]
        +-input_scan=
        | +-TableScan(column_list=[KitchenSinkWithUidValueTable.value#1], table=KitchenSinkWithUidValueTable, column_index_list=[0])
        +-group_by_list=
        | +-int64_val#3 :=
        |   +-GetProtoField
        |     +-type=INT64
        |     +-expr=
        |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
        |     +-field_descriptor=int64_val
        |     +-default_value=0
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(STRING, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-GetProtoField
              | +-type=STRING
              | +-expr=
              | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
              | +-field_descriptor=string_val
              | +-default_value='default_name'
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.int64_val#3 AS int64_val [INT64]
| +-$aggregate.$agg1#2 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.int64_val#3, $aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int64_val#3, $aggregate.$agg1#2]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#6, $groupby.int64_val_partial#7, $group_by.$uid#8]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[KitchenSinkWithUidValueTable.value#1, $project.$string_val#4]
        |   |   +-expr_list=
        |   |   | +-$string_val#4 :=
        |   |   |   +-GetProtoField
        |   |   |     +-type=STRING
        |   |   |     +-expr=
        |   |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
        |   |   |     +-field_descriptor=string_val
        |   |   |     +-default_value='default_name'
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[KitchenSinkWithUidValueTable.value#1], table=KitchenSinkWithUidValueTable, column_index_list=[0])
        |   +-group_by_list=
        |   | +-int64_val_partial#7 :=
        |   | | +-GetProtoField
        |   | |   +-type=INT64
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
        |   | |   +-field_descriptor=int64_val
        |   | |   +-default_value=0
        |   | +-$uid#8 := ColumnRef(type=STRING, column=$project.$string_val#4)
        |   +-aggregate_list=
        |     +-$agg1_partial#6 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(STRING) -> INT64)
        |         +-GetProtoField
        |           +-type=STRING
        |           +-expr=
        |           | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
        |           +-field_descriptor=string_val
        |           +-default_value='default_name'
        +-group_by_list=
        | +-int64_val#3 := ColumnRef(type=INT64, column=$groupby.int64_val_partial#7)
        +-aggregate_list=
        | +-$agg1#2 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#6)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#11 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#11)
==

# Anonymized query against a PROTO value table that explicitly projects userid
# columns (the userid column is 'string_val').
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY count(*)
FROM (SELECT string_val
  FROM KitchenSinkWithUidValueTable);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$subquery1.string_val#2]
        |   +-expr_list=
        |   | +-string_val#2 :=
        |   |   +-GetProtoField
        |   |     +-type=STRING
        |   |     +-expr=
        |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
        |   |     +-field_descriptor=string_val
        |   |     +-default_value='default_name'
        |   +-input_scan=
        |     +-TableScan(column_list=[KitchenSinkWithUidValueTable.value#1], table=KitchenSinkWithUidValueTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#6, $group_by.$uid#7]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.string_val#2]
        |   |   +-expr_list=
        |   |   | +-string_val#2 := ColumnRef(type=STRING, column=$project.$string_val#4)
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[KitchenSinkWithUidValueTable.value#1, $project.$string_val#4]
        |   |       +-expr_list=
        |   |       | +-$string_val#4 :=
        |   |       |   +-GetProtoField
        |   |       |     +-type=STRING
        |   |       |     +-expr=
        |   |       |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
        |   |       |     +-field_descriptor=string_val
        |   |       |     +-default_value='default_name'
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=[KitchenSinkWithUidValueTable.value#1], table=KitchenSinkWithUidValueTable, column_index_list=[0])
        |   +-group_by_list=
        |   | +-$uid#7 := ColumnRef(type=STRING, column=$subquery1.string_val#2)
        |   +-aggregate_list=
        |     +-$agg1_partial#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#3 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#6)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#10 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#10)
==

# Anonymized query against a PROTO value table that explicitly aggregates userid
# columns (the userid column is 'string_val').
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY count(*)
FROM (SELECT count(*), string_val
  FROM KitchenSinkWithUidValueTable
  GROUP BY string_val);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#2, $groupby.string_val#3]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.string_val#3, $aggregate.$agg1#2]
        |       +-input_scan=
        |       | +-TableScan(column_list=[KitchenSinkWithUidValueTable.value#1], table=KitchenSinkWithUidValueTable, column_index_list=[0])
        |       +-group_by_list=
        |       | +-string_val#3 :=
        |       |   +-GetProtoField
        |       |     +-type=STRING
        |       |     +-expr=
        |       |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
        |       |     +-field_descriptor=string_val
        |       |     +-default_value='default_name'
        |       +-aggregate_list=
        |         +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#7, $group_by.$uid#8]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#2, $groupby.string_val#3]
        |   |   +-input_scan=
        |   |     +-AggregateScan
        |   |       +-column_list=[$groupby.string_val#3, $aggregate.$agg1#2]
        |   |       +-input_scan=
        |   |       | +-ProjectScan
        |   |       |   +-column_list=[KitchenSinkWithUidValueTable.value#1, $project.$string_val#5]
        |   |       |   +-expr_list=
        |   |       |   | +-$string_val#5 :=
        |   |       |   |   +-GetProtoField
        |   |       |   |     +-type=STRING
        |   |       |   |     +-expr=
        |   |       |   |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=KitchenSinkWithUidValueTable.value#1)
        |   |       |   |     +-field_descriptor=string_val
        |   |       |   |     +-default_value='default_name'
        |   |       |   +-input_scan=
        |   |       |     +-TableScan(column_list=[KitchenSinkWithUidValueTable.value#1], table=KitchenSinkWithUidValueTable, column_index_list=[0])
        |   |       +-group_by_list=
        |   |       | +-string_val#3 := ColumnRef(type=STRING, column=$project.$string_val#5)
        |   |       +-aggregate_list=
        |   |         +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-group_by_list=
        |   | +-$uid#8 := ColumnRef(type=STRING, column=$groupby.string_val#3)
        |   +-aggregate_list=
        |     +-$agg1_partial#7 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#4 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#7)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#11 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#11)
==

# Anonymized query against a PROTO value table qualifies userid column errors.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY count(*)
FROM (SELECT WITH DIFFERENTIAL_PRIVACY count(*)
  FROM KitchenSinkWithUidValueTable AS t);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#2]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$aggregate.$agg1#2]
        |       +-input_scan=
        |       | +-TableScan(table=KitchenSinkWithUidValueTable, alias='t')
        |       +-aggregate_list=
        |         +-$agg1#2 :=
        |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 't.string_val'
==

# Anonymized query against a STRUCT value table that does not explicitly
# reference any columns.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY count(*)
FROM TestStructWithUidValueTable;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-TableScan(table=TestStructWithUidValueTable)
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#6, $group_by.$uid#7]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$table_scan.$value#3, $project.$a#4]
        |   |   +-expr_list=
        |   |   | +-$a#4 :=
        |   |   |   +-GetStructField
        |   |   |     +-type=INT32
        |   |   |     +-expr=
        |   |   |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$table_scan.$value#3)
        |   |   |     +-field_idx=0
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[$table_scan.$value#3], table=TestStructWithUidValueTable, column_index_list=[0])
        |   +-group_by_list=
        |   | +-$uid#7 := ColumnRef(type=INT32, column=$project.$a#4)
        |   +-aggregate_list=
        |     +-$agg1_partial#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#2 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#6)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#10 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#10)
==

# Anonymized query against a STRUCT value table that explicitly references
# non-userid columns (the userid column is 'a').
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY b, COUNT(*)
FROM TestStructWithUidValueTable
GROUP BY b;
--
QueryStmt
+-output_column_list=
| +-$groupby.b#3 AS b [STRING]
| +-$aggregate.$agg1#2 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.b#3, $aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.b#3, $aggregate.$agg1#2]
        +-input_scan=
        | +-TableScan(column_list=[TestStructWithUidValueTable.value#1], table=TestStructWithUidValueTable, column_index_list=[0])
        +-group_by_list=
        | +-b#3 :=
        |   +-GetStructField
        |     +-type=STRING
        |     +-expr=
        |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructWithUidValueTable.value#1)
        |     +-field_idx=1
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.b#3 AS b [STRING]
| +-$aggregate.$agg1#2 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.b#3, $aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.b#3, $aggregate.$agg1#2]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#6, $groupby.b_partial#7, $group_by.$uid#8]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[TestStructWithUidValueTable.value#1, $project.$a#4]
        |   |   +-expr_list=
        |   |   | +-$a#4 :=
        |   |   |   +-GetStructField
        |   |   |     +-type=INT32
        |   |   |     +-expr=
        |   |   |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructWithUidValueTable.value#1)
        |   |   |     +-field_idx=0
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[TestStructWithUidValueTable.value#1], table=TestStructWithUidValueTable, column_index_list=[0])
        |   +-group_by_list=
        |   | +-b_partial#7 :=
        |   | | +-GetStructField
        |   | |   +-type=STRING
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructWithUidValueTable.value#1)
        |   | |   +-field_idx=1
        |   | +-$uid#8 := ColumnRef(type=INT32, column=$project.$a#4)
        |   +-aggregate_list=
        |     +-$agg1_partial#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-group_by_list=
        | +-b#3 := ColumnRef(type=STRING, column=$groupby.b_partial#7)
        +-aggregate_list=
        | +-$agg1#2 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#6)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#11 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#11)
==

# Anonymized query against a STRUCT value table that explicitly references
# userid and non-userid columns.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY b, SUM(a)
FROM TestStructWithUidValueTable
GROUP BY b;
--
QueryStmt
+-output_column_list=
| +-$groupby.b#3 AS b [STRING]
| +-$aggregate.$agg1#2 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.b#3, $aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.b#3, $aggregate.$agg1#2]
        +-input_scan=
        | +-TableScan(column_list=[TestStructWithUidValueTable.value#1], table=TestStructWithUidValueTable, column_index_list=[0])
        +-group_by_list=
        | +-b#3 :=
        |   +-GetStructField
        |     +-type=STRING
        |     +-expr=
        |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructWithUidValueTable.value#1)
        |     +-field_idx=1
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Cast(INT32 -> INT64)
              | +-GetStructField
              |   +-type=INT32
              |   +-expr=
              |   | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructWithUidValueTable.value#1)
              |   +-field_idx=0
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.b#3 AS b [STRING]
| +-$aggregate.$agg1#2 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.b#3, $aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.b#3, $aggregate.$agg1#2]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#6, $groupby.b_partial#7, $group_by.$uid#8]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[TestStructWithUidValueTable.value#1, $project.$a#4]
        |   |   +-expr_list=
        |   |   | +-$a#4 :=
        |   |   |   +-GetStructField
        |   |   |     +-type=INT32
        |   |   |     +-expr=
        |   |   |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructWithUidValueTable.value#1)
        |   |   |     +-field_idx=0
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[TestStructWithUidValueTable.value#1], table=TestStructWithUidValueTable, column_index_list=[0])
        |   +-group_by_list=
        |   | +-b_partial#7 :=
        |   | | +-GetStructField
        |   | |   +-type=STRING
        |   | |   +-expr=
        |   | |   | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructWithUidValueTable.value#1)
        |   | |   +-field_idx=1
        |   | +-$uid#8 := ColumnRef(type=INT32, column=$project.$a#4)
        |   +-aggregate_list=
        |     +-$agg1_partial#6 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-Cast(INT32 -> INT64)
        |           +-GetStructField
        |             +-type=INT32
        |             +-expr=
        |             | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructWithUidValueTable.value#1)
        |             +-field_idx=0
        +-group_by_list=
        | +-b#3 := ColumnRef(type=STRING, column=$groupby.b_partial#7)
        +-aggregate_list=
        | +-$agg1#2 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#6)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#11 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#11)
==

# Anonymized query against a STRUCT value table that explicitly projects userid
# columns (the userid column is 'a').
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY count(*)
FROM (SELECT a
  FROM TestStructWithUidValueTable);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$subquery1.a#2]
        |   +-expr_list=
        |   | +-a#2 :=
        |   |   +-GetStructField
        |   |     +-type=INT32
        |   |     +-expr=
        |   |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructWithUidValueTable.value#1)
        |   |     +-field_idx=0
        |   +-input_scan=
        |     +-TableScan(column_list=[TestStructWithUidValueTable.value#1], table=TestStructWithUidValueTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#6, $group_by.$uid#7]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.a#2]
        |   |   +-expr_list=
        |   |   | +-a#2 := ColumnRef(type=INT32, column=$project.$a#4)
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[TestStructWithUidValueTable.value#1, $project.$a#4]
        |   |       +-expr_list=
        |   |       | +-$a#4 :=
        |   |       |   +-GetStructField
        |   |       |     +-type=INT32
        |   |       |     +-expr=
        |   |       |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructWithUidValueTable.value#1)
        |   |       |     +-field_idx=0
        |   |       +-input_scan=
        |   |         +-TableScan(column_list=[TestStructWithUidValueTable.value#1], table=TestStructWithUidValueTable, column_index_list=[0])
        |   +-group_by_list=
        |   | +-$uid#7 := ColumnRef(type=INT32, column=$subquery1.a#2)
        |   +-aggregate_list=
        |     +-$agg1_partial#6 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#3 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#6)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#10 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#10)
==

# Anonymized query against a STRUCT value table that explicitly aggregates userid
# columns (the userid column is 'a').
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY count(*)
FROM (SELECT count(*), a
  FROM TestStructWithUidValueTable
  GROUP BY a);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#2, $groupby.a#3]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.a#3, $aggregate.$agg1#2]
        |       +-input_scan=
        |       | +-TableScan(column_list=[TestStructWithUidValueTable.value#1], table=TestStructWithUidValueTable, column_index_list=[0])
        |       +-group_by_list=
        |       | +-a#3 :=
        |       |   +-GetStructField
        |       |     +-type=INT32
        |       |     +-expr=
        |       |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructWithUidValueTable.value#1)
        |       |     +-field_idx=0
        |       +-aggregate_list=
        |         +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#7, $group_by.$uid#8]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#2, $groupby.a#3]
        |   |   +-input_scan=
        |   |     +-AggregateScan
        |   |       +-column_list=[$groupby.a#3, $aggregate.$agg1#2]
        |   |       +-input_scan=
        |   |       | +-ProjectScan
        |   |       |   +-column_list=[TestStructWithUidValueTable.value#1, $project.$a#5]
        |   |       |   +-expr_list=
        |   |       |   | +-$a#5 :=
        |   |       |   |   +-GetStructField
        |   |       |   |     +-type=INT32
        |   |       |   |     +-expr=
        |   |       |   |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=TestStructWithUidValueTable.value#1)
        |   |       |   |     +-field_idx=0
        |   |       |   +-input_scan=
        |   |       |     +-TableScan(column_list=[TestStructWithUidValueTable.value#1], table=TestStructWithUidValueTable, column_index_list=[0])
        |   |       +-group_by_list=
        |   |       | +-a#3 := ColumnRef(type=INT32, column=$project.$a#5)
        |   |       +-aggregate_list=
        |   |         +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-group_by_list=
        |   | +-$uid#8 := ColumnRef(type=INT32, column=$groupby.a#3)
        |   +-aggregate_list=
        |     +-$agg1_partial#7 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#4 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#7)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#11 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#11)
==

# Anonymized query against a STRUCT value table qualifies userid column errors.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY count(*)
FROM (SELECT count(*)
  FROM TestStructWithUidValueTable AS t);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#2]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#2]
        |       +-input_scan=
        |       | +-TableScan(table=TestStructWithUidValueTable, alias='t')
        |       +-aggregate_list=
        |         +-$agg1#2 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 't.a'
==

# Nested anonymization
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from
  ((select with differential_privacy count(*), uid
       from SimpleTypesWithAnonymizationUid group by uid) a
  inner join
  (SELECT WITH DIFFERENTIAL_PRIVACY count(*), uid from SimpleTypesWithAnonymizationUid group by uid) b
  on a.uid = b.uid);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#29 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#29]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#29]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[$aggregate.$agg1#13, $groupby.uid#14, $aggregate.$agg1#27, $groupby.uid#28]
        |   +-left_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#13, $groupby.uid#14]
        |   |   +-input_scan=
        |   |     +-DifferentialPrivacyAggregateScan
        |   |       +-column_list=[$groupby.uid#14, $aggregate.$agg1#13]
        |   |       +-input_scan=
        |   |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |       +-group_by_list=
        |   |       | +-uid#14 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |   |       +-aggregate_list=
        |   |         +-$agg1#13 :=
        |   |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |   |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        |   +-right_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#27, $groupby.uid#28]
        |   |   +-input_scan=
        |   |     +-DifferentialPrivacyAggregateScan
        |   |       +-column_list=[$groupby.uid#28, $aggregate.$agg1#27]
        |   |       +-input_scan=
        |   |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#25], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |       +-group_by_list=
        |   |       | +-uid#28 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#25)
        |   |       +-aggregate_list=
        |   |         +-$agg1#27 :=
        |   |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |   |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        |   +-join_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$groupby.uid#14)
        |       +-ColumnRef(type=INT64, column=$groupby.uid#28)
        +-aggregate_list=
          +-$agg1#29 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid'
==

# Nested anonymization
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from
  (SELECT count(*), uid
      from (select with differential_privacy count(*), uid
                from SimpleTypesWithAnonymizationUid group by uid)
      group by uid);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#17 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#17]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#17]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#15, $groupby.uid#16]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.uid#16, $aggregate.$agg1#15]
        |       +-input_scan=
        |       | +-ProjectScan
        |       |   +-column_list=[$aggregate.$agg1#13, $groupby.uid#14]
        |       |   +-input_scan=
        |       |     +-DifferentialPrivacyAggregateScan
        |       |       +-column_list=[$groupby.uid#14, $aggregate.$agg1#13]
        |       |       +-input_scan=
        |       |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       |       +-group_by_list=
        |       |       | +-uid#14 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       |       +-aggregate_list=
        |       |         +-$agg1#13 :=
        |       |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        |       +-group_by_list=
        |       | +-uid#16 := ColumnRef(type=INT64, column=$groupby.uid#14)
        |       +-aggregate_list=
        |         +-$agg1#15 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
          +-$agg1#17 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid'
==

# Join anonymization
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select * from
  ((select with differential_privacy count(*), uid
       from SimpleTypesWithAnonymizationUid group by uid) a
  inner join
  (select with differential_privacy sum(int64), uid
       from SimpleTypesWithAnonymizationUid group by uid) b
  on a.uid = b.uid);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
| +-$groupby.uid#14 AS uid [INT64]
| +-$aggregate.$agg1#27 AS "$col1" [INT64]
| +-$groupby.uid#28 AS uid [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13, $groupby.uid#14, $aggregate.$agg1#27, $groupby.uid#28]
    +-input_scan=
      +-JoinScan
        +-column_list=[$aggregate.$agg1#13, $groupby.uid#14, $aggregate.$agg1#27, $groupby.uid#28]
        +-left_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#13, $groupby.uid#14]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$groupby.uid#14, $aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       +-group_by_list=
        |       | +-uid#14 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       +-aggregate_list=
        |         +-$agg1#13 :=
        |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        +-right_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#27, $groupby.uid#28]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$groupby.uid#28, $aggregate.$agg1#27]
        |       +-input_scan=
        |       | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#16, uid#25], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |       +-group_by_list=
        |       | +-uid#28 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#25)
        |       +-aggregate_list=
        |         +-$agg1#27 :=
        |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |             +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#16)
        |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        +-join_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=$groupby.uid#14)
            +-ColumnRef(type=INT64, column=$groupby.uid#28)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [INT64]
| +-$groupby.uid#14 AS uid [INT64]
| +-$aggregate.$agg1#27 AS "$col1" [INT64]
| +-$groupby.uid#28 AS uid [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13, $groupby.uid#14, $aggregate.$agg1#27, $groupby.uid#28]
    +-input_scan=
      +-JoinScan
        +-column_list=[$aggregate.$agg1#13, $groupby.uid#14, $aggregate.$agg1#27, $groupby.uid#28]
        +-left_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#13, $groupby.uid#14]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$groupby.uid#14, $aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-AggregateScan
        |       |   +-column_list=[$aggregate.$agg1_partial#30, $groupby.uid_partial#31, $group_by.$uid#32]
        |       |   +-input_scan=
        |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       |   +-group_by_list=
        |       |   | +-uid_partial#31 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       |   | +-$uid#32 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       |   +-aggregate_list=
        |       |     +-$agg1_partial#30 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |       +-group_by_list=
        |       | +-uid#14 := ColumnRef(type=INT64, column=$groupby.uid_partial#31)
        |       +-aggregate_list=
        |       | +-$agg1#13 :=
        |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#30)
        |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        |       | +-$group_selection_threshold_col#35 :=
        |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       |     +-Literal(type=INT64, value=1)
        |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        |       +-group_selection_threshold_expr=
        |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#35)
        +-right_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#27, $groupby.uid#28]
        |   +-input_scan=
        |     +-DifferentialPrivacyAggregateScan
        |       +-column_list=[$groupby.uid#28, $aggregate.$agg1#27]
        |       +-input_scan=
        |       | +-AggregateScan
        |       |   +-column_list=[$aggregate.$agg1_partial#37, $groupby.uid_partial#38, $group_by.$uid#39]
        |       |   +-input_scan=
        |       |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#16, uid#25], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |       |   +-group_by_list=
        |       |   | +-uid_partial#38 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#25)
        |       |   | +-$uid#39 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#25)
        |       |   +-aggregate_list=
        |       |     +-$agg1_partial#37 :=
        |       |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |       |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#16)
        |       +-group_by_list=
        |       | +-uid#28 := ColumnRef(type=INT64, column=$groupby.uid_partial#38)
        |       +-aggregate_list=
        |       | +-$agg1#27 :=
        |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#37)
        |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        |       | +-$group_selection_threshold_col#42 :=
        |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |       |     +-Literal(type=INT64, value=1)
        |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        |       +-group_selection_threshold_expr=
        |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#42)
        +-join_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=$groupby.uid#14)
            +-ColumnRef(type=INT64, column=$groupby.uid#28)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[mode=expression]
(select with differential_privacy count(int64)
from SimpleTypesWithAnonymizationUid)
--
SubqueryExpr
+-type=INT64
+-subquery_type=SCALAR
+-subquery=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
SubqueryExpr
+-type=INT64
+-subquery_type=SCALAR
+-subquery=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

# doubly nested struct uid
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*)
       from TestWithDoublyNestedStructUidValueTable;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-TableScan(table=TestWithDoublyNestedStructUidValueTable)
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#8, $group_by.$uid#9]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$table_scan.$value#3, $project.$a#6]
        |   |   +-expr_list=
        |   |   | +-$a#6 :=
        |   |   |   +-GetStructField
        |   |   |     +-type=INT32
        |   |   |     +-expr=
        |   |   |     | +-GetStructField
        |   |   |     |   +-type=STRUCT<a INT32, b STRING>
        |   |   |     |   +-expr=
        |   |   |     |   | +-GetStructField
        |   |   |     |   |   +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
        |   |   |     |   |   +-expr=
        |   |   |     |   |   | +-ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=$table_scan.$value#3)
        |   |   |     |   |   +-field_idx=1
        |   |   |     |   +-field_idx=1
        |   |   |     +-field_idx=0
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[$table_scan.$value#3], table=TestWithDoublyNestedStructUidValueTable, column_index_list=[0])
        |   +-group_by_list=
        |   | +-$uid#9 := ColumnRef(type=INT32, column=$project.$a#6)
        |   +-aggregate_list=
        |     +-$agg1_partial#8 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#2 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#8)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#12 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#12)
==

# nested proto uid
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*)
       from TestWithProtoUidValueTable;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-TableScan(table=TestWithProtoUidValueTable)
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#8, $group_by.$uid#9]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$table_scan.$value#3, $project.$nested_int64#6]
        |   |   +-expr_list=
        |   |   | +-$nested_int64#6 :=
        |   |   |   +-GetProtoField
        |   |   |     +-type=INT64
        |   |   |     +-expr=
        |   |   |     | +-GetProtoField
        |   |   |     |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
        |   |   |     |   +-expr=
        |   |   |     |   | +-GetProtoField
        |   |   |     |   |   +-type=PROTO<zetasql_test__.KitchenSinkPB>
        |   |   |     |   |   +-expr=
        |   |   |     |   |   | +-ColumnRef(type=PROTO<zetasql_test__.MessageWithKitchenSinkPB>, column=$table_scan.$value#3)
        |   |   |     |   |   +-field_descriptor=kitchen_sink
        |   |   |     |   |   +-default_value=NULL
        |   |   |     |   +-field_descriptor=nested_value
        |   |   |     |   +-default_value=NULL
        |   |   |     +-field_descriptor=nested_int64
        |   |   |     +-default_value=88
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[$table_scan.$value#3], table=TestWithProtoUidValueTable, column_index_list=[0])
        |   +-group_by_list=
        |   | +-$uid#9 := ColumnRef(type=INT64, column=$project.$nested_int64#6)
        |   +-aggregate_list=
        |     +-$agg1_partial#8 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#2 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#8)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#12 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#12)
==

# nested proto uid of wrong type.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*)
       from TestWithWrongTypeProtoUidValueTable;
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#2 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#2]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#2]
        +-input_scan=
        | +-TableScan(table=TestWithWrongTypeProtoUidValueTable)
        +-aggregate_list=
          +-$agg1#2 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

Rewrite ERROR: User id columns must support grouping, instead got type PROTO
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*)
       from TestWithDoublyNestedStructUidValueTable t1 inner join
            TestWithDoublyNestedStructUidValueTable t2 on t1.f.d.a = t2.f.d.a;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=TestWithDoublyNestedStructUidValueTable.[value#1, value#2]
        |   +-left_scan=
        |   | +-TableScan(column_list=[TestWithDoublyNestedStructUidValueTable.value#1], table=TestWithDoublyNestedStructUidValueTable, column_index_list=[0], alias='t1')
        |   +-right_scan=
        |   | +-TableScan(column_list=[TestWithDoublyNestedStructUidValueTable.value#2], table=TestWithDoublyNestedStructUidValueTable, column_index_list=[0], alias='t2')
        |   +-join_expr=
        |     +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
        |       +-GetStructField
        |       | +-type=INT32
        |       | +-expr=
        |       | | +-GetStructField
        |       | |   +-type=STRUCT<a INT32, b STRING>
        |       | |   +-expr=
        |       | |   | +-GetStructField
        |       | |   |   +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
        |       | |   |   +-expr=
        |       | |   |   | +-ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=TestWithDoublyNestedStructUidValueTable.value#1)
        |       | |   |   +-field_idx=1
        |       | |   +-field_idx=1
        |       | +-field_idx=0
        |       +-GetStructField
        |         +-type=INT32
        |         +-expr=
        |         | +-GetStructField
        |         |   +-type=STRUCT<a INT32, b STRING>
        |         |   +-expr=
        |         |   | +-GetStructField
        |         |   |   +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
        |         |   |   +-expr=
        |         |   |   | +-ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=TestWithDoublyNestedStructUidValueTable.value#2)
        |         |   |   +-field_idx=1
        |         |   +-field_idx=1
        |         +-field_idx=0
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#11, $group_by.$uid#12]
        |   +-input_scan=
        |   | +-JoinScan
        |   |   +-column_list=[TestWithDoublyNestedStructUidValueTable.value#1, TestWithDoublyNestedStructUidValueTable.value#2, $project.$a#6]
        |   |   +-left_scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[TestWithDoublyNestedStructUidValueTable.value#1, $project.$a#6]
        |   |   |   +-expr_list=
        |   |   |   | +-$a#6 :=
        |   |   |   |   +-GetStructField
        |   |   |   |     +-type=INT32
        |   |   |   |     +-expr=
        |   |   |   |     | +-GetStructField
        |   |   |   |     |   +-type=STRUCT<a INT32, b STRING>
        |   |   |   |     |   +-expr=
        |   |   |   |     |   | +-GetStructField
        |   |   |   |     |   |   +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
        |   |   |   |     |   |   +-expr=
        |   |   |   |     |   |   | +-ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=TestWithDoublyNestedStructUidValueTable.value#1)
        |   |   |   |     |   |   +-field_idx=1
        |   |   |   |     |   +-field_idx=1
        |   |   |   |     +-field_idx=0
        |   |   |   +-input_scan=
        |   |   |     +-TableScan(column_list=[TestWithDoublyNestedStructUidValueTable.value#1], table=TestWithDoublyNestedStructUidValueTable, column_index_list=[0], alias='t1')
        |   |   +-right_scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[TestWithDoublyNestedStructUidValueTable.value#2, $project.$a#9]
        |   |   |   +-expr_list=
        |   |   |   | +-$a#9 :=
        |   |   |   |   +-GetStructField
        |   |   |   |     +-type=INT32
        |   |   |   |     +-expr=
        |   |   |   |     | +-GetStructField
        |   |   |   |     |   +-type=STRUCT<a INT32, b STRING>
        |   |   |   |     |   +-expr=
        |   |   |   |     |   | +-GetStructField
        |   |   |   |     |   |   +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
        |   |   |   |     |   |   +-expr=
        |   |   |   |     |   |   | +-ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=TestWithDoublyNestedStructUidValueTable.value#2)
        |   |   |   |     |   |   +-field_idx=1
        |   |   |   |     |   +-field_idx=1
        |   |   |   |     +-field_idx=0
        |   |   |   +-input_scan=
        |   |   |     +-TableScan(column_list=[TestWithDoublyNestedStructUidValueTable.value#2], table=TestWithDoublyNestedStructUidValueTable, column_index_list=[0], alias='t2')
        |   |   +-join_expr=
        |   |     +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
        |   |       +-GetStructField
        |   |       | +-type=INT32
        |   |       | +-expr=
        |   |       | | +-GetStructField
        |   |       | |   +-type=STRUCT<a INT32, b STRING>
        |   |       | |   +-expr=
        |   |       | |   | +-GetStructField
        |   |       | |   |   +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
        |   |       | |   |   +-expr=
        |   |       | |   |   | +-ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=TestWithDoublyNestedStructUidValueTable.value#1)
        |   |       | |   |   +-field_idx=1
        |   |       | |   +-field_idx=1
        |   |       | +-field_idx=0
        |   |       +-GetStructField
        |   |         +-type=INT32
        |   |         +-expr=
        |   |         | +-GetStructField
        |   |         |   +-type=STRUCT<a INT32, b STRING>
        |   |         |   +-expr=
        |   |         |   | +-GetStructField
        |   |         |   |   +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
        |   |         |   |   +-expr=
        |   |         |   |   | +-ColumnRef(type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, column=TestWithDoublyNestedStructUidValueTable.value#2)
        |   |         |   |   +-field_idx=1
        |   |         |   +-field_idx=1
        |   |         +-field_idx=0
        |   +-group_by_list=
        |   | +-$uid#12 := ColumnRef(type=INT32, column=$project.$a#6)
        |   +-aggregate_list=
        |     +-$agg1_partial#11 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#3 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#11)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#15 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#15)
==

# We can't run the unparser because the rewrite generates ORDER BY in an
# aggregate function and the appropriate language feature is not enabled.
[no_run_unparser]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy VAR_POP(int64)
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_var_pop(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
              +-Cast(INT64 -> DOUBLE)
              | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#17, $group_by.$uid#18]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2, SimpleTypesWithAnonymizationUid.uid#14, $orderby.$orderbycol1#16]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#16 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#18 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#17 :=
        |       +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |         +-Cast(INT64 -> DOUBLE)
        |           +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |         +-null_handling_modifier=IGNORE_NULLS
        |         +-order_by_item_list=
        |         | +-OrderByItem
        |         |   +-column_ref=
        |         |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#16)
        |         +-limit=
        |           +-Literal(type=INT64, value=5)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_var_pop(ARRAY<DOUBLE>, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg1_partial#17)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$group_selection_threshold_col#21 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#21)
==

# We can't run the unparser because the rewrite generates ORDER BY in an
# aggregate function and the appropriate language feature is not enabled.
[no_run_unparser]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy VAR_POP(double), SUM(double)
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[8])
        +-aggregate_list=
          +-$agg1#13 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_var_pop(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
          +-$agg2#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $aggregate.$agg2_partial#20, $group_by.$uid#21]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.double#9, SimpleTypesWithAnonymizationUid.uid#15, $orderby.$orderbycol1#17]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#17 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[double#9, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[8, 10])
        |   +-group_by_list=
        |   | +-$uid#21 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 :=
        |     | +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |     |   +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        |     |   +-null_handling_modifier=IGNORE_NULLS
        |     |   +-order_by_item_list=
        |     |   | +-OrderByItem
        |     |   |   +-column_ref=
        |     |   |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |     |   +-limit=
        |     |     +-Literal(type=INT64, value=5)
        |     +-$agg2_partial#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_var_pop(ARRAY<DOUBLE>, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$agg2#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
        | |   +-ColumnRef(type=DOUBLE, column=$aggregate.$agg2_partial#20)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$group_selection_threshold_col#25 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#25)
==

# We can't run the unparser because the rewrite generates ORDER BY in an
# aggregate function and the appropriate language feature is not enabled.
[no_run_unparser]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy VAR_POP(int64), VAR_POP(double)
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 8])
        +-aggregate_list=
          +-$agg1#13 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_var_pop(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
          |   +-Cast(INT64 -> DOUBLE)
          |   | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
          +-$agg2#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_var_pop(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $aggregate.$agg2_partial#20, $group_by.$uid#21]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2, SimpleTypesWithAnonymizationUid.double#9, SimpleTypesWithAnonymizationUid.uid#15, $orderby.$orderbycol1#17]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#17 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, double#9, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 8, 10])
        |   +-group_by_list=
        |   | +-$uid#21 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 :=
        |     | +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |     |   +-Cast(INT64 -> DOUBLE)
        |     |     +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |     |   +-null_handling_modifier=IGNORE_NULLS
        |     |   +-order_by_item_list=
        |     |   | +-OrderByItem
        |     |   |   +-column_ref=
        |     |   |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |     |   +-limit=
        |     |     +-Literal(type=INT64, value=5)
        |     +-$agg2_partial#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        |         +-null_handling_modifier=IGNORE_NULLS
        |         +-order_by_item_list=
        |         | +-OrderByItem
        |         |   +-column_ref=
        |         |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |         +-limit=
        |           +-Literal(type=INT64, value=5)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_var_pop(ARRAY<DOUBLE>, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$agg2#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_var_pop(ARRAY<DOUBLE>, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg2_partial#20)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$group_selection_threshold_col#25 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#25)
==

# We can't run the unparser because the rewrite generates ORDER BY in an
# aggregate function and the appropriate language feature is not enabled.
[no_run_unparser]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy STDDEV_POP(int64, contribution_bounds_per_row => (2,3.5))
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_stddev_pop(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
              +-Cast(INT64 -> DOUBLE)
              | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={2, 3.5})


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#17, $group_by.$uid#18]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2, SimpleTypesWithAnonymizationUid.uid#14, $orderby.$orderbycol1#16]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#16 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#18 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#17 :=
        |       +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |         +-Cast(INT64 -> DOUBLE)
        |           +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |         +-null_handling_modifier=IGNORE_NULLS
        |         +-order_by_item_list=
        |         | +-OrderByItem
        |         |   +-column_ref=
        |         |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#16)
        |         +-limit=
        |           +-Literal(type=INT64, value=5)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_stddev_pop(ARRAY<DOUBLE>, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg1_partial#17)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={2, 3.5})
        | +-$group_selection_threshold_col#21 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#21)
==

# We can't run the unparser because the rewrite generates ORDER BY in an
# aggregate function and the appropriate language feature is not enabled.
[no_run_unparser]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy STDDEV_POP(int64)
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_stddev_pop(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
              +-Cast(INT64 -> DOUBLE)
              | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#17, $group_by.$uid#18]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2, SimpleTypesWithAnonymizationUid.uid#14, $orderby.$orderbycol1#16]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#16 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#18 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#17 :=
        |       +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |         +-Cast(INT64 -> DOUBLE)
        |           +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |         +-null_handling_modifier=IGNORE_NULLS
        |         +-order_by_item_list=
        |         | +-OrderByItem
        |         |   +-column_ref=
        |         |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#16)
        |         +-limit=
        |           +-Literal(type=INT64, value=5)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_stddev_pop(ARRAY<DOUBLE>, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg1_partial#17)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$group_selection_threshold_col#21 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#21)
==

# We can't run the unparser because the rewrite generates ORDER BY in an
# aggregate function and the appropriate language feature is not enabled.
[no_run_unparser]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy STDDEV_POP(int64), STDDEV_POP(double)
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 8])
        +-aggregate_list=
          +-$agg1#13 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_stddev_pop(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
          |   +-Cast(INT64 -> DOUBLE)
          |   | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
          +-$agg2#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_stddev_pop(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $aggregate.$agg2_partial#20, $group_by.$uid#21]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2, SimpleTypesWithAnonymizationUid.double#9, SimpleTypesWithAnonymizationUid.uid#15, $orderby.$orderbycol1#17]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#17 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, double#9, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 8, 10])
        |   +-group_by_list=
        |   | +-$uid#21 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 :=
        |     | +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |     |   +-Cast(INT64 -> DOUBLE)
        |     |     +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |     |   +-null_handling_modifier=IGNORE_NULLS
        |     |   +-order_by_item_list=
        |     |   | +-OrderByItem
        |     |   |   +-column_ref=
        |     |   |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |     |   +-limit=
        |     |     +-Literal(type=INT64, value=5)
        |     +-$agg2_partial#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        |         +-null_handling_modifier=IGNORE_NULLS
        |         +-order_by_item_list=
        |         | +-OrderByItem
        |         |   +-column_ref=
        |         |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |         +-limit=
        |           +-Literal(type=INT64, value=5)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_stddev_pop(ARRAY<DOUBLE>, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$agg2#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_stddev_pop(ARRAY<DOUBLE>, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg2_partial#20)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$group_selection_threshold_col#25 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#25)
==

# We can't run the unparser because the rewrite generates ORDER BY in an
# aggregate function and the appropriate language feature is not enabled.
[no_run_unparser]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy STDDEV_POP(double), SUM(double)
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[8])
        +-aggregate_list=
          +-$agg1#13 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_stddev_pop(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
          +-$agg2#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $aggregate.$agg2_partial#20, $group_by.$uid#21]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.double#9, SimpleTypesWithAnonymizationUid.uid#15, $orderby.$orderbycol1#17]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#17 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[double#9, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[8, 10])
        |   +-group_by_list=
        |   | +-$uid#21 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 :=
        |     | +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |     |   +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        |     |   +-null_handling_modifier=IGNORE_NULLS
        |     |   +-order_by_item_list=
        |     |   | +-OrderByItem
        |     |   |   +-column_ref=
        |     |   |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |     |   +-limit=
        |     |     +-Literal(type=INT64, value=5)
        |     +-$agg2_partial#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_stddev_pop(ARRAY<DOUBLE>, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$agg2#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
        | |   +-ColumnRef(type=DOUBLE, column=$aggregate.$agg2_partial#20)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$group_selection_threshold_col#25 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#25)
==

# We can't run the unparser because the rewrite generates ORDER BY in an
# aggregate function and the appropriate language feature is not enabled.
[no_run_unparser]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy STDDEV_POP(double), VAR_POP(double)
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[8])
        +-aggregate_list=
          +-$agg1#13 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_stddev_pop(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
          +-$agg2#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_var_pop(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $aggregate.$agg2_partial#20, $group_by.$uid#21]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.double#9, SimpleTypesWithAnonymizationUid.uid#15, $orderby.$orderbycol1#17]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#17 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[double#9, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[8, 10])
        |   +-group_by_list=
        |   | +-$uid#21 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 :=
        |     | +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |     |   +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        |     |   +-null_handling_modifier=IGNORE_NULLS
        |     |   +-order_by_item_list=
        |     |   | +-OrderByItem
        |     |   |   +-column_ref=
        |     |   |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |     |   +-limit=
        |     |     +-Literal(type=INT64, value=5)
        |     +-$agg2_partial#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        |         +-null_handling_modifier=IGNORE_NULLS
        |         +-order_by_item_list=
        |         | +-OrderByItem
        |         |   +-column_ref=
        |         |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |         +-limit=
        |           +-Literal(type=INT64, value=5)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_stddev_pop(ARRAY<DOUBLE>, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$agg2#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_var_pop(ARRAY<DOUBLE>, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg2_partial#20)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$group_selection_threshold_col#25 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#25)
==

# We can't run the unparser because the rewrite generates ORDER BY in an
# aggregate function and the appropriate language feature is not enabled.
[no_run_unparser]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy
    PERCENTILE_CONT(int64, 0.4),
    PERCENTILE_CONT(double, 0.6)
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 8])
        +-aggregate_list=
          +-$agg1#13 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_percentile_cont(DOUBLE, DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
          |   +-Cast(INT64 -> DOUBLE)
          |   | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
          |   +-Literal(type=DOUBLE, value=0.4, float_literal_id=1)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
          +-$agg2#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_percentile_cont(DOUBLE, DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=DOUBLE, value=0.6, float_literal_id=2)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $aggregate.$agg2_partial#20, $group_by.$uid#21]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2, SimpleTypesWithAnonymizationUid.double#9, SimpleTypesWithAnonymizationUid.uid#15, $orderby.$orderbycol1#17]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#17 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, double#9, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 8, 10])
        |   +-group_by_list=
        |   | +-$uid#21 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 :=
        |     | +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |     |   +-Cast(INT64 -> DOUBLE)
        |     |     +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |     |   +-null_handling_modifier=IGNORE_NULLS
        |     |   +-order_by_item_list=
        |     |   | +-OrderByItem
        |     |   |   +-column_ref=
        |     |   |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |     |   +-limit=
        |     |     +-Literal(type=INT64, value=5)
        |     +-$agg2_partial#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        |         +-null_handling_modifier=IGNORE_NULLS
        |         +-order_by_item_list=
        |         | +-OrderByItem
        |         |   +-column_ref=
        |         |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |         +-limit=
        |           +-Literal(type=INT64, value=5)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_percentile_cont(ARRAY<DOUBLE>, DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=DOUBLE, value=0.4, float_literal_id=1)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$agg2#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_percentile_cont(ARRAY<DOUBLE>, DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg2_partial#20)
        | |   +-Literal(type=DOUBLE, value=0.6, float_literal_id=2)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$group_selection_threshold_col#25 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#25)
==

# We can't run the unparser because the rewrite generates ORDER BY in an
# aggregate function and the appropriate language feature is not enabled.
[no_run_unparser]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy
    PERCENTILE_CONT(int64, 0.4, contribution_bounds_per_row => (2,3)),
    PERCENTILE_CONT(double, 0.6, contribution_bounds_per_row => (1,4))
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 8])
        +-aggregate_list=
          +-$agg1#13 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_percentile_cont(DOUBLE, DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
          |   +-Cast(INT64 -> DOUBLE)
          |   | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
          |   +-Literal(type=DOUBLE, value=0.4, float_literal_id=1)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={2, 3})
          +-$agg2#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_percentile_cont(DOUBLE, DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=DOUBLE, value=0.6, float_literal_id=2)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={1, 4})


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
| +-$aggregate.$agg2#14 AS "$col2" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $aggregate.$agg2_partial#20, $group_by.$uid#21]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2, SimpleTypesWithAnonymizationUid.double#9, SimpleTypesWithAnonymizationUid.uid#15, $orderby.$orderbycol1#17]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#17 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, double#9, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 8, 10])
        |   +-group_by_list=
        |   | +-$uid#21 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 :=
        |     | +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |     |   +-Cast(INT64 -> DOUBLE)
        |     |     +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |     |   +-null_handling_modifier=IGNORE_NULLS
        |     |   +-order_by_item_list=
        |     |   | +-OrderByItem
        |     |   |   +-column_ref=
        |     |   |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |     |   +-limit=
        |     |     +-Literal(type=INT64, value=5)
        |     +-$agg2_partial#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        |         +-null_handling_modifier=IGNORE_NULLS
        |         +-order_by_item_list=
        |         | +-OrderByItem
        |         |   +-column_ref=
        |         |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |         +-limit=
        |           +-Literal(type=INT64, value=5)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_percentile_cont(ARRAY<DOUBLE>, DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=DOUBLE, value=0.4, float_literal_id=1)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={2, 3})
        | +-$agg2#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_percentile_cont(ARRAY<DOUBLE>, DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg2_partial#20)
        | |   +-Literal(type=DOUBLE, value=0.6, float_literal_id=2)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={1, 4})
        | +-$group_selection_threshold_col#25 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#25)
==

# We can't run the unparser because the rewrite generates ORDER BY in an
# aggregate function and the appropriate language feature is not enabled.
[no_run_unparser]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy
    PERCENTILE_CONT(int64, 0.4, contribution_bounds_per_row => STRUCT(2 AS val, 3 AS val2)),
from SimpleTypesWithAnonymizationUid;
--

QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_percentile_cont(DOUBLE, DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
              +-Cast(INT64 -> DOUBLE)
              | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=DOUBLE, value=0.4, float_literal_id=1)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={2, 3})


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#17, $group_by.$uid#18]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2, SimpleTypesWithAnonymizationUid.uid#14, $orderby.$orderbycol1#16]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#16 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#18 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#17 :=
        |       +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |         +-Cast(INT64 -> DOUBLE)
        |           +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |         +-null_handling_modifier=IGNORE_NULLS
        |         +-order_by_item_list=
        |         | +-OrderByItem
        |         |   +-column_ref=
        |         |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#16)
        |         +-limit=
        |           +-Literal(type=INT64, value=5)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_percentile_cont(ARRAY<DOUBLE>, DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> DOUBLE)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg1_partial#17)
        | |   +-Literal(type=DOUBLE, value=0.4, float_literal_id=1)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={2, 3})
        | +-$group_selection_threshold_col#21 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#21)

==

# We can't run the unparser because the rewrite generates ORDER BY in an
# aggregate function and the appropriate language feature is not enabled.
[no_run_unparser]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy
    APPROX_QUANTILES(int64, 4, contribution_bounds_per_row => (2,3)),
    APPROX_QUANTILES(double, 6, contribution_bounds_per_row => (1,4))
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [ARRAY<DOUBLE>]
| +-$aggregate.$agg2#14 AS "$col2" [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 8])
        +-aggregate_list=
          +-$agg1#13 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_approx_quantiles(DOUBLE, INT64, STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> ARRAY<DOUBLE>)
          |   +-Cast(INT64 -> DOUBLE)
          |   | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
          |   +-Literal(type=INT64, value=4)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={2, 3})
          +-$agg2#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_approx_quantiles(DOUBLE, INT64, STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> ARRAY<DOUBLE>)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=INT64, value=6)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={1, 4})


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [ARRAY<DOUBLE>]
| +-$aggregate.$agg2#14 AS "$col2" [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $aggregate.$agg2_partial#20, $group_by.$uid#21]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2, SimpleTypesWithAnonymizationUid.double#9, SimpleTypesWithAnonymizationUid.uid#15, $orderby.$orderbycol1#17]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#17 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, double#9, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 8, 10])
        |   +-group_by_list=
        |   | +-$uid#21 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 :=
        |     | +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |     |   +-Cast(INT64 -> DOUBLE)
        |     |     +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |     |   +-null_handling_modifier=IGNORE_NULLS
        |     |   +-order_by_item_list=
        |     |   | +-OrderByItem
        |     |   |   +-column_ref=
        |     |   |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |     |   +-limit=
        |     |     +-Literal(type=INT64, value=5)
        |     +-$agg2_partial#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        |         +-null_handling_modifier=IGNORE_NULLS
        |         +-order_by_item_list=
        |         | +-OrderByItem
        |         |   +-column_ref=
        |         |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |         +-limit=
        |           +-Literal(type=INT64, value=5)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_approx_quantiles(ARRAY<DOUBLE>, INT64, STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> ARRAY<DOUBLE>)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=INT64, value=4)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={2, 3})
        | +-$agg2#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_approx_quantiles(ARRAY<DOUBLE>, INT64, STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> ARRAY<DOUBLE>)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg2_partial#20)
        | |   +-Literal(type=INT64, value=6)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={1, 4})
        | +-$group_selection_threshold_col#25 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#25)
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE,GROUP_BY_ROLLUP]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY int64, double, SUM(int32)
    FROM SimpleTypesWithAnonymizationUid
    GROUP BY ROLLUP(int64, double);
--
ERROR: GROUP BY ROLLUP is not supported in anonymization queries [at 3:14]
    GROUP BY ROLLUP(int64, double);
             ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE,V_1_4_GROUPING_SETS]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY int64, double, SUM(int32)
    FROM SimpleTypesWithAnonymizationUid
    GROUP BY CUBE(int64, double);
--
ERROR: GROUP BY CUBE is not supported in anonymization queries [at 3:14]
    GROUP BY CUBE(int64, double);
             ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE,V_1_4_GROUPING_SETS]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY int64, double, SUM(int32)
    FROM SimpleTypesWithAnonymizationUid
    GROUP BY GROUPING SETS(int64, double);
--
ERROR: GROUP BY GROUPING SETS is not supported in anonymization queries [at 3:14]
    GROUP BY GROUPING SETS(int64, double);
             ^
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy sum(*, contribution_bounds_per_group => (10,100), report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
ERROR: Argument * can only be used in COUNT(*) [at 1:38]
select with differential_privacy sum(*, contribution_bounds_per_group => (10,...
                                     ^
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy sum(*, contribution_bounds_per_group => (10,100))
from SimpleTypesWithAnonymizationUid;
--
ERROR: Argument * can only be used in COUNT(*) [at 1:38]
select with differential_privacy sum(*, contribution_bounds_per_group => (10,...
                                     ^
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*, contribution_bounds_per_group => (bool, "100"), report_format => "JSON")
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator COUNT(*) in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRUCT<BOOL, STRING>, STRING. Supported signatures: COUNT(* [, contribution_bounds_per_group => STRUCT<INT64, INT64>] [, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT]) [at 1:34]
select with differential_privacy count(*, contribution_bounds_per_group => (b...
                                 ^
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY count(* with report)
from SimpleTypesWithAnonymizationUid;
--
ERROR: WITH REPORT is not allowed for function COUNT [at 1:34]
SELECT WITH DIFFERENTIAL_PRIVACY count(* with report)
                                 ^
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy sum(int64, report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

# b/290310062
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy sum(if(int64 is null, 0, 1), report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
              +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
              | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
              | | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              | +-Literal(type=INT64, value=0)
              | +-Literal(type=INT64, value=1)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
        |           +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |           | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |           +-Literal(type=INT64, value=0)
        |           +-Literal(type=INT64, value=1)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy sum(int64, report_format => "JSON")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy sum(int64, contribution_bounds_per_group => (0,10), report_format => "JSON")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy sum(double, contribution_bounds_per_group => (0,10), report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[8])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(DOUBLE, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[double#9, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[8, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(DOUBLE, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
        | |   +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 10})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy avg(int64, report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
              +-Cast(INT64 -> DOUBLE)
              | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:avg(DOUBLE) -> DOUBLE)
        |         +-Cast(INT64 -> DOUBLE)
        |           +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
        | |   +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy avg(int64, report_format => "JSON")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> JSON)
              +-Cast(INT64 -> DOUBLE)
              | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:avg(DOUBLE) -> DOUBLE)
        |         +-Cast(INT64 -> DOUBLE)
        |           +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> JSON)
        | |   +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy avg(double, contribution_bounds_per_group => (0,10), report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[8])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[double#9, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[8, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:avg(DOUBLE) -> DOUBLE)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
        | |   +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 10})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy avg(double, contribution_bounds_per_group => (0,10), report_format => "JSON")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[8])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> JSON)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[double#9, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[8, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:avg(DOUBLE) -> DOUBLE)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> JSON)
        | |   +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 10})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy count(int64, report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy count(int64, report_format => "JSON")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy count(int64, contribution_bounds_per_group => (0,10), report_format => "JSON")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy count(double, contribution_bounds_per_group => (0,10), report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[8])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(DOUBLE, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[double#9, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[8, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(DOUBLE) -> INT64)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy count(*, report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy count(*, report_format => "JSON")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy count(*, contribution_bounds_per_group => (0,10), report_format => "JSON")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy count(*, contribution_bounds_per_group => (0,10), report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy APPROX_QUANTILES(*, 4, contribution_bounds_per_row => (2,3), report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
ERROR: Argument * can only be used in COUNT(*) [at 1:51]
select with differential_privacy APPROX_QUANTILES(*, 4, contribution_bounds_p...
                                                  ^
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy APPROX_QUANTILES(int64, contribution_bounds_per_row =>(4, bool), report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, STRUCT<INT64, BOOL>, STRING. Supported signatures: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>); APPROX_QUANTILES(DOUBLE, INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="JSON"*/, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>); APPROX_QUANTILES(DOUBLE, INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="PROTO"*/, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) [at 1:34]
select with differential_privacy APPROX_QUANTILES(int64, contribution_bounds_...
                                 ^
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy APPROX_QUANTILES(double, contribution_bounds_per_row => (bool, 3), report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE, STRUCT<BOOL, INT64>, STRING. Supported signatures: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>); APPROX_QUANTILES(DOUBLE, INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="JSON"*/, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>); APPROX_QUANTILES(DOUBLE, INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*required_value="PROTO"*/, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) [at 1:34]
select with differential_privacy APPROX_QUANTILES(double, contribution_bounds...
                                 ^
==

# We can't run the unparser because the rewrite generates ORDER BY in an
# aggregate function and the appropriate language feature is not enabled.
[no_run_unparser]
[no_enable_literal_replacement]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy
    APPROX_QUANTILES(int64, 4, contribution_bounds_per_row => (2,3), report_format => "PROTO"),
    APPROX_QUANTILES(double, 6, contribution_bounds_per_row => (1,4), report_format => "JSON")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
| +-$aggregate.$agg2#14 AS "$col2" [JSON]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 8])
        +-aggregate_list=
          +-$agg1#13 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_approx_quantiles(DOUBLE, INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
          |   +-Cast(INT64 -> DOUBLE)
          |   | +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
          |   +-Literal(type=INT64, value=4)
          |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={2, 3})
          +-$agg2#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_approx_quantiles(DOUBLE, INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> JSON)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=INT64, value=6)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={1, 4})


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
| +-$aggregate.$agg2#14 AS "$col2" [JSON]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#13, $agg2#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#13, $agg2#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $aggregate.$agg2_partial#20, $group_by.$uid#21]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2, SimpleTypesWithAnonymizationUid.double#9, SimpleTypesWithAnonymizationUid.uid#15, $orderby.$orderbycol1#17]
        |   |   +-expr_list=
        |   |   | +-$orderbycol1#17 := FunctionCall(ZetaSQL:rand() -> DOUBLE)
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, double#9, uid#15], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 8, 10])
        |   +-group_by_list=
        |   | +-$uid#21 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 :=
        |     | +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |     |   +-Cast(INT64 -> DOUBLE)
        |     |     +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        |     |   +-null_handling_modifier=IGNORE_NULLS
        |     |   +-order_by_item_list=
        |     |   | +-OrderByItem
        |     |   |   +-column_ref=
        |     |   |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |     |   +-limit=
        |     |     +-Literal(type=INT64, value=5)
        |     +-$agg2_partial#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        |         +-null_handling_modifier=IGNORE_NULLS
        |         +-order_by_item_list=
        |         | +-OrderByItem
        |         |   +-column_ref=
        |         |     +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#17)
        |         +-limit=
        |           +-Literal(type=INT64, value=5)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_approx_quantiles(ARRAY<DOUBLE>, INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=INT64, value=4)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={2, 3})
        | +-$agg2#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_approx_quantiles(ARRAY<DOUBLE>, INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_row) -> JSON)
        | |   +-ColumnRef(type=ARRAY<DOUBLE>, column=$aggregate.$agg2_partial#20)
        | |   +-Literal(type=INT64, value=6)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={1, 4})
        | +-$group_selection_threshold_col#25 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#25)
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[no_enable_literal_replacement]
select with differential_privacy avg(double, report_format => "PROTO")
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[8])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#16, $group_by.$uid#17]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[double#9, uid#14], table=SimpleTypesWithAnonymizationUid, column_index_list=[8, 10])
        |   +-group_by_list=
        |   | +-$uid#17 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#16 :=
        |       +-AggregateFunctionCall(ZetaSQL:avg(DOUBLE) -> DOUBLE)
        |         +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> PROTO<zetasql.functions.DifferentialPrivacyOutputWithReport>)
        | |   +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1_partial#16)
        | |   +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=PROTO)
        | |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value=NULL)
        | +-$group_selection_threshold_col#20 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#20)

==

# SELECT WITH custom identifier should return an error
select with custom_identifier count(*);
--

ERROR: Invalid identifier after SELECT WITH; expected DIFFERENTIAL_PRIVACY but got: custom_identifier [at 1:13]
select with custom_identifier count(*);
            ^
==

# SELECT WITH invalid identifier after WITH should return an error
select with sum(x);
--
ERROR: Invalid identifier after SELECT WITH; expected DIFFERENTIAL_PRIVACY but got: sum [at 1:13]
select with sum(x);
            ^
==

[language_features=DIFFERENTIAL_PRIVACY,ANONYMIZATION]
# SELECT WITH invalid identifier after WITH should return an error
select with custom_identifier sum(x);
--
ERROR: Invalid identifier after SELECT WITH; expected ANONYMIZATION, DIFFERENTIAL_PRIVACY but got: custom_identifier [at 2:13]
select with custom_identifier sum(x);
            ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,ANONYMIZATION]
# Using ANON_ functions should return an error in differential_privacy context - FEATURE_ANONYMIZATION enabled.
select with differential_privacy anon_count(*) FROM SimpleTypesWithAnonymizationUid;
--
ERROR: ANON functions are not allowed in SELECT WITH DIFFERENTIAL_PRIVACY queries. Please use non ANON_ versions of the functions [at 2:34]
select with differential_privacy anon_count(*) FROM SimpleTypesWithAnonymizat...
                                 ^
==

[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS]
# Using ANON_ functions should return an error in differential_privacy context - FEATURE_ANONYMIZATION disabled.
select with differential_privacy anon_count(*) FROM SimpleTypesWithAnonymizationUid;
--
ERROR: Function not found: anon_count; Did you mean anon_test? [at 2:34]
select with differential_privacy anon_count(*) FROM SimpleTypesWithAnonymizat...
                                 ^
==

# Using DP functions inside ANONYMIZATION queries.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[ language_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,NUMERIC_TYPE,JSON_TYPE]
select WITH ANONYMIZATION "$differential_privacy_count"(1) from SimpleTypesWithAnonymizationUid;
--

ERROR: Function not found: "$differential_privacy_count" [at 1:27]
select WITH ANONYMIZATION "$differential_privacy_count"(1) from SimpleTypesWi...
                          ^
==

# Using DP functions inside regular queries.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select "$differential_privacy_count"(1) from SimpleTypesWithAnonymizationUid;
--
ERROR: Function not found: "$differential_privacy_count" [at 1:8]
select "$differential_privacy_count"(1) from SimpleTypesWithAnonymizationUid;
       ^
==

# Using DP functions inside regular queries.
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select "$differential_privacy_count1"(1) from SimpleTypesWithAnonymizationUid;
--
ERROR: Function not found: "$differential_privacy_count1" [at 1:8]
select "$differential_privacy_count1"(1) from SimpleTypesWithAnonymizationUid;
       ^
==

# casting inside contribution_bounds_per_group argument.
[enabled_ast_rewrites=DEFAULTS]
select with differential_privacy
  SUM(double, contribution_bounds_per_group => STRUCT<{{INT32|INT64|UINT32|UINT64|FLOAT}},DOUBLE>(0, 1))
  from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS "$col1" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.double#9], table=SimpleTypesWithAnonymizationUid, column_index_list=[8])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
              +-ColumnRef(type=DOUBLE, column=SimpleTypesWithAnonymizationUid.double#9)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1}, has_explicit_type=TRUE)
==

# casting inside contribution_bounds_per_group argument.
[enabled_ast_rewrites=DEFAULTS]
select with differential_privacy
  COUNT(*, contribution_bounds_per_group => (0.0, 1.0))
  from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator COUNT(*) in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRUCT<DOUBLE, DOUBLE>. Supported signatures: COUNT(* [, contribution_bounds_per_group => STRUCT<INT64, INT64>] [, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT]) [at 2:3]
  COUNT(*, contribution_bounds_per_group => (0.0, 1.0))
  ^
==

# contribution_bounds_per_group with select as struct
[enabled_ast_rewrites=DEFAULTS]
select with DIFFERENTIAL_PRIVACY
  SUM(double, contribution_bounds_per_group => (SELECT AS STRUCT 0, 1))
  from SimpleTypesWithAnonymizationUid;
--
ERROR: Argument 'contribution_bounds_per_group' to SUM must be a literal or query parameter [at 2:15]
  SUM(double, contribution_bounds_per_group => (SELECT AS STRUCT 0, 1))
              ^
==

# Union ANONYMIZATION and DIFFERENTIAL_PRIVACY
[ language_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,NUMERIC_TYPE,JSON_TYPE]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with DIFFERENTIAL_PRIVACY
  COUNT(*) from SimpleTypesWithAnonymizationUid
UNION ALL
select with ANONYMIZATION
  ANON_COUNT(*) from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#27 AS "$col1" [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#27]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.$agg1#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.$agg1#13]
      | |       +-input_scan=
      | |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
      | |       +-aggregate_list=
      | |         +-$agg1#13 :=
      | |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | +-output_column_list=[$aggregate.$agg1#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#26]
        |   +-input_scan=
        |     +-AnonymizedAggregateScan
        |       +-column_list=[$aggregate.$agg1#26]
        |       +-input_scan=
        |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |       +-aggregate_list=
        |         +-$agg1#26 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)
        +-output_column_list=[$aggregate.$agg1#26]

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$union_all.$col1#27 AS "$col1" [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#27]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.$agg1#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.$agg1#13]
      | |       +-input_scan=
      | |       | +-AggregateScan
      | |       |   +-column_list=[$aggregate.$agg1_partial#30, $group_by.$uid#31]
      | |       |   +-input_scan=
      | |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#28], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
      | |       |   +-group_by_list=
      | |       |   | +-$uid#31 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#28)
      | |       |   +-aggregate_list=
      | |       |     +-$agg1_partial#30 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
      | |       +-aggregate_list=
      | |       | +-$agg1#13 :=
      | |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#30)
      | |       | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | |       | +-$group_selection_threshold_col#34 :=
      | |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |       |     +-Literal(type=INT64, value=1)
      | |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
      | |       +-group_selection_threshold_expr=
      | |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#34)
      | +-output_column_list=[$aggregate.$agg1#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#26]
        |   +-input_scan=
        |     +-AnonymizedAggregateScan
        |       +-column_list=[$aggregate.$agg1#26]
        |       +-input_scan=
        |       | +-AggregateScan
        |       |   +-column_list=[$aggregate.$agg1_partial#37, $group_by.$uid#38]
        |       |   +-input_scan=
        |       |   | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#35], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       |   +-group_by_list=
        |       |   | +-$uid#38 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#35)
        |       |   +-aggregate_list=
        |       |     +-$agg1_partial#37 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |       +-aggregate_list=
        |       | +-$agg1#26 :=
        |       | | +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(0) INT64, optional(0) INT64) -> INT64)
        |       | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#37)
        |       | +-$k_threshold_col#41 :=
        |       |   +-AggregateFunctionCall(ZetaSQL:anon_sum(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
        |       |     +-Literal(type=INT64, value=1)
        |       |     +-Literal(type=INT64, value=0)
        |       |     +-Literal(type=INT64, value=1)
        |       +-k_threshold_expr=
        |         +-ColumnRef(type=INT64, column=$anon.$k_threshold_col#41)
        +-output_column_list=[$aggregate.$agg1#26]
==

# ANONYMIZATION nested in DIFFERENTIAL_PRIVACY
[ language_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,NUMERIC_TYPE,JSON_TYPE]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with DIFFERENTIAL_PRIVACY
  COUNT(*) from SimpleTypesWithAnonymizationUid CROSS JOIN
    (select with ANONYMIZATION
      ANON_COUNT(*) from SimpleTypesWithAnonymizationUid)
--

[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#26 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#26]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#26]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[$aggregate.$agg1#25]
        |   +-left_scan=
        |   | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |   +-right_scan=
        |     +-ProjectScan
        |       +-column_list=[$aggregate.$agg1#25]
        |       +-input_scan=
        |         +-AnonymizedAggregateScan
        |           +-column_list=[$aggregate.$agg1#25]
        |           +-input_scan=
        |           | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |           +-aggregate_list=
        |             +-$agg1#25 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)
        +-aggregate_list=
          +-$agg1#26 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid'
==

# DIFFERENTIAL_PRIVACY nested in ANONYMIZATION
[ language_features=ANONYMIZATION,DIFFERENTIAL_PRIVACY,DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,NAMED_ARGUMENTS,NUMERIC_TYPE,JSON_TYPE]
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with ANONYMIZATION
  ANON_COUNT(*) from SimpleTypesWithAnonymizationUid CROSS JOIN
    (select with DIFFERENTIAL_PRIVACY
      COUNT(*) from SimpleTypesWithAnonymizationUid)
--

[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#26 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#26]
    +-input_scan=
      +-AnonymizedAggregateScan
        +-column_list=[$aggregate.$agg1#26]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[$aggregate.$agg1#25]
        |   +-left_scan=
        |   | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |   +-right_scan=
        |     +-ProjectScan
        |       +-column_list=[$aggregate.$agg1#25]
        |       +-input_scan=
        |         +-DifferentialPrivacyAggregateScan
        |           +-column_list=[$aggregate.$agg1#25]
        |           +-input_scan=
        |           | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |           +-aggregate_list=
        |             +-$agg1#25 :=
        |               +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |                 +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        +-aggregate_list=
          +-$agg1#26 := AggregateFunctionCall(ZetaSQL:$anon_count_star(optional(0) INT64, optional(0) INT64) -> INT64)

Rewrite ERROR: Subqueries of anonymization queries must explicitly SELECT the userid column 'uid'
==

# Union DIFFERENTIAL_PRIVACY and non dp query
select with DIFFERENTIAL_PRIVACY
  COUNT(*) from SimpleTypesWithAnonymizationUid
UNION ALL
select COUNT(*) from SimpleTypesWithAnonymizationUid
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#27 AS "$col1" [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#27]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$aggregate.$agg1#13]
      | |   +-input_scan=
      | |     +-DifferentialPrivacyAggregateScan
      | |       +-column_list=[$aggregate.$agg1#13]
      | |       +-input_scan=
      | |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
      | |       +-aggregate_list=
      | |         +-$agg1#13 :=
      | |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
      | |             +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
      | +-output_column_list=[$aggregate.$agg1#13]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#26]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#26]
        |       +-input_scan=
        |       | +-TableScan(table=SimpleTypesWithAnonymizationUid)
        |       +-aggregate_list=
        |         +-$agg1#26 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-output_column_list=[$aggregate.$agg1#26]
==

# Union DIFFERENTIAL_PRIVACY and non dp query
select with differential_privacy
  COUNT(* CLAMPED BETWEEN 0 AND 10) from SimpleTypesWithAnonymizationUid
--
ERROR: The CLAMPED BETWEEN clause is not allowed in the function call arguments for function COUNT [at 2:3]
  COUNT(* CLAMPED BETWEEN 0 AND 10) from SimpleTypesWithAnonymizationUid
  ^
==

# Regresssion: b/282900415, expression Subqueries in group by list
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
SELECT WITH DIFFERENTIAL_PRIVACY
  int32,
  (SELECT a FROM UNNEST([STRUCT(1 AS a), STRUCT(2)]) AS e),
  SUM(int64)
FROM SimpleTypesWithAnonymizationUid
GROUP BY 1, 2
--
QueryStmt
+-output_column_list=
| +-$groupby.int32#16 AS int32 [INT32]
| +-$groupby.$col2#17 AS "$col2" [INT64]
| +-$aggregate.$agg1#15 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-165
    +-column_list=[$groupby.int32#16, $groupby.$col2#17, $aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32#16, $groupby.$col2#17, $aggregate.$agg1#15]
        +-input_scan=
        | +-TableScan(parse_location=120-151, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1])
        +-group_by_list=
        | +-int32#16 := ColumnRef(parse_location=35-40, type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        | +-$col2#17 :=
        |   +-SubqueryExpr
        |     +-parse_location=45-99
        |     +-type=INT64
        |     +-subquery_type=SCALAR
        |     +-subquery=
        |       +-ProjectScan
        |         +-parse_location=45-99
        |         +-column_list=[$expr_subquery.a#14]
        |         +-expr_list=
        |         | +-a#14 :=
        |         |   +-GetStructField
        |         |     +-parse_location=52-53
        |         |     +-type=INT64
        |         |     +-expr=
        |         |     | +-ColumnRef(type=STRUCT<a INT64>, column=$array.e#13)
        |         |     +-field_idx=0
        |         +-input_scan=
        |           +-ArrayScan
        |             +-column_list=[$array.e#13]
        |             +-array_expr=
        |             | +-Literal(parse_location=66-93, type=ARRAY<STRUCT<a INT64>>, value=[{a:1}, {a:2}])
        |             +-element_column=$array.e#13
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=104-107
              +-ColumnRef(parse_location=108-113, type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
[REPLACED_LITERALS]
SELECT WITH DIFFERENTIAL_PRIVACY
  int32,
  (SELECT a FROM UNNEST(@_p0_ARRAY) AS e),
  SUM(int64)
FROM SimpleTypesWithAnonymizationUid
GROUP BY 1, 2

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.int32#16 AS int32 [INT32]
| +-$groupby.$col2#17 AS "$col2" [INT64]
| +-$aggregate.$agg1#15 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-165
    +-column_list=[$groupby.int32#16, $groupby.$col2#17, $aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32#16, $groupby.$col2#17, $aggregate.$agg1#15]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#20, $groupby.int32_partial#21, $groupby.$col2_partial#22, $group_by.$uid#23]
        |   +-input_scan=
        |   | +-TableScan(parse_location=120-151, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uid#18], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 10])
        |   +-group_by_list=
        |   | +-int32_partial#21 := ColumnRef(parse_location=35-40, type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        |   | +-$col2_partial#22 :=
        |   | | +-SubqueryExpr
        |   | |   +-parse_location=45-99
        |   | |   +-type=INT64
        |   | |   +-subquery_type=SCALAR
        |   | |   +-subquery=
        |   | |     +-ProjectScan
        |   | |       +-parse_location=45-99
        |   | |       +-column_list=[$expr_subquery.a#14]
        |   | |       +-expr_list=
        |   | |       | +-a#14 :=
        |   | |       |   +-GetStructField
        |   | |       |     +-parse_location=52-53
        |   | |       |     +-type=INT64
        |   | |       |     +-expr=
        |   | |       |     | +-ColumnRef(type=STRUCT<a INT64>, column=$array.e#13)
        |   | |       |     +-field_idx=0
        |   | |       +-input_scan=
        |   | |         +-ArrayScan
        |   | |           +-column_list=[$array.e#13]
        |   | |           +-array_expr=
        |   | |           | +-Literal(parse_location=66-93, type=ARRAY<STRUCT<a INT64>>, value=[{a:1}, {a:2}])
        |   | |           +-element_column=$array.e#13
        |   | +-$uid#23 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#18)
        |   +-aggregate_list=
        |     +-$agg1_partial#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-ColumnRef(parse_location=108-113, type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-group_by_list=
        | +-int32#16 := ColumnRef(type=INT32, column=$groupby.int32_partial#21)
        | +-$col2#17 := ColumnRef(type=INT64, column=$groupby.$col2_partial#22)
        +-aggregate_list=
        | +-$agg1#15 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#20)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#26 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#26)
==

# Regresssion: b/282900415, expression Subqueries in group by list
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
SELECT WITH DIFFERENTIAL_PRIVACY
  int32,
  (SELECT a FROM UNNEST([STRUCT(1 AS a), STRUCT(2)]) AS e) as x,
  SUM(int64)
FROM SimpleTypesWithAnonymizationUid
GROUP BY 1, (SELECT a FROM UNNEST([STRUCT(1 AS a), STRUCT(2)]) AS e)
--
QueryStmt
+-output_column_list=
| +-$groupby.int32#16 AS int32 [INT32]
| +-$query.x#22 AS x [INT64]
| +-$aggregate.$agg1#15 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-225
    +-column_list=[$groupby.int32#16, $query.x#22, $aggregate.$agg1#15]
    +-expr_list=
    | +-x#22 :=
    |   +-SubqueryExpr
    |     +-parse_location=45-99
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-parse_location=45-99
    |         +-column_list=[$expr_subquery.a#21]
    |         +-expr_list=
    |         | +-a#21 :=
    |         |   +-GetStructField
    |         |     +-parse_location=52-53
    |         |     +-type=INT64
    |         |     +-expr=
    |         |     | +-ColumnRef(type=STRUCT<a INT64>, column=$array.e#20)
    |         |     +-field_idx=0
    |         +-input_scan=
    |           +-ArrayScan
    |             +-column_list=[$array.e#20]
    |             +-array_expr=
    |             | +-Literal(parse_location=66-93, type=ARRAY<STRUCT<a INT64>>, value=[{a:1}, {a:2}])
    |             +-element_column=$array.e#20
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32#16, $aggregate.$agg1#15]
        +-input_scan=
        | +-TableScan(parse_location=125-156, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1])
        +-group_by_list=
        | +-int32#16 := ColumnRef(parse_location=35-40, type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        | +-$groupbycol2#19 :=
        |   +-SubqueryExpr
        |     +-parse_location=170-224
        |     +-type=INT64
        |     +-subquery_type=SCALAR
        |     +-subquery=
        |       +-ProjectScan
        |         +-parse_location=170-224
        |         +-column_list=[$expr_subquery.a#18]
        |         +-expr_list=
        |         | +-a#18 :=
        |         |   +-GetStructField
        |         |     +-parse_location=177-178
        |         |     +-type=INT64
        |         |     +-expr=
        |         |     | +-ColumnRef(type=STRUCT<a INT64>, column=$array.e#17)
        |         |     +-field_idx=0
        |         +-input_scan=
        |           +-ArrayScan
        |             +-column_list=[$array.e#17]
        |             +-array_expr=
        |             | +-Literal(parse_location=191-218, type=ARRAY<STRUCT<a INT64>>, value=[{a:1}, {a:2}])
        |             +-element_column=$array.e#17
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=109-112
              +-ColumnRef(parse_location=113-118, type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
[REPLACED_LITERALS]
SELECT WITH DIFFERENTIAL_PRIVACY
  int32,
  (SELECT a FROM UNNEST(@_p0_ARRAY) AS e) as x,
  SUM(int64)
FROM SimpleTypesWithAnonymizationUid
GROUP BY 1, (SELECT a FROM UNNEST(@_p1_ARRAY) AS e)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.int32#16 AS int32 [INT32]
| +-$query.x#22 AS x [INT64]
| +-$aggregate.$agg1#15 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-225
    +-column_list=[$groupby.int32#16, $query.x#22, $aggregate.$agg1#15]
    +-expr_list=
    | +-x#22 :=
    |   +-SubqueryExpr
    |     +-parse_location=45-99
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-parse_location=45-99
    |         +-column_list=[$expr_subquery.a#21]
    |         +-expr_list=
    |         | +-a#21 :=
    |         |   +-GetStructField
    |         |     +-parse_location=52-53
    |         |     +-type=INT64
    |         |     +-expr=
    |         |     | +-ColumnRef(type=STRUCT<a INT64>, column=$array.e#20)
    |         |     +-field_idx=0
    |         +-input_scan=
    |           +-ArrayScan
    |             +-column_list=[$array.e#20]
    |             +-array_expr=
    |             | +-Literal(parse_location=66-93, type=ARRAY<STRUCT<a INT64>>, value=[{a:1}, {a:2}])
    |             +-element_column=$array.e#20
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32#16, $aggregate.$agg1#15]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#25, $groupby.int32_partial#26, $groupby.$groupbycol2_partial#27, $group_by.$uid#28]
        |   +-input_scan=
        |   | +-TableScan(parse_location=125-156, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uid#23], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 10])
        |   +-group_by_list=
        |   | +-int32_partial#26 := ColumnRef(parse_location=35-40, type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        |   | +-$groupbycol2_partial#27 :=
        |   | | +-SubqueryExpr
        |   | |   +-parse_location=170-224
        |   | |   +-type=INT64
        |   | |   +-subquery_type=SCALAR
        |   | |   +-subquery=
        |   | |     +-ProjectScan
        |   | |       +-parse_location=170-224
        |   | |       +-column_list=[$expr_subquery.a#18]
        |   | |       +-expr_list=
        |   | |       | +-a#18 :=
        |   | |       |   +-GetStructField
        |   | |       |     +-parse_location=177-178
        |   | |       |     +-type=INT64
        |   | |       |     +-expr=
        |   | |       |     | +-ColumnRef(type=STRUCT<a INT64>, column=$array.e#17)
        |   | |       |     +-field_idx=0
        |   | |       +-input_scan=
        |   | |         +-ArrayScan
        |   | |           +-column_list=[$array.e#17]
        |   | |           +-array_expr=
        |   | |           | +-Literal(parse_location=191-218, type=ARRAY<STRUCT<a INT64>>, value=[{a:1}, {a:2}])
        |   | |           +-element_column=$array.e#17
        |   | +-$uid#28 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#23)
        |   +-aggregate_list=
        |     +-$agg1_partial#25 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-ColumnRef(parse_location=113-118, type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-group_by_list=
        | +-int32#16 := ColumnRef(type=INT32, column=$groupby.int32_partial#26)
        | +-$groupbycol2#19 := ColumnRef(type=INT64, column=$groupby.$groupbycol2_partial#27)
        +-aggregate_list=
        | +-$agg1#15 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#25)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#31 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#31)
==

# Regresssion: b/282900415, non-subquery select expr in select list
# Disable array_filter rewrite due to b/290669074
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE,V_1_3_INLINE_LAMBDA_ARGUMENT]
[enabled_ast_rewrites=NONE,+ANONYMIZATION]
SELECT WITH DIFFERENTIAL_PRIVACY
  int32,
  ARRAY_TO_STRING(ARRAY_FILTER(['a', 'b', 'c'], e -> e = 'x'), ','),
  SUM(int64)
FROM SimpleTypesWithAnonymizationUid
GROUP BY 1, 2
--
QueryStmt
+-output_column_list=
| +-$groupby.int32#15 AS int32 [INT32]
| +-$groupby.$col2#16 AS "$col2" [STRING]
| +-$aggregate.$agg1#14 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.int32#15, $groupby.$col2#16, $aggregate.$agg1#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32#15, $groupby.$col2#16, $aggregate.$agg1#14]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1])
        +-group_by_list=
        | +-int32#15 := ColumnRef(type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        | +-$col2#16 :=
        |   +-FunctionCall(ZetaSQL:array_to_string(ARRAY<STRING>, STRING, optional(0) STRING) -> STRING)
        |     +-FunctionCall(ZetaSQL:array_filter(ARRAY<STRING> array_to_filter, FUNCTION<STRING->BOOL> condition) -> ARRAY<STRING>)
        |     | +-FunctionArgument
        |     | | +-expr=
        |     | |   +-Literal(type=ARRAY<STRING>, value=['a', 'b', 'c'])
        |     | +-FunctionArgument
        |     |   +-inline_lambda=
        |     |     +-InlineLambda
        |     |       +-argument_list=[$lambda_arg.e#13]
        |     |       +-body=
        |     |         +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
        |     |           +-ColumnRef(type=STRING, column=$lambda_arg.e#13)
        |     |           +-Literal(type=STRING, value='x')
        |     +-Literal(type=STRING, value=',')
        +-aggregate_list=
          +-$agg1#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.int32#15 AS int32 [INT32]
| +-$groupby.$col2#16 AS "$col2" [STRING]
| +-$aggregate.$agg1#14 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.int32#15, $groupby.$col2#16, $aggregate.$agg1#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32#15, $groupby.$col2#16, $aggregate.$agg1#14]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#19, $groupby.int32_partial#20, $groupby.$col2_partial#21, $group_by.$uid#22]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uid#17], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 10])
        |   +-group_by_list=
        |   | +-int32_partial#20 := ColumnRef(type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        |   | +-$col2_partial#21 :=
        |   | | +-FunctionCall(ZetaSQL:array_to_string(ARRAY<STRING>, STRING, optional(0) STRING) -> STRING)
        |   | |   +-FunctionCall(ZetaSQL:array_filter(ARRAY<STRING> array_to_filter, FUNCTION<STRING->BOOL> condition) -> ARRAY<STRING>)
        |   | |   | +-FunctionArgument
        |   | |   | | +-expr=
        |   | |   | |   +-Literal(type=ARRAY<STRING>, value=['a', 'b', 'c'])
        |   | |   | +-FunctionArgument
        |   | |   |   +-inline_lambda=
        |   | |   |     +-InlineLambda
        |   | |   |       +-argument_list=[$lambda_arg.e#13]
        |   | |   |       +-body=
        |   | |   |         +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
        |   | |   |           +-ColumnRef(type=STRING, column=$lambda_arg.e#13)
        |   | |   |           +-Literal(type=STRING, value='x')
        |   | |   +-Literal(type=STRING, value=',')
        |   | +-$uid#22 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#17)
        |   +-aggregate_list=
        |     +-$agg1_partial#19 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-group_by_list=
        | +-int32#15 := ColumnRef(type=INT32, column=$groupby.int32_partial#20)
        | +-$col2#16 := ColumnRef(type=STRING, column=$groupby.$col2_partial#21)
        +-aggregate_list=
        | +-$agg1#14 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#19)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#25 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#25)
==

# Regresssion: b/282900415, non-subquery, not selected, select expr in select list
# Disable array_filter rewrite due to b/290669074
[language_features=DIFFERENTIAL_PRIVACY,NAMED_ARGUMENTS,NUMERIC_TYPE,V_1_3_INLINE_LAMBDA_ARGUMENT]
[enabled_ast_rewrites=NONE,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
SELECT WITH DIFFERENTIAL_PRIVACY
  s,
  ARRAY_FILTER(SPLIT(s), e -> e = 'x'),
  SUM(int64)
FROM (SELECT *, 'a,b,c' as s
      FROM SimpleTypesWithAnonymizationUid)
GROUP BY 1
--
QueryStmt
+-output_column_list=
| +-$groupby.s#16 AS s [STRING]
| +-$query.$col2#18 AS "$col2" [ARRAY<STRING>]
| +-$aggregate.$agg1#15 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-174
    +-column_list=[$groupby.s#16, $query.$col2#18, $aggregate.$agg1#15]
    +-expr_list=
    | +-$col2#18 :=
    |   +-FunctionCall(ZetaSQL:array_filter(ARRAY<STRING> array_to_filter, FUNCTION<STRING->BOOL> condition) -> ARRAY<STRING>)
    |     +-parse_location=40-52
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-FunctionCall(ZetaSQL:split(STRING, optional(0) STRING) -> ARRAY<STRING>)
    |     |     +-parse_location=53-58
    |     |     +-ColumnRef(parse_location=59-60, type=STRING, column=$groupby.s#16)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#17]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |               +-ColumnRef(parse_location=68-69, type=STRING, column=$lambda_arg.e#17)
    |               +-Literal(parse_location=72-75, type=STRING, value="x")
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.s#16, $aggregate.$agg1#15]
        +-input_scan=
        | +-ProjectScan
        |   +-parse_location=97-162
        |   +-column_list=[SimpleTypesWithAnonymizationUid.int32#1, SimpleTypesWithAnonymizationUid.int64#2, SimpleTypesWithAnonymizationUid.uint32#3, SimpleTypesWithAnonymizationUid.uint64#4, SimpleTypesWithAnonymizationUid.string#5, SimpleTypesWithAnonymizationUid.bytes#6, SimpleTypesWithAnonymizationUid.bool#7, SimpleTypesWithAnonymizationUid.float#8, SimpleTypesWithAnonymizationUid.double#9, SimpleTypesWithAnonymizationUid.date#10, SimpleTypesWithAnonymizationUid.uid#11, SimpleTypesWithAnonymizationUid.numeric#12, $subquery1.s#13]
        |   +-expr_list=
        |   | +-s#13 := Literal(parse_location=107-114, type=STRING, value="a,b,c")
        |   +-input_scan=
        |     +-TableScan(parse_location=131-162, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        +-group_by_list=
        | +-s#16 := ColumnRef(parse_location=35-36, type=STRING, column=$subquery1.s#13)
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=80-83
              +-ColumnRef(parse_location=84-89, type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
[REPLACED_LITERALS]
SELECT WITH DIFFERENTIAL_PRIVACY
  s,
  ARRAY_FILTER(SPLIT(s), e -> e = @_p0_STRING),
  SUM(int64)
FROM (SELECT *, @_p1_STRING as s
      FROM SimpleTypesWithAnonymizationUid)
GROUP BY 1

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.s#16 AS s [STRING]
| +-$query.$col2#18 AS "$col2" [ARRAY<STRING>]
| +-$aggregate.$agg1#15 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-174
    +-column_list=[$groupby.s#16, $query.$col2#18, $aggregate.$agg1#15]
    +-expr_list=
    | +-$col2#18 :=
    |   +-FunctionCall(ZetaSQL:array_filter(ARRAY<STRING> array_to_filter, FUNCTION<STRING->BOOL> condition) -> ARRAY<STRING>)
    |     +-parse_location=40-52
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-FunctionCall(ZetaSQL:split(STRING, optional(0) STRING) -> ARRAY<STRING>)
    |     |     +-parse_location=53-58
    |     |     +-ColumnRef(parse_location=59-60, type=STRING, column=$groupby.s#16)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#17]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |               +-ColumnRef(parse_location=68-69, type=STRING, column=$lambda_arg.e#17)
    |               +-Literal(parse_location=72-75, type=STRING, value="x")
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.s#16, $aggregate.$agg1#15]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#20, $groupby.s_partial#21, $group_by.$uid#22]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-parse_location=97-162
        |   |   +-column_list=[SimpleTypesWithAnonymizationUid.int32#1, SimpleTypesWithAnonymizationUid.int64#2, SimpleTypesWithAnonymizationUid.uint32#3, SimpleTypesWithAnonymizationUid.uint64#4, SimpleTypesWithAnonymizationUid.string#5, SimpleTypesWithAnonymizationUid.bytes#6, SimpleTypesWithAnonymizationUid.bool#7, SimpleTypesWithAnonymizationUid.float#8, SimpleTypesWithAnonymizationUid.double#9, SimpleTypesWithAnonymizationUid.date#10, SimpleTypesWithAnonymizationUid.uid#11, SimpleTypesWithAnonymizationUid.numeric#12, $subquery1.s#13]
        |   |   +-expr_list=
        |   |   | +-s#13 := Literal(parse_location=107-114, type=STRING, value="a,b,c")
        |   |   +-input_scan=
        |   |     +-TableScan(parse_location=131-162, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |   +-group_by_list=
        |   | +-s_partial#21 := ColumnRef(parse_location=35-36, type=STRING, column=$subquery1.s#13)
        |   | +-$uid#22 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |   +-aggregate_list=
        |     +-$agg1_partial#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-ColumnRef(parse_location=84-89, type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-group_by_list=
        | +-s#16 := ColumnRef(type=STRING, column=$groupby.s_partial#21)
        +-aggregate_list=
        | +-$agg1#15 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#20)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#25 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#25)
==

# Regresssion: b/282900415, expression Subqueries not in group by list
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
SELECT WITH DIFFERENTIAL_PRIVACY
  int32,
  (SELECT a FROM UNNEST([STRUCT(1 AS a), STRUCT(2)]) AS e),
  SUM(int64)
FROM SimpleTypesWithAnonymizationUid
GROUP BY 1
--
QueryStmt
+-output_column_list=
| +-$groupby.int32#16 AS int32 [INT32]
| +-$query.$col2#19 AS "$col2" [INT64]
| +-$aggregate.$agg1#15 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-162
    +-column_list=[$groupby.int32#16, $query.$col2#19, $aggregate.$agg1#15]
    +-expr_list=
    | +-$col2#19 :=
    |   +-SubqueryExpr
    |     +-parse_location=45-99
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-parse_location=45-99
    |         +-column_list=[$expr_subquery.a#18]
    |         +-expr_list=
    |         | +-a#18 :=
    |         |   +-GetStructField
    |         |     +-parse_location=52-53
    |         |     +-type=INT64
    |         |     +-expr=
    |         |     | +-ColumnRef(type=STRUCT<a INT64>, column=$array.e#17)
    |         |     +-field_idx=0
    |         +-input_scan=
    |           +-ArrayScan
    |             +-column_list=[$array.e#17]
    |             +-array_expr=
    |             | +-Literal(parse_location=66-93, type=ARRAY<STRUCT<a INT64>>, value=[{a:1}, {a:2}])
    |             +-element_column=$array.e#17
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32#16, $aggregate.$agg1#15]
        +-input_scan=
        | +-TableScan(parse_location=120-151, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1])
        +-group_by_list=
        | +-int32#16 := ColumnRef(parse_location=35-40, type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=104-107
              +-ColumnRef(parse_location=108-113, type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
[REPLACED_LITERALS]
SELECT WITH DIFFERENTIAL_PRIVACY
  int32,
  (SELECT a FROM UNNEST(@_p0_ARRAY) AS e),
  SUM(int64)
FROM SimpleTypesWithAnonymizationUid
GROUP BY 1

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.int32#16 AS int32 [INT32]
| +-$query.$col2#19 AS "$col2" [INT64]
| +-$aggregate.$agg1#15 AS "$col3" [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-162
    +-column_list=[$groupby.int32#16, $query.$col2#19, $aggregate.$agg1#15]
    +-expr_list=
    | +-$col2#19 :=
    |   +-SubqueryExpr
    |     +-parse_location=45-99
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-parse_location=45-99
    |         +-column_list=[$expr_subquery.a#18]
    |         +-expr_list=
    |         | +-a#18 :=
    |         |   +-GetStructField
    |         |     +-parse_location=52-53
    |         |     +-type=INT64
    |         |     +-expr=
    |         |     | +-ColumnRef(type=STRUCT<a INT64>, column=$array.e#17)
    |         |     +-field_idx=0
    |         +-input_scan=
    |           +-ArrayScan
    |             +-column_list=[$array.e#17]
    |             +-array_expr=
    |             | +-Literal(parse_location=66-93, type=ARRAY<STRUCT<a INT64>>, value=[{a:1}, {a:2}])
    |             +-element_column=$array.e#17
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$groupby.int32#16, $aggregate.$agg1#15]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#22, $groupby.int32_partial#23, $group_by.$uid#24]
        |   +-input_scan=
        |   | +-TableScan(parse_location=120-151, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uid#20], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 10])
        |   +-group_by_list=
        |   | +-int32_partial#23 := ColumnRef(parse_location=35-40, type=INT32, column=SimpleTypesWithAnonymizationUid.int32#1)
        |   | +-$uid#24 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#20)
        |   +-aggregate_list=
        |     +-$agg1_partial#22 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-ColumnRef(parse_location=108-113, type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-group_by_list=
        | +-int32#16 := ColumnRef(type=INT32, column=$groupby.int32_partial#23)
        +-aggregate_list=
        | +-$agg1#15 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#22)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
        | +-$group_selection_threshold_col#27 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#27)
