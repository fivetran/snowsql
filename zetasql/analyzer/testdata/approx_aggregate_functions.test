select approx_count_distinct(key), approx_quantiles(key, 100) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [INT64]
| +-$aggregate.$agg2#4 AS `$col2` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#3, $agg2#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#3, $agg2#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
          | +-AggregateFunctionCall(ZetaSQL:approx_count_distinct(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          +-$agg2#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=100)
==

select approx_count_distinct(KitchenSink) from TestTable
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type zetasql_test__.KitchenSinkPB does not [at 1:30]
select approx_count_distinct(KitchenSink) from TestTable
                             ^
==

select approx_count_distinct(TestEnum) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.TestEnum#2], table=TestTable, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_count_distinct(ENUM<zetasql_test__.TestEnum>) -> INT64)
              +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#2)
==

# A literal ARRAY of groupable elements.
[language_features={{|V_1_2_GROUP_BY_ARRAY}}]
select approx_count_distinct([10]) from TestTable
--
ALTERNATION GROUP: <empty>
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type ARRAY<INT64> does not [at 1:30]
select approx_count_distinct([10]) from TestTable
                             ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_count_distinct(ARRAY<INT64>) -> INT64)
              +-Literal(type=ARRAY<INT64>, value=[10])
==

# A non-literal ARRAY of groupable elements.
[language_features={{|V_1_2_GROUP_BY_ARRAY}}]
select approx_count_distinct([string, 'a']) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type ARRAY<STRING> does not [at 1:30]
select approx_count_distinct([string, 'a']) from SimpleTypes
                             ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:approx_count_distinct(ARRAY<STRING>) -> INT64)
              +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
                +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
                +-Literal(type=STRING, value="a")
==

# ARRAY of non-groupable elements.
[language_features={{|V_1_2_GROUP_BY_ARRAY}}]
select approx_count_distinct([KitchenSink]) from TestTable
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type ARRAY<zetasql_test__.KitchenSinkPB> does not [at 1:30]
select approx_count_distinct([KitchenSink]) from TestTable
                             ^
==

# A literal STRUCT with groupable fields.
[language_features={{|V_1_2_GROUP_BY_STRUCT}}]
select approx_count_distinct((1,2)) from TestTable
--
ALTERNATION GROUP: <empty>
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type STRUCT<INT64, INT64> does not [at 1:30]
select approx_count_distinct((1,2)) from TestTable
                             ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_count_distinct(STRUCT<INT64, INT64>) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={1, 2})
==

# A non-literal STRUCT with groupable fields.
[language_features={{|V_1_2_GROUP_BY_STRUCT}}]
select approx_count_distinct((1,string)) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type STRUCT<INT64, STRING> does not [at 1:30]
select approx_count_distinct((1,string)) from SimpleTypes
                             ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:approx_count_distinct(STRUCT<INT64, STRING>) -> INT64)
              +-MakeStruct
                +-type=STRUCT<INT64, STRING>
                +-field_list=
                  +-Literal(type=INT64, value=1)
                  +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
==

# STRUCT with non-groupable fields.
[language_features={{|V_1_2_GROUP_BY_STRUCT}}]
select approx_count_distinct((1,2, KitchenSink)) from TestTable
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type STRUCT<INT64, INT64, zetasql_test__.KitchenSinkPB> does not [at 1:30]
select approx_count_distinct((1,2, KitchenSink)) from TestTable
                             ^
==

select approx_quantiles(key, @test_param_int64) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Parameter(type=INT64, name="test_param_int64")
==

# Script variables should work with approx_quantiles.
select approx_quantiles(key, int_variable_foo)
from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Cast(INT32 -> INT64)
                +-Constant(int_variable_foo, type=INT32, value=4)

==

# Cast of a param still counts as a constant argument.
select approx_quantiles(key, cast(cast(@test_param_uint32 as string) as int64))
from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Cast(STRING -> INT64)
                +-Cast(UINT32 -> STRING)
                  +-Parameter(type=UINT32, name="test_param_uint32")
==

# During unparsing, this parameter has a widening cast to int64 added.
# We still want this to pass parameter checks after unparsing.
select approx_quantiles(key, @test_param_int32) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Cast(INT32 -> INT64)
                +-Parameter(type=INT32, name="test_param_int32")
==

select approx_quantiles(KitchenSink, 10) from TestTable
--
ERROR: Argument 1 to APPROX_QUANTILES must support ordering; Type zetasql_test__.KitchenSinkPB does not [at 1:25]
select approx_quantiles(KitchenSink, 10) from TestTable
                        ^
==

select approx_quantiles(key, NULL) from KeyValue
--
ERROR: Argument 2 to APPROX_QUANTILES must be non-NULL [at 1:30]
select approx_quantiles(key, NULL) from KeyValue
                             ^
==

select approx_quantiles(key, 0) from KeyValue
--
ERROR: Argument 2 to APPROX_QUANTILES must be at least 1 [at 1:30]
select approx_quantiles(key, 0) from KeyValue
                             ^
==

select approx_quantiles(key, -1) from KeyValue
--
ERROR: Argument 2 to APPROX_QUANTILES must be at least 1 [at 1:30]
select approx_quantiles(key, -1) from KeyValue
                             ^
==

select approx_quantiles(key, 1+0) from KeyValue
--
ERROR: Argument 2 to APPROX_QUANTILES must be a literal or query parameter [at 1:30]
select approx_quantiles(key, 1+0) from KeyValue
                             ^
==

select approx_quantiles(key, cast(1 as int32)) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
==

select approx_quantiles(key, cast(@test_param_int64 as int32)) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Cast(INT32 -> INT64)
                +-Cast(INT64 -> INT32)
                  +-Parameter(type=INT64, name="test_param_int64")
==

# IGNORE NULLS are allowed.
[language_features={{V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE|}}]
select approx_quantiles(key, 10 ignore nulls) from KeyValue
--
ALTERNATION GROUP: V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=10)
              +-null_handling_modifier=IGNORE_NULLS
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in aggregate functions are not supported [at 1:8]
select approx_quantiles(key, 10 ignore nulls) from KeyValue
       ^
==

# RESPECT NULLS are allowed.
[language_features={{V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE|}}]
select approx_quantiles(key, 10 respect nulls) from KeyValue
--
ALTERNATION GROUP: V_1_1_NULL_HANDLING_MODIFIER_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=10)
              +-null_handling_modifier=RESPECT_NULLS
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in aggregate functions are not supported [at 1:8]
select approx_quantiles(key, 10 respect nulls) from KeyValue
       ^
==

select approx_quantiles() from KeyValue
--
ERROR: Number of arguments does not match for aggregate function APPROX_QUANTILES. Supported signature: APPROX_QUANTILES(ANY, INT64) [at 1:8]
select approx_quantiles() from KeyValue
       ^
==

select approx_quantiles(key) from KeyValue
--
ERROR: Number of arguments does not match for aggregate function APPROX_QUANTILES. Supported signature: APPROX_QUANTILES(ANY, INT64) [at 1:8]
select approx_quantiles(key) from KeyValue
       ^
==

select approx_top_count(int64, 10) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [ARRAY<STRUCT<value INT64, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(INT64, INT64) -> ARRAY<STRUCT<value INT64, count INT64>>)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-Literal(type=INT64, value=10)
==

select approx_top_count(string, @test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [ARRAY<STRUCT<value STRING, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(STRING, INT64) -> ARRAY<STRUCT<value STRING, count INT64>>)
              +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
              +-Parameter(type=INT64, name="test_param_int64")
==

select approx_top_count(string, null) from SimpleTypes
--
ERROR: Argument 2 to APPROX_TOP_COUNT must be non-NULL [at 1:33]
select approx_top_count(string, null) from SimpleTypes
                                ^
==

select approx_top_count(string, 0) from SimpleTypes
--
ERROR: Argument 2 to APPROX_TOP_COUNT must be at least 1 [at 1:33]
select approx_top_count(string, 0) from SimpleTypes
                                ^
==

select approx_top_count(string, -1) from SimpleTypes
--
ERROR: Argument 2 to APPROX_TOP_COUNT must be at least 1 [at 1:33]
select approx_top_count(string, -1) from SimpleTypes
                                ^
==

select approx_top_count(string, 1+1) from SimpleTypes
--
ERROR: Argument 2 to APPROX_TOP_COUNT must be a literal or query parameter [at 1:33]
select approx_top_count(string, 1+1) from SimpleTypes
                                ^
==

select approx_top_count(string) from SimpleTypes
--
ERROR: Number of arguments does not match for aggregate function APPROX_TOP_COUNT. Supported signature: APPROX_TOP_COUNT(ANY, INT64) [at 1:8]
select approx_top_count(string) from SimpleTypes
       ^
==

select approx_top_count() from SimpleTypes
--
ERROR: Number of arguments does not match for aggregate function APPROX_TOP_COUNT. Supported signature: APPROX_TOP_COUNT(ANY, INT64) [at 1:8]
select approx_top_count() from SimpleTypes
       ^
==

select approx_top_count(string, 10, 11) from SimpleTypes
--
ERROR: Number of arguments does not match for aggregate function APPROX_TOP_COUNT. Supported signature: APPROX_TOP_COUNT(ANY, INT64) [at 1:8]
select approx_top_count(string, 10, 11) from SimpleTypes
       ^
==

select approx_top_count(KitchenSink, 10) from TestTable
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type zetasql_test__.KitchenSinkPB does not [at 1:25]
select approx_top_count(KitchenSink, 10) from TestTable
                        ^
==

select approx_top_count(TestEnum, 10) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value ENUM<zetasql_test__.TestEnum>, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.TestEnum#2], table=TestTable, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(ENUM<zetasql_test__.TestEnum>, INT64) -> ARRAY<STRUCT<value ENUM<zetasql_test__.TestEnum>, count INT64>>)
              +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#2)
              +-Literal(type=INT64, value=10)
==

# A literal ARRAY with groupable elements
[language_features={{|V_1_2_GROUP_BY_ARRAY}}]
select approx_top_count([1,2], 10) from TestTable
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type ARRAY<INT64> does not [at 1:25]
select approx_top_count([1,2], 10) from TestTable
                        ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value ARRAY<INT64>, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(ARRAY<INT64>, INT64) -> ARRAY<STRUCT<value ARRAY<INT64>, count INT64>>)
              +-Literal(type=ARRAY<INT64>, value=[1, 2])
              +-Literal(type=INT64, value=10)
==

# A non-literal ARRAY with groupable elements
[language_features={{|V_1_2_GROUP_BY_ARRAY}}]
select approx_top_count(['a',string], 10) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type ARRAY<STRING> does not [at 1:25]
select approx_top_count(['a',string], 10) from SimpleTypes
                        ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [ARRAY<STRUCT<value ARRAY<STRING>, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(ARRAY<STRING>, INT64) -> ARRAY<STRUCT<value ARRAY<STRING>, count INT64>>)
              +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
              | +-Literal(type=STRING, value="a")
              | +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
              +-Literal(type=INT64, value=10)
==

# An ARRAY with non-groupable elements
[language_features={{|V_1_2_GROUP_BY_ARRAY}}]
select approx_top_count([KitchenSink], 10) from TestTable
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type ARRAY<zetasql_test__.KitchenSinkPB> does not [at 1:25]
select approx_top_count([KitchenSink], 10) from TestTable
                        ^
==

# A literal STRUCT with groupable fields
[language_features={{|V_1_2_GROUP_BY_STRUCT}}]
select approx_top_count((1,2), 10) from TestTable
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type STRUCT<INT64, INT64> does not [at 1:25]
select approx_top_count((1,2), 10) from TestTable
                        ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value STRUCT<INT64, INT64>, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(STRUCT<INT64, INT64>, INT64) -> ARRAY<STRUCT<value STRUCT<INT64, INT64>, count INT64>>)
              +-Literal(type=STRUCT<INT64, INT64>, value={1, 2})
              +-Literal(type=INT64, value=10)
==

# A non-literal STRUCT with groupable fields
[language_features={{|V_1_2_GROUP_BY_STRUCT}}]
select approx_top_count((1,string), 10) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type STRUCT<INT64, STRING> does not [at 1:25]
select approx_top_count((1,string), 10) from SimpleTypes
                        ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [ARRAY<STRUCT<value STRUCT<INT64, STRING>, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(STRUCT<INT64, STRING>, INT64) -> ARRAY<STRUCT<value STRUCT<INT64, STRING>, count INT64>>)
              +-MakeStruct
              | +-type=STRUCT<INT64, STRING>
              | +-field_list=
              |   +-Literal(type=INT64, value=1)
              |   +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
              +-Literal(type=INT64, value=10)
==

# A STRUCT with non-groupable fields
[language_features={{|V_1_2_GROUP_BY_STRUCT}}]
select approx_top_count((1,KitchenSink), 10) from TestTable
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type STRUCT<INT64, zetasql_test__.KitchenSinkPB> does not [at 1:25]
select approx_top_count((1,KitchenSink), 10) from TestTable
                        ^
==

select approx_top_sum(int64, int64, 10) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [ARRAY<STRUCT<value INT64, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(INT64, INT64, INT64) -> ARRAY<STRUCT<value INT64, sum INT64>>)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-Literal(type=INT64, value=10)
==

select approx_top_sum(bytes, double, 10) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [ARRAY<STRUCT<value BYTES, sum DOUBLE>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[bytes#6, double#9], table=SimpleTypes, column_index_list=[5, 8])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(BYTES, DOUBLE, INT64) -> ARRAY<STRUCT<value BYTES, sum DOUBLE>>)
              +-ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
              +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
              +-Literal(type=INT64, value=10)
==

select approx_top_sum(TestEnum, KitchenSink.double_val, @test_param_int64) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value ENUM<zetasql_test__.TestEnum>, sum DOUBLE>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[1, 2])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(ENUM<zetasql_test__.TestEnum>, DOUBLE, INT64) -> ARRAY<STRUCT<value ENUM<zetasql_test__.TestEnum>, sum DOUBLE>>)
              +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#2)
              +-GetProtoField
              | +-type=DOUBLE
              | +-expr=
              | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              | +-field_descriptor=double_val
              | +-default_value=0
              +-Parameter(type=INT64, name="test_param_int64")
==

select approx_top_sum(null, 1.6, @test_param_int64) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value INT64, sum DOUBLE>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(INT64, DOUBLE, INT64) -> ARRAY<STRUCT<value INT64, sum DOUBLE>>)
              +-Literal(type=INT64, value=NULL)
              +-Literal(type=DOUBLE, value=1.6)
              +-Parameter(type=INT64, name="test_param_int64")
==

select approx_top_sum(key, null, @test_param_int64) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value INT32, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(INT32, INT64, INT64) -> ARRAY<STRUCT<value INT32, sum INT64>>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-Literal(type=INT64, value=NULL)
              +-Parameter(type=INT64, name="test_param_int64")
==

select approx_top_sum(key, 1.6, null) from TestTable
--
ERROR: Argument 3 to APPROX_TOP_SUM must be non-NULL [at 1:33]
select approx_top_sum(key, 1.6, null) from TestTable
                                ^
==

select approx_top_sum(key, 1.5, 0) from TestTable
--
ERROR: Argument 3 to APPROX_TOP_SUM must be at least 1 [at 1:33]
select approx_top_sum(key, 1.5, 0) from TestTable
                                ^
==

select approx_top_sum(key, 1.4, -1) from TestTable
--
ERROR: Argument 3 to APPROX_TOP_SUM must be at least 1 [at 1:33]
select approx_top_sum(key, 1.4, -1) from TestTable
                                ^
==

select approx_top_sum(KitchenSink, key, 10) from TestTable
--
ERROR: Argument 1 to APPROX_TOP_SUM must support grouping; Type zetasql_test__.KitchenSinkPB does not [at 1:23]
select approx_top_sum(KitchenSink, key, 10) from TestTable
                      ^
==

# A literal ARRAY with groupable elements.
[language_features={{|V_1_2_GROUP_BY_ARRAY}}]
select approx_top_sum([1], key, 10) from TestTable
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_SUM must support grouping; Type ARRAY<INT64> does not [at 1:23]
select approx_top_sum([1], key, 10) from TestTable
                      ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value ARRAY<INT64>, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(ARRAY<INT64>, INT64, INT64) -> ARRAY<STRUCT<value ARRAY<INT64>, sum INT64>>)
              +-Literal(type=ARRAY<INT64>, value=[1])
              +-Cast(INT32 -> INT64)
              | +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-Literal(type=INT64, value=10)
==

# A non-literal ARRAY with groupable elements.
[language_features={{|V_1_2_GROUP_BY_ARRAY}}]
select approx_top_sum(['a', string], int64, 10) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_SUM must support grouping; Type ARRAY<STRING> does not [at 1:23]
select approx_top_sum(['a', string], int64, 10) from SimpleTypes
                      ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [ARRAY<STRUCT<value ARRAY<STRING>, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, string#5], table=SimpleTypes, column_index_list=[1, 4])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(ARRAY<STRING>, INT64, INT64) -> ARRAY<STRUCT<value ARRAY<STRING>, sum INT64>>)
              +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
              | +-Literal(type=STRING, value="a")
              | +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-Literal(type=INT64, value=10)
==

# An ARRAY with non-groupable elements.
[language_features={{|V_1_2_GROUP_BY_ARRAY}}]
select approx_top_sum([KitchenSink], int64, 10) from TestTable
--
ERROR: Unrecognized name: int64 [at 1:38]
select approx_top_sum([KitchenSink], int64, 10) from TestTable
                                     ^
==

# A literal STRUCT with groupable fields.
[language_features={{|V_1_2_GROUP_BY_STRUCT}}]
select approx_top_sum((1,2), key, 10) from TestTable
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_SUM must support grouping; Type STRUCT<INT64, INT64> does not [at 1:23]
select approx_top_sum((1,2), key, 10) from TestTable
                      ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value STRUCT<INT64, INT64>, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(STRUCT<INT64, INT64>, INT64, INT64) -> ARRAY<STRUCT<value STRUCT<INT64, INT64>, sum INT64>>)
              +-Literal(type=STRUCT<INT64, INT64>, value={1, 2})
              +-Cast(INT32 -> INT64)
              | +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-Literal(type=INT64, value=10)
==

# A non-literal STRUCT with groupable fields.
[language_features={{|V_1_2_GROUP_BY_STRUCT}}]
select approx_top_sum((1, string), int64, 10) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_SUM must support grouping; Type STRUCT<INT64, STRING> does not [at 1:23]
select approx_top_sum((1, string), int64, 10) from SimpleTypes
                      ^
--
ALTERNATION GROUP: V_1_2_GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [ARRAY<STRUCT<value STRUCT<INT64, STRING>, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, string#5], table=SimpleTypes, column_index_list=[1, 4])
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(STRUCT<INT64, STRING>, INT64, INT64) -> ARRAY<STRUCT<value STRUCT<INT64, STRING>, sum INT64>>)
              +-MakeStruct
              | +-type=STRUCT<INT64, STRING>
              | +-field_list=
              |   +-Literal(type=INT64, value=1)
              |   +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-Literal(type=INT64, value=10)
==

# A STRUCT with non-groupable fields.
[language_features={{|V_1_2_GROUP_BY_STRUCT}}]
select approx_top_sum((1, KitchenSink), key, 10) from TestTable
--
ERROR: Argument 1 to APPROX_TOP_SUM must support grouping; Type STRUCT<INT64, zetasql_test__.KitchenSinkPB> does not [at 1:23]
select approx_top_sum((1, KitchenSink), key, 10) from TestTable
                      ^
==

select approx_top_sum(key, cast(5 as int32), 10) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value INT32, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(INT32, INT64, INT64) -> ARRAY<STRUCT<value INT32, sum INT64>>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-Literal(type=INT64, value=5, has_explicit_type=TRUE)
              +-Literal(type=INT64, value=10)
==

select sum(cast(5 as uint64)), approx_top_sum(key, cast(5 as uint64), 10) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [UINT64]
| +-$aggregate.$agg2#5 AS `$col2` [ARRAY<STRUCT<value INT32, sum UINT64>>]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#4, $agg2#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#4, $agg2#5]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(UINT64) -> UINT64)
          |   +-Literal(type=UINT64, value=5, has_explicit_type=TRUE)
          +-$agg2#5 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(INT32, UINT64, INT64) -> ARRAY<STRUCT<value INT32, sum UINT64>>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-Literal(type=UINT64, value=5, has_explicit_type=TRUE)
              +-Literal(type=INT64, value=10)
==

# UINT32 widens to UINT64, not INT64.
select sum(cast(5 as uint32)), approx_top_sum(key, cast(5 as uint32), 10) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [UINT64]
| +-$aggregate.$agg2#5 AS `$col2` [ARRAY<STRUCT<value INT32, sum UINT64>>]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#4, $agg2#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#4, $agg2#5]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(UINT64) -> UINT64)
          |   +-Literal(type=UINT64, value=5, has_explicit_type=TRUE)
          +-$agg2#5 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(INT32, UINT64, INT64) -> ARRAY<STRUCT<value INT32, sum UINT64>>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-Literal(type=UINT64, value=5, has_explicit_type=TRUE)
              +-Literal(type=INT64, value=10)
==

select hll_count.merge(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.merge(BYTES) -> INT64)
              +-Parameter(type=BYTES, name="test_param_bytes")
==

select hll_count.extract(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-FunctionCall(ZetaSQL:hll_count.extract(BYTES) -> INT64)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

select hll_count.init(@test_param_int64, 10) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(INT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Literal(type=INT64, value=10)
==

select hll_count.init(@test_param_int64, 24) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(INT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Literal(type=INT64, value=24)
==

select hll_count.init(@test_param_int64, @test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(INT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Parameter(type=INT64, name="test_param_int64")
==

select hll_count.init(@test_param_int64, key) from KeyValue
--
ERROR: Argument 2 to HLL_COUNT.INIT must be a literal or query parameter [at 1:42]
select hll_count.init(@test_param_int64, key) from KeyValue
                                         ^
==

select hll_count.init(@test_param_int64, null) from SimpleTypes
--
ERROR: Argument 2 to HLL_COUNT.INIT must be non-NULL [at 1:42]
select hll_count.init(@test_param_int64, null) from SimpleTypes
                                         ^
==

select hll_count.init(@test_param_int64, 9) from SimpleTypes
--
ERROR: Argument 2 to HLL_COUNT.INIT must be between 10 and 24 [at 1:42]
select hll_count.init(@test_param_int64, 9) from SimpleTypes
                                         ^
==

# Value range checking should happen even if we start from an int32
# and have to widen to int64.
select hll_count.init(@test_param_int64, cast(12 as int32)),
       hll_count.init(@test_param_int64, cast(9 as int32))
from SimpleTypes
--
ERROR: Argument 2 to HLL_COUNT.INIT must be between 10 and 24 [at 2:42]
       hll_count.init(@test_param_int64, cast(9 as int32))
                                         ^
==

select hll_count.init(@test_param_int64, 25) from SimpleTypes
--
ERROR: Argument 2 to HLL_COUNT.INIT must be between 10 and 24 [at 1:42]
select hll_count.init(@test_param_int64, 25) from SimpleTypes
                                         ^
==

select hll_count.init(@test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(INT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
==

# INT32 widens to INT64
select hll_count.init(@test_param_int32) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(INT64, optional(0) INT64) -> BYTES)
              +-Cast(INT32 -> INT64)
                +-Parameter(type=INT32, name="test_param_int32")
==

select hll_count.init(@test_param_uint64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(UINT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
==

# UINT32 widens to UINT64
select hll_count.init(@test_param_uint32) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(UINT64, optional(0) INT64) -> BYTES)
              +-Cast(UINT32 -> UINT64)
                +-Parameter(type=UINT32, name="test_param_uint32")
==

select hll_count.init(@test_param_string) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(STRING, optional(0) INT64) -> BYTES)
              +-Parameter(type=STRING, name="test_param_string")
==

select hll_count.init(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(BYTES, optional(0) INT64) -> BYTES)
              +-Parameter(type=BYTES, name="test_param_bytes")
==

select hll_count.init(@test_param_proto) from SimpleTypes
--
ERROR: No matching signature for aggregate function HLL_COUNT.INIT for argument types: zetasql_test__.KitchenSinkPB. Supported signatures: HLL_COUNT.INIT(INT64, [INT64]); HLL_COUNT.INIT(UINT64, [INT64]); HLL_COUNT.INIT(STRING, [INT64]); HLL_COUNT.INIT(BYTES, [INT64]) [at 1:8]
select hll_count.init(@test_param_proto) from SimpleTypes
       ^
==

select hll_count.merge_partial(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.merge_partial(BYTES) -> BYTES)
              +-Parameter(type=BYTES, name="test_param_bytes")
==

select d3a_count.merge(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.merge(BYTES) -> INT64)
              +-Parameter(type=BYTES, name="test_param_bytes")
==

select d3a_count.extract(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-FunctionCall(ZetaSQL:d3a_count.extract(BYTES) -> INT64)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

select d3a_count.to_hll(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-FunctionCall(ZetaSQL:d3a_count.to_hll(BYTES) -> BYTES)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

select d3a_count.init(@test_param_int64, @test_param_int64 * 2, 10) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.init(INT64, INT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
              | +-Parameter(type=INT64, name="test_param_int64")
              | +-Literal(type=INT64, value=2)
              +-Literal(type=INT64, value=10)
==

select d3a_count.init(@test_param_int64, @test_param_int64, 24) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.init(INT64, INT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Parameter(type=INT64, name="test_param_int64")
              +-Literal(type=INT64, value=24)
==

select d3a_count.init(@test_param_int64, @test_param_int64, @test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.init(INT64, INT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Parameter(type=INT64, name="test_param_int64")
              +-Parameter(type=INT64, name="test_param_int64")
==

select d3a_count.init(TRUE, @test_param_int64, @test_param_int64) from SimpleTypes
--
ERROR: No matching signature for aggregate function D3A_COUNT.INIT for argument types: BOOL, INT64, INT64. Supported signatures: D3A_COUNT.INIT(INT64, INT64, [INT64]); D3A_COUNT.INIT(UINT64, INT64, [INT64]); D3A_COUNT.INIT(STRING, INT64, [INT64]); D3A_COUNT.INIT(BYTES, INT64, [INT64]) [at 1:8]
select d3a_count.init(TRUE, @test_param_int64, @test_param_int64) from Simple...
       ^
==

select d3a_count.init(NULL, @test_param_int64, @test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.init(INT64, INT64, optional(1) INT64) -> BYTES)
              +-Literal(type=INT64, value=NULL)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Parameter(type=INT64, name="test_param_int64")
==

select d3a_count.init("ABC", @test_param_int64, @test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.init(STRING, INT64, optional(1) INT64) -> BYTES)
              +-Literal(type=STRING, value="ABC")
              +-Parameter(type=INT64, name="test_param_int64")
              +-Parameter(type=INT64, name="test_param_int64")
==

select d3a_count.init(@test_param_int64, 123, @test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.init(INT64, INT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Literal(type=INT64, value=123)
              +-Parameter(type=INT64, name="test_param_int64")
==

select d3a_count.init(@test_param_int64, @test_param_int64, key) from KeyValue
--
ERROR: Argument 3 to D3A_COUNT.INIT must be a literal or query parameter [at 1:61]
select d3a_count.init(@test_param_int64, @test_param_int64, key) from KeyValue
                                                            ^
==

select d3a_count.init(@test_param_int64, @test_param_int64, null) from SimpleTypes
--
ERROR: Argument 3 to D3A_COUNT.INIT must be non-NULL [at 1:61]
...init(@test_param_int64, @test_param_int64, null) from SimpleTypes
                                              ^
==

select d3a_count.init(@test_param_int64, null) from SimpleTypes
--
ERROR: Argument 2 to D3A_COUNT.INIT must be non-NULL [at 1:42]
select d3a_count.init(@test_param_int64, null) from SimpleTypes
                                         ^
==

select d3a_count.init(@test_param_int64, @test_param_int64, 3) from SimpleTypes
--
ERROR: Argument 3 to D3A_COUNT.INIT must be between 4 and 24 [at 1:61]
select d3a_count.init(@test_param_int64, @test_param_int64, 3) from SimpleTypes
                                                            ^
==

# Value range checking should happen even if we start from an int32
# and have to widen to int64.
select d3a_count.init(@test_param_int64, @test_param_int64, cast(12 as int32)),
       d3a_count.init(@test_param_int64, @test_param_int64, cast(3 as int32))
from SimpleTypes
--
ERROR: Argument 3 to D3A_COUNT.INIT must be between 4 and 24 [at 2:61]
       d3a_count.init(@test_param_int64, @test_param_int64, cast(3 as int32))
                                                            ^
==

select d3a_count.init(@test_param_int64, @test_param_int64, 25) from SimpleTypes
--
ERROR: Argument 3 to D3A_COUNT.INIT must be between 4 and 24 [at 1:61]
select d3a_count.init(@test_param_int64, @test_param_int64, 25) from SimpleTypes
                                                            ^
==

select d3a_count.init(@test_param_int64, @test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.init(INT64, INT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Parameter(type=INT64, name="test_param_int64")
==

# INT32 widens to INT64
select d3a_count.init(@test_param_int32, @test_param_int32) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.init(INT64, INT64, optional(0) INT64) -> BYTES)
              +-Cast(INT32 -> INT64)
              | +-Parameter(type=INT32, name="test_param_int32")
              +-Cast(INT32 -> INT64)
                +-Parameter(type=INT32, name="test_param_int32")
==

# The second argument must be of type INT64, UINT64 is not acceptable because it
# may overflow when casting to INT64.
select d3a_count.init(@test_param_uint64, @test_param_uint64) from SimpleTypes
--
ERROR: No matching signature for aggregate function D3A_COUNT.INIT for argument types: UINT64, UINT64. Supported signatures: D3A_COUNT.INIT(INT64, INT64, [INT64]); D3A_COUNT.INIT(UINT64, INT64, [INT64]); D3A_COUNT.INIT(STRING, INT64, [INT64]); D3A_COUNT.INIT(BYTES, INT64, [INT64]) [at 1:8]
select d3a_count.init(@test_param_uint64, @test_param_uint64) from SimpleTypes
       ^
==

select d3a_count.init(@test_param_uint64, @test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.init(UINT64, INT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
              +-Parameter(type=INT64, name="test_param_int64")
==

# For the first argument, UINT32 widens to UINT64.
# The second argument can be UINT32 because it won't overflow when casting to
# INT64.
select d3a_count.init(@test_param_uint32, @test_param_uint32) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.init(UINT64, INT64, optional(0) INT64) -> BYTES)
              +-Cast(UINT32 -> UINT64)
              | +-Parameter(type=UINT32, name="test_param_uint32")
              +-Cast(UINT32 -> INT64)
                +-Parameter(type=UINT32, name="test_param_uint32")
==

select d3a_count.init(@test_param_string, @test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.init(STRING, INT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=STRING, name="test_param_string")
              +-Parameter(type=INT64, name="test_param_int64")
==

select d3a_count.init(@test_param_bytes, @test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.init(BYTES, INT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Parameter(type=INT64, name="test_param_int64")
==

select d3a_count.init(@test_param_proto, @test_param_int64) from SimpleTypes
--
ERROR: No matching signature for aggregate function D3A_COUNT.INIT for argument types: zetasql_test__.KitchenSinkPB, INT64. Supported signatures: D3A_COUNT.INIT(INT64, INT64, [INT64]); D3A_COUNT.INIT(UINT64, INT64, [INT64]); D3A_COUNT.INIT(STRING, INT64, [INT64]); D3A_COUNT.INIT(BYTES, INT64, [INT64]) [at 1:8]
select d3a_count.init(@test_param_proto, @test_param_int64) from SimpleTypes
       ^
==

select d3a_count.init(DISTINCT @test_param_int64, @test_param_int64, @test_param_int64) from SimpleTypes
--
ERROR: Aggregate function D3A_COUNT.INIT does not support DISTINCT in arguments [at 1:8]
select d3a_count.init(DISTINCT @test_param_int64, @test_param_int64, @test_pa...
       ^
==

select d3a_count.merge_partial(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:d3a_count.merge_partial(BYTES) -> BYTES)
              +-Parameter(type=BYTES, name="test_param_bytes")
==

select kll_quantiles.init_int64(@test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_int64(INT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
==

select kll_quantiles.init_uint64(@test_param_uint64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
==

select kll_quantiles.init_double(@test_param_double) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_double(DOUBLE, optional(0) INT64) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
==

select kll_quantiles.init_int64(@test_param_int64, 100) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_int64(INT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Literal(type=INT64, value=100)
==

select kll_quantiles.init_double(@test_param_double, 10000) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_double(DOUBLE, optional(1) INT64) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
              +-Literal(type=INT64, value=10000)
==

select kll_quantiles.init_int64(@test_param_int64, 1) from SimpleTypes
--
ERROR: Argument 2 to KLL_QUANTILES.INIT_INT64 must be at least 2 [at 1:52]
select kll_quantiles.init_int64(@test_param_int64, 1) from SimpleTypes
                                                   ^
==

select kll_quantiles.init_uint64(@test_param_uint64, 0) from SimpleTypes
--
ERROR: Argument 2 to KLL_QUANTILES.INIT_UINT64 must be at least 2 [at 1:54]
select kll_quantiles.init_uint64(@test_param_uint64, 0) from SimpleTypes
                                                     ^
==

select kll_quantiles.init_double(@test_param_double, @test_param_int64)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_double(DOUBLE, optional(1) INT64) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
              +-Parameter(type=INT64, name="test_param_int64")
==

select kll_quantiles.init_int64(@test_param_int64, key) from KeyValue
--
ERROR: Argument 2 to KLL_QUANTILES.INIT_INT64 must be a literal or query parameter [at 1:52]
select kll_quantiles.init_int64(@test_param_int64, key) from KeyValue
                                                   ^
==

select kll_quantiles.init_uint64(@test_param_uint64, key) from KeyValue
--
ERROR: Argument 2 to KLL_QUANTILES.INIT_UINT64 must be a literal or query parameter [at 1:54]
select kll_quantiles.init_uint64(@test_param_uint64, key) from KeyValue
                                                     ^
==

select kll_quantiles.init_int64(@test_param_int64, null) from SimpleTypes
--
ERROR: Argument 2 to KLL_QUANTILES.INIT_INT64 must be non-NULL [at 1:52]
select kll_quantiles.init_int64(@test_param_int64, null) from SimpleTypes
                                                   ^
==

select kll_quantiles.init_double(@test_param_double, null) from SimpleTypes
--
ERROR: Argument 2 to KLL_QUANTILES.INIT_DOUBLE must be non-NULL [at 1:54]
select kll_quantiles.init_double(@test_param_double, null) from SimpleTypes
                                                     ^
==

# INT32 widens to INT64
select kll_quantiles.init_int64(@test_param_int32) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_int64(INT64, optional(0) INT64) -> BYTES)
              +-Cast(INT32 -> INT64)
                +-Parameter(type=INT32, name="test_param_int32")
==

# UINT32 widens to UINT64
select kll_quantiles.init_uint64(@test_param_uint32) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(0) INT64) -> BYTES)
              +-Cast(UINT32 -> UINT64)
                +-Parameter(type=UINT32, name="test_param_uint32")
==

# BYTES cannot be cast to INT64
select kll_quantiles.init_int64(@test_param_bytes) from SimpleTypes
--
ERROR: No matching signature for aggregate function KLL_QUANTILES.INIT_INT64 for argument types: BYTES. Supported signature: KLL_QUANTILES.INIT_INT64(INT64, [INT64]) [at 1:8]
select kll_quantiles.init_int64(@test_param_bytes) from SimpleTypes
       ^
==

select kll_quantiles.merge_partial(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_partial(BYTES) -> BYTES)
              +-Parameter(type=BYTES, name="test_param_bytes")
==

select kll_quantiles.merge_int64(@test_param_bytes, 5) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_int64(BYTES, INT64) -> ARRAY<INT64>)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=INT64, value=5)
==

select kll_quantiles.merge_uint64(@test_param_bytes, 2) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [ARRAY<UINT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_uint64(BYTES, INT64) -> ARRAY<UINT64>)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=INT64, value=2)
==

select kll_quantiles.merge_double(@test_param_bytes, 50) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_double(BYTES, INT64) -> ARRAY<DOUBLE>)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=INT64, value=50)
==

select kll_quantiles.merge_int64(@test_param_bytes) from SimpleTypes
--
ERROR: Number of arguments does not match for aggregate function KLL_QUANTILES.MERGE_INT64. Supported signature: KLL_QUANTILES.MERGE_INT64(BYTES, INT64) [at 1:8]
select kll_quantiles.merge_int64(@test_param_bytes) from SimpleTypes
       ^
==

select kll_quantiles.merge_int64(@test_param_bytes, key) from KeyValue
--
ERROR: Argument 2 to KLL_QUANTILES.MERGE_INT64 must be a literal or query parameter [at 1:53]
select kll_quantiles.merge_int64(@test_param_bytes, key) from KeyValue
                                                    ^
==

select kll_quantiles.merge_int64(@test_param_bytes, 1) from SimpleTypes
--
ERROR: Argument 2 to KLL_QUANTILES.MERGE_INT64 must be at least 2 [at 1:53]
select kll_quantiles.merge_int64(@test_param_bytes, 1) from SimpleTypes
                                                    ^
==

select kll_quantiles.extract_int64(@test_param_bytes, 10) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_int64(BYTES, INT64) -> ARRAY<INT64>)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=INT64, value=10)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

select kll_quantiles.extract_uint64(@test_param_bytes, 20) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [ARRAY<UINT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_uint64(BYTES, INT64) -> ARRAY<UINT64>)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=INT64, value=20)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

select kll_quantiles.extract_double(@test_param_bytes, 5) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_double(BYTES, INT64) -> ARRAY<DOUBLE>)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=INT64, value=5)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

select kll_quantiles.extract_double(@test_param_bytes, key) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_double(BYTES, INT64) -> ARRAY<DOUBLE>)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])

==

select kll_quantiles.extract_double(@test_param_bytes, 1) from SimpleTypes
--

ERROR: Argument 2 to KLL_QUANTILES.EXTRACT_DOUBLE must be at least 2 [at 1:56]
select kll_quantiles.extract_double(@test_param_bytes, 1) from SimpleTypes
                                                       ^
==

select kll_quantiles.extract_double(@test_param_bytes, NULL) from SimpleTypes
--
ERROR: Argument 2 to KLL_QUANTILES.EXTRACT_DOUBLE must be non-NULL [at 1:56]
select kll_quantiles.extract_double(@test_param_bytes, NULL) from SimpleTypes
                                                       ^
==

select kll_quantiles.merge_point_int64(@test_param_bytes, 0.99)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_point_int64(BYTES, DOUBLE) -> INT64)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=DOUBLE, value=0.99)
==

select kll_quantiles.merge_point_uint64(@test_param_bytes, 0.5)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [UINT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_point_uint64(BYTES, DOUBLE) -> UINT64)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=DOUBLE, value=0.5)
==

select kll_quantiles.merge_point_double(@test_param_bytes, 1) from SimpleTypes
--

QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_point_double(BYTES, DOUBLE) -> DOUBLE)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=DOUBLE, value=1)
==

select kll_quantiles.merge_point_uint64(@test_param_bytes, 0.5+0.1) from SimpleTypes
--

ERROR: Argument 2 to KLL_QUANTILES.MERGE_POINT_UINT64 must be a literal or query parameter [at 1:60]
...kll_quantiles.merge_point_uint64(@test_param_bytes, 0.5+0.1) from SimpleTypes
                                                       ^
==

select kll_quantiles.merge_point_uint64(@test_param_bytes, key) from KeyValue
--

ERROR: Argument 2 to KLL_QUANTILES.MERGE_POINT_UINT64 must be a literal or query parameter [at 1:60]
select kll_quantiles.merge_point_uint64(@test_param_bytes, key) from KeyValue
                                                           ^
==

select kll_quantiles.merge_point_uint64(@test_param_bytes, 5) from SimpleTypes
--

ERROR: Argument 2 to KLL_QUANTILES.MERGE_POINT_UINT64 must be between 0 and 1 [at 1:60]
select kll_quantiles.merge_point_uint64(@test_param_bytes, 5) from SimpleTypes
                                                           ^
==

select kll_quantiles.merge_point_uint64(@test_param_bytes, NULL)
from SimpleTypes
--
ERROR: Argument 2 to KLL_QUANTILES.MERGE_POINT_UINT64 must be non-NULL [at 1:60]
select kll_quantiles.merge_point_uint64(@test_param_bytes, NULL)
                                                           ^
==

select kll_quantiles.extract_point_int64(@test_param_bytes, 0) from SimpleTypes
--

QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_int64(BYTES, DOUBLE) -> INT64)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=DOUBLE, value=0)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

select kll_quantiles.extract_point_uint64(@test_param_bytes, 0.75)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [UINT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_uint64(BYTES, DOUBLE) -> UINT64)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=DOUBLE, value=0.75)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

select kll_quantiles.extract_point_double(@test_param_bytes, 0.995)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_double(BYTES, DOUBLE) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=DOUBLE, value=0.995)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

select kll_quantiles.extract_point_double(@test_param_bytes, 0.5+0.1) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_double(BYTES, DOUBLE) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
    |       +-Literal(type=DOUBLE, value=0.5)
    |       +-Literal(type=DOUBLE, value=0.1)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

select kll_quantiles.extract_point_double(@test_param_bytes, key) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_double(BYTES, DOUBLE) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Cast(INT64 -> DOUBLE)
    |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
==

select kll_quantiles.extract_point_double(@test_param_bytes, 1.1) from SimpleTypes
--

ERROR: Argument 2 to KLL_QUANTILES.EXTRACT_POINT_DOUBLE must be between 0 and 1 [at 1:62]
...extract_point_double(@test_param_bytes, 1.1) from SimpleTypes
                                           ^
==

select kll_quantiles.extract_point_double(@test_param_bytes, -1) from SimpleTypes
--
ERROR: Argument 2 to KLL_QUANTILES.EXTRACT_POINT_DOUBLE must be between 0 and 1 [at 1:62]
...extract_point_double(@test_param_bytes, -1) from SimpleTypes
                                           ^
==

# Compare behavior when the feature is enabled vs. not enabled.  Tests
[language_features={{|NAMED_ARGUMENTS|NAMED_ARGUMENTS,V_1_3_KLL_WEIGHTS}}]
select kll_quantiles.init_uint64(@test_param_uint64)
from SimpleTypes;
--
ALTERNATION GROUPS:
    <empty>
    NAMED_ARGUMENTS
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
--
ALTERNATION GROUP: NAMED_ARGUMENTS,V_1_3_KLL_WEIGHTS
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(1) INT64, optional(1) INT64 weight) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
              +-Literal(type=INT64, value=1000)
              +-Literal(type=INT64, value=1)
==

[language_features={{|NAMED_ARGUMENTS|NAMED_ARGUMENTS,V_1_3_KLL_WEIGHTS}}]
select kll_quantiles.init_uint64(@test_param_uint64, 100)
from SimpleTypes;
--
ALTERNATION GROUPS:
    <empty>
    NAMED_ARGUMENTS
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
              +-Literal(type=INT64, value=100)
--
ALTERNATION GROUP: NAMED_ARGUMENTS,V_1_3_KLL_WEIGHTS
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(1) INT64, optional(1) INT64 weight) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
              +-Literal(type=INT64, value=100)
              +-Literal(type=INT64, value=1)
==

# The 'weight' argument has a mandatory name, so the query fails when
# expressing it positionally.
[language_features={{|NAMED_ARGUMENTS|NAMED_ARGUMENTS,V_1_3_KLL_WEIGHTS}}]
select kll_quantiles.init_uint64(@test_param_uint64, 100,
                                 IF(@test_param_uint64 > 5, 2, 1))
from SimpleTypes;
--
ALTERNATION GROUPS:
    <empty>
    NAMED_ARGUMENTS
--
ERROR: Number of arguments does not match for aggregate function KLL_QUANTILES.INIT_UINT64. Supported signature: KLL_QUANTILES.INIT_UINT64(UINT64, [INT64]) [at 1:8]
select kll_quantiles.init_uint64(@test_param_uint64, 100,
       ^
--
ALTERNATION GROUP: NAMED_ARGUMENTS,V_1_3_KLL_WEIGHTS
--
ERROR: Positional argument is invalid because this function restricts that this argument is referred to by name "weight" only [at 2:34]
                                 IF(@test_param_uint64 > 5, 2, 1))
                                 ^
==

[language_features={{|NAMED_ARGUMENTS|NAMED_ARGUMENTS,V_1_3_KLL_WEIGHTS}}]
select kll_quantiles.init_uint64(@test_param_uint64, 100,
                                 weight => IF(@test_param_uint64 > 5, 2, 1))
from SimpleTypes;
--
ALTERNATION GROUPS:
    <empty>
    NAMED_ARGUMENTS
--
ERROR: Number of arguments does not match for aggregate function KLL_QUANTILES.INIT_UINT64. Supported signature: KLL_QUANTILES.INIT_UINT64(UINT64, [INT64]) [at 1:8]
select kll_quantiles.init_uint64(@test_param_uint64, 100,
       ^
--
ALTERNATION GROUP: NAMED_ARGUMENTS,V_1_3_KLL_WEIGHTS
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(1) INT64, optional(1) INT64 weight) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
              +-Literal(type=INT64, value=100)
              +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
                +-FunctionCall(ZetaSQL:$greater(UINT64, INT64) -> BOOL)
                | +-Parameter(type=UINT64, name="test_param_uint64")
                | +-Literal(type=INT64, value=5)
                +-Literal(type=INT64, value=2)
                +-Literal(type=INT64, value=1)
==

# The second optional 'precision' argument is omitted.
[language_features={{|NAMED_ARGUMENTS|NAMED_ARGUMENTS,V_1_3_KLL_WEIGHTS}}]
select kll_quantiles.init_uint64(@test_param_uint64,
                                 weight => IF(@test_param_uint64 > 5, 2, 1))
from SimpleTypes;
--
ALTERNATION GROUP: <empty>
--
ERROR: Named arguments are not supported [at 2:34]
                                 weight => IF(@test_param_uint64 > 5, 2, 1))
                                 ^
--
ALTERNATION GROUP: NAMED_ARGUMENTS
--
ERROR: Named argument weight not found in signature for call to function ZetaSQL:kll_quantiles.init_uint64 [at 2:34]
                                 weight => IF(@test_param_uint64 > 5, 2, 1))
                                 ^
--
ALTERNATION GROUP: NAMED_ARGUMENTS,V_1_3_KLL_WEIGHTS
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#19]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#19 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(1) INT64, optional(1) INT64 weight) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
              +-Literal(type=INT64, value=1000)
              +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
                +-FunctionCall(ZetaSQL:$greater(UINT64, INT64) -> BOOL)
                | +-Parameter(type=UINT64, name="test_param_uint64")
                | +-Literal(type=INT64, value=5)
                +-Literal(type=INT64, value=2)
                +-Literal(type=INT64, value=1)
==

# Same as the above, but without the NAMED_ARGUMENTS feature, to ensure we
# get a reasonable error message.
[language_features=V_1_3_KLL_WEIGHTS]
select kll_quantiles.init_uint64(@test_param_uint64,
                                 weight => IF(@test_param_uint64 > 5, 2, 1))
from SimpleTypes;
--
ERROR: Named arguments are not supported [at 2:34]
                                 weight => IF(@test_param_uint64 > 5, 2, 1))
                                 ^
