[language_features={{|V_1_3_DATE_TIME_CONSTRUCTORS}}]
select date(@test_param_string);
--
ALTERNATION GROUP: <empty>

--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [DATE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:date(TIMESTAMP, optional(0) STRING) -> DATE)
    |     +-Cast(STRING -> TIMESTAMP)
    |       +-Parameter(type=STRING, name="test_param_string")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: V_1_3_DATE_TIME_CONSTRUCTORS
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [DATE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:date(STRING) -> DATE)
    |     +-Parameter(type=STRING, name="test_param_string")
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_3_DATE_TIME_CONSTRUCTORS}}]
select date("2019-08-01 21:00:00+00");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [DATE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:date(TIMESTAMP, optional(0) STRING) -> DATE)
    |     +-Literal(type=TIMESTAMP, value=2019-08-01 21:00:00+00)
    +-input_scan=
      +-SingleRowScan

==

select 1 + cast(2 as int32) = cast(3 as int32);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     | +-Literal(type=INT64, value=1)
    |     | +-Literal(type=INT64, value=2, has_explicit_type=TRUE)
    |     +-Literal(type=INT64, value=3, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

select 0x1 + cast(2 as INT32) = CAST(3 as INT32);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     | +-Literal(type=INT64, value=1)
    |     | +-Literal(type=INT64, value=2, has_explicit_type=TRUE)
    |     +-Literal(type=INT64, value=3, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

select key + 1 from TestTable where key = 5;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Cast(INT32 -> INT64)
    |     | +-ColumnRef(type=INT32, column=TestTable.key#1)
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.key#1]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT32, INT32) -> BOOL)
            +-ColumnRef(type=INT32, column=TestTable.key#1)
            +-Literal(type=INT32, value=5)
==

# No coercion, INT64 literals remain unchanged.
select 1 + 0x2 = 3;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     | +-Literal(type=INT64, value=1)
    |     | +-Literal(type=INT64, value=2)
    |     +-Literal(type=INT64, value=3)
    +-input_scan=
      +-SingleRowScan
==

select int32 + 1, int64 + 1, uint32 + 1, uint64 + 1, float + 1, double + 1
from SimpleTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS "$col1" [INT64]
| +-$query.$col2#20 AS "$col2" [INT64]
| +-$query.$col3#21 AS "$col3" [UINT64]
| +-$query.$col4#22 AS "$col4" [UINT64]
| +-$query.$col5#23 AS "$col5" [DOUBLE]
| +-$query.$col6#24 AS "$col6" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#19, $col2#20, $col3#21, $col4#22, $col5#23, $col6#24]
    +-expr_list=
    | +-$col1#19 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-Cast(INT32 -> INT64)
    | |   | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | |   +-Literal(type=INT64, value=1)
    | +-$col2#20 :=
    | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | |   +-Literal(type=INT64, value=1)
    | +-$col3#21 :=
    | | +-FunctionCall(ZetaSQL:$add(UINT64, UINT64) -> UINT64)
    | |   +-Cast(UINT32 -> UINT64)
    | |   | +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | |   +-Literal(type=UINT64, value=1)
    | +-$col4#22 :=
    | | +-FunctionCall(ZetaSQL:$add(UINT64, UINT64) -> UINT64)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | |   +-Literal(type=UINT64, value=1)
    | +-$col5#23 :=
    | | +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Cast(FLOAT -> DOUBLE)
    | |   | +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
    | |   +-Literal(type=DOUBLE, value=1)
    | +-$col6#24 :=
    |   +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
    |     +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
    |     +-Literal(type=DOUBLE, value=1)
    +-input_scan=
      +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, float#8, double#9], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 7, 8])
==

select 1 + '1';
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     +-Literal(type=INT64, value=1)
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

# NULL tests for simple types.
select if(true, NULL, bool),
       if(true, int32, NULL),
       if(true, int64, NULL),
       if(true, uint32, NULL),
       if(true, uint64, NULL),
       if(true, float, NULL),
       if(true, string, NULL),
       if(true, bytes, NULL),
       if(true, date, NULL),
       if(true, timestamp, NULL)
from SimpleTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS "$col1" [BOOL]
| +-$query.$col2#20 AS "$col2" [INT32]
| +-$query.$col3#21 AS "$col3" [INT64]
| +-$query.$col4#22 AS "$col4" [UINT32]
| +-$query.$col5#23 AS "$col5" [UINT64]
| +-$query.$col6#24 AS "$col6" [FLOAT]
| +-$query.$col7#25 AS "$col7" [STRING]
| +-$query.$col8#26 AS "$col8" [BYTES]
| +-$query.$col9#27 AS "$col9" [DATE]
| +-$query.$col10#28 AS "$col10" [TIMESTAMP]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#19, $col2#20, $col3#21, $col4#22, $col5#23, $col6#24, $col7#25, $col8#26, $col9#27, $col10#28]
    +-expr_list=
    | +-$col1#19 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BOOL, value=NULL)
    | |   +-ColumnRef(type=BOOL, column=SimpleTypes.bool#7)
    | +-$col2#20 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, INT32, INT32) -> INT32)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | |   +-Literal(type=INT32, value=NULL)
    | +-$col3#21 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | |   +-Literal(type=INT64, value=NULL)
    | +-$col4#22 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, UINT32, UINT32) -> UINT32)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | |   +-Literal(type=UINT32, value=NULL)
    | +-$col5#23 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, UINT64, UINT64) -> UINT64)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | |   +-Literal(type=UINT64, value=NULL)
    | +-$col6#24 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, FLOAT, FLOAT) -> FLOAT)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
    | |   +-Literal(type=FLOAT, value=NULL)
    | +-$col7#25 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, STRING, STRING) -> STRING)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
    | |   +-Literal(type=STRING, value=NULL)
    | +-$col8#26 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BYTES, BYTES) -> BYTES)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
    | |   +-Literal(type=BYTES, value=NULL)
    | +-$col9#27 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DATE, DATE) -> DATE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=DATE, column=SimpleTypes.date#10)
    | |   +-Literal(type=DATE, value=NULL)
    | +-$col10#28 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, TIMESTAMP, TIMESTAMP) -> TIMESTAMP)
    |     +-Literal(type=BOOL, value=true)
    |     +-ColumnRef(type=TIMESTAMP, column=SimpleTypes.timestamp#15)
    |     +-Literal(type=TIMESTAMP, value=NULL)
    +-input_scan=
      +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, date#10, timestamp#15], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 9, 14])
==

# NULL tests for non-simple types.
select if(true, KitchenSink, NULL),
       if(true, KitchenSink.repeated_int32_val, NULL),
       if(true, KitchenSink.test_enum, NULL),
       if(true, KitchenSink.key_value, NULL),
       if(true, NULL, KitchenSink.key_value_array)
from TestTable;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [PROTO<zetasql_test__.KitchenSinkPB>]
| +-$query.$col2#5 AS "$col2" [ARRAY<INT32>]
| +-$query.$col3#6 AS "$col3" [ENUM<zetasql_test__.TestEnum>]
| +-$query.$col4#7 AS "$col4" [PROTO<zetasql_test__.KeyValueStruct>]
| +-$query.$col5#8 AS "$col5" [ARRAY<PROTO<zetasql_test__.KeyValueStruct>>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#4, $col2#5, $col3#6, $col4#7, $col5#8]
    +-expr_list=
    | +-$col1#4 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, PROTO<zetasql_test__.KitchenSinkPB>, PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   +-Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value=NULL)
    | +-$col2#5 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<INT32>, ARRAY<INT32>) -> ARRAY<INT32>)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-GetProtoField
    | |   | +-type=ARRAY<INT32>
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=repeated_int32_val
    | |   | +-default_value=[]
    | |   +-Literal(type=ARRAY<INT32>, value=NULL)
    | +-$col3#6 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> ENUM<zetasql_test__.TestEnum>)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-GetProtoField
    | |   | +-type=ENUM<zetasql_test__.TestEnum>
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=test_enum
    | |   | +-default_value=TESTENUM0
    | |   +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=NULL)
    | +-$col4#7 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, PROTO<zetasql_test__.KeyValueStruct>, PROTO<zetasql_test__.KeyValueStruct>) -> PROTO<zetasql_test__.KeyValueStruct>)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-GetProtoField
    | |   | +-type=PROTO<zetasql_test__.KeyValueStruct>
    | |   | +-expr=
    | |   | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   | +-field_descriptor=key_value
    | |   | +-default_value=NULL
    | |   +-Literal(type=PROTO<zetasql_test__.KeyValueStruct>, value=NULL)
    | +-$col5#8 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<PROTO<zetasql_test__.KeyValueStruct>>, ARRAY<PROTO<zetasql_test__.KeyValueStruct>>) -> ARRAY<PROTO<zetasql_test__.KeyValueStruct>>)
    |     +-Literal(type=BOOL, value=true)
    |     +-Literal(type=ARRAY<PROTO<zetasql_test__.KeyValueStruct>>, value=NULL)
    |     +-GetProtoField
    |       +-type=ARRAY<PROTO<zetasql_test__.KeyValueStruct>>
    |       +-expr=
    |       | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |       +-field_descriptor=key_value_array
    |       +-default_value=[]
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# More interesting NULL coercion tests.
select array_length(cast(NULL as array<bool>))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:array_length(ARRAY<BOOL>) -> INT64)
    |     +-Literal(type=ARRAY<BOOL>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

select array_length(NULL)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:array_length(ARRAY<INT64>) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

select (cast(NULL as array<bool>))[default_offset(0)]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<BOOL>, INT64) -> BOOL)
    |     +-Literal(type=ARRAY<BOOL>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=INT64, value=0)
    +-input_scan=
      +-SingleRowScan
==

# Java test is implemented separatly at "testExtendedSubscriptFunction" in
# "javatests/com/google/zetasql/AnalyzerTest.java"
# See more context at b/186869835.
[no_java]
select NULL[default_offset(0)]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript_with_offset(STRING, INT64) -> STRING)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=INT64, value=0)
    +-input_scan=
      +-SingleRowScan
==

select fn_on_arbitrary_type_argument(NULL),
       fn_on_any_element_returns_array(NULL)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
| +-$query.$col2#2 AS "$col2" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(sample_functions:fn_on_arbitrary_type_argument(INT64) -> BOOL)
    | |   +-Literal(type=INT64, value=NULL)
    | +-$col2#2 :=
    |   +-FunctionCall(sample_functions:fn_on_any_element_returns_array(INT64) -> ARRAY<INT64>)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

select fn_on_any_array_returns_element(NULL)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_any_array_returns_element(ARRAY<INT64>) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

# For a function that takes any enum, proto, or struct, passing a NULL literal
# is not valid since we do not know what enum, struct, or proto type it actually is.
select fn_on_any_enum(NULL)
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_ANY_ENUM for argument types: NULL. Supported signature: FN_ON_ANY_ENUM(ENUM) [at 1:8]
select fn_on_any_enum(NULL)
       ^
==

select fn_on_any_proto(NULL)
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_ANY_PROTO for argument types: NULL. Supported signature: FN_ON_ANY_PROTO(PROTO) [at 1:8]
select fn_on_any_proto(NULL)
       ^
==

select fn_on_any_struct(NULL)
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_ANY_STRUCT for argument types: NULL. Supported signature: FN_ON_ANY_STRUCT(STRUCT) [at 1:8]
select fn_on_any_struct(NULL)
       ^
==

select if (true, "uint64", 1)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS "$col1" [UINT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, UINT64, UINT64) -> UINT64)
    |     +-Literal(type=BOOL, value=true)
    |     +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    |     +-Literal(type=UINT64, value=1)
    +-input_scan=
      +-TableScan(column_list=[SimpleTypes.uint64#4], table=SimpleTypes, column_index_list=[3])
==

select if (true, "uint64", -1)
from SimpleTypes
--
ERROR: Could not cast literal -1 to type UINT64 [at 1:28]
select if (true, "uint64", -1)
                           ^
==

select true
  FROM TestTable
  WHERE KitchenSink.test_enum = 1 AND
        KitchenSink.test_enum = 'TESTENUM0' AND
        1 = KitchenSink.test_enum AND
        'TESTENUM0' = KitchenSink.test_enum;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=BOOL, value=true)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$and(BOOL, repeated(3) BOOL) -> BOOL)
            +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
            | +-GetProtoField
            | | +-type=ENUM<zetasql_test__.TestEnum>
            | | +-expr=
            | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | | +-field_descriptor=test_enum
            | | +-default_value=TESTENUM0
            | +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
            +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
            | +-GetProtoField
            | | +-type=ENUM<zetasql_test__.TestEnum>
            | | +-expr=
            | | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | | +-field_descriptor=test_enum
            | | +-default_value=TESTENUM0
            | +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
            +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
            | +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
            | +-GetProtoField
            |   +-type=ENUM<zetasql_test__.TestEnum>
            |   +-expr=
            |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            |   +-field_descriptor=test_enum
            |   +-default_value=TESTENUM0
            +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
              +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
              +-GetProtoField
                +-type=ENUM<zetasql_test__.TestEnum>
                +-expr=
                | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
                +-field_descriptor=test_enum
                +-default_value=TESTENUM0
==

# Comparing enum against out of range int64 literal (which can fit in an int32).
select 1 FROM TestTable WHERE KitchenSink.test_enum = 12345;
--
ERROR: Could not cast literal 12345 to type zetasql_test__.TestEnum [at 1:55]
select 1 FROM TestTable WHERE KitchenSink.test_enum = 12345;
                                                      ^
==

# Comparing enum against out of range int64 literal. This should fail before
# doing enum range check, as the given int64 wont fit into an int32 to carry
# the enum conversion.
select 1 FROM TestTable WHERE KitchenSink.test_enum = 123456890123;
--
ERROR: Could not cast literal 123456890123 to type zetasql_test__.TestEnum [at 1:55]
select 1 FROM TestTable WHERE KitchenSink.test_enum = 123456890123;
                                                      ^
==

select 1 FROM TestTable WHERE KitchenSink.test_enum = "a";
--
ERROR: Could not cast literal "a" to type zetasql_test__.TestEnum [at 1:55]
select 1 FROM TestTable WHERE KitchenSink.test_enum = "a";
                                                      ^
==

select 1 FROM TestTable WHERE KitchenSink.test_enum = NULL;
--
ERROR: Operands of = cannot be literal NULL [at 1:55]
select 1 FROM TestTable WHERE KitchenSink.test_enum = NULL;
                                                      ^
==

select 1 FROM TestTable WHERE KitchenSink.test_enum = KitchenSink.string_val;
--
ERROR: No matching signature for operator = for argument types: zetasql_test__.TestEnum, STRING. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64; BOOL = STRING; STRING = BOOL; INT64 = STRING; STRING = INT64; FLOAT = STRING; STRING = FLOAT; DOUBLE = STRING; STRING = DOUBLE [at 1:31]
select 1 FROM TestTable WHERE KitchenSink.test_enum = KitchenSink.string_val;
                              ^
==

select 1 FROM TestTable WHERE KitchenSink.test_enum = KitchenSink.int64_val;
--
ERROR: No matching signature for operator = for argument types: zetasql_test__.TestEnum, INT64. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64; BOOL = STRING; STRING = BOOL; INT64 = STRING; STRING = INT64; FLOAT = STRING; STRING = FLOAT; DOUBLE = STRING; STRING = DOUBLE [at 1:31]
select 1 FROM TestTable WHERE KitchenSink.test_enum = KitchenSink.int64_val;
                              ^
==

select 1
  FROM TestTable
  WHERE CAST(KitchenSink.string_val AS "zetasql_test__.TestEnum") =
        KitchenSink.test_enum;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
            +-Cast(STRING -> ENUM<zetasql_test__.TestEnum>)
            | +-GetProtoField
            |   +-type=STRING
            |   +-expr=
            |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            |   +-field_descriptor=string_val
            |   +-default_value='default_name'
            +-GetProtoField
              +-type=ENUM<zetasql_test__.TestEnum>
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              +-field_descriptor=test_enum
              +-default_value=TESTENUM0
==

select 1
  FROM TestTable
  WHERE KitchenSink.test_enum
        IN ('TESTENUM0',
            1,
            NULL,
            CAST(KitchenSink.string_val AS "zetasql_test__.TestEnum"),
            CAST(KitchenSink.int64_val AS "zetasql_test__.TestEnum"),
            CAST(1 AS "zetasql_test__.TestEnum"));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$in(ENUM<zetasql_test__.TestEnum>, repeated(6) ENUM<zetasql_test__.TestEnum>) -> BOOL)
            +-GetProtoField
            | +-type=ENUM<zetasql_test__.TestEnum>
            | +-expr=
            | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | +-field_descriptor=test_enum
            | +-default_value=TESTENUM0
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=NULL)
            +-Cast(STRING -> ENUM<zetasql_test__.TestEnum>)
            | +-GetProtoField
            |   +-type=STRING
            |   +-expr=
            |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            |   +-field_descriptor=string_val
            |   +-default_value='default_name'
            +-Cast(INT64 -> ENUM<zetasql_test__.TestEnum>)
            | +-GetProtoField
            |   +-type=INT64
            |   +-expr=
            |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            |   +-field_descriptor=int64_val
            |   +-default_value=0
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
==

select 1
  FROM TestTable
  WHERE KitchenSink.test_enum
        IN ('TESTENUM0', 'TESTENUM1', 'TESTENUM2', 'TESTENUM2147483647',
            0, 1, 2, 2147483647);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$in(ENUM<zetasql_test__.TestEnum>, repeated(8) ENUM<zetasql_test__.TestEnum>) -> BOOL)
            +-GetProtoField
            | +-type=ENUM<zetasql_test__.TestEnum>
            | +-expr=
            | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | +-field_descriptor=test_enum
            | +-default_value=TESTENUM0
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2147483647)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2)
            +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2147483647)
==

select 1
  FROM TestTable
  WHERE KitchenSink.test_enum
        IN ('TESTENUM0', 12345, 'INVALID_VALUE');
--
ERROR: Could not cast literal 12345 to type zetasql_test__.TestEnum [at 4:26]
        IN ('TESTENUM0', 12345, 'INVALID_VALUE');
                         ^
==

select 1
  FROM TestTable
  WHERE KitchenSink.test_enum IN (KitchenSink.string_val, 'TESTENUM0');
--
ERROR: No matching signature for operator IN for argument types ENUM<zetasql_test__.TestEnum> and {STRING, STRING} [at 3:31]
  WHERE KitchenSink.test_enum IN (KitchenSink.string_val, 'TESTENUM0');
                              ^
==

# Test supertyping of PROTO and STRING literal.  The STRING is implicitly
# cast to PROTO.
select if(false,
          KitchenSink,
          """int64_key_1: 1, int64_key_2: 2""")
from TestTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, PROTO<zetasql_test__.KitchenSinkPB>, PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     +-Literal(type=BOOL, value=false)
    |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={int64_key_1: 1 int64_key_2: 2})
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# Same test as previous, but the STRING literal is explicitly cast to STRING,
# and becomes a constant-folded STRING literal.  Supertyping of PROTO and
# constant-folded STRING literal does not work.
select if(false,
          KitchenSink,
          CAST("""int64_key_1: 1, int64_key_2: 2""" AS STRING))
from TestTable
--
ERROR: No matching signature for function IF for argument types: BOOL, zetasql_test__.KitchenSinkPB, STRING. Supported signature: IF(BOOL, ANY, ANY) [at 1:8]
select if(false,
       ^
==

# Test implicit supertyping of proto and string literal.  Fails since the
# string literal is not valid.
select if(false,
          KitchenSink,
          """int64_key_1: int64_key_2: 2""")
from TestTable
--
ERROR: Could not cast literal "int64_key_1: int64_key_2: 2" to type zetasql_test__.KitchenSinkPB (Error parsing proto: Expected integer, got: int64_key_2 [1:14]) [at 3:11]
          """int64_key_1: int64_key_2: 2""")
          ^
==

# Test supertyping of proto and bytes literal.
select if(false,
          KitchenSink,
          b"int64_key_1: 1, int64_key_2: 2")
from TestTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, PROTO<zetasql_test__.KitchenSinkPB>, PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     +-Literal(type=BOOL, value=false)
    |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={<unparseable>})
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# Supertyping two different protos does not work.
select if(false,
          KitchenSink,
          KitchenSink.nested_value)
from TestTable
--
ERROR: No matching signature for function IF for argument types: BOOL, zetasql_test__.KitchenSinkPB, zetasql_test__.KitchenSinkPB.Nested. Supported signature: IF(BOOL, ANY, ANY) [at 1:8]
select if(false,
       ^
==

# Supertyping proto and non-literal string does not work.
select if(false,
          KitchenSink,
          cast(KitchenSink as string))
from TestTable
--
ERROR: No matching signature for function IF for argument types: BOOL, zetasql_test__.KitchenSinkPB, STRING. Supported signature: IF(BOOL, ANY, ANY) [at 1:8]
select if(false,
       ^
==

# Supertyping proto and non-literal bytes does not work.
select if(false,
          KitchenSink,
          cast(KitchenSink as bytes))
from TestTable
--
ERROR: No matching signature for function IF for argument types: BOOL, zetasql_test__.KitchenSinkPB, BYTES. Supported signature: IF(BOOL, ANY, ANY) [at 1:8]
select if(false,
       ^
==

# Super-type three function arguments with different types with a literal or
# parameter in the first slot.
select coalesce(
  {{'int64_key_1:1 int64_key_2:2'|@test_param_string|@test_param_proto|KitchenSink}},
  coalesce(CAST('' as alt_descriptor_pool.zetasql_test__.KitchenSinkPB)),
  KitchenSink)
from TestTable
--
ALTERNATION GROUP: 'int64_key_1:1 int64_key_2:2'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(3) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     +-Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={int64_key_1: 1 int64_key_2: 2})
    |     +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     | +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     |   +-Literal(type=STRING, value='')
    |     +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
    |       +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
--
ALTERNATION GROUP: @test_param_string
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(3) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     | +-Parameter(type=STRING, name="test_param_string")
    |     +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     | +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     |   +-Literal(type=STRING, value='')
    |     +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
    |       +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
--
ALTERNATION GROUP: @test_param_proto
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(3) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     +-Parameter(type=PROTO<zetasql_test__.KitchenSinkPB>, name="test_param_proto")
    |     +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     | +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     |   +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     |     +-Literal(type=STRING, value='')
    |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
--
ALTERNATION GROUP: KitchenSink
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(3) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     | +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     |   +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
    |     |     +-Literal(type=STRING, value='')
    |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# Super-type three union arguments with different types with a literal or
# param in the first slot.
select {{'int64_key_1:1 int64_key_2:2'|@test_param_string|@test_param_proto|KitchenSink}} from TestTable
union all
select coalesce(CAST('' as alt_descriptor_pool.zetasql_test__.KitchenSinkPB))
union all
select KitchenSink from TestTable
--
ALTERNATION GROUP: 'int64_key_1:1 int64_key_2:2'
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#9 AS "$col1" [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#9]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.$col1#10]
      | |   +-expr_list=
      | |   | +-$col1#10 := Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={int64_key_1: 1 int64_key_2: 2})
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$union_all1.$col1#4]
      | |       +-expr_list=
      | |       | +-$col1#4 := Literal(type=STRING, value="int64_key_1:1 int64_key_2:2")
      | |       +-input_scan=
      | |         +-TableScan(table=TestTable)
      | +-output_column_list=[$union_all1_cast.$col1#10]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2.$col1#5]
      | |   +-expr_list=
      | |   | +-$col1#5 :=
      | |   |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |     +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |       +-Literal(type=STRING, value='')
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=[$union_all2.$col1#5]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3_cast.KitchenSink#11]
        |   +-expr_list=
        |   | +-KitchenSink#11 :=
        |   |   +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
        |   |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#8)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[TestTable.KitchenSink#8]
        |       +-input_scan=
        |         +-TableScan(column_list=[TestTable.KitchenSink#8], table=TestTable, column_index_list=[2])
        +-output_column_list=[$union_all3_cast.KitchenSink#11]
--
ALTERNATION GROUP: @test_param_string
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#9 AS "$col1" [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#9]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.$col1#10]
      | |   +-expr_list=
      | |   | +-$col1#10 :=
      | |   |   +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |     +-ColumnRef(type=STRING, column=$union_all1.$col1#4)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$union_all1.$col1#4]
      | |       +-expr_list=
      | |       | +-$col1#4 := Parameter(type=STRING, name="test_param_string")
      | |       +-input_scan=
      | |         +-TableScan(table=TestTable)
      | +-output_column_list=[$union_all1_cast.$col1#10]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2.$col1#5]
      | |   +-expr_list=
      | |   | +-$col1#5 :=
      | |   |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |     +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |       +-Literal(type=STRING, value='')
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=[$union_all2.$col1#5]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3_cast.KitchenSink#11]
        |   +-expr_list=
        |   | +-KitchenSink#11 :=
        |   |   +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
        |   |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#8)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[TestTable.KitchenSink#8]
        |       +-input_scan=
        |         +-TableScan(column_list=[TestTable.KitchenSink#8], table=TestTable, column_index_list=[2])
        +-output_column_list=[$union_all3_cast.KitchenSink#11]
--
ALTERNATION GROUP: @test_param_proto
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#9 AS "$col1" [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#9]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1.$col1#4]
      | |   +-expr_list=
      | |   | +-$col1#4 := Parameter(type=PROTO<zetasql_test__.KitchenSinkPB>, name="test_param_proto")
      | |   +-input_scan=
      | |     +-TableScan(table=TestTable)
      | +-output_column_list=[$union_all1.$col1#4]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.$col1#10]
      | |   +-expr_list=
      | |   | +-$col1#10 :=
      | |   |   +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=$union_all2.$col1#5)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$union_all2.$col1#5]
      | |       +-expr_list=
      | |       | +-$col1#5 :=
      | |       |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |       |     +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |       |       +-Literal(type=STRING, value='')
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$union_all2_cast.$col1#10]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.KitchenSink#8]
        |   +-input_scan=
        |     +-TableScan(column_list=[TestTable.KitchenSink#8], table=TestTable, column_index_list=[2])
        +-output_column_list=[TestTable.KitchenSink#8]
--
ALTERNATION GROUP: KitchenSink
--
QueryStmt
+-output_column_list=
| +-$union_all.KitchenSink#8 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.KitchenSink#8]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[TestTable.KitchenSink#3]
      | |   +-input_scan=
      | |     +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
      | +-output_column_list=[TestTable.KitchenSink#3]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.$col1#9]
      | |   +-expr_list=
      | |   | +-$col1#9 :=
      | |   |   +-Cast(PROTO<zetasql_test__.KitchenSinkPB> -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |   |     +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=$union_all2.$col1#4)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$union_all2.$col1#4]
      | |       +-expr_list=
      | |       | +-$col1#4 :=
      | |       |   +-FunctionCall(ZetaSQL:coalesce(repeated(1) PROTO<zetasql_test__.KitchenSinkPB>) -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |       |     +-Cast(STRING -> PROTO<zetasql_test__.KitchenSinkPB>)
      | |       |       +-Literal(type=STRING, value='')
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$union_all2_cast.$col1#9]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[TestTable.KitchenSink#7]
        |   +-input_scan=
        |     +-TableScan(column_list=[TestTable.KitchenSink#7], table=TestTable, column_index_list=[2])
        +-output_column_list=[TestTable.KitchenSink#7]
==

select {{Array<int64>[]|Array<int32>[]|Array<string>[]}} union all select []
--
ALTERNATION GROUP: Array<int64>[]
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#3 AS "$col1" [ARRAY<INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#3]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1.$col1#1]
      | |   +-expr_list=
      | |   | +-$col1#1 := Literal(type=ARRAY<INT64>, value=[], has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=[$union_all1.$col1#1]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2.$col1#2]
        |   +-expr_list=
        |   | +-$col1#2 := Literal(type=ARRAY<INT64>, value=[])
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=[$union_all2.$col1#2]
--
ALTERNATION GROUP: Array<int32>[]
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#3 AS "$col1" [ARRAY<INT32>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#3]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1.$col1#1]
      | |   +-expr_list=
      | |   | +-$col1#1 := Literal(type=ARRAY<INT32>, value=[], has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=[$union_all1.$col1#1]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2_cast.$col1#4]
        |   +-expr_list=
        |   | +-$col1#4 := Literal(type=ARRAY<INT32>, value=[])
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$union_all2.$col1#2]
        |       +-expr_list=
        |       | +-$col1#2 := Literal(type=ARRAY<INT64>, value=[])
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$union_all2_cast.$col1#4]
--
ALTERNATION GROUP: Array<string>[]
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#3 AS "$col1" [ARRAY<STRING>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#3]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1.$col1#1]
      | |   +-expr_list=
      | |   | +-$col1#1 := Literal(type=ARRAY<STRING>, value=[], has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=[$union_all1.$col1#1]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2_cast.$col1#4]
        |   +-expr_list=
        |   | +-$col1#4 := Literal(type=ARRAY<STRING>, value=[])
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$union_all2.$col1#2]
        |       +-expr_list=
        |       | +-$col1#2 := Literal(type=ARRAY<INT64>, value=[])
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$union_all2_cast.$col1#4]
==

select fn_on_any_array_returns_element(
    {{Array<int64>[]|Array<int32>[]|Array<string>[]|[]}})
--
ALTERNATION GROUP: Array<int64>[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_any_array_returns_element(ARRAY<INT64>) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: Array<int32>[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_any_array_returns_element(ARRAY<INT32>) -> INT32)
    |     +-Literal(type=ARRAY<INT32>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: Array<string>[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_any_array_returns_element(ARRAY<STRING>) -> STRING)
    |     +-Literal(type=ARRAY<STRING>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: []
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_any_array_returns_element(ARRAY<INT64>) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select fn_on_int32_array_returns_int32(
    {{ARRAY<int32>[]|ARRAY<int64>[]|ARRAY<string>[]|[]}})
--
ALTERNATION GROUP: ARRAY<int32>[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_int32_array_returns_int32(ARRAY<INT32>) -> INT32)
    |     +-Literal(type=ARRAY<INT32>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: ARRAY<int64>[]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<INT64>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 1:8]
select fn_on_int32_array_returns_int32(
       ^
--
ALTERNATION GROUP: ARRAY<string>[]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<STRING>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 1:8]
select fn_on_int32_array_returns_int32(
       ^
--
ALTERNATION GROUP: []
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_int32_array_returns_int32(ARRAY<INT32>) -> INT32)
    |     +-Literal(type=ARRAY<INT32>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select fn_on_int64_array_returns_int64(
    {{ARRAY<int64>[]|ARRAY<int32>[]|ARRAY<uint32>[]|[]}})
--
ALTERNATION GROUP: ARRAY<int64>[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_int64_array_returns_int64(ARRAY<INT64>) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: ARRAY<int32>[]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT64_ARRAY_RETURNS_INT64 for argument types: ARRAY<INT32>. Supported signature: FN_ON_INT64_ARRAY_RETURNS_INT64(ARRAY<INT64>) [at 1:8]
select fn_on_int64_array_returns_int64(
       ^
--
ALTERNATION GROUP: ARRAY<uint32>[]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT64_ARRAY_RETURNS_INT64 for argument types: ARRAY<UINT32>. Supported signature: FN_ON_INT64_ARRAY_RETURNS_INT64(ARRAY<INT64>) [at 1:8]
select fn_on_int64_array_returns_int64(
       ^
--
ALTERNATION GROUP: []
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_int64_array_returns_int64(ARRAY<INT64>) -> INT64)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select if(true, [1,2,3], [])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<INT64>, ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=BOOL, value=true)
    |     +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select ifnull(NULL, [])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:ifnull(ARRAY<INT64>, ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=ARRAY<INT64>, value=NULL)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select ifnull([], NULL)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:ifnull(ARRAY<INT64>, ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    |     +-Literal(type=ARRAY<INT64>, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

select ifnull([], [])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:ifnull(ARRAY<INT64>, ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select ifnull(CAST(NULL AS INT32), NULL)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:ifnull(INT32, INT32) -> INT32)
    |     +-Literal(type=INT32, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=INT32, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

select ifnull(ARRAY<INT32>[], [])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:ifnull(ARRAY<INT32>, ARRAY<INT32>) -> ARRAY<INT32>)
    |     +-Literal(type=ARRAY<INT32>, value=[], has_explicit_type=TRUE)
    |     +-Literal(type=ARRAY<INT32>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select (case when true then array<int32>[] else [] end)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$case_no_value(repeated(1) BOOL, repeated(1) ARRAY<INT32>, ARRAY<INT32>) -> ARRAY<INT32>)
    |     +-Literal(type=BOOL, value=true)
    |     +-Literal(type=ARRAY<INT32>, value=[], has_explicit_type=TRUE)
    |     +-Literal(type=ARRAY<INT32>, value=[])
    +-input_scan=
      +-SingleRowScan
==

select coalesce({{NULL|[]}}, {{[]|NULL}})
--
ALTERNATION GROUP: NULL,[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=ARRAY<INT64>, value=NULL)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL,NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) INT64) -> INT64)
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: [],[]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    |     +-Literal(type=ARRAY<INT64>, value=[])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: [],NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) ARRAY<INT64>) -> ARRAY<INT64>)
    |     +-Literal(type=ARRAY<INT64>, value=[])
    |     +-Literal(type=ARRAY<INT64>, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select KitchenSink.repeated_int32_val
from TestTable
where KitchenSink.repeated_int32_val = []
--
ALTERNATION GROUP: <empty>
--
ERROR: Equality is not defined for arguments of type ARRAY<INT32> [at 3:7]
where KitchenSink.repeated_int32_val = []
      ^
--
ALTERNATION GROUP: V_1_1_ARRAY_EQUALITY
--
QueryStmt
+-output_column_list=
| +-$query.repeated_int32_val#4 AS repeated_int32_val [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.repeated_int32_val#4]
    +-expr_list=
    | +-repeated_int32_val#4 :=
    |   +-GetProtoField
    |     +-type=ARRAY<INT32>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-field_descriptor=repeated_int32_val
    |     +-default_value=[]
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(ARRAY<INT32>, ARRAY<INT32>) -> BOOL)
            +-GetProtoField
            | +-type=ARRAY<INT32>
            | +-expr=
            | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | +-field_descriptor=repeated_int32_val
            | +-default_value=[]
            +-Literal(type=ARRAY<INT32>, value=[])
==

[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select KitchenSink.repeated_int32_val = KitchenSink.repeated_string_val
from TestTable
--
ERROR: No matching signature for operator = for argument types: ARRAY<INT32>, ARRAY<STRING>. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64; BOOL = STRING; STRING = BOOL; INT64 = STRING; STRING = INT64; FLOAT = STRING; STRING = FLOAT; DOUBLE = STRING; STRING = DOUBLE [at 1:8]
select KitchenSink.repeated_int32_val = KitchenSink.repeated_string_val
       ^
==

[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select KitchenSink.repeated_int32_val = KitchenSink.repeated_int64_val
from TestTable
--
ERROR: No matching signature for operator = for argument types: ARRAY<INT32>, ARRAY<INT64>. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64; BOOL = STRING; STRING = BOOL; INT64 = STRING; STRING = INT64; FLOAT = STRING; STRING = FLOAT; DOUBLE = STRING; STRING = DOUBLE [at 1:8]
select KitchenSink.repeated_int32_val = KitchenSink.repeated_int64_val
       ^
==

# TODO: This should work when implicit array coercion is allowed.
[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select KitchenSink.repeated_int32_val = [1,2,3]
from TestTable
--
ERROR: No matching signature for operator = for argument types: ARRAY<INT32>, ARRAY<INT64>. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64; BOOL = STRING; STRING = BOOL; INT64 = STRING; STRING = INT64; FLOAT = STRING; STRING = FLOAT; DOUBLE = STRING; STRING = DOUBLE [at 1:8]
select KitchenSink.repeated_int32_val = [1,2,3]
       ^

==

# TODO: This should work when implicit array coercion is allowed.
[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select KitchenSink.repeated_int64_val = [null]
from TestTable
--

ALTERNATION GROUP: <empty>
--
ERROR: Equality is not defined for arguments of type ARRAY<INT64> [at 1:8]
select KitchenSink.repeated_int64_val = [null]
       ^
--
ALTERNATION GROUP: V_1_1_ARRAY_EQUALITY
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:$equal(ARRAY<INT64>, ARRAY<INT64>) -> BOOL)
    |     +-GetProtoField
    |     | +-type=ARRAY<INT64>
    |     | +-expr=
    |     | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     | +-field_descriptor=repeated_int64_val
    |     | +-default_value=[]
    |     +-Literal(type=ARRAY<INT64>, value=[NULL])
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

# TODO: This should work when implicit array coercion is allowed.
[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select KitchenSink.repeated_string_val = [null]
from TestTable
--
ERROR: No matching signature for operator = for argument types: ARRAY<STRING>, ARRAY<INT64>. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64; BOOL = STRING; STRING = BOOL; INT64 = STRING; STRING = INT64; FLOAT = STRING; STRING = FLOAT; DOUBLE = STRING; STRING = DOUBLE [at 1:8]
select KitchenSink.repeated_string_val = [null]
       ^
==

[language_features=NUMERIC_TYPE]
SELECT if (true, 0.93, NUMERIC '0.94'),
       if (true, cast(0.93 as double), NUMERIC '0.94'),
       if (true, @test_param_double, NUMERIC '0.94'),
       if (true, 0.93 * 0.93, NUMERIC '0.94'),
       if (true, cast(0.93 as double), cast(0.94 as numeric)),
       if (true, 0.92, @test_param_numeric),
       if (true, cast(0.93 as double), @test_param_numeric),
       if (true, @test_param_double, @test_param_numeric),
       if (true, 0.93 * 0.93, @test_param_numeric)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [NUMERIC]
| +-$query.$col2#2 AS "$col2" [DOUBLE]
| +-$query.$col3#3 AS "$col3" [DOUBLE]
| +-$query.$col4#4 AS "$col4" [DOUBLE]
| +-$query.$col5#5 AS "$col5" [DOUBLE]
| +-$query.$col6#6 AS "$col6" [NUMERIC]
| +-$query.$col7#7 AS "$col7" [DOUBLE]
| +-$query.$col8#8 AS "$col8" [DOUBLE]
| +-$query.$col9#9 AS "$col9" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6, $col7#7, $col8#8, $col9#9]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, NUMERIC, NUMERIC) -> NUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=NUMERIC, value=0.93)
    | |   +-Literal(type=NUMERIC, value=0.94, has_explicit_type=TRUE)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Parameter(type=DOUBLE, name="test_param_double")
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col4#4 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
    | |   | +-Literal(type=DOUBLE, value=0.93, float_literal_id=3)
    | |   | +-Literal(type=DOUBLE, value=0.93, float_literal_id=4)
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col5#5 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col6#6 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, NUMERIC, NUMERIC) -> NUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=NUMERIC, value=0.92)
    | |   +-Parameter(type=NUMERIC, name="test_param_numeric")
    | +-$col7#7 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | |   +-Cast(NUMERIC -> DOUBLE)
    | |     +-Parameter(type=NUMERIC, name="test_param_numeric")
    | +-$col8#8 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Parameter(type=DOUBLE, name="test_param_double")
    | |   +-Cast(NUMERIC -> DOUBLE)
    | |     +-Parameter(type=NUMERIC, name="test_param_numeric")
    | +-$col9#9 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    |     +-Literal(type=BOOL, value=true)
    |     +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
    |     | +-Literal(type=DOUBLE, value=0.93, float_literal_id=9)
    |     | +-Literal(type=DOUBLE, value=0.93, float_literal_id=10)
    |     +-Cast(NUMERIC -> DOUBLE)
    |       +-Parameter(type=NUMERIC, name="test_param_numeric")
    +-input_scan=
      +-SingleRowScan
==

[language_features=NUMERIC_TYPE]
SELECT if (true, numeric_col, 0.93),
       if (true, numeric_col, cast(0.93 as double)),
       if (true, numeric_col, @test_param_double)
FROM NumericTypeTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS "$col1" [NUMERIC]
| +-$query.$col2#3 AS "$col2" [DOUBLE]
| +-$query.$col3#4 AS "$col3" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#2, $col2#3, $col3#4]
    +-expr_list=
    | +-$col1#2 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, NUMERIC, NUMERIC) -> NUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#1)
    | |   +-Literal(type=NUMERIC, value=0.93)
    | +-$col2#3 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Cast(NUMERIC -> DOUBLE)
    | |   | +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#1)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | +-$col3#4 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    |     +-Literal(type=BOOL, value=true)
    |     +-Cast(NUMERIC -> DOUBLE)
    |     | +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#1)
    |     +-Parameter(type=DOUBLE, name="test_param_double")
    +-input_scan=
      +-TableScan(column_list=[NumericTypeTable.numeric_col#1], table=NumericTypeTable, column_index_list=[0])
==

[language_features=NUMERIC_TYPE]
SELECT "int64" x FROM SimpleTypes
UNION ALL
SELECT numeric_col x FROM NumericTypeTable
UNION ALL
SELECT 0.93 x
--
QueryStmt
+-output_column_list=
| +-$union_all.x#21 AS x [NUMERIC]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#21]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#22]
      | |   +-expr_list=
      | |   | +-int64#22 :=
      | |   |   +-Cast(INT64 -> NUMERIC)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#22]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[NumericTypeTable.numeric_col#19]
      | |   +-input_scan=
      | |     +-TableScan(column_list=[NumericTypeTable.numeric_col#19], table=NumericTypeTable, column_index_list=[0])
      | +-output_column_list=[NumericTypeTable.numeric_col#19]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3_cast.x#23]
        |   +-expr_list=
        |   | +-x#23 := Literal(type=NUMERIC, value=0.93)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$union_all3.x#20]
        |       +-expr_list=
        |       | +-x#20 := Literal(type=DOUBLE, value=0.93, float_literal_id=1)
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$union_all3_cast.x#23]
==

[language_features=NUMERIC_TYPE]
SELECT "int64" x FROM SimpleTypes
UNION ALL
SELECT numeric_col x FROM NumericTypeTable
UNION ALL
SELECT CAST(0.93 AS DOUBLE) x
--
QueryStmt
+-output_column_list=
| +-$union_all.x#21 AS x [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#21]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#22]
      | |   +-expr_list=
      | |   | +-int64#22 :=
      | |   |   +-Cast(INT64 -> DOUBLE)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#22]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.numeric_col#23]
      | |   +-expr_list=
      | |   | +-numeric_col#23 :=
      | |   |   +-Cast(NUMERIC -> DOUBLE)
      | |   |     +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#19)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[NumericTypeTable.numeric_col#19]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[NumericTypeTable.numeric_col#19], table=NumericTypeTable, column_index_list=[0])
      | +-output_column_list=[$union_all2_cast.numeric_col#23]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3.x#20]
        |   +-expr_list=
        |   | +-x#20 := Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=[$union_all3.x#20]
==

[language_features=NUMERIC_TYPE]
SELECT "int64" x FROM SimpleTypes
UNION ALL
SELECT NUMERIC '1.23' x
UNION ALL
SELECT CAST(0.93 AS DOUBLE) x
--
QueryStmt
+-output_column_list=
| +-$union_all.x#21 AS x [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#21]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#22]
      | |   +-expr_list=
      | |   | +-int64#22 :=
      | |   |   +-Cast(INT64 -> DOUBLE)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#22]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.x#23]
      | |   +-expr_list=
      | |   | +-x#23 := Literal(type=DOUBLE, value=1.23, has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$union_all2.x#19]
      | |       +-expr_list=
      | |       | +-x#19 := Literal(type=NUMERIC, value=1.23, has_explicit_type=TRUE)
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$union_all2_cast.x#23]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3.x#20]
        |   +-expr_list=
        |   | +-x#20 := Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=[$union_all3.x#20]
==

# This test demonstrates that a direct cast of a floating point literal into a
# NUMERIC does not lose precision.
[language_features=NUMERIC_TYPE]
SELECT cast(99999999999999999999999999999.999999999 as NUMERIC),
       cast(-99999999999999999999999999999.999999999 as NUMERIC),
       cast(cast("99999999999999999999999999999.999999999" as DOUBLE) as NUMERIC),
       cast(cast("-99999999999999999999999999999.999999999" as DOUBLE) as NUMERIC),
       cast(x as NUMERIC)
FROM (SELECT 99999999999999999999999999999.999999999 x)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS "$col1" [NUMERIC]
| +-$query.$col2#3 AS "$col2" [NUMERIC]
| +-$query.$col3#4 AS "$col3" [NUMERIC]
| +-$query.$col4#5 AS "$col4" [NUMERIC]
| +-$query.$col5#6 AS "$col5" [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#2, $col2#3, $col3#4, $col4#5, $col5#6]
    +-expr_list=
    | +-$col1#2 := Literal(type=NUMERIC, value=99999999999999999999999999999.999999999, has_explicit_type=TRUE)
    | +-$col2#3 := Literal(type=NUMERIC, value=-99999999999999999999999999999.999999999, has_explicit_type=TRUE)
    | +-$col3#4 := Literal(type=NUMERIC, value=99999999999999991433150857216, has_explicit_type=TRUE)
    | +-$col4#5 := Literal(type=NUMERIC, value=-99999999999999991433150857216, has_explicit_type=TRUE)
    | +-$col5#6 :=
    |   +-Cast(DOUBLE -> NUMERIC)
    |     +-ColumnRef(type=DOUBLE, column=$subquery1.x#1)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$subquery1.x#1]
        +-expr_list=
        | +-x#1 := Literal(type=DOUBLE, value=1e+29, float_literal_id=1)
        +-input_scan=
          +-SingleRowScan
==

[language_features=NUMERIC_TYPE]
SELECT cast(123.12 as NUMERIC),
       cast(.456 as NUMERIC),
       cast(678. as NUMERIC),
       cast(-34.789 as NUMERIC),
       cast(1.1e5 as NUMERIC),
       cast(-2.2e-2 as NUMERIC),
       cast(0.0 as NUMERIC),
       cast(.1e10 as NUMERIC),
       cast(3.e10 as NUMERIC),
       cast(.4e-3 as NUMERIC),
       cast(-.5 as NUMERIC)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [NUMERIC]
| +-$query.$col2#2 AS "$col2" [NUMERIC]
| +-$query.$col3#3 AS "$col3" [NUMERIC]
| +-$query.$col4#4 AS "$col4" [NUMERIC]
| +-$query.$col5#5 AS "$col5" [NUMERIC]
| +-$query.$col6#6 AS "$col6" [NUMERIC]
| +-$query.$col7#7 AS "$col7" [NUMERIC]
| +-$query.$col8#8 AS "$col8" [NUMERIC]
| +-$query.$col9#9 AS "$col9" [NUMERIC]
| +-$query.$col10#10 AS "$col10" [NUMERIC]
| +-$query.$col11#11 AS "$col11" [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6, $col7#7, $col8#8, $col9#9, $col10#10, $col11#11]
    +-expr_list=
    | +-$col1#1 := Literal(type=NUMERIC, value=123.12, has_explicit_type=TRUE)
    | +-$col2#2 := Literal(type=NUMERIC, value=0.456, has_explicit_type=TRUE)
    | +-$col3#3 := Literal(type=NUMERIC, value=678, has_explicit_type=TRUE)
    | +-$col4#4 := Literal(type=NUMERIC, value=-34.789, has_explicit_type=TRUE)
    | +-$col5#5 := Literal(type=NUMERIC, value=110000, has_explicit_type=TRUE)
    | +-$col6#6 := Literal(type=NUMERIC, value=-0.022, has_explicit_type=TRUE)
    | +-$col7#7 := Literal(type=NUMERIC, value=0, has_explicit_type=TRUE)
    | +-$col8#8 := Literal(type=NUMERIC, value=1000000000, has_explicit_type=TRUE)
    | +-$col9#9 := Literal(type=NUMERIC, value=30000000000, has_explicit_type=TRUE)
    | +-$col10#10 := Literal(type=NUMERIC, value=0.0004, has_explicit_type=TRUE)
    | +-$col11#11 := Literal(type=NUMERIC, value=-0.5, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# BIGNUMERIC type coercion tests
[language_features=BIGNUMERIC_TYPE]
SELECT if (true, 0.93, BIGNUMERIC '0.94'),
       if (true, cast(0.93 as double), BIGNUMERIC '0.94'),
       if (true, @test_param_double, BIGNUMERIC '0.94'),
       if (true, 0.93 * 0.93, BIGNUMERIC '0.94'),
       if (true, cast(0.93 as double), cast(0.94 as BIGNUMERIC)),
       if (true, 0.92, @test_param_bignumeric),
       if (true, cast(0.93 as double), @test_param_bignumeric),
       if (true, @test_param_double, @test_param_bignumeric),
       if (true, 0.93 * 0.93, @test_param_bignumeric)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BIGNUMERIC]
| +-$query.$col2#2 AS "$col2" [DOUBLE]
| +-$query.$col3#3 AS "$col3" [DOUBLE]
| +-$query.$col4#4 AS "$col4" [DOUBLE]
| +-$query.$col5#5 AS "$col5" [DOUBLE]
| +-$query.$col6#6 AS "$col6" [BIGNUMERIC]
| +-$query.$col7#7 AS "$col7" [DOUBLE]
| +-$query.$col8#8 AS "$col8" [DOUBLE]
| +-$query.$col9#9 AS "$col9" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6, $col7#7, $col8#8, $col9#9]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.93)
    | |   +-Literal(type=BIGNUMERIC, value=0.94, has_explicit_type=TRUE)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Parameter(type=DOUBLE, name="test_param_double")
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col4#4 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
    | |   | +-Literal(type=DOUBLE, value=0.93, float_literal_id=3)
    | |   | +-Literal(type=DOUBLE, value=0.93, float_literal_id=4)
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col5#5 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=DOUBLE, value=0.94, has_explicit_type=TRUE)
    | +-$col6#6 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.92)
    | |   +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    | +-$col7#7 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | |   +-Cast(BIGNUMERIC -> DOUBLE)
    | |     +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    | +-$col8#8 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Parameter(type=DOUBLE, name="test_param_double")
    | |   +-Cast(BIGNUMERIC -> DOUBLE)
    | |     +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    | +-$col9#9 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    |     +-Literal(type=BOOL, value=true)
    |     +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
    |     | +-Literal(type=DOUBLE, value=0.93, float_literal_id=9)
    |     | +-Literal(type=DOUBLE, value=0.93, float_literal_id=10)
    |     +-Cast(BIGNUMERIC -> DOUBLE)
    |       +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    +-input_scan=
      +-SingleRowScan
==

[language_features=BIGNUMERIC_TYPE,NUMERIC_TYPE]
SELECT if (true, NUMERIC '0.93', BIGNUMERIC '0.94'),
       if (true, cast(0.93 as NUMERIC), BIGNUMERIC '0.94'),
       if (true, @test_param_numeric, BIGNUMERIC '0.94'),
       if (true, cast(0.93 as NUMERIC), cast(0.94 as BIGNUMERIC)),
       if (true, NUMERIC '0.93', @test_param_bignumeric),
       if (true, cast(0.93 as NUMERIC), @test_param_bignumeric),
       if (true, @test_param_numeric, @test_param_bignumeric)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BIGNUMERIC]
| +-$query.$col2#2 AS "$col2" [BIGNUMERIC]
| +-$query.$col3#3 AS "$col3" [BIGNUMERIC]
| +-$query.$col4#4 AS "$col4" [BIGNUMERIC]
| +-$query.$col5#5 AS "$col5" [BIGNUMERIC]
| +-$query.$col6#6 AS "$col6" [BIGNUMERIC]
| +-$query.$col7#7 AS "$col7" [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6, $col7#7]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=BIGNUMERIC, value=0.94, has_explicit_type=TRUE)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=BIGNUMERIC, value=0.94, has_explicit_type=TRUE)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Cast(NUMERIC -> BIGNUMERIC)
    | |   | +-Parameter(type=NUMERIC, name="test_param_numeric")
    | |   +-Literal(type=BIGNUMERIC, value=0.94, has_explicit_type=TRUE)
    | +-$col4#4 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | |   +-Literal(type=BIGNUMERIC, value=0.94, has_explicit_type=TRUE)
    | +-$col5#5 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | |   +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    | +-$col6#6 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | |   +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    | +-$col7#7 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    |     +-Literal(type=BOOL, value=true)
    |     +-Cast(NUMERIC -> BIGNUMERIC)
    |     | +-Parameter(type=NUMERIC, name="test_param_numeric")
    |     +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    +-input_scan=
      +-SingleRowScan
==

[language_features=BIGNUMERIC_TYPE]
SELECT if (true, bignumeric_col, 0.93),
       if (true, bignumeric_col, cast(0.93 as double)),
       if (true, bignumeric_col, @test_param_double)
FROM BigNumericTypeTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS "$col1" [BIGNUMERIC]
| +-$query.$col2#3 AS "$col2" [DOUBLE]
| +-$query.$col3#4 AS "$col3" [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#2, $col2#3, $col3#4]
    +-expr_list=
    | +-$col1#2 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=BIGNUMERIC, column=BigNumericTypeTable.bignumeric_col#1)
    | |   +-Literal(type=BIGNUMERIC, value=0.93)
    | +-$col2#3 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Cast(BIGNUMERIC -> DOUBLE)
    | |   | +-ColumnRef(type=BIGNUMERIC, column=BigNumericTypeTable.bignumeric_col#1)
    | |   +-Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
    | +-$col3#4 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, DOUBLE, DOUBLE) -> DOUBLE)
    |     +-Literal(type=BOOL, value=true)
    |     +-Cast(BIGNUMERIC -> DOUBLE)
    |     | +-ColumnRef(type=BIGNUMERIC, column=BigNumericTypeTable.bignumeric_col#1)
    |     +-Parameter(type=DOUBLE, name="test_param_double")
    +-input_scan=
      +-TableScan(column_list=[BigNumericTypeTable.bignumeric_col#1], table=BigNumericTypeTable, column_index_list=[0])
==

[language_features=BIGNUMERIC_TYPE,NUMERIC_TYPE]
SELECT if (true, numeric_col, BIGNUMERIC '0.93'),
       if (true, numeric_col, cast(0.93 as BIGNUMERIC)),
       if (true, numeric_col, @test_param_bignumeric)
FROM NumericTypeTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS "$col1" [BIGNUMERIC]
| +-$query.$col2#3 AS "$col2" [BIGNUMERIC]
| +-$query.$col3#4 AS "$col3" [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#2, $col2#3, $col3#4]
    +-expr_list=
    | +-$col1#2 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Cast(NUMERIC -> BIGNUMERIC)
    | |   | +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#1)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | +-$col2#3 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    | |   +-Literal(type=BOOL, value=true)
    | |   +-Cast(NUMERIC -> BIGNUMERIC)
    | |   | +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#1)
    | |   +-Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
    | +-$col3#4 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
    |     +-Literal(type=BOOL, value=true)
    |     +-Cast(NUMERIC -> BIGNUMERIC)
    |     | +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#1)
    |     +-Parameter(type=BIGNUMERIC, name="test_param_bignumeric")
    +-input_scan=
      +-TableScan(column_list=[NumericTypeTable.numeric_col#1], table=NumericTypeTable, column_index_list=[0])
==

[language_features=BIGNUMERIC_TYPE]
SELECT "int64" x FROM SimpleTypes
UNION ALL
SELECT bignumeric_col x FROM BigNumericTypeTable
UNION ALL
SELECT 0.93 x
--
QueryStmt
+-output_column_list=
| +-$union_all.x#21 AS x [BIGNUMERIC]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#21]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#22]
      | |   +-expr_list=
      | |   | +-int64#22 :=
      | |   |   +-Cast(INT64 -> BIGNUMERIC)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#22]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[BigNumericTypeTable.bignumeric_col#19]
      | |   +-input_scan=
      | |     +-TableScan(column_list=[BigNumericTypeTable.bignumeric_col#19], table=BigNumericTypeTable, column_index_list=[0])
      | +-output_column_list=[BigNumericTypeTable.bignumeric_col#19]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3_cast.x#23]
        |   +-expr_list=
        |   | +-x#23 := Literal(type=BIGNUMERIC, value=0.93)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$union_all3.x#20]
        |       +-expr_list=
        |       | +-x#20 := Literal(type=DOUBLE, value=0.93, float_literal_id=1)
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$union_all3_cast.x#23]
==

[language_features=BIGNUMERIC_TYPE]
SELECT "int64" x FROM SimpleTypes
UNION ALL
SELECT bignumeric_col x FROM BigNumericTypeTable
UNION ALL
SELECT CAST(0.93 AS DOUBLE) x
--
QueryStmt
+-output_column_list=
| +-$union_all.x#21 AS x [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#21]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#22]
      | |   +-expr_list=
      | |   | +-int64#22 :=
      | |   |   +-Cast(INT64 -> DOUBLE)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#22]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.bignumeric_col#23]
      | |   +-expr_list=
      | |   | +-bignumeric_col#23 :=
      | |   |   +-Cast(BIGNUMERIC -> DOUBLE)
      | |   |     +-ColumnRef(type=BIGNUMERIC, column=BigNumericTypeTable.bignumeric_col#19)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[BigNumericTypeTable.bignumeric_col#19]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[BigNumericTypeTable.bignumeric_col#19], table=BigNumericTypeTable, column_index_list=[0])
      | +-output_column_list=[$union_all2_cast.bignumeric_col#23]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3.x#20]
        |   +-expr_list=
        |   | +-x#20 := Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=[$union_all3.x#20]
==

[language_features=BIGNUMERIC_TYPE]
SELECT "int64" x FROM SimpleTypes
UNION ALL
SELECT BIGNUMERIC '1.23' x
UNION ALL
SELECT CAST(0.93 AS DOUBLE) x
--
QueryStmt
+-output_column_list=
| +-$union_all.x#21 AS x [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#21]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#22]
      | |   +-expr_list=
      | |   | +-int64#22 :=
      | |   |   +-Cast(INT64 -> DOUBLE)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#22]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.x#23]
      | |   +-expr_list=
      | |   | +-x#23 := Literal(type=DOUBLE, value=1.23, has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$union_all2.x#19]
      | |       +-expr_list=
      | |       | +-x#19 := Literal(type=BIGNUMERIC, value=1.23, has_explicit_type=TRUE)
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$union_all2_cast.x#23]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3.x#20]
        |   +-expr_list=
        |   | +-x#20 := Literal(type=DOUBLE, value=0.93, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=[$union_all3.x#20]
==

[language_features=BIGNUMERIC_TYPE,NUMERIC_TYPE]
SELECT "int64" x FROM SimpleTypes
UNION ALL
SELECT numeric_col x FROM NumericTypeTable
UNION ALL
SELECT BIGNUMERIC '0.93'
--
QueryStmt
+-output_column_list=
| +-$union_all.x#21 AS x [BIGNUMERIC]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.x#21]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.int64#22]
      | |   +-expr_list=
      | |   | +-int64#22 :=
      | |   |   +-Cast(INT64 -> BIGNUMERIC)
      | |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[SimpleTypes.int64#2]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
      | +-output_column_list=[$union_all1_cast.int64#22]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2_cast.numeric_col#23]
      | |   +-expr_list=
      | |   | +-numeric_col#23 :=
      | |   |   +-Cast(NUMERIC -> BIGNUMERIC)
      | |   |     +-ColumnRef(type=NUMERIC, column=NumericTypeTable.numeric_col#19)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[NumericTypeTable.numeric_col#19]
      | |       +-input_scan=
      | |         +-TableScan(column_list=[NumericTypeTable.numeric_col#19], table=NumericTypeTable, column_index_list=[0])
      | +-output_column_list=[$union_all2_cast.numeric_col#23]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3.$col1#20]
        |   +-expr_list=
        |   | +-$col1#20 := Literal(type=BIGNUMERIC, value=0.93, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=[$union_all3.$col1#20]
==

# This test demonstrates that a direct cast of a floating point literal into a
# NUMERIC does not lose precision.
[language_features=BIGNUMERIC_TYPE]
SELECT cast(578960446186580977117854925043439539266.34992332820282019728792003956564819967 as BIGNUMERIC),
       cast(-578960446186580977117854925043439539266.34992332820282019728792003956564819968 as BIGNUMERIC),
       cast(cast("578960446186580977117854925043439539266.34992332820282019728792003956564819967" as DOUBLE) as BIGNUMERIC),
       cast(cast("-578960446186580977117854925043439539266.34992332820282019728792003956564819968" as DOUBLE) as BIGNUMERIC),
       cast(x as BIGNUMERIC)
FROM (SELECT 578960446186580977117854925043439539266.34992332820282019728792003956564819967 x)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS "$col1" [BIGNUMERIC]
| +-$query.$col2#3 AS "$col2" [BIGNUMERIC]
| +-$query.$col3#4 AS "$col3" [BIGNUMERIC]
| +-$query.$col4#5 AS "$col4" [BIGNUMERIC]
| +-$query.$col5#6 AS "$col5" [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#2, $col2#3, $col3#4, $col4#5, $col5#6]
    +-expr_list=
    | +-$col1#2 := Literal(type=BIGNUMERIC, value=578960446186580977117854925043439539266.34992332820282019728792003956564819967, has_explicit_type=TRUE)
    | +-$col2#3 := Literal(type=BIGNUMERIC, value=-578960446186580977117854925043439539266.34992332820282019728792003956564819968, has_explicit_type=TRUE)
    | +-$col3#4 := Literal(type=BIGNUMERIC, value=578960446186580955070694765308237840384, has_explicit_type=TRUE)
    | +-$col4#5 := Literal(type=BIGNUMERIC, value=-578960446186580955070694765308237840384, has_explicit_type=TRUE)
    | +-$col5#6 :=
    |   +-Cast(DOUBLE -> BIGNUMERIC)
    |     +-ColumnRef(type=DOUBLE, column=$subquery1.x#1)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$subquery1.x#1]
        +-expr_list=
        | +-x#1 := Literal(type=DOUBLE, value=5.7896044618658096e+38, float_literal_id=1)
        +-input_scan=
          +-SingleRowScan
==

[language_features=BIGNUMERIC_TYPE]
SELECT cast(123.12 as BIGNUMERIC),
       cast(.456 as BIGNUMERIC),
       cast(678. as BIGNUMERIC),
       cast(-34.789 as BIGNUMERIC),
       cast(1.1e5 as BIGNUMERIC),
       cast(-2.2e-2 as BIGNUMERIC),
       cast(0.0 as BIGNUMERIC),
       cast(.1e10 as BIGNUMERIC),
       cast(3.e10 as BIGNUMERIC),
       cast(.4e-3 as BIGNUMERIC),
       cast(-.5 as BIGNUMERIC)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BIGNUMERIC]
| +-$query.$col2#2 AS "$col2" [BIGNUMERIC]
| +-$query.$col3#3 AS "$col3" [BIGNUMERIC]
| +-$query.$col4#4 AS "$col4" [BIGNUMERIC]
| +-$query.$col5#5 AS "$col5" [BIGNUMERIC]
| +-$query.$col6#6 AS "$col6" [BIGNUMERIC]
| +-$query.$col7#7 AS "$col7" [BIGNUMERIC]
| +-$query.$col8#8 AS "$col8" [BIGNUMERIC]
| +-$query.$col9#9 AS "$col9" [BIGNUMERIC]
| +-$query.$col10#10 AS "$col10" [BIGNUMERIC]
| +-$query.$col11#11 AS "$col11" [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4, $col5#5, $col6#6, $col7#7, $col8#8, $col9#9, $col10#10, $col11#11]
    +-expr_list=
    | +-$col1#1 := Literal(type=BIGNUMERIC, value=123.12, has_explicit_type=TRUE)
    | +-$col2#2 := Literal(type=BIGNUMERIC, value=0.456, has_explicit_type=TRUE)
    | +-$col3#3 := Literal(type=BIGNUMERIC, value=678, has_explicit_type=TRUE)
    | +-$col4#4 := Literal(type=BIGNUMERIC, value=-34.789, has_explicit_type=TRUE)
    | +-$col5#5 := Literal(type=BIGNUMERIC, value=110000, has_explicit_type=TRUE)
    | +-$col6#6 := Literal(type=BIGNUMERIC, value=-0.022, has_explicit_type=TRUE)
    | +-$col7#7 := Literal(type=BIGNUMERIC, value=0, has_explicit_type=TRUE)
    | +-$col8#8 := Literal(type=BIGNUMERIC, value=1000000000, has_explicit_type=TRUE)
    | +-$col9#9 := Literal(type=BIGNUMERIC, value=30000000000, has_explicit_type=TRUE)
    | +-$col10#10 := Literal(type=BIGNUMERIC, value=0.0004, has_explicit_type=TRUE)
    | +-$col11#11 := Literal(type=BIGNUMERIC, value=-0.5, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select fn_on_int32_array_returns_int32(NULL)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(sample_functions:fn_on_int32_array_returns_int32(ARRAY<INT32>) -> INT32)
    |     +-Literal(type=ARRAY<INT32>, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

# Implicit coercion of non-empty array literals is now supported. (Implicit
# coercion of empty array literals was always supported.)
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select [],
       [1, 2, 3],
       fn_on_int32_array_returns_int32([]),
       fn_on_int32_array_returns_int32([1, 2, 3])
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<INT64>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 4:8]
       fn_on_int32_array_returns_int32([1, 2, 3])
       ^
--
ALTERNATION GROUP: V_1_1_CAST_DIFFERENT_ARRAY_TYPES
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [ARRAY<INT64>]
| +-$query.$col2#2 AS "$col2" [ARRAY<INT64>]
| +-$query.$col3#3 AS "$col3" [INT32]
| +-$query.$col4#4 AS "$col4" [INT32]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4]
    +-expr_list=
    | +-$col1#1 := Literal(type=ARRAY<INT64>, value=[])
    | +-$col2#2 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    | +-$col3#3 :=
    | | +-FunctionCall(sample_functions:fn_on_int32_array_returns_int32(ARRAY<INT32>) -> INT32)
    | |   +-Literal(type=ARRAY<INT32>, value=[])
    | +-$col4#4 :=
    |   +-FunctionCall(sample_functions:fn_on_int32_array_returns_int32(ARRAY<INT32>) -> INT32)
    |     +-Literal(type=ARRAY<INT32>, value=[1, 2, 3])
    +-input_scan=
      +-SingleRowScan
==

# Of course, we don't allow implicit coercion of array literals with elements
# that are out of range for the destination element type.
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select fn_on_int32_array_returns_int32([1152921504606846976])
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<INT64>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 1:8]
select fn_on_int32_array_returns_int32([1152921504606846976])
       ^
--
ALTERNATION GROUP: V_1_1_CAST_DIFFERENT_ARRAY_TYPES
--
ERROR: Could not cast literal [1152921504606846976] to type ARRAY<INT32> [at 1:40]
select fn_on_int32_array_returns_int32([1152921504606846976])
                                       ^
==

# Due to runtime performance concerns, we don't support implicit coercion of
# array non-literals.
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select fn_on_int32_array_returns_int32(
         {{Int64Array|array_concat(Int64Array, Int64Array)}})
from ArrayTypes
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<INT64>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 1:8]
select fn_on_int32_array_returns_int32(
       ^
==

# For consistency with general expressions, we don't support implicit coercion
# of explicitly typed array literals either.
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select fn_on_int32_array_returns_int32(ARRAY<INT64>{{[1, 2, 3]|[]}})
--
ALTERNATION GROUPS:
    [1, 2, 3]
    V_1_1_CAST_DIFFERENT_ARRAY_TYPES,[1, 2, 3]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<INT64>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 1:8]
select fn_on_int32_array_returns_int32(ARRAY<INT64>[1, 2, 3])
       ^
--
ALTERNATION GROUPS:
    []
    V_1_1_CAST_DIFFERENT_ARRAY_TYPES,[]
--
ERROR: No matching signature for function SAMPLE_FUNCTIONS:FN_ON_INT32_ARRAY_RETURNS_INT32 for argument types: ARRAY<INT64>. Supported signature: FN_ON_INT32_ARRAY_RETURNS_INT32(ARRAY<INT32>) [at 1:8]
select fn_on_int32_array_returns_int32(ARRAY<INT64>[])
       ^

==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
[product_mode={{internal|external}}]
# Integers should coerce to opaque enums - it's not likely to
# be used much in practice, but it is part of the spec.  However
# this should _not_ be the case for product mode external, which
# doesn't have access to the underlying proto to determine the
# meaning of the integer.
#
SELECT ROUND(NUMERIC "1", 1, 1);
--
ALTERNATION GROUP: internal

--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:round(NUMERIC, INT64, ENUM<ROUNDING_MODE>) -> NUMERIC)
    |     +-Literal(type=NUMERIC, value=1, has_explicit_type=TRUE)
    |     +-Literal(type=INT64, value=1)
    |     +-Literal(type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_AWAY_FROM_ZERO)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: external
--
ERROR: No matching signature for function ROUND for argument types: NUMERIC, INT64, INT64. Supported signatures: ROUND(FLOAT64); ROUND(NUMERIC); ROUND(FLOAT64, INT64); ROUND(NUMERIC, INT64); ROUND(NUMERIC, INT64, ROUNDING_MODE) [at 7:8]
SELECT ROUND(NUMERIC "1", 1, 1);
       ^
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
[product_mode={{internal|external}}]
select 1 = CAST(1 as ROUNDING_MODE),
       'ROUND_HALF_EVEN' = CAST(1 as ROUNDING_MODE)
--
ALTERNATION GROUP: internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
| +-$query.$col2#2 AS "$col2" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:$equal(ENUM<ROUNDING_MODE>, ENUM<ROUNDING_MODE>) -> BOOL)
    | |   +-Literal(type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_AWAY_FROM_ZERO)
    | |   +-Cast(INT64 -> ENUM<ROUNDING_MODE>)
    | |     +-Literal(type=INT64, value=1)
    | +-$col2#2 :=
    |   +-FunctionCall(ZetaSQL:$equal(ENUM<ROUNDING_MODE>, ENUM<ROUNDING_MODE>) -> BOOL)
    |     +-Literal(type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_EVEN)
    |     +-Cast(INT64 -> ENUM<ROUNDING_MODE>)
    |       +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: external
--
ERROR: Type not found: ROUNDING_MODE [at 1:22]
select 1 = CAST(1 as ROUNDING_MODE),
                     ^
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
[product_mode={{internal|external}}]
[no_java]
# TODO: Fix java
select STRUCT( nested_catalog.constant_rounding_mode) = struct(1)
--
ALTERNATION GROUP: internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$equal(STRUCT<constant_rounding_mode ENUM<ROUNDING_MODE>>, STRUCT<constant_rounding_mode ENUM<ROUNDING_MODE>>) -> BOOL)
    |     +-MakeStruct
    |     | +-type=STRUCT<constant_rounding_mode ENUM<ROUNDING_MODE>>
    |     | +-field_list=
    |     |   +-Constant(nested_catalog.constant_rounding_mode, type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_EVEN)
    |     +-Literal(type=STRUCT<constant_rounding_mode ENUM<ROUNDING_MODE>>, value={constant_rounding_mode:ROUND_HALF_AWAY_FROM_ZERO})
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: external
--
ERROR: No matching signature for operator = for argument types: STRUCT<constant_rounding_mode ROUNDING_MODE>, STRUCT<INT64>. Supported signatures: ANY = ANY; BOOL = STRING; STRING = BOOL; INT64 = STRING; STRING = INT64; NUMERIC = STRING; STRING = NUMERIC; FLOAT64 = STRING; STRING = FLOAT64 [at 2:8]
select STRUCT( nested_catalog.constant_rounding_mode) = struct(1)
       ^

==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
[product_mode={{internal|external}}]
[no_java]
# TODO: Fix java
select nested_catalog.constant_rounding_mode in (1, 2)
--
ALTERNATION GROUP: internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in(ENUM<ROUNDING_MODE>, repeated(2) ENUM<ROUNDING_MODE>) -> BOOL)
    |     +-Constant(nested_catalog.constant_rounding_mode, type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_EVEN)
    |     +-Literal(type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_AWAY_FROM_ZERO)
    |     +-Literal(type=ENUM<ROUNDING_MODE>, value=ROUND_HALF_EVEN)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: external
--
ERROR: No matching signature for operator IN for argument types ENUM<ROUNDING_MODE> and {INT64} [at 2:46]
select nested_catalog.constant_rounding_mode in (1, 2)
                                             ^

==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
# Types are not coercible with each other
select CAST(1 as "zetasql.functions.RoundingMode") = CAST(1 as ROUNDING_MODE),
--
ERROR: No matching signature for operator = for argument types: zetasql.functions.RoundingMode, ROUNDING_MODE. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64; BOOL = STRING; STRING = BOOL; INT64 = STRING; STRING = INT64; FLOAT = STRING; STRING = FLOAT; NUMERIC = STRING; STRING = NUMERIC; DOUBLE = STRING; STRING = DOUBLE [at 2:8]
select CAST(1 as "zetasql.functions.RoundingMode") = CAST(1 as ROUNDING_MODE),
       ^
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
select CAST(1 as "zetasql.functions.RoundingMode") = CAST(1 as ROUNDING_MODE)
--
ERROR: No matching signature for operator = for argument types: zetasql.functions.RoundingMode, ROUNDING_MODE. Supported signatures: ANY = ANY; INT64 = UINT64; UINT64 = INT64; BOOL = STRING; STRING = BOOL; INT64 = STRING; STRING = INT64; FLOAT = STRING; STRING = FLOAT; NUMERIC = STRING; STRING = NUMERIC; DOUBLE = STRING; STRING = DOUBLE [at 1:8]
select CAST(1 as "zetasql.functions.RoundingMode") = CAST(1 as ROUNDING_MODE)
       ^
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
# ROUNDING_MODE_UNSPECIFIED is marked invalid in ROUNDING_MODE (but not
# 'zetasql.functions.RoundingMode')
select 'ROUNDING_MODE_UNSPECIFIED' = CAST(1 as ROUNDING_MODE)
--
ERROR: Could not cast literal "ROUNDING_MODE_UNSPECIFIED" to type ROUNDING_MODE [at 3:8]
select 'ROUNDING_MODE_UNSPECIFIED' = CAST(1 as ROUNDING_MODE)
       ^
==

[language_features=NUMERIC_TYPE,ROUND_WITH_ROUNDING_MODE]
# 0 (ROUNDING_MODE_UNSPECIFIED) is marked invalid in ROUNDING_MODE.
select 0 = CAST(1 as ROUNDING_MODE)
--
ERROR: Could not cast literal 0 to type ROUNDING_MODE [at 2:8]
select 0 = CAST(1 as ROUNDING_MODE)
       ^
