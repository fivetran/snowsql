select 'a' IN ('a', 'b', 'c');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in(STRING, repeated(3) STRING) -> BOOL)
    |     +-Literal(type=STRING, value='a')
    |     +-Literal(type=STRING, value='a')
    |     +-Literal(type=STRING, value='b')
    |     +-Literal(type=STRING, value='c')
    +-input_scan=
      +-SingleRowScan
==

select KitchenSink.string_val, KitchenSink.bytes_val
  from TestTable where 'a' in ('a', 'b', 'c');
--
QueryStmt
+-output_column_list=
| +-$query.string_val#4 AS string_val [STRING]
| +-$query.bytes_val#5 AS bytes_val [BYTES]
+-query=
  +-ProjectScan
    +-column_list=$query.[string_val#4, bytes_val#5]
    +-expr_list=
    | +-string_val#4 :=
    | | +-GetProtoField
    | |   +-type=STRING
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    | |   +-field_descriptor=string_val
    | |   +-default_value='default_name'
    | +-bytes_val#5 :=
    |   +-GetProtoField
    |     +-type=BYTES
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     +-field_descriptor=bytes_val
    |     +-default_value=b""
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$in(STRING, repeated(3) STRING) -> BOOL)
            +-Literal(type=STRING, value='a')
            +-Literal(type=STRING, value='a')
            +-Literal(type=STRING, value='b')
            +-Literal(type=STRING, value='c')
==

select false from TestTable where true IN ('a');
--
ERROR: Could not cast literal 'a' to type BOOL [at 1:44]
select false from TestTable where true IN ('a');
                                           ^
==

select 5 IN ('a', 4 + 5, KitchenSink.bytes_val) from TestTable;
--
ERROR: No matching signature for operator IN for argument types literal INT64 and {INT64, STRING, BYTES} [at 1:10]
select 5 IN ('a', 4 + 5, KitchenSink.bytes_val) from TestTable;
         ^
==

select 3 + 4 NOT NOT IN (6, 7, 8);
--
ERROR: Syntax error: Expected end of input but got keyword NOT [at 1:14]
select 3 + 4 NOT NOT IN (6, 7, 8);
             ^
==

select NULL IN (NULL);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in(INT64, repeated(1) INT64) -> BOOL)
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

select NOT NULL NOT IN (NULL, NULL);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$not(BOOL) -> BOOL)
    |     +-FunctionCall(ZetaSQL:$not(BOOL) -> BOOL)
    |       +-FunctionCall(ZetaSQL:$in(INT64, repeated(2) INT64) -> BOOL)
    |         +-Literal(type=INT64, value=NULL)
    |         +-Literal(type=INT64, value=NULL)
    |         +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

select KitchenSink.int64_val
  IN (KitchenSink.uint32_val,
      KitchenSink.int32_val,
      KitchenSink.int64_val,
      KitchenSink.double_val)
  from TestTable;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-FunctionCall(ZetaSQL:$in(DOUBLE, repeated(4) DOUBLE) -> BOOL)
    |     +-Cast(INT64 -> DOUBLE)
    |     | +-GetProtoField
    |     |   +-type=INT64
    |     |   +-expr=
    |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     |   +-field_descriptor=int64_val
    |     |   +-default_value=0
    |     +-Cast(UINT32 -> DOUBLE)
    |     | +-GetProtoField
    |     |   +-type=UINT32
    |     |   +-expr=
    |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     |   +-field_descriptor=uint32_val
    |     |   +-default_value=777
    |     +-Cast(INT32 -> DOUBLE)
    |     | +-GetProtoField
    |     |   +-type=INT32
    |     |   +-expr=
    |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     |   +-field_descriptor=int32_val
    |     |   +-default_value=77
    |     +-Cast(INT64 -> DOUBLE)
    |     | +-GetProtoField
    |     |   +-type=INT64
    |     |   +-expr=
    |     |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |     |   +-field_descriptor=int64_val
    |     |   +-default_value=0
    |     +-GetProtoField
    |       +-type=DOUBLE
    |       +-expr=
    |       | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
    |       +-field_descriptor=double_val
    |       +-default_value=0
    +-input_scan=
      +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
==

select true from TestTable where cast(1 as int32) IN (cast(1 as int32), 123);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=BOOL, value=true)
    +-input_scan=
      +-FilterScan
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$in(INT32, repeated(2) INT32) -> BOOL)
            +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
            +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
            +-Literal(type=INT32, value=123)
==

select cast(1 as int32) IN (cast(1 as int32), 1234567890123);
--
ERROR: Could not cast literal 1234567890123 to type INT32 [at 1:47]
select cast(1 as int32) IN (cast(1 as int32), 1234567890123);
                                              ^
==

select cast(1 as int64) IN (cast(1 as int32), 1234567890123);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in(INT64, repeated(2) INT64) -> BOOL)
    |     +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |     +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |     +-Literal(type=INT64, value=1234567890123)
    +-input_scan=
      +-SingleRowScan
==

select true from TestTable where cast(1 as int32) IN (cast(1 as int64));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=BOOL, value=true)
    +-input_scan=
      +-FilterScan
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$in(INT64, repeated(1) INT64) -> BOOL)
            +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
            +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
==

select 5 IN (cast(5 as int32));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in(INT32, repeated(1) INT32) -> BOOL)
    |     +-Literal(type=INT32, value=5)
    |     +-Literal(type=INT32, value=5, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

select cast(1 as int32) IN (1, 2, 3);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in(INT32, repeated(3) INT32) -> BOOL)
    |     +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
    |     +-Literal(type=INT32, value=1)
    |     +-Literal(type=INT32, value=2)
    |     +-Literal(type=INT32, value=3)
    +-input_scan=
      +-SingleRowScan
==

select 1 IN (select 1)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=INT64, value=1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#1]
    |         +-expr_list=
    |         | +-$col1#1 := Literal(type=INT64, value=1)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

select 1 NOT IN (select 1)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(ZetaSQL:$not(BOOL) -> BOOL)
    |     +-SubqueryExpr
    |       +-type=BOOL
    |       +-subquery_type=IN
    |       +-in_expr=
    |       | +-Literal(type=INT64, value=1)
    |       +-subquery=
    |         +-ProjectScan
    |           +-column_list=[$expr_subquery.$col1#1]
    |           +-expr_list=
    |           | +-$col1#1 := Literal(type=INT64, value=1)
    |           +-input_scan=
    |             +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

select 1 IN (select 1, 2)
--
ERROR: Subquery of type IN must have only one output column [at 1:14]
select 1 IN (select 1, 2)
             ^
==

select countif("int32" > 0)
from SimpleTypes
having countif("int64" > 0) > 5;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#19 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#19]
    +-input_scan=
      +-FilterScan
        +-column_list=$aggregate.[$agg1#19, $agg2#20]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=$aggregate.[$agg1#19, $agg2#20]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
        |   +-aggregate_list=
        |     +-$agg1#19 :=
        |     | +-AggregateFunctionCall(ZetaSQL:countif(BOOL) -> INT64)
        |     |   +-FunctionCall(ZetaSQL:$greater(INT32, INT32) -> BOOL)
        |     |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
        |     |     +-Literal(type=INT32, value=0)
        |     +-$agg2#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:countif(BOOL) -> INT64)
        |         +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |           +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
        |           +-Literal(type=INT64, value=0)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=$aggregate.$agg2#20)
            +-Literal(type=INT64, value=5)
==

select 1 IN (select 'a')
--
ERROR: Cannot execute IN subquery with uncomparable types INT64 and STRING [at 1:8]
select 1 IN (select 'a')
       ^
==

select 'a' IN (select 1)
--
ERROR: Cannot execute IN subquery with uncomparable types STRING and INT64 [at 1:8]
select 'a' IN (select 1)
       ^
==

select cast(1 as int64) IN (select cast(1 as uint64))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#1]
    |         +-expr_list=
    |         | +-$col1#1 := Literal(type=UINT64, value=1, has_explicit_type=TRUE)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

select cast(1 as int64) IN (select cast(1 as int32))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$in_subquery_cast.$col1#3]
    |         +-expr_list=
    |         | +-$col1#3 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$expr_subquery.$col1#1]
    |             +-expr_list=
    |             | +-$col1#1 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

select cast(1 as int32) IN (select cast(1 as int64))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#1]
    |         +-expr_list=
    |         | +-$col1#1 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |         +-input_scan=
    |           +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

select int32 IN (select uint64 from SimpleTypes),
       int64 IN (select uint64 from SimpleTypes),
       uint32 IN (select int64 from SimpleTypes),
       uint64 IN (select int64 from SimpleTypes),
       int64 IN (select double from SimpleTypes),
       double IN (select int64 from SimpleTypes),
       float IN (select int64 from SimpleTypes)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#149 AS "$col1" [BOOL]
| +-$query.$col2#150 AS "$col2" [BOOL]
| +-$query.$col3#151 AS "$col3" [BOOL]
| +-$query.$col4#152 AS "$col4" [BOOL]
| +-$query.$col5#153 AS "$col5" [BOOL]
| +-$query.$col6#154 AS "$col6" [BOOL]
| +-$query.$col7#155 AS "$col7" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#149, $col2#150, $col3#151, $col4#152, $col5#153, $col6#154, $col7#155]
    +-expr_list=
    | +-$col1#149 :=
    | | +-SubqueryExpr
    | |   +-type=BOOL
    | |   +-subquery_type=IN
    | |   +-in_expr=
    | |   | +-Cast(INT32 -> INT64)
    | |   |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[SimpleTypes.uint64#22]
    | |       +-input_scan=
    | |         +-TableScan(column_list=[SimpleTypes.uint64#22], table=SimpleTypes, column_index_list=[3])
    | +-$col2#150 :=
    | | +-SubqueryExpr
    | |   +-type=BOOL
    | |   +-subquery_type=IN
    | |   +-in_expr=
    | |   | +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[SimpleTypes.uint64#40]
    | |       +-input_scan=
    | |         +-TableScan(column_list=[SimpleTypes.uint64#40], table=SimpleTypes, column_index_list=[3])
    | +-$col3#151 :=
    | | +-SubqueryExpr
    | |   +-type=BOOL
    | |   +-subquery_type=IN
    | |   +-in_expr=
    | |   | +-Cast(UINT32 -> INT64)
    | |   |   +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[SimpleTypes.int64#56]
    | |       +-input_scan=
    | |         +-TableScan(column_list=[SimpleTypes.int64#56], table=SimpleTypes, column_index_list=[1])
    | +-$col4#152 :=
    | | +-SubqueryExpr
    | |   +-type=BOOL
    | |   +-subquery_type=IN
    | |   +-in_expr=
    | |   | +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[SimpleTypes.int64#74]
    | |       +-input_scan=
    | |         +-TableScan(column_list=[SimpleTypes.int64#74], table=SimpleTypes, column_index_list=[1])
    | +-$col5#153 :=
    | | +-SubqueryExpr
    | |   +-type=BOOL
    | |   +-subquery_type=IN
    | |   +-in_expr=
    | |   | +-Cast(INT64 -> DOUBLE)
    | |   |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[SimpleTypes.double#99]
    | |       +-input_scan=
    | |         +-TableScan(column_list=[SimpleTypes.double#99], table=SimpleTypes, column_index_list=[8])
    | +-$col6#154 :=
    | | +-SubqueryExpr
    | |   +-type=BOOL
    | |   +-subquery_type=IN
    | |   +-in_expr=
    | |   | +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[$in_subquery_cast.int64#128]
    | |       +-expr_list=
    | |       | +-int64#128 :=
    | |       |   +-Cast(INT64 -> DOUBLE)
    | |       |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#110)
    | |       +-input_scan=
    | |         +-ProjectScan
    | |           +-column_list=[SimpleTypes.int64#110]
    | |           +-input_scan=
    | |             +-TableScan(column_list=[SimpleTypes.int64#110], table=SimpleTypes, column_index_list=[1])
    | +-$col7#155 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Cast(FLOAT -> DOUBLE)
    |     |   +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$in_subquery_cast.int64#148]
    |         +-expr_list=
    |         | +-int64#148 :=
    |         |   +-Cast(INT64 -> DOUBLE)
    |         |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#130)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[SimpleTypes.int64#130]
    |             +-input_scan=
    |               +-TableScan(column_list=[SimpleTypes.int64#130], table=SimpleTypes, column_index_list=[1])
    +-input_scan=
      +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, float#8, double#9], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 7, 8])
==

# Same enum type.
select testenum IN (select testenum from TestTable)
from TestTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[TestTable.TestEnum#5]
    |         +-input_scan=
    |           +-TableScan(column_list=[TestTable.TestEnum#5], table=TestTable, column_index_list=[1])
    +-input_scan=
      +-TableScan(column_list=[TestTable.TestEnum#2], table=TestTable, column_index_list=[1])
==

# Equivalent enums from different descriptor pools.
select
  CAST(1 as zetasql_test__.TestEnum) IN (
    select CAST(2 as alt_descriptor_pool.zetasql_test__.TestEnum)),
  CAST(2 as alt_descriptor_pool.zetasql_test__.TestEnum) IN (
    select CAST(1 as zetasql_test__.TestEnum))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS "$col1" [BOOL]
| +-$query.$col2#8 AS "$col2" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#7, $col2#8]
    +-expr_list=
    | +-$col1#7 :=
    | | +-SubqueryExpr
    | |   +-type=BOOL
    | |   +-subquery_type=IN
    | |   +-in_expr=
    | |   | +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[$in_subquery_cast.$col1#3]
    | |       +-expr_list=
    | |       | +-$col1#3 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2, has_explicit_type=TRUE)
    | |       +-input_scan=
    | |         +-ProjectScan
    | |           +-column_list=[$expr_subquery.$col1#1]
    | |           +-expr_list=
    | |           | +-$col1#1 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2, has_explicit_type=TRUE)
    | |           +-input_scan=
    | |             +-SingleRowScan
    | +-$col2#8 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2, has_explicit_type=TRUE)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$in_subquery_cast.$col1#6]
    |         +-expr_list=
    |         | +-$col1#6 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$expr_subquery.$col1#4]
    |             +-expr_list=
    |             | +-$col1#4 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Similar to the previous test, but with column references rather than
# literals.  This illustrates that we actually do cast the inputs to a
# common supertype when the enums are equivalent but not equal.  We do
# this above also, but it's not obvious in the output due to constant
# folding.
WITH t1 as (select CAST(1 as zetasql_test__.TestEnum) as enum1,
                   CAST(2 as alt_descriptor_pool.zetasql_test__.TestEnum) as enum2),
     t2 as (select CAST(1 as zetasql_test__.TestEnum) as enum1,
                   CAST(2 as alt_descriptor_pool.zetasql_test__.TestEnum) as enum2)
select *
from t1
where t1.enum1 IN (select enum2 from t2)
   or t1.enum2 IN (select enum1 from t2)
--
QueryStmt
+-output_column_list=
| +-t1.enum1#5 AS enum1 [ENUM<zetasql_test__.TestEnum>]
| +-t1.enum2#6 AS enum2 [ENUM<zetasql_test__.TestEnum>]
+-query=
  +-WithScan
    +-column_list=t1.[enum1#5, enum2#6]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=t1.[enum1#1, enum2#2]
    | |     +-expr_list=
    | |     | +-enum1#1 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
    | |     | +-enum2#2 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2, has_explicit_type=TRUE)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t2.[enum1#3, enum2#4]
    |       +-expr_list=
    |       | +-enum1#3 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
    |       | +-enum2#4 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2, has_explicit_type=TRUE)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=t1.[enum1#5, enum2#6]
        +-input_scan=
          +-FilterScan
            +-column_list=t1.[enum1#5, enum2#6]
            +-input_scan=
            | +-WithRefScan(column_list=t1.[enum1#5, enum2#6], with_query_name='t1')
            +-filter_expr=
              +-FunctionCall(ZetaSQL:$or(BOOL, repeated(1) BOOL) -> BOOL)
                +-SubqueryExpr
                | +-type=BOOL
                | +-subquery_type=IN
                | +-in_expr=
                | | +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=t1.enum1#5)
                | +-subquery=
                |   +-ProjectScan
                |     +-column_list=[$in_subquery_cast.enum2#10]
                |     +-expr_list=
                |     | +-enum2#10 :=
                |     |   +-Cast(ENUM<zetasql_test__.TestEnum> -> ENUM<zetasql_test__.TestEnum>)
                |     |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=t2.enum2#8)
                |     +-input_scan=
                |       +-ProjectScan
                |         +-column_list=[t2.enum2#8]
                |         +-input_scan=
                |           +-WithRefScan(column_list=t2.[enum1#7, enum2#8], with_query_name='t2')
                +-SubqueryExpr
                  +-type=BOOL
                  +-subquery_type=IN
                  +-in_expr=
                  | +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=t1.enum2#6)
                  +-subquery=
                    +-ProjectScan
                      +-column_list=[$in_subquery_cast.enum1#14]
                      +-expr_list=
                      | +-enum1#14 :=
                      |   +-Cast(ENUM<zetasql_test__.TestEnum> -> ENUM<zetasql_test__.TestEnum>)
                      |     +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=t2.enum1#11)
                      +-input_scan=
                        +-ProjectScan
                          +-column_list=[t2.enum1#11]
                          +-input_scan=
                            +-WithRefScan(column_list=t2.[enum1#11, enum2#12], with_query_name='t2')
==

select
  CAST(1 as zetasql_test__.TestEnum) =
    CAST(2 as alt_descriptor_pool.zetasql_test__.TestEnum),
  CAST(2 as alt_descriptor_pool.zetasql_test__.TestEnum) !=
    CAST(1 as zetasql_test__.TestEnum)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
| +-$query.$col2#2 AS "$col2" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
    | |   +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
    | |   +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2, has_explicit_type=TRUE)
    | +-$col2#2 :=
    |   +-FunctionCall(ZetaSQL:$not_equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
    |     +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2, has_explicit_type=TRUE)
    |     +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

WITH t1 as (select CAST(1 as zetasql_test__.TestEnum) as enum1,
                   CAST(2 as alt_descriptor_pool.zetasql_test__.TestEnum) as enum2)
select *
from t1
where t1.enum1 = t1.enum2
   or t1.enum2 = t1.enum1;
--
QueryStmt
+-output_column_list=
| +-t1.enum1#3 AS enum1 [ENUM<zetasql_test__.TestEnum>]
| +-t1.enum2#4 AS enum2 [ENUM<zetasql_test__.TestEnum>]
+-query=
  +-WithScan
    +-column_list=t1.[enum1#3, enum2#4]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t1.[enum1#1, enum2#2]
    |       +-expr_list=
    |       | +-enum1#1 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM1, has_explicit_type=TRUE)
    |       | +-enum2#2 := Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM2, has_explicit_type=TRUE)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=t1.[enum1#3, enum2#4]
        +-input_scan=
          +-FilterScan
            +-column_list=t1.[enum1#3, enum2#4]
            +-input_scan=
            | +-WithRefScan(column_list=t1.[enum1#3, enum2#4], with_query_name='t1')
            +-filter_expr=
              +-FunctionCall(ZetaSQL:$or(BOOL, repeated(1) BOOL) -> BOOL)
                +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
                | +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=t1.enum1#3)
                | +-Cast(ENUM<zetasql_test__.TestEnum> -> ENUM<zetasql_test__.TestEnum>)
                |   +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=t1.enum2#4)
                +-FunctionCall(ZetaSQL:$equal(ENUM<zetasql_test__.TestEnum>, ENUM<zetasql_test__.TestEnum>) -> BOOL)
                  +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=t1.enum2#4)
                  +-Cast(ENUM<zetasql_test__.TestEnum> -> ENUM<zetasql_test__.TestEnum>)
                    +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=t1.enum1#3)
==

# TODO: These should probably work, for cases where the left
# IN expression is a literal that is implicitly coercible to the subquery
# column type.
select 'TESTENUM0' IN (select testenum from TestTable)
--
ERROR: Cannot execute IN subquery with uncomparable types STRING and zetasql_test__.TestEnum [at 1:8]
select 'TESTENUM0' IN (select testenum from TestTable)
       ^
==

# TODO: This should probably work.
select 1 IN (select testenum from TestTable)
--
ERROR: Cannot execute IN subquery with uncomparable types INT64 and zetasql_test__.TestEnum [at 1:8]
select 1 IN (select testenum from TestTable)
       ^
==

# Literal coercion does not reach inside the subquery.
select testenum IN (select 1)
from TestTable
--
ERROR: Cannot execute IN subquery with uncomparable types zetasql_test__.TestEnum and INT64 [at 1:8]
select testenum IN (select 1)
       ^
==

select 1 IN (select uint64 from SimpleTypes)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=UINT64, value=1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[SimpleTypes.uint64#4]
    |         +-input_scan=
    |           +-TableScan(column_list=[SimpleTypes.uint64#4], table=SimpleTypes, column_index_list=[3])
    +-input_scan=
      +-SingleRowScan
==

# UINT64 literal IN subquery with INT64
# TODO: This should probably not be an error since we can compare
# them for equality using a UINT64/INT64 signature.
select 99999999999999999999 IN (select int64 from SimpleTypes)
--
ERROR: Invalid integer literal: 99999999999999999999 [at 1:8]
select 99999999999999999999 IN (select int64 from SimpleTypes)
       ^
==

# Same test with IN list rather than IN subquery.
select 99999999999999999999 IN (int64, int64)
from SimpleTypes
--
ERROR: Invalid integer literal: 99999999999999999999 [at 1:8]
select 99999999999999999999 IN (int64, int64)
       ^
==

select 99999999999999999999 IN (select int32 from SimpleTypes)
--
ERROR: Invalid integer literal: 99999999999999999999 [at 1:8]
select 99999999999999999999 IN (select int32 from SimpleTypes)
       ^
==

select 99999999999999999999 IN (select double from SimpleTypes)
--
ERROR: Invalid integer literal: 99999999999999999999 [at 1:8]
select 99999999999999999999 IN (select double from SimpleTypes)
       ^
==

[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select ARRAY<int32>[1, 2, 3] IN (select array_agg(key) from TestTable)
--
ALTERNATION GROUP: <empty>
--
ERROR: Cannot execute IN subquery with uncomparable types ARRAY<INT32> and ARRAY<INT32> [at 1:8]
select ARRAY<int32>[1, 2, 3] IN (select array_agg(key) from TestTable)
       ^
--
ALTERNATION GROUP: V_1_1_ARRAY_EQUALITY
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=ARRAY<INT32>, value=[1, 2, 3], has_explicit_type=TRUE)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$aggregate.$agg1#4]
    |         +-input_scan=
    |           +-AggregateScan
    |             +-column_list=[$aggregate.$agg1#4]
    |             +-input_scan=
    |             | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
    |             +-aggregate_list=
    |               +-$agg1#4 :=
    |                 +-AggregateFunctionCall(ZetaSQL:array_agg(INT32) -> ARRAY<INT32>)
    |                   +-ColumnRef(type=INT32, column=TestTable.key#1)
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_1_ARRAY_EQUALITY}}]
select ARRAY<int64>[1] IN ([1], [2], [3])
--
ALTERNATION GROUP: <empty>
--
ERROR: IN is not defined for arguments of type ARRAY<INT64> [at 1:24]
select ARRAY<int64>[1] IN ([1], [2], [3])
                       ^
--
ALTERNATION GROUP: V_1_1_ARRAY_EQUALITY
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in(ARRAY<INT64>, repeated(3) ARRAY<INT64>) -> BOOL)
    |     +-Literal(type=ARRAY<INT64>, value=[1], has_explicit_type=TRUE)
    |     +-Literal(type=ARRAY<INT64>, value=[1])
    |     +-Literal(type=ARRAY<INT64>, value=[2])
    |     +-Literal(type=ARRAY<INT64>, value=[3])
    +-input_scan=
      +-SingleRowScan
==

# (select 1, 2) is the parenthesized query of the IN subquery which outputs
# more than one output columns.
select (select AS STRUCT 1, 2) IN ( (select 1, 2) )
--
ERROR: Subquery of type IN must have only one output column [at 1:38]
select (select AS STRUCT 1, 2) IN ( (select 1, 2) )
                                     ^
==

select (select AS STRUCT 1, 2) IN ( (select AS STRUCT 1, 2) )
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-SubqueryExpr
    |     |   +-type=STRUCT<INT64, INT64>
    |     |   +-subquery_type=SCALAR
    |     |   +-subquery=
    |     |     +-ProjectScan
    |     |       +-column_list=[$make_struct.$struct#3]
    |     |       +-expr_list=
    |     |       | +-$struct#3 :=
    |     |       |   +-MakeStruct
    |     |       |     +-type=STRUCT<INT64, INT64>
    |     |       |     +-field_list=
    |     |       |       +-ColumnRef(type=INT64, column=$expr_subquery.$col1#1)
    |     |       |       +-ColumnRef(type=INT64, column=$expr_subquery.$col2#2)
    |     |       +-input_scan=
    |     |         +-ProjectScan
    |     |           +-column_list=$expr_subquery.[$col1#1, $col2#2]
    |     |           +-expr_list=
    |     |           | +-$col1#1 := Literal(type=INT64, value=1)
    |     |           | +-$col2#2 := Literal(type=INT64, value=2)
    |     |           +-input_scan=
    |     |             +-SingleRowScan
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$make_struct.$struct#6]
    |         +-expr_list=
    |         | +-$struct#6 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<INT64, INT64>
    |         |     +-field_list=
    |         |       +-ColumnRef(type=INT64, column=$expr_subquery.$col1#4)
    |         |       +-ColumnRef(type=INT64, column=$expr_subquery.$col2#5)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=$expr_subquery.[$col1#4, $col2#5]
    |             +-expr_list=
    |             | +-$col1#4 := Literal(type=INT64, value=1)
    |             | +-$col2#5 := Literal(type=INT64, value=2)
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

SELECT (1,1) IN ((1,1), (1,2))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in(STRUCT<INT64, INT64>, repeated(2) STRUCT<INT64, INT64>) -> BOOL)
    |     +-Literal(type=STRUCT<INT64, INT64>, value={1, 1})
    |     +-Literal(type=STRUCT<INT64, INT64>, value={1, 1})
    |     +-Literal(type=STRUCT<INT64, INT64>, value={1, 2})
    +-input_scan=
      +-SingleRowScan
==

SELECT (1,1) IN UNNEST([(1,1), (1,2)])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in_array(STRUCT<INT64, INT64>, ARRAY<STRUCT<INT64, INT64>>) -> BOOL)
    |     +-Literal(type=STRUCT<INT64, INT64>, value={1, 1})
    |     +-Literal(type=ARRAY<STRUCT<INT64, INT64>>, value=[{1, 1}, {1, 2}])
    +-input_scan=
      +-SingleRowScan
==

SELECT (1,1) IN (SELECT u FROM UNNEST([(1,1),(1, 2)]) u)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=STRUCT<INT64, INT64>, value={1, 1})
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$array.u#1]
    |         +-input_scan=
    |           +-ArrayScan
    |             +-column_list=[$array.u#1]
    |             +-array_expr=
    |             | +-Literal(type=ARRAY<STRUCT<INT64, INT64>>, value=[{1, 1}, {1, 2}])
    |             +-element_column=$array.u#1
    +-input_scan=
      +-SingleRowScan
==

select struct(cast(1 as int32)) IN (struct(cast(1 as int64))),
       struct(cast(1 as int64)) IN (struct(cast(1 as int32)))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
| +-$query.$col2#2 AS "$col2" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:$in(STRUCT<INT64>, repeated(1) STRUCT<INT64>) -> BOOL)
    | |   +-Literal(type=STRUCT<INT64>, value={1}, has_explicit_type=TRUE)
    | |   +-Literal(type=STRUCT<INT64>, value={1}, has_explicit_type=TRUE)
    | +-$col2#2 :=
    |   +-FunctionCall(ZetaSQL:$in(STRUCT<INT64>, repeated(1) STRUCT<INT64>) -> BOOL)
    |     +-Literal(type=STRUCT<INT64>, value={1}, has_explicit_type=TRUE)
    |     +-Literal(type=STRUCT<INT64>, value={1}, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# NOTE: We are not currently supporting implicit coercion of struct fields
# for IN, although we would support implicit coercion of those scalar types.
select struct(cast(1 as int32)) IN (select struct(cast(1 as int64)))
--
ERROR: Cannot execute IN subquery with uncomparable types STRUCT<INT32> and STRUCT<INT64> [at 1:8]
select struct(cast(1 as int32)) IN (select struct(cast(1 as int64)))
       ^
==

select struct(cast(1 as int64)) IN (select struct(cast(1 as int32)))
--
ERROR: Cannot execute IN subquery with uncomparable types STRUCT<INT64> and STRUCT<INT32> [at 1:8]
select struct(cast(1 as int64)) IN (select struct(cast(1 as int32)))
       ^
==

# Coercion is supported for IN UNNEST, though. Fixed in b/24130693.
# (The element can be coerced, but the array can only be coerced if it is a
# literal or a parameter.)
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select struct(cast(1 as int32)) IN UNNEST([struct(cast(1 as int64))])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in_array(STRUCT<INT64>, ARRAY<STRUCT<INT64>>) -> BOOL)
    |     +-Literal(type=STRUCT<INT64>, value={1}, has_explicit_type=TRUE)
    |     +-Literal(type=ARRAY<STRUCT<INT64>>, value=[{1}], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Another variant from b/24130693 (fixed).
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select cast(1 as uint64) IN UNNEST([1, 2])
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for operator IN UNNEST for argument types: UINT64, ARRAY<INT64> [at 1:26]
select cast(1 as uint64) IN UNNEST([1, 2])
                         ^
--
ALTERNATION GROUP: V_1_1_CAST_DIFFERENT_ARRAY_TYPES
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in_array(UINT64, ARRAY<UINT64>) -> BOOL)
    |     +-Literal(type=UINT64, value=1, has_explicit_type=TRUE)
    |     +-Literal(type=ARRAY<UINT64>, value=[1, 2])
    +-input_scan=
      +-SingleRowScan
==

# Another variant from b/24130693 (fixed).
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select cast(1 as int32) IN UNNEST([2,3])
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for operator IN UNNEST for argument types: INT32, ARRAY<INT64> [at 1:25]
select cast(1 as int32) IN UNNEST([2,3])
                        ^
--
ALTERNATION GROUP: V_1_1_CAST_DIFFERENT_ARRAY_TYPES
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in_array(INT32, ARRAY<INT32>) -> BOOL)
    |     +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
    |     +-Literal(type=ARRAY<INT32>, value=[2, 3])
    +-input_scan=
      +-SingleRowScan
==

# Another variant from b/24130693 (fixed).
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select 123 IN UNNEST(array<int32>[123])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in_array(INT32, ARRAY<INT32>) -> BOOL)
    |     +-Literal(type=INT32, value=123)
    |     +-Literal(type=ARRAY<INT32>, value=[123], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Another variant from b/24130693 (fixed). We decided not to support implicit
# coercion of non-literal arrays.
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select {{1|s.int64}} IN UNNEST([s.int32]) from SimpleTypes s
--
ALTERNATION GROUPS:
    1
    V_1_1_CAST_DIFFERENT_ARRAY_TYPES,1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-FunctionCall(ZetaSQL:$in_array(INT32, ARRAY<INT32>) -> BOOL)
    |     +-Literal(type=INT32, value=1)
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(1) INT32) -> ARRAY<INT32>)
    |       +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    +-input_scan=
      +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0], alias='s')
--
ALTERNATION GROUPS:
    s.int64
    V_1_1_CAST_DIFFERENT_ARRAY_TYPES,s.int64
--
ERROR: No matching signature for operator IN UNNEST for argument types: INT64, ARRAY<INT32> [at 1:16]
select s.int64 IN UNNEST([s.int32]) from SimpleTypes s
               ^
==

# Array literals can only be implicitly coerced if they are not explicitly
# typed. This is a caveat from b/24130693 (fixed).
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select cast(1 as int64) IN UNNEST({{|ARRAY<INT32>}}[1, 2, 3])
--
ALTERNATION GROUPS:
    <empty>
    V_1_1_CAST_DIFFERENT_ARRAY_TYPES,
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in_array(INT64, ARRAY<INT64>) -> BOOL)
    |     +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |     +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUPS:
    ARRAY<INT32>
    V_1_1_CAST_DIFFERENT_ARRAY_TYPES,ARRAY<INT32>
--
ERROR: No matching signature for operator IN UNNEST for argument types: INT64, ARRAY<INT32> [at 1:25]
select cast(1 as int64) IN UNNEST(ARRAY<INT32>[1, 2, 3])
                        ^
==

# Another variant from b/24130693 (fixed).
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select 'TESTENUM0' IN UNNEST([TestEnum]) from EnumTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-FunctionCall(ZetaSQL:$in_array(ENUM<zetasql_test__.TestEnum>, ARRAY<ENUM<zetasql_test__.TestEnum>>) -> BOOL)
    |     +-Literal(type=ENUM<zetasql_test__.TestEnum>, value=TESTENUM0)
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(1) ENUM<zetasql_test__.TestEnum>) -> ARRAY<ENUM<zetasql_test__.TestEnum>>)
    |       +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=EnumTable.TestEnum#2)
    +-input_scan=
      +-TableScan(column_list=[EnumTable.TestEnum#2], table=EnumTable, column_index_list=[1])
==

# Another variant from b/24130693 (fixed).
[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select null in unnest([1, 2, 3])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in_array(INT64, ARRAY<INT64>) -> BOOL)
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select null in unnest(['foo', 'bar', 'baz'])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in_array(STRING, ARRAY<STRING>) -> BOOL)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=ARRAY<STRING>, value=['foo', 'bar', 'baz'])
    +-input_scan=
      +-SingleRowScan
==

# Another variant from b/24130693 (fixed).

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select cast(1 as int32) in unnest(null)
--
ERROR: Second argument of IN UNNEST must be an array but was NULL [at 1:25]
select cast(1 as int32) in unnest(null)
                        ^
==

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select null in unnest(null)
--
ERROR: Second argument of IN UNNEST must be an array but was NULL [at 1:13]
select null in unnest(null)
            ^
==

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select struct(cast(1 as int64)) IN UNNEST([struct(cast(1 as int32))])
--
ERROR: No matching signature for operator IN UNNEST for argument types: STRUCT<INT64>, ARRAY<STRUCT<INT32>> [at 1:33]
select struct(cast(1 as int64)) IN UNNEST([struct(cast(1 as int32))])
                                ^
==

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select struct(cast(1 as zetasql_test__.TestEnum))
    IN UNNEST([struct('TESTENUM1')])
--
ERROR: No matching signature for operator IN UNNEST for argument types: STRUCT<zetasql_test__.TestEnum>, ARRAY<STRUCT<STRING>> [at 2:5]
    IN UNNEST([struct('TESTENUM1')])
    ^
==

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select struct('TESTENUM1')
    IN UNNEST([struct(cast(1 as zetasql_test__.TestEnum))])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in_array(STRUCT<ENUM<zetasql_test__.TestEnum>>, ARRAY<STRUCT<ENUM<zetasql_test__.TestEnum>>>) -> BOOL)
    |     +-Literal(type=STRUCT<ENUM<zetasql_test__.TestEnum>>, value={TESTENUM1})
    |     +-Literal(type=ARRAY<STRUCT<ENUM<zetasql_test__.TestEnum>>>, value=[{TESTENUM1}], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

select struct(1) IN (struct('abc'))
--
ERROR: Could not cast literal {'abc'} to type STRUCT<INT64> [at 1:22]
select struct(1) IN (struct('abc'))
                     ^
==

select struct(1) IN (select struct('abc'))
--
ERROR: Cannot execute IN subquery with uncomparable types STRUCT<INT64> and STRUCT<STRING> [at 1:8]
select struct(1) IN (select struct('abc'))
       ^
==

select 1 IN ( (select 1) UNION ALL (select 2) )
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=INT64, value=1)
    |     +-subquery=
    |       +-SetOperationScan
    |         +-column_list=[$union_all.$col1#3]
    |         +-op_type=UNION_ALL
    |         +-input_item_list=
    |           +-SetOperationItem
    |           | +-scan=
    |           | | +-ProjectScan
    |           | |   +-column_list=[$union_all1.$col1#1]
    |           | |   +-expr_list=
    |           | |   | +-$col1#1 := Literal(type=INT64, value=1)
    |           | |   +-input_scan=
    |           | |     +-SingleRowScan
    |           | +-output_column_list=[$union_all1.$col1#1]
    |           +-SetOperationItem
    |             +-scan=
    |             | +-ProjectScan
    |             |   +-column_list=[$union_all2.$col1#2]
    |             |   +-expr_list=
    |             |   | +-$col1#2 := Literal(type=INT64, value=2)
    |             |   +-input_scan=
    |             |     +-SingleRowScan
    |             +-output_column_list=[$union_all2.$col1#2]
    +-input_scan=
      +-SingleRowScan
==

select 1 IN ( (select 1), (select 2) )
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:$in(INT64, repeated(2) INT64) -> BOOL)
    |     +-Literal(type=INT64, value=1)
    |     +-SubqueryExpr
    |     | +-type=INT64
    |     | +-subquery_type=SCALAR
    |     | +-subquery=
    |     |   +-ProjectScan
    |     |     +-column_list=[$expr_subquery.$col1#1]
    |     |     +-expr_list=
    |     |     | +-$col1#1 := Literal(type=INT64, value=1)
    |     |     +-input_scan=
    |     |       +-SingleRowScan
    |     +-SubqueryExpr
    |       +-type=INT64
    |       +-subquery_type=SCALAR
    |       +-subquery=
    |         +-ProjectScan
    |           +-column_list=[$expr_subquery.$col1#2]
    |           +-expr_list=
    |           | +-$col1#2 := Literal(type=INT64, value=2)
    |           +-input_scan=
    |             +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

select 1
from TestTable T
where T.KitchenSink.int32_val
      IN
      (select * from T.KitchenSink.repeated_int32_val)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias='T')
        +-filter_expr=
          +-SubqueryExpr
            +-type=BOOL
            +-subquery_type=IN
            +-parameter_list=
            | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            +-in_expr=
            | +-GetProtoField
            |   +-type=INT32
            |   +-expr=
            |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            |   +-field_descriptor=int32_val
            |   +-default_value=77
            +-subquery=
              +-ProjectScan
                +-column_list=[$array.repeated_int32_val#4]
                +-input_scan=
                  +-ArrayScan
                    +-column_list=[$array.repeated_int32_val#4]
                    +-array_expr=
                    | +-GetProtoField
                    |   +-type=ARRAY<INT32>
                    |   +-expr=
                    |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
                    |   +-field_descriptor=repeated_int32_val
                    |   +-default_value=[]
                    +-element_column=$array.repeated_int32_val#4
==

select true from TestTable where 1 IN ((1)&(2), (1) + (2), 1 < 2)
--
ERROR: No matching signature for operator IN for argument types literal INT64 and {INT64, BOOL} [at 1:36]
select true from TestTable where 1 IN ((1)&(2), (1) + (2), 1 < 2)
                                   ^
==

select true from TestTable where 1 IN (1&2, 1 + 2)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=BOOL, value=true)
    +-input_scan=
      +-FilterScan
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$in(INT64, repeated(2) INT64) -> BOOL)
            +-Literal(type=INT64, value=1)
            +-FunctionCall(ZetaSQL:$bitwise_and(INT64, INT64) -> INT64)
            | +-Literal(type=INT64, value=1)
            | +-Literal(type=INT64, value=2)
            +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
              +-Literal(type=INT64, value=1)
              +-Literal(type=INT64, value=2)
==

select true from TestTable where true IN ((1) < (2), @test_param_bool IS TRUE)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=BOOL, value=true)
    +-input_scan=
      +-FilterScan
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$in(BOOL, repeated(2) BOOL) -> BOOL)
            +-Literal(type=BOOL, value=true)
            +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            | +-Literal(type=INT64, value=1)
            | +-Literal(type=INT64, value=2)
            +-FunctionCall(ZetaSQL:$is_true(BOOL) -> BOOL)
              +-Parameter(type=BOOL, name='test_param_bool')
==

select 1 IN ([1])
--
ERROR: No matching signature for operator IN for argument types literal INT64 and {ARRAY<INT64>} [at 1:10]
select 1 IN ([1])
         ^
==

select cast(1 as int32) IN (@test_param_array)
--
ERROR: No matching signature for operator IN for argument types INT32 and {ARRAY<INT32>} [at 1:25]
select cast(1 as int32) IN (@test_param_array)
                        ^
==

select cast(1 as int32) IN @test_param_array
--
ERROR: Syntax error: Expected "(" or keyword UNNEST but got "@" [at 1:28]
select cast(1 as int32) IN @test_param_array
                           ^
==

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select cast(1 as int32) IN UNNEST(@test_param_array)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in_array(INT32, ARRAY<INT32>) -> BOOL)
    |     +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
    |     +-Parameter(type=ARRAY<INT32>, name='test_param_array')
    +-input_scan=
      +-SingleRowScan
==

select 1 IN UNNEST([1])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in_array(INT64, ARRAY<INT64>) -> BOOL)
    |     +-Literal(type=INT64, value=1)
    |     +-Literal(type=ARRAY<INT64>, value=[1])
    +-input_scan=
      +-SingleRowScan
==

select 1 IN UNNEST([1*1, 1+1, 1*1+1])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$in_array(INT64, ARRAY<INT64>) -> BOOL)
    |     +-Literal(type=INT64, value=1)
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(3) INT64) -> ARRAY<INT64>)
    |       +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |       | +-Literal(type=INT64, value=1)
    |       | +-Literal(type=INT64, value=1)
    |       +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |       | +-Literal(type=INT64, value=1)
    |       | +-Literal(type=INT64, value=1)
    |       +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |         +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |         | +-Literal(type=INT64, value=1)
    |         | +-Literal(type=INT64, value=1)
    |         +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select KitchenSink IN UNNEST(ARRAY<"zetasql_test__.KitchenSinkPB">[])
from TestTable
--
ERROR: First argument to IN UNNEST of type PROTO<zetasql_test__.KitchenSinkPB> does not support equality comparison [at 1:20]
select KitchenSink IN UNNEST(ARRAY<"zetasql_test__.KitchenSinkPB">[])
                   ^
==

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select KitchenSink.int32_val IN UNNEST(ARRAY<"zetasql_test__.KitchenSinkPB">[])
from TestTable
--
ERROR: Second argument to IN UNNEST of type ARRAY<PROTO<zetasql_test__.KitchenSinkPB>> is not supported because array element type is not equality comparable [at 1:30]
select KitchenSink.int32_val IN UNNEST(ARRAY<"zetasql_test__.KitchenSinkPB">[])
                             ^
==

select 1 from SimpleTypes where "int32" IN UNNEST( (select "int32") )
--
ERROR: Second argument of IN UNNEST must be an array but was INT32 [at 1:41]
select 1 from SimpleTypes where "int32" IN UNNEST( (select "int32") )
                                        ^
==

select 1 IN UNNEST(1)
--
ERROR: Second argument of IN UNNEST must be an array but was INT64 [at 1:10]
select 1 IN UNNEST(1)
         ^
==

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select 1
from TestTable T
where T.KitchenSink.string_val IN UNNEST(T.KitchenSink.repeated_string_val)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias='T')
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$in_array(STRING, ARRAY<STRING>) -> BOOL)
            +-GetProtoField
            | +-type=STRING
            | +-expr=
            | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | +-field_descriptor=string_val
            | +-default_value='default_name'
            +-GetProtoField
              +-type=ARRAY<STRING>
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              +-field_descriptor=repeated_string_val
              +-default_value=[]
==

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select key
from KeyValue
where key IN UNNEST( (select ARRAY_AGG(key) from KeyValue) )
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1]
    +-input_scan=
      +-FilterScan
        +-column_list=[KeyValue.Key#1]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$in_array(INT64, ARRAY<INT64>) -> BOOL)
            +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-SubqueryExpr
              +-type=ARRAY<INT64>
              +-subquery_type=SCALAR
              +-subquery=
                +-ProjectScan
                  +-column_list=[$aggregate.$agg1#5]
                  +-input_scan=
                    +-AggregateScan
                      +-column_list=[$aggregate.$agg1#5]
                      +-input_scan=
                      | +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0])
                      +-aggregate_list=
                        +-$agg1#5 :=
                          +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                            +-ColumnRef(type=INT64, column=KeyValue.Key#3)
==

[language_features={{|V_1_1_CAST_DIFFERENT_ARRAY_TYPES}}]
select 1
from TestTable T
where T.KitchenSink.date IN UNNEST(ARRAY(select T.KitchenSink.date))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 := Literal(type=INT64, value=1)
    +-input_scan=
      +-FilterScan
        +-column_list=[TestTable.KitchenSink#3]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2], alias='T')
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$in_array(DATE, ARRAY<DATE>) -> BOOL)
            +-GetProtoField
            | +-type=DATE
            | +-expr=
            | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
            | +-field_descriptor=date
            | +-default_value=1970-01-01
            | +-format=DATE
            +-SubqueryExpr
              +-type=ARRAY<DATE>
              +-subquery_type=ARRAY
              +-parameter_list=
              | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              +-subquery=
                +-ProjectScan
                  +-column_list=[$expr_subquery.date#4]
                  +-expr_list=
                  | +-date#4 :=
                  |   +-GetProtoField
                  |     +-type=DATE
                  |     +-expr=
                  |     | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3, is_correlated=TRUE)
                  |     +-field_descriptor=date
                  |     +-default_value=1970-01-01
                  |     +-format=DATE
                  +-input_scan=
                    +-SingleRowScan
==

select 5 in (select key from KeyValue)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=INT64, value=5)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[KeyValue.Key#1]
    |         +-input_scan=
    |           +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-input_scan=
      +-SingleRowScan
==

# IN subquery with a correlated column and another table scan.
select "double"
from SimpleTypes T
where (select "int64") IN (select "int32" + key from KeyValue)
--
QueryStmt
+-output_column_list=
| +-SimpleTypes.double#9 AS double [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[SimpleTypes.double#9]
    +-input_scan=
      +-FilterScan
        +-column_list=SimpleTypes.[int32#1, int64#2, double#9]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, double#9], table=SimpleTypes, column_index_list=[0, 1, 8], alias='T')
        +-filter_expr=
          +-SubqueryExpr
            +-type=BOOL
            +-subquery_type=IN
            +-parameter_list=
            | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            +-in_expr=
            | +-SubqueryExpr
            |   +-type=INT64
            |   +-subquery_type=SCALAR
            |   +-parameter_list=
            |   | +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            |   +-subquery=
            |     +-ProjectScan
            |       +-column_list=[$expr_subquery.int64#19]
            |       +-expr_list=
            |       | +-int64#19 := ColumnRef(type=INT64, column=SimpleTypes.int64#2, is_correlated=TRUE)
            |       +-input_scan=
            |         +-SingleRowScan
            +-subquery=
              +-ProjectScan
                +-column_list=[$expr_subquery.$col1#22]
                +-expr_list=
                | +-$col1#22 :=
                |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                |     +-Cast(INT32 -> INT64)
                |     | +-ColumnRef(type=INT32, column=SimpleTypes.int32#1, is_correlated=TRUE)
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#20)
                +-input_scan=
                  +-TableScan(column_list=[KeyValue.Key#20], table=KeyValue, column_index_list=[0])
==

# Multiple columns in UNNEST is not allowed.
SELECT 1 IN UNNEST([1], [2])
--
ERROR: UNNEST expression used with IN operator does not allow multiple arguments [at 1:25]
SELECT 1 IN UNNEST([1], [2])
                        ^
==

# Column with alias in UNNEST is not allowed.
SELECT 1 IN UNNEST([1] AS array_alias)
--
ERROR: UNNEST expression used with IN operator does not allow argument aliases inside UNNEST [at 1:24]
SELECT 1 IN UNNEST([1] AS array_alias)
                       ^
==

# Multiple columns with and without aliases are not allowed.
SELECT 1 IN UNNEST([1] AS array_alias, [2])
--
ERROR: UNNEST expression used with IN operator does not allow multiple arguments [at 1:40]
SELECT 1 IN UNNEST([1] AS array_alias, [2])
                                       ^
==

# Array zip mode is not allowed.
SELECT 1 IN UNNEST([1], mode => 'STRICT')
--
ERROR: UNNEST expression used with IN operator does not allow named arguments [at 1:25]
SELECT 1 IN UNNEST([1], mode => 'STRICT')
                        ^
