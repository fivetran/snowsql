
[default language_features=CREATE_TABLE_AS_SELECT_COLUMN_LIST,V_1_1_ORDER_BY_IN_AGGREGATE,V_1_1_ORDER_BY_COLLATE,ANALYTIC_FUNCTIONS,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_2_GROUP_BY_ARRAY,V_1_2_GROUP_BY_STRUCT,CREATE_TABLE_FIELD_ANNOTATIONS,PARAMETERIZED_TYPES,NUMERIC_TYPE,NAMED_ARGUMENTS,V_1_3_INLINE_LAMBDA_ARGUMENT,V_1_3_ARRAY_ORDERING,TABLE_VALUED_FUNCTIONS,CREATE_TABLE_FUNCTION,V_1_4_COLLATION_IN_EXPLICIT_CAST,V_1_4_PRESERVE_ANNOTATION_IN_IMPLICIT_CAST_IN_SCAN,V_1_4_GROUPING_SETS,GROUP_BY_ROLLUP,V_1_4_GROUPING_BUILTIN]
# Cast string with collation to string type.
select cast(string_ci AS STRING),
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-Cast(STRING -> STRING)
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
==

# Cast struct with collation (in subfield) to struct type without collation.
select cast(struct_with_string_ci AS STRUCT<a INT32, b STRING>) from CollatedTable;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [STRUCT<a INT32, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-Cast(STRUCT<a INT32, b STRING> -> STRUCT<a INT32, b STRING>)
    |     +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>], table=CollatedTable, column_index_list=[2])
==

# Cast MakeStruct with collation (in subfield) to struct type without collation.
select cast((string_ci, string_cs) AS STRUCT<STRING, x STRING>) from CollatedTable;
--
ERROR: Unrecognized name: string_cs; Did you mean string_ci? [at 1:25]
select cast((string_ci, string_cs) AS STRUCT<STRING, x STRING>) from Collated...
                        ^
==

# Cast array with collation to array type without collation.
select cast(array_with_string_ci as ARRAY<STRING>) from CollatedTable;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-Cast(ARRAY<STRING> -> ARRAY<STRING>)
    |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}]], table=CollatedTable, column_index_list=[3])
==

# Literal replacement test places query parameters which is not allowed to be
# the second argument of collate().
select
  collate('abc', 'und:ci'),
  collate(collate('abc', 'und:ci'), ''),
  collate(string_binary, 'und:ci'),
  collate(string_binary, ''),
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5{Collation:"und:ci"} AS "$col1" [STRING]
| +-$query.$col2#6 AS "$col2" [STRING]
| +-$query.$col3#7{Collation:"und:ci"} AS "$col3" [STRING]
| +-$query.$col4#8 AS "$col4" [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-Literal(type=STRING, value='abc')
    | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | +-$col2#6 :=
    | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |   | +-type_annotation_map={Collation:"und:ci"}
    | |   | +-Literal(type=STRING, value='abc')
    | |   | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |   +-Literal(type=STRING, value='', preserve_in_literal_remover=TRUE)
    | +-$col3#7 :=
    | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | +-$col4#8 :=
    |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    |     +-Literal(type=STRING, value='', preserve_in_literal_remover=TRUE)
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.string_binary#2{Collation:"binary"}], table=CollatedTable, column_index_list=[1])
==

# Regression test for b/241009864, invoke collate() with only 1 argument.
select collate('abc');
--
ERROR: Number of arguments does not match for function COLLATE. Supported signature: COLLATE(STRING, STRING) [at 1:8]
select collate('abc');
       ^
==

[language_features=]
# COLLATE function is not found when the language feature is turned off.
select collate('abc', 'und:ci');
--
ERROR: Function not found: "collate"; Did you mean concat? [at 2:8]
select collate('abc', 'und:ci');
       ^
==

select collate('abc', upper('und:ci'));
--
ERROR: The second argument of COLLATE() must be a string literal [at 1:8]
select collate('abc', upper('und:ci'));
       ^
==

select collate('abc', CAST(NULL AS STRING));
--
ERROR: The second argument of COLLATE() must be a string literal [at 1:8]
select collate('abc', CAST(NULL AS STRING));
       ^
==

select collate('abc', @test_param_string);
--
ERROR: The second argument of COLLATE() must be a string literal [at 1:8]
select collate('abc', @test_param_string);
       ^
==

select string_ci, string_binary from CollatedTable
--
QueryStmt
+-output_column_list=
| +-CollatedTable.string_ci#1{Collation:"und:ci"} AS string_ci [STRING]
| +-CollatedTable.string_binary#2{Collation:"binary"} AS string_binary [STRING]
+-query=
  +-ProjectScan
    +-column_list=CollatedTable.[string_ci#1, string_binary#2]
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
==

# Collation on first argument is rejected.
select fn_reject_collation(string_ci, 'abc')
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 1:8]
select fn_reject_collation(string_ci, 'abc')
       ^
==

# Collation on the named argument is rejected.
select fn_reject_collation('abc', second_arg => array_with_string_ci)
from CollatedTable
--
ERROR: Collation is not allowed on argument second_arg (["und:ci"]) [at 1:8]
select fn_reject_collation('abc', second_arg => array_with_string_ci)
       ^
==

# Collation on the named argument is rejected.
select fn_reject_collation('abc', second_arg => struct_with_string_ci)
from CollatedTable
--
ERROR: Collation is not allowed on argument second_arg (<_,"und:ci">) [at 1:8]
select fn_reject_collation('abc', second_arg => struct_with_string_ci)
       ^
==

with test as (select * from CollatedTable)
select string_ci || 'abc', string_binary
from test
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9{Collation:"und:ci"} AS "$col1" [STRING]
| +-test.string_binary#6{Collation:"binary"} AS string_binary [STRING]
+-query=
  +-WithScan
    +-column_list=[$query.$col1#9{Collation:"und:ci"}, test.string_binary#6{Collation:"binary"}]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='test'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4]
    |       +-input_scan=
    |         +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 2, 3])
    +-query=
      +-ProjectScan
        +-column_list=[$query.$col1#9{Collation:"und:ci"}, test.string_binary#6{Collation:"binary"}]
        +-expr_list=
        | +-$col1#9 :=
        |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
        |     +-type_annotation_map={Collation:"und:ci"}
        |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=test.string_ci#5{Collation:"und:ci"})
        |     +-Literal(type=STRING, value='abc')
        +-input_scan=
          +-WithRefScan(column_list=test.[string_ci#5, string_binary#6, struct_with_string_ci#7, array_with_string_ci#8], with_query_name='test')
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
with recursive
  t as (select 1 as ind, COLLATE('a', 'und:ci') as string_ci union {{all|distinct}}
  (select ind + 1 as ind, string_ci from t where ind < 3))
select ind, string_ci from t
--
ALTERNATION GROUP: all
--
QueryStmt
+-output_column_list=
| +-t.ind#8 AS ind [INT64]
| +-t.string_ci#9{Collation:"und:ci"} AS string_ci [STRING]
+-query=
  +-WithScan
    +-column_list=t.[ind#8, string_ci#9]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=$union_all.[ind#3, string_ci#4]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=$union_all1.[ind#1, string_ci#2]
    |       |   |   +-expr_list=
    |       |   |   | +-ind#1 := Literal(type=INT64, value=1)
    |       |   |   | +-string_ci#2 :=
    |       |   |   |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |   |   |     +-type_annotation_map={Collation:"und:ci"}
    |       |   |   |     +-Literal(type=STRING, value='a')
    |       |   |   |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=$union_all1.[ind#1, string_ci#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.ind#7, t.string_ci#6{Collation:"und:ci"}]
    |           |   +-expr_list=
    |           |   | +-ind#7 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=t.ind#5)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=t.[ind#5, string_ci#6]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=t.[ind#5, string_ci#6])
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t.ind#5)
    |           |           +-Literal(type=INT64, value=3)
    |           +-output_column_list=[$union_all2.ind#7, t.string_ci#6{Collation:"und:ci"}]
    +-query=
    | +-ProjectScan
    |   +-column_list=t.[ind#8, string_ci#9]
    |   +-input_scan=
    |     +-WithRefScan(column_list=t.[ind#8, string_ci#9], with_query_name='t')
    +-recursive=TRUE
--
ALTERNATION GROUP: distinct
--
QueryStmt
+-output_column_list=
| +-t.ind#8 AS ind [INT64]
| +-t.string_ci#9{Collation:"und:ci"} AS string_ci [STRING]
+-query=
  +-WithScan
    +-column_list=t.[ind#8, string_ci#9]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=$union_distinct.[ind#3, string_ci#4]
    |       +-op_type=UNION_DISTINCT
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=$union_distinct1.[ind#1, string_ci#2]
    |       |   |   +-expr_list=
    |       |   |   | +-ind#1 := Literal(type=INT64, value=1)
    |       |   |   | +-string_ci#2 :=
    |       |   |   |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |   |   |     +-type_annotation_map={Collation:"und:ci"}
    |       |   |   |     +-Literal(type=STRING, value='a')
    |       |   |   |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=$union_distinct1.[ind#1, string_ci#2]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_distinct2.ind#7, t.string_ci#6{Collation:"und:ci"}]
    |           |   +-expr_list=
    |           |   | +-ind#7 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=t.ind#5)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=t.[ind#5, string_ci#6]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=t.[ind#5, string_ci#6])
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t.ind#5)
    |           |           +-Literal(type=INT64, value=3)
    |           +-output_column_list=[$union_distinct2.ind#7, t.string_ci#6{Collation:"und:ci"}]
    +-query=
    | +-ProjectScan
    |   +-column_list=t.[ind#8, string_ci#9]
    |   +-input_scan=
    |     +-WithRefScan(column_list=t.[ind#8, string_ci#9], with_query_name='t')
    +-recursive=TRUE
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE]
with recursive
  t as (select 1 as ind, COLLATE('a', 'und:ci') as string_ci union {{all|distinct}}
  (select ind + 1 as ind, string_ci from t where ind < 3))
select ind, string_ci from t
--
ALTERNATION GROUP: all
--
ERROR: Collation is not supported in recursive queries [at 2:9]
  t as (select 1 as ind, COLLATE('a', 'und:ci') as string_ci union all
        ^
--
ALTERNATION GROUP: distinct
--
ERROR: Collation is not supported in recursive queries [at 2:9]
  t as (select 1 as ind, COLLATE('a', 'und:ci') as string_ci union distinct
        ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
with recursive
  t as (select 1 as ind, string_ci from CollatedTable union {{all|distinct}}
  (select ind + 1 as ind, concat(string_ci, 'foo') from t where ind < 3))
select ind, string_ci from t
--
ALTERNATION GROUP: all
--
QueryStmt
+-output_column_list=
| +-t.ind#12 AS ind [INT64]
| +-t.string_ci#13{Collation:"und:ci"} AS string_ci [STRING]
+-query=
  +-WithScan
    +-column_list=t.[ind#12, string_ci#13]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=$union_all.[ind#6, string_ci#7]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.ind#5, CollatedTable.string_ci#1{Collation:"und:ci"}]
    |       |   |   +-expr_list=
    |       |   |   | +-ind#5 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
    |       |   +-output_column_list=[$union_all1.ind#5, CollatedTable.string_ci#1{Collation:"und:ci"}]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=$union_all2.[ind#10, $col2#11]
    |           |   +-expr_list=
    |           |   | +-ind#10 :=
    |           |   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   | |   +-ColumnRef(type=INT64, column=t.ind#8)
    |           |   | |   +-Literal(type=INT64, value=1)
    |           |   | +-$col2#11 :=
    |           |   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |           |   |     +-type_annotation_map={Collation:"und:ci"}
    |           |   |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t.string_ci#9{Collation:"und:ci"})
    |           |   |     +-Literal(type=STRING, value='foo')
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=t.[ind#8, string_ci#9]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=t.[ind#8, string_ci#9])
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t.ind#8)
    |           |           +-Literal(type=INT64, value=3)
    |           +-output_column_list=$union_all2.[ind#10, $col2#11]
    +-query=
    | +-ProjectScan
    |   +-column_list=t.[ind#12, string_ci#13]
    |   +-input_scan=
    |     +-WithRefScan(column_list=t.[ind#12, string_ci#13], with_query_name='t')
    +-recursive=TRUE
--
ALTERNATION GROUP: distinct
--
QueryStmt
+-output_column_list=
| +-t.ind#12 AS ind [INT64]
| +-t.string_ci#13{Collation:"und:ci"} AS string_ci [STRING]
+-query=
  +-WithScan
    +-column_list=t.[ind#12, string_ci#13]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=$union_distinct.[ind#6, string_ci#7]
    |       +-op_type=UNION_DISTINCT
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_distinct1.ind#5, CollatedTable.string_ci#1{Collation:"und:ci"}]
    |       |   |   +-expr_list=
    |       |   |   | +-ind#5 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
    |       |   +-output_column_list=[$union_distinct1.ind#5, CollatedTable.string_ci#1{Collation:"und:ci"}]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=$union_distinct2.[ind#10, $col2#11]
    |           |   +-expr_list=
    |           |   | +-ind#10 :=
    |           |   | | +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   | |   +-ColumnRef(type=INT64, column=t.ind#8)
    |           |   | |   +-Literal(type=INT64, value=1)
    |           |   | +-$col2#11 :=
    |           |   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |           |   |     +-type_annotation_map={Collation:"und:ci"}
    |           |   |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t.string_ci#9{Collation:"und:ci"})
    |           |   |     +-Literal(type=STRING, value='foo')
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=t.[ind#8, string_ci#9]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=t.[ind#8, string_ci#9])
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t.ind#8)
    |           |           +-Literal(type=INT64, value=3)
    |           +-output_column_list=$union_distinct2.[ind#10, $col2#11]
    +-query=
    | +-ProjectScan
    |   +-column_list=t.[ind#12, string_ci#13]
    |   +-input_scan=
    |     +-WithRefScan(column_list=t.[ind#12, string_ci#13], with_query_name='t')
    +-recursive=TRUE

==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE]
with recursive
  t as (select 1 as ind, 'a' as string_ci union {{all|distinct}}
  (select ind + 1 as ind, COLLATE('a', 'und:ci') as string_ci from t where ind < 3))
select ind, string_ci from t
--
ALTERNATION GROUP: all
--
ERROR: Collation is not supported in recursive queries [at 2:9]
  t as (select 1 as ind, 'a' as string_ci union all
        ^
--
ALTERNATION GROUP: distinct
--
ERROR: Collation is not supported in recursive queries [at 2:9]
  t as (select 1 as ind, 'a' as string_ci union distinct
        ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
with recursive
  t as (select 1 as ind, 'a' as string_ci union {{all|distinct}}
  (select ind + 1 as ind, COLLATE('a', 'und:ci') as string_ci from t where ind < 3))
select ind, string_ci from t

--
ERROR: Collation conflict: "null" vs. "{Collation:"und:ci"}"; in column 2 of recursive scan [at 3:4]
  (select ind + 1 as ind, COLLATE('a', 'und:ci') as string_ci from t where in...
   ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
with recursive
  t as (select 1 as ind, COLLATE('a', 'binary') as string_binary union {{all|distinct}}
  (select ind + 1 as ind, COLLATE('a', '') as string_ci from t where ind < 3))
select ind, string_ci from t

--
ERROR: Collation conflict: "{Collation:"binary"}" vs. "null"; in column 2 of recursive scan [at 3:4]
  (select ind + 1 as ind, COLLATE('a', '') as string_ci from t where ind < 3))
   ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
WITH RECURSIVE t AS (
  SELECT '1' AS n UNION ALL SELECT collate('2', 'und:ci') AS n UNION ALL SELECT '3' AS n
  UNION ALL SELECT concat(n, '1') FROM t)
  SELECT * FROM t
--
QueryStmt
+-output_column_list=
| +-t.n#8{Collation:"und:ci"} AS n [STRING]
+-query=
  +-WithScan
    +-column_list=[t.n#8{Collation:"und:ci"}]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#4{Collation:"und:ci"}]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-SetOperationScan
    |       |   |   +-column_list=[$union_all.n#5{Collation:"und:ci"}]
    |       |   |   +-op_type=UNION_ALL
    |       |   |   +-input_item_list=
    |       |   |     +-SetOperationItem
    |       |   |     | +-scan=
    |       |   |     | | +-ProjectScan
    |       |   |     | |   +-column_list=[$union_all1.n#1]
    |       |   |     | |   +-expr_list=
    |       |   |     | |   | +-n#1 := Literal(type=STRING, value='1')
    |       |   |     | |   +-input_scan=
    |       |   |     | |     +-SingleRowScan
    |       |   |     | +-output_column_list=[$union_all1.n#1]
    |       |   |     +-SetOperationItem
    |       |   |     | +-scan=
    |       |   |     | | +-ProjectScan
    |       |   |     | |   +-column_list=[$union_all2.n#2{Collation:"und:ci"}]
    |       |   |     | |   +-expr_list=
    |       |   |     | |   | +-n#2 :=
    |       |   |     | |   |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |   |     | |   |     +-type_annotation_map={Collation:"und:ci"}
    |       |   |     | |   |     +-Literal(type=STRING, value='2')
    |       |   |     | |   |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       |   |     | |   +-input_scan=
    |       |   |     | |     +-SingleRowScan
    |       |   |     | +-output_column_list=[$union_all2.n#2{Collation:"und:ci"}]
    |       |   |     +-SetOperationItem
    |       |   |       +-scan=
    |       |   |       | +-ProjectScan
    |       |   |       |   +-column_list=[$union_all3.n#3]
    |       |   |       |   +-expr_list=
    |       |   |       |   | +-n#3 := Literal(type=STRING, value='3')
    |       |   |       |   +-input_scan=
    |       |   |       |     +-SingleRowScan
    |       |   |       +-output_column_list=[$union_all3.n#3]
    |       |   +-output_column_list=[$union_all.n#5{Collation:"und:ci"}]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all4.$col1#7{Collation:"und:ci"}]
    |           |   +-expr_list=
    |           |   | +-$col1#7 :=
    |           |   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |           |   |     +-type_annotation_map={Collation:"und:ci"}
    |           |   |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t.n#6{Collation:"und:ci"})
    |           |   |     +-Literal(type=STRING, value='1')
    |           |   +-input_scan=
    |           |     +-RecursiveRefScan(column_list=[t.n#6{Collation:"und:ci"}])
    |           +-output_column_list=[$union_all4.$col1#7{Collation:"und:ci"}]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t.n#8{Collation:"und:ci"}]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t.n#8{Collation:"und:ci"}], with_query_name='t')
    +-recursive=TRUE
==


[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
WITH RECURSIVE t AS (
  SELECT '1' AS n UNION ALL SELECT collate('2', 'und:ci') AS n UNION ALL SELECT '3' AS n
  UNION ALL SELECT collate(n, '') FROM t)
  SELECT * FROM t
--
ERROR: Collation conflict: "{Collation:"und:ci"}" vs. "null"; in column 1 of recursive scan [at 3:13]
  UNION ALL SELECT collate(n, '') FROM t)
            ^

==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (SELECT * FROM t3 CROSS JOIN t4),
  t3 AS (SELECT * FROM UNNEST(['a','A', collate('a', 'und:ci')])),
  t4 AS (SELECT * FROM UNNEST(['a','A', collate('a', 'und:ci')]))
SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.$unnest2#7{Collation:"und:ci"} AS "$unnest2" [STRING]
| +-t1.$unnest1#8{Collation:"und:ci"} AS "$unnest1" [STRING]
+-query=
  +-WithScan
    +-column_list=t1.[$unnest2#7, $unnest1#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t4'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.$unnest1#1{Collation:"und:ci"}]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.$unnest1#1{Collation:"und:ci"}]
    | |         +-array_expr=
    | |         | +-FunctionCall(ZetaSQL:$make_array(repeated(3) STRING) -> ARRAY<STRING>)
    | |         |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |         |   +-Literal(type=STRING, value='a')
    | |         |   +-Literal(type=STRING, value='A')
    | |         |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |         |     +-type_annotation_map={Collation:"und:ci"}
    | |         |     +-Literal(type=STRING, value='a')
    | |         |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |         +-element_column=$array.$unnest1#1{Collation:"und:ci"}
    | +-WithEntry
    | | +-with_query_name='t3'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.$unnest2#2{Collation:"und:ci"}]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.$unnest2#2{Collation:"und:ci"}]
    | |         +-array_expr=
    | |         | +-FunctionCall(ZetaSQL:$make_array(repeated(3) STRING) -> ARRAY<STRING>)
    | |         |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |         |   +-Literal(type=STRING, value='a')
    | |         |   +-Literal(type=STRING, value='A')
    | |         |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |         |     +-type_annotation_map={Collation:"und:ci"}
    | |         |     +-Literal(type=STRING, value='a')
    | |         |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |         +-element_column=$array.$unnest2#2{Collation:"und:ci"}
    | +-WithEntry
    | | +-with_query_name='t2'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[t3.$unnest2#3{Collation:"und:ci"}, t4.$unnest1#4{Collation:"und:ci"}]
    | |     +-input_scan=
    | |       +-JoinScan
    | |         +-column_list=[t3.$unnest2#3{Collation:"und:ci"}, t4.$unnest1#4{Collation:"und:ci"}]
    | |         +-left_scan=
    | |         | +-WithRefScan(column_list=[t3.$unnest2#3{Collation:"und:ci"}], with_query_name='t3')
    | |         +-right_scan=
    | |           +-WithRefScan(column_list=[t4.$unnest1#4{Collation:"und:ci"}], with_query_name='t4')
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t2.[$unnest2#5, $unnest1#6]
    |       +-input_scan=
    |         +-WithRefScan(column_list=t2.[$unnest2#5, $unnest1#6], with_query_name='t2')
    +-query=
    | +-ProjectScan
    |   +-column_list=t1.[$unnest2#7, $unnest1#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=t1.[$unnest2#7, $unnest1#8], with_query_name='t1')
    +-recursive=TRUE
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
WITH RECURSIVE
  t1 AS (SELECT collate('a', 'und:ci') AS n UNION ALL SELECT concat(n, 'a') FROM t1 WHERE n < 'c')
SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.n#5{Collation:"und:ci"} AS n [STRING]
+-query=
  +-WithScan
    +-column_list=[t1.n#5{Collation:"und:ci"}]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2{Collation:"und:ci"}]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1{Collation:"und:ci"}]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 :=
    |       |   |   |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |   |   |     +-type_annotation_map={Collation:"und:ci"}
    |       |   |   |     +-Literal(type=STRING, value='a')
    |       |   |   |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1{Collation:"und:ci"}]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all2.$col1#4{Collation:"und:ci"}]
    |           |   +-expr_list=
    |           |   | +-$col1#4 :=
    |           |   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |           |   |     +-type_annotation_map={Collation:"und:ci"}
    |           |   |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t1.n#3{Collation:"und:ci"})
    |           |   |     +-Literal(type=STRING, value='a')
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=[t1.n#3{Collation:"und:ci"}]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=[t1.n#3{Collation:"und:ci"}])
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(STRING, STRING) -> BOOL)
    |           |           +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t1.n#3{Collation:"und:ci"})
    |           |           +-Literal(type=STRING, value='c')
    |           |           +-collation_list=[und:ci]
    |           +-output_column_list=[$union_all2.$col1#4{Collation:"und:ci"}]
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.n#5{Collation:"und:ci"}]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.n#5{Collation:"und:ci"}], with_query_name='t1')
    +-recursive=TRUE
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
WITH RECURSIVE
  t1 AS (SELECT * FROM KeyValue),
  KeyValue AS (SELECT * FROM UNNEST(['a', collate('A', 'und:ci')]))
SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.$unnest1#3{Collation:"und:ci"} AS "$unnest1" [STRING]
+-query=
  +-WithScan
    +-column_list=[t1.$unnest1#3{Collation:"und:ci"}]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='KeyValue'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.$unnest1#1{Collation:"und:ci"}]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.$unnest1#1{Collation:"und:ci"}]
    | |         +-array_expr=
    | |         | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    | |         |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |         |   +-Literal(type=STRING, value='a')
    | |         |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |         |     +-type_annotation_map={Collation:"und:ci"}
    | |         |     +-Literal(type=STRING, value='A')
    | |         |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |         +-element_column=$array.$unnest1#1{Collation:"und:ci"}
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[KeyValue.$unnest1#2{Collation:"und:ci"}]
    |       +-input_scan=
    |         +-WithRefScan(column_list=[KeyValue.$unnest1#2{Collation:"und:ci"}], with_query_name='KeyValue')
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.$unnest1#3{Collation:"und:ci"}]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.$unnest1#3{Collation:"und:ci"}], with_query_name='t1')
    +-recursive=TRUE
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
WITH RECURSIVE
  t1 AS (SELECT collate(key, '') FROM KeyValue),
  KeyValue AS (SELECT key FROM UNNEST(['a', collate('A', 'und:ci')]) as key)
SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.$col1#4 AS "$col1" [STRING]
+-query=
  +-WithScan
    +-column_list=[t1.$col1#4]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='KeyValue'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.key#1{Collation:"und:ci"}]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.key#1{Collation:"und:ci"}]
    | |         +-array_expr=
    | |         | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    | |         |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |         |   +-Literal(type=STRING, value='a')
    | |         |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |         |     +-type_annotation_map={Collation:"und:ci"}
    | |         |     +-Literal(type=STRING, value='A')
    | |         |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |         +-element_column=$array.key#1{Collation:"und:ci"}
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t1.$col1#3]
    |       +-expr_list=
    |       | +-$col1#3 :=
    |       |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=KeyValue.key#2{Collation:"und:ci"})
    |       |     +-Literal(type=STRING, value='', preserve_in_literal_remover=TRUE)
    |       +-input_scan=
    |         +-WithRefScan(column_list=[KeyValue.key#2{Collation:"und:ci"}], with_query_name='KeyValue')
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.$col1#4]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.$col1#4], with_query_name='t1')
    +-recursive=TRUE
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
WITH RECURSIVE
  KeyValue AS (SELECT * FROM UNNEST(['a', collate('A', 'und:ci')])),
  t1 AS (SELECT * FROM KeyValue)
SELECT * FROM t1;
--
QueryStmt
+-output_column_list=
| +-t1.$unnest1#3{Collation:"und:ci"} AS "$unnest1" [STRING]
+-query=
  +-WithScan
    +-column_list=[t1.$unnest1#3{Collation:"und:ci"}]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='KeyValue'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$array.$unnest1#1{Collation:"und:ci"}]
    | |     +-input_scan=
    | |       +-ArrayScan
    | |         +-column_list=[$array.$unnest1#1{Collation:"und:ci"}]
    | |         +-array_expr=
    | |         | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    | |         |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |         |   +-Literal(type=STRING, value='a')
    | |         |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |         |     +-type_annotation_map={Collation:"und:ci"}
    | |         |     +-Literal(type=STRING, value='A')
    | |         |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |         +-element_column=$array.$unnest1#1{Collation:"und:ci"}
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[KeyValue.$unnest1#2{Collation:"und:ci"}]
    |       +-input_scan=
    |         +-WithRefScan(column_list=[KeyValue.$unnest1#2{Collation:"und:ci"}], with_query_name='KeyValue')
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.$unnest1#3{Collation:"und:ci"}]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.$unnest1#3{Collation:"und:ci"}], with_query_name='t1')
    +-recursive=TRUE
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE,V_1_1_WITH_ON_SUBQUERY]
# Due to name shadowing, this query is allowed (not a multi-element cycle)
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (WITH t1 AS (SELECT collate('1', 'und:ci')) SELECT * FROM t1)
SELECT * FROM t1;

--
QueryStmt
+-output_column_list=
| +-t1_2.$col1#4{Collation:"und:ci"} AS "$col1" [STRING]
+-query=
  +-WithScan
    +-column_list=[t1_2.$col1#4{Collation:"und:ci"}]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t2'
    | | +-with_subquery=
    | |   +-WithScan
    | |     +-column_list=[t1.$col1#2{Collation:"und:ci"}]
    | |     +-with_entry_list=
    | |     | +-WithEntry
    | |     |   +-with_query_name='t1'
    | |     |   +-with_subquery=
    | |     |     +-ProjectScan
    | |     |       +-column_list=[t1.$col1#1{Collation:"und:ci"}]
    | |     |       +-expr_list=
    | |     |       | +-$col1#1 :=
    | |     |       |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |     |       |     +-type_annotation_map={Collation:"und:ci"}
    | |     |       |     +-Literal(type=STRING, value='1')
    | |     |       |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |     |       +-input_scan=
    | |     |         +-SingleRowScan
    | |     +-query=
    | |       +-ProjectScan
    | |         +-column_list=[t1.$col1#2{Collation:"und:ci"}]
    | |         +-input_scan=
    | |           +-WithRefScan(column_list=[t1.$col1#2{Collation:"und:ci"}], with_query_name='t1')
    | +-WithEntry
    |   +-with_query_name='t1_2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t2.$col1#3{Collation:"und:ci"}]
    |       +-input_scan=
    |         +-WithRefScan(column_list=[t2.$col1#3{Collation:"und:ci"}], with_query_name='t2')
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1_2.$col1#4{Collation:"und:ci"}]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1_2.$col1#4{Collation:"und:ci"}], with_query_name='t1_2')
    +-recursive=TRUE
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE,V_1_1_WITH_ON_SUBQUERY]
# Not a multi-element cycle, due to 't1' being a forward reference in inner,
# recursive WITH
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (WITH RECURSIVE t1 AS (SELECT * FROM t3), t3 AS (SELECT collate('1', 'und:ci')) SELECT * FROM t1, t3)
SELECT * FROM t1;

--
QueryStmt
+-output_column_list=
| +-t1_3.$col1#7{Collation:"und:ci"} AS "$col1" [STRING]
| +-t1_3.$col1#8{Collation:"und:ci"} AS "$col1" [STRING]
+-query=
  +-WithScan
    +-column_list=t1_3.[$col1#7, $col1#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t2'
    | | +-with_subquery=
    | |   +-WithScan
    | |     +-column_list=[t1.$col1#3{Collation:"und:ci"}, t3.$col1#4{Collation:"und:ci"}]
    | |     +-with_entry_list=
    | |     | +-WithEntry
    | |     | | +-with_query_name='t3'
    | |     | | +-with_subquery=
    | |     | |   +-ProjectScan
    | |     | |     +-column_list=[t3.$col1#1{Collation:"und:ci"}]
    | |     | |     +-expr_list=
    | |     | |     | +-$col1#1 :=
    | |     | |     |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |     | |     |     +-type_annotation_map={Collation:"und:ci"}
    | |     | |     |     +-Literal(type=STRING, value='1')
    | |     | |     |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |     | |     +-input_scan=
    | |     | |       +-SingleRowScan
    | |     | +-WithEntry
    | |     |   +-with_query_name='t1'
    | |     |   +-with_subquery=
    | |     |     +-ProjectScan
    | |     |       +-column_list=[t3.$col1#2{Collation:"und:ci"}]
    | |     |       +-input_scan=
    | |     |         +-WithRefScan(column_list=[t3.$col1#2{Collation:"und:ci"}], with_query_name='t3')
    | |     +-query=
    | |     | +-ProjectScan
    | |     |   +-column_list=[t1.$col1#3{Collation:"und:ci"}, t3.$col1#4{Collation:"und:ci"}]
    | |     |   +-input_scan=
    | |     |     +-JoinScan
    | |     |       +-column_list=[t1.$col1#3{Collation:"und:ci"}, t3.$col1#4{Collation:"und:ci"}]
    | |     |       +-left_scan=
    | |     |       | +-WithRefScan(column_list=[t1.$col1#3{Collation:"und:ci"}], with_query_name='t1')
    | |     |       +-right_scan=
    | |     |         +-WithRefScan(column_list=[t3.$col1#4{Collation:"und:ci"}], with_query_name='t3')
    | |     +-recursive=TRUE
    | +-WithEntry
    |   +-with_query_name='t1_3'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t2.[$col1#5, $col1#6]
    |       +-input_scan=
    |         +-WithRefScan(column_list=t2.[$col1#5, $col1#6], with_query_name='t2')
    +-query=
    | +-ProjectScan
    |   +-column_list=t1_3.[$col1#7, $col1#8]
    |   +-input_scan=
    |     +-WithRefScan(column_list=t1_3.[$col1#7, $col1#8], with_query_name='t1_3')
    +-recursive=TRUE
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE,V_1_1_WITH_ON_SUBQUERY]
# Not recursive at all, due to inner t2 shadowing outer t2
WITH RECURSIVE
  t1 AS (SELECT * FROM t2),
  t2 AS (WITH RECURSIVE t2 AS (SELECT collate('a', 'und:ci')) SELECT * FROM t2)
SELECT * FROM t1;

--
QueryStmt
+-output_column_list=
| +-t1.$col1#4{Collation:"und:ci"} AS "$col1" [STRING]
+-query=
  +-WithScan
    +-column_list=[t1.$col1#4{Collation:"und:ci"}]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t2'
    | | +-with_subquery=
    | |   +-WithScan
    | |     +-column_list=[t2_1.$col1#2{Collation:"und:ci"}]
    | |     +-with_entry_list=
    | |     | +-WithEntry
    | |     |   +-with_query_name='t2_1'
    | |     |   +-with_subquery=
    | |     |     +-ProjectScan
    | |     |       +-column_list=[t2.$col1#1{Collation:"und:ci"}]
    | |     |       +-expr_list=
    | |     |       | +-$col1#1 :=
    | |     |       |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |     |       |     +-type_annotation_map={Collation:"und:ci"}
    | |     |       |     +-Literal(type=STRING, value='a')
    | |     |       |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |     |       +-input_scan=
    | |     |         +-SingleRowScan
    | |     +-query=
    | |     | +-ProjectScan
    | |     |   +-column_list=[t2_1.$col1#2{Collation:"und:ci"}]
    | |     |   +-input_scan=
    | |     |     +-WithRefScan(column_list=[t2_1.$col1#2{Collation:"und:ci"}], with_query_name='t2_1')
    | |     +-recursive=TRUE
    | +-WithEntry
    |   +-with_query_name='t1'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t2.$col1#3{Collation:"und:ci"}]
    |       +-input_scan=
    |         +-WithRefScan(column_list=[t2.$col1#3{Collation:"und:ci"}], with_query_name='t2')
    +-query=
    | +-ProjectScan
    |   +-column_list=[t1.$col1#4{Collation:"und:ci"}]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[t1.$col1#4{Collation:"und:ci"}], with_query_name='t1')
    +-recursive=TRUE
==

# Items in non-recursive term and recursive term have different collation
[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
with recursive
  t as (select 1 as ind, string_ci from CollatedTable union all
  (select ind + 1 as ind, collate(string_ci, 'binary') from t where ind < 3))
select ind, string_ci from t
--
ERROR: Collation conflict: "binary" vs. "und:ci"; in column 2, item 2 of recursive scan [at 2:9]
  t as (select 1 as ind, string_ci from CollatedTable union all
        ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
# Prototype with annotation doesn't propropagte for recursive scan
with recursive
  t as (select 1 as ind, proto_with_collation from CollatedTableWithProto union all
  (select ind + 1 as ind, proto_with_collation from t where ind < 3))
select ind, proto_with_collation from t
--
ERROR: Collation conflict: "{Collation:"und:ci"}" vs. "null"; in column 2 of recursive scan [at 4:4]
  (select ind + 1 as ind, proto_with_collation from t where ind < 3))
   ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_LIKE_ANY_SOME_ALL,V_1_4_LIKE_ANY_SOME_ALL_SUBQUERY]

# Test propagation of collation through subquery
select
  (select string_ci from CollatedTable),
  ARRAY(select string_ci from CollatedTable order by string_ci),
  EXISTS (select string_ci from CollatedTable),
  'abc' in (select string_ci from CollatedTable),

  # Expects no collation propagated from like any/like all.
  'abc' like any (select string_ci from CollatedTable),
  'abc' like all (select string_ci from CollatedTable),
--
QueryStmt
+-output_column_list=
| +-$query.$col1#25{Collation:"und:ci"} AS "$col1" [STRING]
| +-$query.$col2#26[{Collation:"und:ci"}] AS "$col2" [ARRAY<STRING>]
| +-$query.$col3#27 AS "$col3" [BOOL]
| +-$query.$col4#28 AS "$col4" [BOOL]
| +-$query.$col5#29 AS "$col5" [BOOL]
| +-$query.$col6#30 AS "$col6" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#25, $col2#26, $col3#27, $col4#28, $col5#29, $col6#30]
    +-expr_list=
    | +-$col1#25 :=
    | | +-SubqueryExpr
    | |   +-type=STRING
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-subquery_type=SCALAR
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}]
    | |       +-input_scan=
    | |         +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
    | +-$col2#26 :=
    | | +-SubqueryExpr
    | |   +-type=ARRAY<STRING>
    | |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |   +-subquery_type=ARRAY
    | |   +-subquery=
    | |     +-OrderByScan
    | |       +-column_list=[CollatedTable.string_ci#5{Collation:"und:ci"}]
    | |       +-is_ordered=TRUE
    | |       +-input_scan=
    | |       | +-TableScan(column_list=[CollatedTable.string_ci#5{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
    | |       +-order_by_item_list=
    | |         +-OrderByItem
    | |           +-column_ref=
    | |           | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#5{Collation:"und:ci"})
    | |           +-collation=und:ci
    | +-$col3#27 :=
    | | +-SubqueryExpr
    | |   +-type=BOOL
    | |   +-subquery_type=EXISTS
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[CollatedTable.string_ci#9{Collation:"und:ci"}]
    | |       +-input_scan=
    | |         +-TableScan(column_list=[CollatedTable.string_ci#9{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
    | +-$col4#28 :=
    | | +-SubqueryExpr
    | |   +-type=BOOL
    | |   +-subquery_type=IN
    | |   +-in_expr=
    | |   | +-Literal(type=STRING, value='abc')
    | |   +-in_collation=und:ci
    | |   +-subquery=
    | |     +-ProjectScan
    | |       +-column_list=[CollatedTable.string_ci#13{Collation:"und:ci"}]
    | |       +-input_scan=
    | |         +-TableScan(column_list=[CollatedTable.string_ci#13{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
    | +-$col5#29 :=
    | | +-FunctionCall(ZetaSQL:$like_any(STRING, repeated(1) STRING) -> BOOL)
    | |   +-Literal(type=STRING, value='abc')
    | |   +-SubqueryExpr
    | |     +-type=STRING
    | |     +-type_annotation_map={Collation:"und:ci"}
    | |     +-subquery_type=SCALAR
    | |     +-subquery=
    | |       +-ProjectScan
    | |         +-column_list=[CollatedTable.string_ci#17{Collation:"und:ci"}]
    | |         +-input_scan=
    | |           +-TableScan(column_list=[CollatedTable.string_ci#17{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
    | |   +-collation_list=[und:ci]
    | +-$col6#30 :=
    |   +-FunctionCall(ZetaSQL:$like_all(STRING, repeated(1) STRING) -> BOOL)
    |     +-Literal(type=STRING, value='abc')
    |     +-SubqueryExpr
    |       +-type=STRING
    |       +-type_annotation_map={Collation:"und:ci"}
    |       +-subquery_type=SCALAR
    |       +-subquery=
    |         +-ProjectScan
    |           +-column_list=[CollatedTable.string_ci#21{Collation:"und:ci"}]
    |           +-input_scan=
    |             +-TableScan(column_list=[CollatedTable.string_ci#21{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
    |     +-collation_list=[und:ci]
    +-input_scan=
      +-SingleRowScan
==

select collate('abc', 'und:ci') in (select string_ci from CollatedTable)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |   +-type_annotation_map={Collation:"und:ci"}
    |     |   +-Literal(type=STRING, value='abc')
    |     |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-in_collation=und:ci
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}]
    |         +-input_scan=
    |           +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
    +-input_scan=
      +-SingleRowScan
==

select collate('abc', 'und:ci') in (select string_no_collation from ComplexCollatedTable)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |   +-type_annotation_map={Collation:"und:ci"}
    |     |   +-Literal(type=STRING, value='abc')
    |     |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-in_collation=und:ci
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[ComplexCollatedTable.string_no_collation#1]
    |         +-input_scan=
    |           +-TableScan(column_list=[ComplexCollatedTable.string_no_collation#1], table=ComplexCollatedTable, column_index_list=[0])
    +-input_scan=
      +-SingleRowScan
==

# Collation mismatch between input expr and subquery column is rejected.
select collate('abc', 'binary') in (select string_ci from CollatedTable)
--
ERROR: Collation conflict: "binary" vs. "und:ci". Collation for IN operator is different on input expr ("binary") and subquery column ("und:ci") [at 1:37]
select collate('abc', 'binary') in (select string_ci from CollatedTable)
                                    ^
==

# Test ResolvedGetStructField
select struct_with_string_ci,
       struct_with_string_ci.b field_b,
       struct_with_string_ci.*,
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}> AS struct_with_string_ci [STRUCT<a INT32, b STRING>]
| +-$query.field_b#5{Collation:"und:ci"} AS field_b [STRING]
| +-$query.a#6 AS a [INT32]
| +-$query.b#7{Collation:"und:ci"} AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>, $query.field_b#5{Collation:"und:ci"}, $query.a#6, $query.b#7{Collation:"und:ci"}]
    +-expr_list=
    | +-field_b#5 :=
    | | +-GetStructField
    | |   +-type=STRING
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    | |   +-field_idx=1
    | +-a#6 :=
    | | +-GetStructField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    | |   +-field_idx=0
    | +-b#7 :=
    |   +-GetStructField
    |     +-type=STRING
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    |     +-field_idx=1
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>], table=CollatedTable, column_index_list=[2])
==

[no_run_unparser]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# TODO: for ResolvedMakeStruct:
# * handle UNPIVOT query with rewriter calling MakeResolvedMakeStruct

# Test ResolvedMakeStruct
select
  ('def', string_ci, null),           -- String column / literal mixed fields
  (string_ci, string_binary),             -- 2 string fields
  -- String/array/struct mix fields
  (string_ci, array_with_string_ci, struct_with_string_ci),
  (string_ci, (string_ci, (string_ci, string_binary))) -- Nested struct type
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5<_,{Collation:"und:ci"},_> AS "$col1" [STRUCT<STRING, STRING, INT64>]
| +-$query.$col2#6<{Collation:"und:ci"},{Collation:"binary"}> AS "$col2" [STRUCT<STRING, STRING>]
| +-$query.$col3#7<{Collation:"und:ci"},[{Collation:"und:ci"}],<_,{Collation:"und:ci"}>> AS "$col3" [STRUCT<STRING, ARRAY<STRING>, STRUCT<a INT32, b STRING>>]
| +-$query.$col4#8<{Collation:"und:ci"},<{Collation:"und:ci"},<{Collation:"und:ci"},{Collation:"binary"}>>> AS "$col4" [STRUCT<STRING, STRUCT<STRING, STRUCT<STRING, STRING>>>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8]
    +-expr_list=
    | +-$col1#5 :=
    | | +-MakeStruct
    | |   +-type=STRUCT<STRING, STRING, INT64>
    | |   +-type_annotation_map=<_,{Collation:"und:ci"},_>
    | |   +-field_list=
    | |     +-Literal(type=STRING, value='def')
    | |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |     +-Literal(type=INT64, value=NULL)
    | +-$col2#6 :=
    | | +-MakeStruct
    | |   +-type=STRUCT<STRING, STRING>
    | |   +-type_annotation_map=<{Collation:"und:ci"},{Collation:"binary"}>
    | |   +-field_list=
    | |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    | +-$col3#7 :=
    | | +-MakeStruct
    | |   +-type=STRUCT<STRING, ARRAY<STRING>, STRUCT<a INT32, b STRING>>
    | |   +-type_annotation_map=<{Collation:"und:ci"},[{Collation:"und:ci"}],<_,{Collation:"und:ci"}>>
    | |   +-field_list=
    | |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    | |     +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    | +-$col4#8 :=
    |   +-MakeStruct
    |     +-type=STRUCT<STRING, STRUCT<STRING, STRUCT<STRING, STRING>>>
    |     +-type_annotation_map=<{Collation:"und:ci"},<{Collation:"und:ci"},<{Collation:"und:ci"},{Collation:"binary"}>>>
    |     +-field_list=
    |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |       +-MakeStruct
    |         +-type=STRUCT<STRING, STRUCT<STRING, STRING>>
    |         +-type_annotation_map=<{Collation:"und:ci"},<{Collation:"und:ci"},{Collation:"binary"}>>
    |         +-field_list=
    |           +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |           +-MakeStruct
    |             +-type=STRUCT<STRING, STRING>
    |             +-type_annotation_map=<{Collation:"und:ci"},{Collation:"binary"}>
    |             +-field_list=
    |               +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |               +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 2, 3])
==

# Test comparing a struct type with a ResolvedMakeStruct.
select struct_with_string_ci = (1, string_binary)
from CollatedTable
--
ERROR: Collation conflict: "binary" vs. "und:ci". Collation on argument 2 (<_,"binary">) in function = is not compatible with other arguments [at 1:8]
select struct_with_string_ci = (1, string_binary)
       ^
==

# Test comparing two structs with the same CI collation succeed
select struct_with_string_ci = (1, string_ci)
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:$equal(STRUCT<a INT32, b STRING>, STRUCT<a INT32, b STRING>) -> BOOL)
    |     +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    |     +-MakeStruct
    |       +-type=STRUCT<a INT32, b STRING>
    |       +-type_annotation_map=<_,{Collation:"und:ci"}>
    |       +-field_list=
    |         +-Literal(type=INT32, value=1)
    |         +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     +-collation_list=[[_,und:ci]]
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, struct_with_string_ci#3], table=CollatedTable, column_index_list=[0, 2])

==

# Test comparing struct_with_ci_collation with struct_without_collation succeed
select struct_with_string_ci = (1, 'plain_string_without_collation')
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:$equal(STRUCT<a INT32, b STRING>, STRUCT<a INT32, b STRING>) -> BOOL)
    |     +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    |     +-Literal(type=STRUCT<a INT32, b STRING>, value={a:1, b:'plain_string_without_collation'})
    |     +-collation_list=[[_,und:ci]]
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>], table=CollatedTable, column_index_list=[2])

==

# Test comparing struct_with_ci_collation with struct_with_empty_collation succeed
select struct_with_string_ci = (1, COLLATE('abc', ''))
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:$equal(STRUCT<a INT32, b STRING>, STRUCT<a INT32, b STRING>) -> BOOL)
    |     +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    |     +-MakeStruct
    |       +-type=STRUCT<a INT32, b STRING>
    |       +-field_list=
    |         +-Literal(type=INT32, value=1)
    |         +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |           +-Literal(type=STRING, value='abc')
    |           +-Literal(type=STRING, value='', preserve_in_literal_remover=TRUE)
    |     +-collation_list=[[_,und:ci]]
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>], table=CollatedTable, column_index_list=[2])

==

# Test comparing two arrays with the same CI collation succeed
[language_features=V_1_1_ARRAY_EQUALITY,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT]
select array_with_string_ci = [string_ci]
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:$equal(ARRAY<STRING>, ARRAY<STRING>) -> BOOL)
    |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
    |       +-type_annotation_map=[{Collation:"und:ci"}]
    |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     +-collation_list=[[und:ci]]
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 3])

==

[no_run_unparser]
# Test DotStar from an expression
# TODO: enable the unparser once cast with collate is implemented.
select ('def', string_ci, null).*
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$field1#6 AS "$field1" [STRING]
| +-$query.$field2#7{Collation:"und:ci"} AS "$field2" [STRING]
| +-$query.$field3#8 AS "$field3" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$field1#6, $field2#7, $field3#8]
    +-expr_list=
    | +-$field1#6 :=
    | | +-GetStructField
    | |   +-type=STRING
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<STRING, STRING, INT64>, type_annotation_map=<_,{Collation:"und:ci"},_>, column=$preproject.$struct#5<_,{Collation:"und:ci"},_>)
    | |   +-field_idx=0
    | +-$field2#7 :=
    | | +-GetStructField
    | |   +-type=STRING
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-expr=
    | |   | +-ColumnRef(type=STRUCT<STRING, STRING, INT64>, type_annotation_map=<_,{Collation:"und:ci"},_>, column=$preproject.$struct#5<_,{Collation:"und:ci"},_>)
    | |   +-field_idx=1
    | +-$field3#8 :=
    |   +-GetStructField
    |     +-type=INT64
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<STRING, STRING, INT64>, type_annotation_map=<_,{Collation:"und:ci"},_>, column=$preproject.$struct#5<_,{Collation:"und:ci"},_>)
    |     +-field_idx=2
    +-input_scan=
      +-ProjectScan
        +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, $preproject.$struct#5<_,{Collation:"und:ci"},_>]
        +-expr_list=
        | +-$struct#5 :=
        |   +-MakeStruct
        |     +-type=STRUCT<STRING, STRING, INT64>
        |     +-type_annotation_map=<_,{Collation:"und:ci"},_>
        |     +-field_list=
        |       +-Literal(type=STRING, value='def')
        |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        |       +-Literal(type=INT64, value=NULL)
        +-input_scan=
          +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
==

[no_run_unparser]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# Test ResolvedMakeStruct in value table
select as struct 1, 'abc', (string_ci, (string_ci, string_binary))
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$make_struct.$struct#8<_,_,<{Collation:"und:ci"},<{Collation:"und:ci"},{Collation:"binary"}>>> AS "$struct" [STRUCT<INT64, STRING, STRUCT<STRING, STRUCT<STRING, STRING>>>]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$make_struct.$struct#8<_,_,<{Collation:"und:ci"},<{Collation:"und:ci"},{Collation:"binary"}>>>]
    +-expr_list=
    | +-$struct#8 :=
    |   +-MakeStruct
    |     +-type=STRUCT<INT64, STRING, STRUCT<STRING, STRUCT<STRING, STRING>>>
    |     +-type_annotation_map=<_,_,<{Collation:"und:ci"},<{Collation:"und:ci"},{Collation:"binary"}>>>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=$query.$col1#5)
    |       +-ColumnRef(type=STRING, column=$query.$col2#6)
    |       +-ColumnRef(type=STRUCT<STRING, STRUCT<STRING, STRING>>, type_annotation_map=<{Collation:"und:ci"},<{Collation:"und:ci"},{Collation:"binary"}>>, column=$query.$col3#7<{Collation:"und:ci"},<{Collation:"und:ci"},{Collation:"binary"}>>)
    +-input_scan=
      +-ProjectScan
        +-column_list=$query.[$col1#5, $col2#6, $col3#7]
        +-expr_list=
        | +-$col1#5 := Literal(type=INT64, value=1)
        | +-$col2#6 := Literal(type=STRING, value='abc')
        | +-$col3#7 :=
        |   +-MakeStruct
        |     +-type=STRUCT<STRING, STRUCT<STRING, STRING>>
        |     +-type_annotation_map=<{Collation:"und:ci"},<{Collation:"und:ci"},{Collation:"binary"}>>
        |     +-field_list=
        |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        |       +-MakeStruct
        |         +-type=STRUCT<STRING, STRING>
        |         +-type_annotation_map=<{Collation:"und:ci"},{Collation:"binary"}>
        |         +-field_list=
        |           +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        |           +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        +-input_scan=
          +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
==

# Test make struct with keyword constructor. There should be implicit casts when
# input fields have collations.
# TODO: Support collated type inside struct constructor,
# i.e. STRUCT<STRING COLLATE '...'>.
select
  struct<a INT32, b STRING>(1, 'a'),
  struct<a INT32, b STRING>(1, collate('a', 'und:ci')),
  struct<a INT32, b ARRAY<STRING>>(1, [collate('a', 'und:ci')]),
  struct<a INT32, b STRUCT<x INT32, y STRING>>(1, (2, collate('a', 'und:ci'))),
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [STRUCT<a INT32, b STRING>]
| +-$query.$col2#6 AS "$col2" [STRUCT<a INT32, b STRING>]
| +-$query.$col3#7 AS "$col3" [STRUCT<a INT32, b ARRAY<STRING>>]
| +-$query.$col4#8 AS "$col4" [STRUCT<a INT32, b STRUCT<x INT32, y STRING>>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8]
    +-expr_list=
    | +-$col1#5 := Literal(type=STRUCT<a INT32, b STRING>, value={a:1, b:'a'}, has_explicit_type=TRUE)
    | +-$col2#6 :=
    | | +-MakeStruct
    | |   +-type=STRUCT<a INT32, b STRING>
    | |   +-field_list=
    | |     +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
    | |     +-Cast(STRING -> STRING)
    | |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |         +-type_annotation_map={Collation:"und:ci"}
    | |         +-Literal(type=STRING, value='a')
    | |         +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | +-$col3#7 :=
    | | +-MakeStruct
    | |   +-type=STRUCT<a INT32, b ARRAY<STRING>>
    | |   +-field_list=
    | |     +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
    | |     +-Cast(ARRAY<STRING> -> ARRAY<STRING>)
    | |       +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
    | |         +-type_annotation_map=[{Collation:"und:ci"}]
    | |         +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |           +-type_annotation_map={Collation:"und:ci"}
    | |           +-Literal(type=STRING, value='a')
    | |           +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | +-$col4#8 :=
    |   +-MakeStruct
    |     +-type=STRUCT<a INT32, b STRUCT<x INT32, y STRING>>
    |     +-field_list=
    |       +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
    |       +-MakeStruct
    |         +-type=STRUCT<x INT32, y STRING>
    |         +-field_list=
    |           +-Literal(type=INT32, value=2, has_explicit_type=TRUE)
    |           +-Cast(STRING -> STRING)
    |             +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |               +-type_annotation_map={Collation:"und:ci"}
    |               +-Literal(type=STRING, value='a')
    |               +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    +-input_scan=
      +-TableScan(table=CollatedTable)
==

# Default collation propagation through function call
select concat(string_ci, 'abc')
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5{Collation:"und:ci"} AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5{Collation:"und:ci"}]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     +-Literal(type=STRING, value='abc')
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
==

# Default collation propagation through aggregate function call
select string_agg(string_binary), any_value(array_with_string_ci)
from CollatedTable
group by string_ci
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5{Collation:"binary"} AS "$col1" [STRING]
| +-$aggregate.$agg2#6[{Collation:"und:ci"}] AS "$col2" [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#5, $agg2#6]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#5, $agg2#6]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 3])
        +-group_by_list=
        | +-string_ci#7 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        +-collation_list=[und:ci]
        +-aggregate_list=
          +-$agg1#5 :=
          | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
          |   +-type_annotation_map={Collation:"binary"}
          |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
          +-$agg2#6 :=
            +-AggregateFunctionCall(ZetaSQL:any_value(ARRAY<STRING>) -> ARRAY<STRING>)
              +-type_annotation_map=[{Collation:"und:ci"}]
              +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
==

# Default collation propagation through analytic function call
select string_agg(string_binary) OVER (),
       any_value(array_with_string_ci) OVER (),
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#7{Collation:"binary"} AS "$col1" [STRING]
| +-$analytic.$analytic2#8[{Collation:"und:ci"}] AS "$col2" [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#7, $analytic2#8]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[CollatedTable.string_binary#2{Collation:"binary"}, CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}], $analytic.$analytic1#7{Collation:"binary"}, $analytic.$analytic2#8[{Collation:"und:ci"}]]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_binary#2, array_with_string_ci#4], table=CollatedTable, column_index_list=[1, 3])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#7 :=
              | +-AnalyticFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
              |   +-type_annotation_map={Collation:"binary"}
              |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
              |   +-window_frame=
              |     +-WindowFrame(frame_unit=ROWS)
              |       +-start_expr=
              |       | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
              |       +-end_expr=
              |         +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
              +-$analytic2#8 :=
                +-AnalyticFunctionCall(ZetaSQL:any_value(ARRAY<STRING>) -> ARRAY<STRING>)
                  +-type_annotation_map=[{Collation:"und:ci"}]
                  +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

[language_features=V_1_3_QUALIFY,ANALYTIC_FUNCTIONS,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT]
# Test that collation propagates into the QUALIFY clause.
select (string_agg(string_binary) over ()) as a
from CollatedTable
where true
qualify a = 'abc'
--
QueryStmt
+-output_column_list=
| +-$analytic.a#6{Collation:"binary"} AS a [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.a#6{Collation:"binary"}]
    +-input_scan=
      +-FilterScan
        +-column_list=[CollatedTable.string_binary#2{Collation:"binary"}, $analytic.a#6{Collation:"binary"}]
        +-input_scan=
        | +-AnalyticScan
        |   +-column_list=[CollatedTable.string_binary#2{Collation:"binary"}, $analytic.a#6{Collation:"binary"}]
        |   +-input_scan=
        |   | +-FilterScan
        |   |   +-column_list=[CollatedTable.string_binary#2{Collation:"binary"}]
        |   |   +-input_scan=
        |   |   | +-TableScan(column_list=[CollatedTable.string_binary#2{Collation:"binary"}], table=CollatedTable, column_index_list=[1])
        |   |   +-filter_expr=
        |   |     +-Literal(type=BOOL, value=true)
        |   +-function_group_list=
        |     +-AnalyticFunctionGroup
        |       +-analytic_function_list=
        |         +-a#6 :=
        |           +-AnalyticFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
        |             +-type_annotation_map={Collation:"binary"}
        |             +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        |             +-window_frame=
        |               +-WindowFrame(frame_unit=ROWS)
        |                 +-start_expr=
        |                 | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
        |                 +-end_expr=
        |                   +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
            +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=$analytic.a#6{Collation:"binary"})
            +-Literal(type=STRING, value='abc')
            +-collation_list=[binary]
==

# Default collation propagation through function call with templated argument
# and return type
select
  IF(TRUE, string_ci, 'abc'),
  IF(TRUE, struct_with_string_ci, STRUCT<a INT32, b STRING>(1, 'abc')),
  IF(TRUE, array_with_string_ci, ['abc']),
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5{Collation:"und:ci"} AS "$col1" [STRING]
| +-$query.$col2#6<_,{Collation:"und:ci"}> AS "$col2" [STRUCT<a INT32, b STRING>]
| +-$query.$col3#7[{Collation:"und:ci"}] AS "$col3" [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, STRING, STRING) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | +-$col2#6 :=
    | | +-FunctionCall(ZetaSQL:if(BOOL, STRUCT<a INT32, b STRING>, STRUCT<a INT32, b STRING>) -> STRUCT<a INT32, b STRING>)
    | |   +-type_annotation_map=<_,{Collation:"und:ci"}>
    | |   +-Literal(type=BOOL, value=true)
    | |   +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    | |   +-Literal(type=STRUCT<a INT32, b STRING>, value={a:1, b:'abc'}, has_explicit_type=TRUE)
    | +-$col3#7 :=
    |   +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<STRING>, ARRAY<STRING>) -> ARRAY<STRING>)
    |     +-type_annotation_map=[{Collation:"und:ci"}]
    |     +-Literal(type=BOOL, value=true)
    |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    |     +-Literal(type=ARRAY<STRING>, value=['abc'])
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 2, 3])
==

# Default collation propagation through function call with lambda argument
SELECT fn_fp_T_LAMBDA_RET_T(string_ci, e->e),
       array_filter(array_with_string_ci, e->e = 'abc'),
       array_includes(array_with_string_ci, e->e = 'abc'),
FROM CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8{Collation:"und:ci"} AS "$col1" [STRING]
| +-$query.$col2#9[{Collation:"und:ci"}] AS "$col2" [ARRAY<STRING>]
| +-$query.$col3#10 AS "$col3" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#8, $col2#9, $col3#10]
    +-expr_list=
    | +-$col1#8 :=
    | | +-FunctionCall(sample_functions:fn_fp_T_LAMBDA_RET_T(STRING, FUNCTION<STRING->STRING>) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-FunctionArgument
    | |   | +-expr=
    | |   |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-FunctionArgument
    | |     +-inline_lambda=
    | |       +-InlineLambda
    | |         +-argument_list=[$lambda_arg.e#5]
    | |         +-body=
    | |           +-ColumnRef(type=STRING, column=$lambda_arg.e#5)
    | +-$col2#9 :=
    | | +-FunctionCall(ZetaSQL:array_filter(ARRAY<STRING> array_to_filter, FUNCTION<STRING->BOOL> condition) -> ARRAY<STRING>)
    | |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |   +-FunctionArgument
    | |   | +-expr=
    | |   |   +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    | |   +-FunctionArgument
    | |     +-inline_lambda=
    | |       +-InlineLambda
    | |         +-argument_list=[$lambda_arg.e#6]
    | |         +-body=
    | |           +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    | |             +-ColumnRef(type=STRING, column=$lambda_arg.e#6)
    | |             +-Literal(type=STRING, value='abc')
    | +-$col3#10 :=
    |   +-FunctionCall(ZetaSQL:array_includes(ARRAY<STRING> array_to_search, FUNCTION<STRING->BOOL> condition) -> BOOL)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#7]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |               +-ColumnRef(type=STRING, column=$lambda_arg.e#7)
    |               +-Literal(type=STRING, value='abc')
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 3])
==

# ARRAY_TRANSFORM has signature:
#    (ARRAY_TYPE_ANY_1, Lambda(TYPE_ANY_1) -> TYPE_ANY_2) -> ARRAY_TYPE_ANY_2
#
# The collation should be propagated from lambda return type TYPE_ANY_2 to the
# ARRAY_TRANSFORM() return type ARRAY_TYPE_ANY_2
SELECT ARRAY_TRANSFORM(
          ARRAY(SELECT struct_with_string_ci FROM CollatedTable),
          (a) -> collate('unrelated_string', 'uni:cs')
       )
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6[{Collation:"uni:cs"}] AS "$col1" [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6[{Collation:"uni:cs"}]]
    +-expr_list=
    | +-$col1#6 :=
    |   +-FunctionCall(ZetaSQL:array_transform(ARRAY<STRUCT<a INT32, b STRING>> array_to_transform, FUNCTION<STRUCT<a INT32, b STRING>->STRING> transformation) -> ARRAY<STRING>)
    |     +-type_annotation_map=[{Collation:"uni:cs"}]
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-SubqueryExpr
    |     |     +-type=ARRAY<STRUCT<a INT32, b STRING>>
    |     |     +-type_annotation_map=[<_,{Collation:"und:ci"}>]
    |     |     +-subquery_type=ARRAY
    |     |     +-subquery=
    |     |       +-ProjectScan
    |     |         +-column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>]
    |     |         +-input_scan=
    |     |           +-TableScan(column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>], table=CollatedTable, column_index_list=[2])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.a#5]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |               +-type_annotation_map={Collation:"uni:cs"}
    |               +-Literal(type=STRING, value='unrelated_string')
    |               +-Literal(type=STRING, value='uni:cs', preserve_in_literal_remover=TRUE)
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,JSON_ARRAY_FUNCTIONS]

# All cases with non-default propagation rule.
select
  # ARRAY<T> -> T cases
  # $array_at_offset
  array_with_string_ci[default_offset(0)]           fn_array_at_offset,
  # $safe_array_at_offset
  array_with_string_ci[safe_offset(0)]      fn_safe_array_at_offset,
  # $array_at_ordinal
  array_with_string_ci[ordinal(1)]          fn_array_at_ordinal,
  # $safe_array_at_ordinal
  array_with_string_ci[safe_ordinal(1)]     fn_safe_array_at_ordinal,
  array_to_string(array_with_string_ci, '') fn_array_to_string,

  # T -> ARRAY<T> cases
  # $make_array
  [string_ci, 'a', 'b']                     fn_make_array,
  split(string_ci)                          fn_split,

  # No propagation
  to_json_string(array_with_string_ci)      fn_to_json_string,

  # Only propagates collation from the first argument
  format(string_binary, array_with_string_ci, struct_with_string_ci) fn_format,
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.fn_array_at_offset#5{Collation:"und:ci"} AS fn_array_at_offset [STRING]
| +-$query.fn_safe_array_at_offset#6{Collation:"und:ci"} AS fn_safe_array_at_offset [STRING]
| +-$query.fn_array_at_ordinal#7{Collation:"und:ci"} AS fn_array_at_ordinal [STRING]
| +-$query.fn_safe_array_at_ordinal#8{Collation:"und:ci"} AS fn_safe_array_at_ordinal [STRING]
| +-$query.fn_array_to_string#9{Collation:"und:ci"} AS fn_array_to_string [STRING]
| +-$query.fn_make_array#10[{Collation:"und:ci"}] AS fn_make_array [ARRAY<STRING>]
| +-$query.fn_split#11[{Collation:"und:ci"}] AS fn_split [ARRAY<STRING>]
| +-$query.fn_to_json_string#12 AS fn_to_json_string [STRING]
| +-$query.fn_format#13{Collation:"binary"} AS fn_format [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[fn_array_at_offset#5, fn_safe_array_at_offset#6, fn_array_at_ordinal#7, fn_safe_array_at_ordinal#8, fn_array_to_string#9, fn_make_array#10, fn_split#11, fn_to_json_string#12, fn_format#13]
    +-expr_list=
    | +-fn_array_at_offset#5 :=
    | | +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<STRING>, INT64) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    | |   +-Literal(type=INT64, value=0)
    | +-fn_safe_array_at_offset#6 :=
    | | +-FunctionCall(ZetaSQL:$safe_array_at_offset(ARRAY<STRING>, INT64) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    | |   +-Literal(type=INT64, value=0)
    | +-fn_array_at_ordinal#7 :=
    | | +-FunctionCall(ZetaSQL:$array_at_ordinal(ARRAY<STRING>, INT64) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    | |   +-Literal(type=INT64, value=1)
    | +-fn_safe_array_at_ordinal#8 :=
    | | +-FunctionCall(ZetaSQL:$safe_array_at_ordinal(ARRAY<STRING>, INT64) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    | |   +-Literal(type=INT64, value=1)
    | +-fn_array_to_string#9 :=
    | | +-FunctionCall(ZetaSQL:array_to_string(ARRAY<STRING>, STRING, optional(0) STRING) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    | |   +-Literal(type=STRING, value='')
    | +-fn_make_array#10 :=
    | | +-FunctionCall(ZetaSQL:$make_array(repeated(3) STRING) -> ARRAY<STRING>)
    | |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='a')
    | |   +-Literal(type=STRING, value='b')
    | +-fn_split#11 :=
    | | +-FunctionCall(ZetaSQL:split(STRING, optional(0) STRING) -> ARRAY<STRING>)
    | |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-collation_list=[und:ci]
    | +-fn_to_json_string#12 :=
    | | +-FunctionCall(ZetaSQL:to_json_string(ARRAY<STRING>, optional(0) BOOL) -> STRING)
    | |   +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    | +-fn_format#13 :=
    |   +-FunctionCall(ZetaSQL:format(STRING, repeated(1) ARRAY<STRING>, repeated(1) STRUCT<a INT32, b STRING>) -> STRING)
    |     +-type_annotation_map={Collation:"binary"}
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    |     +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 2, 3])
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,JSON_ARRAY_FUNCTIONS]
# Collation is disallowed on the function arguments
select
  json_extract_array(string_ci),
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 3:3]
  json_extract_array(string_ci),
  ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,JSON_ARRAY_FUNCTIONS]
# Collation is disallowed on the function arguments
select
  json_extract(string_ci),
from CollatedTable
--
ERROR: Number of arguments does not match for function JSON_EXTRACT. Supported signature: JSON_EXTRACT(STRING, STRING) [at 3:3]
  json_extract(string_ci),
  ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,JSON_ARRAY_FUNCTIONS]
# Collation is disallowed on the function arguments
select
  json_extract_string_array(string_ci),
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 3:3]
  json_extract_string_array(string_ci),
  ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,JSON_ARRAY_FUNCTIONS]
# Collation is disallowed on the function arguments
select
  json_extract_scalar(string_ci),
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 3:3]
  json_extract_scalar(string_ci),
  ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,JSON_ARRAY_FUNCTIONS]
# Collation is disallowed on the function arguments
select
  json_query_array(string_ci),
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 3:3]
  json_query_array(string_ci),
  ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,JSON_ARRAY_FUNCTIONS]
# Collation is disallowed on the function arguments
select
  json_query(string_ci),
from CollatedTable
--
ERROR: Number of arguments does not match for function JSON_QUERY. Supported signature: JSON_QUERY(STRING, STRING) [at 3:3]
  json_query(string_ci),
  ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,JSON_ARRAY_FUNCTIONS]
# Collation is disallowed on the function arguments
select
  json_value(string_ci),
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 3:3]
  json_value(string_ci),
  ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,JSON_ARRAY_FUNCTIONS]
# Collation is disallowed on the function arguments
select
  json_value_array(string_ci),
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 3:3]
  json_value_array(string_ci),
  ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_LIKE_ANY_SOME_ALL]
# Collation is allowed on LIKE operands
select
  string_ci LIKE 'abc',
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:$like(STRING, STRING) -> BOOL)
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     +-Literal(type=STRING, value='abc')
    |     +-collation_list=[und:ci]
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_LIKE_ANY_SOME_ALL]
# Different explicit collations are disallowed on LIKE operands
select
  string_ci LIKE COLLATE('abc', 'binary'),
from CollatedTable
--
ERROR: Collation conflict: "binary" vs. "und:ci". Collation on argument 2 ("binary") in function LIKE is not compatible with other arguments [at 3:3]
  string_ci LIKE COLLATE('abc', 'binary'),
  ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_ADDITIONAL_STRING_FUNCTIONS]
# Collation is disallowed on the function arguments
select
  translate(string_ci, 'a', 'b')
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 3:3]
  translate(string_ci, 'a', 'b')
  ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_ADDITIONAL_STRING_FUNCTIONS]
# Collation is disallowed on the function arguments
select
  initcap(string_ci, 'abc')
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 3:3]
  initcap(string_ci, 'abc')
  ^
==

# Collation is disallowed on the function arguments
select
  regexp_match(string_ci, 'abc')
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 2:3]
  regexp_match(string_ci, 'abc')
  ^
==

# Collation is disallowed on the function arguments
select
  regexp_contains(string_ci, 'abc')
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 2:3]
  regexp_contains(string_ci, 'abc')
  ^
==

# Collation is disallowed on the function arguments
select
  regexp_extract(string_ci, 'abc')
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 2:3]
  regexp_extract(string_ci, 'abc')
  ^
==

# Collation is disallowed on the function arguments
select
  regexp_instr(string_ci, 'abc')
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 2:3]
  regexp_instr(string_ci, 'abc')
  ^
==

# Collation is disallowed on the function arguments
select
  regexp_replace(string_ci, 'abc', 'def')
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 2:3]
  regexp_replace(string_ci, 'abc', 'def')
  ^
==

# Collation is disallowed on the function arguments
select
  approx_quantiles(string_ci, 2)
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 2:3]
  approx_quantiles(string_ci, 2)
  ^
==

# Collation is disallowed on the function arguments
select
  approx_top_count(string_ci, 100)
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 2:3]
  approx_top_count(string_ci, 100)
  ^
==

# Collation is disallowed on the function arguments
select
  approx_top_sum(string_ci, 1, 100)
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 2:3]
  approx_top_sum(string_ci, 1, 100)
  ^
==

# Collation is disallowed on the function arguments
select
  regexp_extract_all(string_ci, 'abc')
from CollatedTable
--
ERROR: Collation is not allowed on argument 1 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 2:3]
  regexp_extract_all(string_ci, 'abc')
  ^
==

# Propagate collation through ResolvedArrayScan on an array column
select array_with_string_ci from CollatedTable, CollatedTable.array_with_string_ci
--
QueryStmt
+-output_column_list=
| +-$array.array_with_string_ci#5{Collation:"und:ci"} AS array_with_string_ci [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$array.array_with_string_ci#5{Collation:"und:ci"}]
    +-input_scan=
      +-ArrayScan
        +-column_list=[CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}], $array.array_with_string_ci#5{Collation:"und:ci"}]
        +-input_scan=
        | +-TableScan(column_list=[CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}]], table=CollatedTable, column_index_list=[3])
        +-array_expr=
        | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
        +-element_column=$array.array_with_string_ci#5{Collation:"und:ci"}
==

# Propagate collation through ResolvedArrayScan on unnest function
select n from unnest([collate('abc', 'und:ci')]) n
--
QueryStmt
+-output_column_list=
| +-$array.n#1{Collation:"und:ci"} AS n [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$array.n#1{Collation:"und:ci"}]
    +-input_scan=
      +-ArrayScan
        +-column_list=[$array.n#1{Collation:"und:ci"}]
        +-array_expr=
        | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
        |   +-type_annotation_map=[{Collation:"und:ci"}]
        |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |     +-type_annotation_map={Collation:"und:ci"}
        |     +-Literal(type=STRING, value='abc')
        |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
        +-element_column=$array.n#1{Collation:"und:ci"}
==

# Throw an error if arguments have different collation
select concat(string_ci, string_binary)
from CollatedTable
--
ERROR: Collation conflict: "binary" vs. "und:ci". Collation on argument 2 ("binary") in function CONCAT is not compatible with other arguments [at 1:8]
select concat(string_ci, string_binary)
       ^
==

[language_features=V_1_1_ARRAY_EQUALITY,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT]
# Throw an error if array arguments have different collation
select array_with_string_ci = array_agg(distinct string_binary)
from CollatedTable
--
ERROR: Collation conflict: "binary" vs. "und:ci". Collation on argument 2 (["binary"]) in function = is not compatible with other arguments [at 2:8]
select array_with_string_ci = array_agg(distinct string_binary)
       ^
==

# Throw an error if struct arguments have different collation in the same field
select ('a', string_ci) = ('b', string_binary)
from CollatedTable
--
ERROR: Collation conflict: "binary" vs. "und:ci". Collation on argument 2 (<_,"binary">) in function = is not compatible with other arguments [at 1:8]
select ('a', string_ci) = ('b', string_binary)
       ^
==

# Throw an error if named arguments have different collation
select fn_named_arguments_returns_string('abc',
                                         date_string => string_ci,
                                         format_string => string_binary)
from CollatedTable
--
ERROR: Collation conflict: "und:ci" vs. "binary". Collation on argument date_string ("und:ci") in function SAMPLE_FUNCTIONS:FN_NAMED_ARGUMENTS_RETURNS_STRING is not compatible with other arguments [at 1:8]
select fn_named_arguments_returns_string('abc',
       ^
==

# Throw an error if named arguments have different collation, mix positional and
# named argument.
select fn_named_arguments_returns_string(string_binary,
                                         date_string => string_ci,
                                         format_string => string_binary)
from CollatedTable
--
ERROR: Collation conflict: "und:ci" vs. "binary". Collation on argument date_string ("und:ci") in function SAMPLE_FUNCTIONS:FN_NAMED_ARGUMENTS_RETURNS_STRING is not compatible with other arguments [at 1:8]
select fn_named_arguments_returns_string(string_binary,
       ^
==

# Throw an error if aggregate function's arguments have different collation
select fn_agg_string_string_collation(string_ci, string_binary)
from CollatedTable
--
ERROR: Collation conflict: "binary" vs. "und:ci". Collation on argument 2 ("binary") in function SAMPLE_FUNCTIONS:FN_AGG_STRING_STRING_COLLATION is not compatible with other arguments [at 1:8]
select fn_agg_string_string_collation(string_ci, string_binary)
       ^
==

# Throw an error if analytic function's arguments have different collation
select fn_agg_string_string_collation(string_ci, string_binary) OVER ()
from CollatedTable
--
ERROR: Collation conflict: "binary" vs. "und:ci". Collation on argument 2 ("binary") in function SAMPLE_FUNCTIONS:FN_AGG_STRING_STRING_COLLATION is not compatible with other arguments [at 1:8]
select fn_agg_string_string_collation(string_ci, string_binary) OVER ()
       ^
==

# Default propagation skips function that has return type not supporting
# collation
select
  NET.IP_IN_NET(string_ci, 'abc'),
  NET.IP_IN_NET(string_ci, string_binary),
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [BOOL]
| +-$query.$col2#6 AS "$col2" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:net.ip_in_net(STRING, STRING) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | +-$col2#6 :=
    |   +-FunctionCall(ZetaSQL:net.ip_in_net(STRING, STRING) -> BOOL)
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
==

# Test all analytic functions with operation collation that we have the
# <collation_list> set for each of the ResolvedAnalyticFunctionCall.
# See (broken link).
# Cases are ordered alphabetically.
[language_features=NUMERIC_TYPE,ANALYTIC_FUNCTIONS,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT]

select
  -- PERCENTILE_DISC(<T1>, FLOAT64 /*must_be_non_null*/ NOT AGGREGATE)
  percentile_disc(string_ci, 0.1) OVER(),
  -- PERCENTILE_DISC(<T1>, NUMERIC /*must_be_non_null*/ NOT AGGREGATE)
  percentile_disc(string_ci, NUMERIC '0.1') OVER(),
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#7{Collation:"und:ci"} AS "$col1" [STRING]
| +-$analytic.$analytic2#8{Collation:"und:ci"} AS "$col2" [STRING]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#7, $analytic2#8]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, $analytic.$analytic1#7{Collation:"und:ci"}, $analytic.$analytic2#8{Collation:"und:ci"}]
        +-input_scan=
        | +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#7 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_disc(STRING, DOUBLE) -> STRING)
              |   +-type_annotation_map={Collation:"und:ci"}
              |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
              |   +-Literal(type=DOUBLE, value=0.1, float_literal_id=2)
              |   +-collation_list=[und:ci]
              +-$analytic2#8 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(STRING, NUMERIC) -> STRING)
                  +-type_annotation_map={Collation:"und:ci"}
                  +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
                  +-Literal(type=NUMERIC, value=0.1, has_explicit_type=TRUE)
                  +-collation_list=[und:ci]
==

# Test all scalar functions with operation collation that we have the
# <collation_list> set for each of the ResolvedFunctionCall.
# See (broken link).
# Cases are ordered alphabetically.
[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_IS_DISTINCT,V_1_3_ADDITIONAL_STRING_FUNCTIONS,V_1_3_LIKE_ANY_SOME_ALL]

select
  -- $between
  string_ci between 'a' and 'z',
  -- $equal
  string_ci = 'abc',
  -- $greater
  string_ci > 'abc',
  -- $greater_or_equal
  string_ci >= 'abc',
  -- $in
  string_ci in ('a', 'b', 'c'),
  -- $in_array
  string_ci in unnest(array_with_string_ci),
  -- $is_distinct_from
  string_ci is distinct from 'abc',
  -- $is_not_distinct_from
  string_ci is not distinct from 'abc',
  -- $less
  string_ci < 'abc',
  -- $less_or_equal
  string_ci <= 'abc',
  -- $not_equal
  string_ci != 'abc',
  ends_with(string_ci, 'abc'),
  greatest(string_ci, 'abc'),
  instr(string_ci, 'abc'),
  least(string_ci, 'abc'),
  replace(string_ci, 'abc', 'def'),
  split(string_ci),
  starts_with(string_ci, 'abc'),
  strpos(string_ci, 'abc'),
  range_bucket(string_ci, ['a', 'b']),
  range_bucket('a', array_with_string_ci)
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [BOOL]
| +-$query.$col2#6 AS "$col2" [BOOL]
| +-$query.$col3#7 AS "$col3" [BOOL]
| +-$query.$col4#8 AS "$col4" [BOOL]
| +-$query.$col5#9 AS "$col5" [BOOL]
| +-$query.$col6#10 AS "$col6" [BOOL]
| +-$query.$col7#11 AS "$col7" [BOOL]
| +-$query.$col8#12 AS "$col8" [BOOL]
| +-$query.$col9#13 AS "$col9" [BOOL]
| +-$query.$col10#14 AS "$col10" [BOOL]
| +-$query.$col11#15 AS "$col11" [BOOL]
| +-$query.$col12#16 AS "$col12" [BOOL]
| +-$query.$col13#17{Collation:"und:ci"} AS "$col13" [STRING]
| +-$query.$col14#18 AS "$col14" [INT64]
| +-$query.$col15#19{Collation:"und:ci"} AS "$col15" [STRING]
| +-$query.$col16#20{Collation:"und:ci"} AS "$col16" [STRING]
| +-$query.$col17#21[{Collation:"und:ci"}] AS "$col17" [ARRAY<STRING>]
| +-$query.$col18#22 AS "$col18" [BOOL]
| +-$query.$col19#23 AS "$col19" [INT64]
| +-$query.$col20#24 AS "$col20" [INT64]
| +-$query.$col21#25 AS "$col21" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8, $col5#9, $col6#10, $col7#11, $col8#12, $col9#13, $col10#14, $col11#15, $col12#16, $col13#17, $col14#18, $col15#19, $col16#20, $col17#21, $col18#22, $col19#23, $col20#24, $col21#25]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:$between(STRING, STRING, STRING) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='a')
    | |   +-Literal(type=STRING, value='z')
    | |   +-collation_list=[und:ci]
    | +-$col2#6 :=
    | | +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col3#7 :=
    | | +-FunctionCall(ZetaSQL:$greater(STRING, STRING) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col4#8 :=
    | | +-FunctionCall(ZetaSQL:$greater_or_equal(STRING, STRING) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col5#9 :=
    | | +-FunctionCall(ZetaSQL:$in(STRING, repeated(3) STRING) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='a')
    | |   +-Literal(type=STRING, value='b')
    | |   +-Literal(type=STRING, value='c')
    | |   +-collation_list=[und:ci]
    | +-$col6#10 :=
    | | +-FunctionCall(ZetaSQL:$in_array(STRING, ARRAY<STRING>) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    | |   +-collation_list=[und:ci]
    | +-$col7#11 :=
    | | +-FunctionCall(ZetaSQL:$is_distinct_from(STRING, STRING) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col8#12 :=
    | | +-FunctionCall(ZetaSQL:$is_not_distinct_from(STRING, STRING) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col9#13 :=
    | | +-FunctionCall(ZetaSQL:$less(STRING, STRING) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col10#14 :=
    | | +-FunctionCall(ZetaSQL:$less_or_equal(STRING, STRING) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col11#15 :=
    | | +-FunctionCall(ZetaSQL:$not_equal(STRING, STRING) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col12#16 :=
    | | +-FunctionCall(ZetaSQL:ends_with(STRING, STRING) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col13#17 :=
    | | +-FunctionCall(ZetaSQL:greatest(repeated(2) STRING) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col14#18 :=
    | | +-FunctionCall(ZetaSQL:instr(STRING, STRING, optional(0) INT64, optional(0) INT64) -> INT64)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col15#19 :=
    | | +-FunctionCall(ZetaSQL:least(repeated(2) STRING) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col16#20 :=
    | | +-FunctionCall(ZetaSQL:replace(STRING, STRING, STRING) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-Literal(type=STRING, value='def')
    | |   +-collation_list=[und:ci]
    | +-$col17#21 :=
    | | +-FunctionCall(ZetaSQL:split(STRING, optional(0) STRING) -> ARRAY<STRING>)
    | |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-collation_list=[und:ci]
    | +-$col18#22 :=
    | | +-FunctionCall(ZetaSQL:starts_with(STRING, STRING) -> BOOL)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col19#23 :=
    | | +-FunctionCall(ZetaSQL:strpos(STRING, STRING) -> INT64)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='abc')
    | |   +-collation_list=[und:ci]
    | +-$col20#24 :=
    | | +-FunctionCall(ZetaSQL:range_bucket(STRING, ARRAY<STRING>) -> INT64)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=ARRAY<STRING>, value=['a', 'b'])
    | |   +-collation_list=[und:ci]
    | +-$col21#25 :=
    |   +-FunctionCall(ZetaSQL:range_bucket(STRING, ARRAY<STRING>) -> INT64)
    |     +-Literal(type=STRING, value='a')
    |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    |     +-collation_list=[und:ci]
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 3])
==

# Struct comparison, = and !=, same collation in the same string field.
select
  (1, string_ci) = (2, collate('abc', 'und:ci')),
  (1, COLLATE('abc', 'und:ci')) != (2, string_ci)
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [BOOL]
| +-$query.$col2#6 AS "$col2" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:$equal(STRUCT<INT64, STRING>, STRUCT<INT64, STRING>) -> BOOL)
    | |   +-MakeStruct
    | |   | +-type=STRUCT<INT64, STRING>
    | |   | +-type_annotation_map=<_,{Collation:"und:ci"}>
    | |   | +-field_list=
    | |   |   +-Literal(type=INT64, value=1)
    | |   |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-MakeStruct
    | |     +-type=STRUCT<INT64, STRING>
    | |     +-type_annotation_map=<_,{Collation:"und:ci"}>
    | |     +-field_list=
    | |       +-Literal(type=INT64, value=2)
    | |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |         +-type_annotation_map={Collation:"und:ci"}
    | |         +-Literal(type=STRING, value='abc')
    | |         +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |   +-collation_list=[[_,und:ci]]
    | +-$col2#6 :=
    |   +-FunctionCall(ZetaSQL:$not_equal(STRUCT<INT64, STRING>, STRUCT<INT64, STRING>) -> BOOL)
    |     +-MakeStruct
    |     | +-type=STRUCT<INT64, STRING>
    |     | +-type_annotation_map=<_,{Collation:"und:ci"}>
    |     | +-field_list=
    |     |   +-Literal(type=INT64, value=1)
    |     |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |     +-type_annotation_map={Collation:"und:ci"}
    |     |     +-Literal(type=STRING, value='abc')
    |     |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-MakeStruct
    |       +-type=STRUCT<INT64, STRING>
    |       +-type_annotation_map=<_,{Collation:"und:ci"}>
    |       +-field_list=
    |         +-Literal(type=INT64, value=2)
    |         +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     +-collation_list=[[_,und:ci]]
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
==

# Struct comparison, = and !=, different but not conflicting collation in the same field.
select
  (1, Value) = (2, collate('abc', 'und:ci')),
  (1, collate('abc', 'und:ci')) != (2, Value)
from KeyValue
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS "$col1" [BOOL]
| +-$query.$col2#4 AS "$col2" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#3, $col2#4]
    +-expr_list=
    | +-$col1#3 :=
    | | +-FunctionCall(ZetaSQL:$equal(STRUCT<INT64, STRING>, STRUCT<INT64, STRING>) -> BOOL)
    | |   +-MakeStruct
    | |   | +-type=STRUCT<INT64, STRING>
    | |   | +-field_list=
    | |   |   +-Literal(type=INT64, value=1)
    | |   |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    | |   +-MakeStruct
    | |     +-type=STRUCT<INT64, STRING>
    | |     +-type_annotation_map=<_,{Collation:"und:ci"}>
    | |     +-field_list=
    | |       +-Literal(type=INT64, value=2)
    | |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |         +-type_annotation_map={Collation:"und:ci"}
    | |         +-Literal(type=STRING, value='abc')
    | |         +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |   +-collation_list=[[_,und:ci]]
    | +-$col2#4 :=
    |   +-FunctionCall(ZetaSQL:$not_equal(STRUCT<INT64, STRING>, STRUCT<INT64, STRING>) -> BOOL)
    |     +-MakeStruct
    |     | +-type=STRUCT<INT64, STRING>
    |     | +-type_annotation_map=<_,{Collation:"und:ci"}>
    |     | +-field_list=
    |     |   +-Literal(type=INT64, value=1)
    |     |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |     +-type_annotation_map={Collation:"und:ci"}
    |     |     +-Literal(type=STRING, value='abc')
    |     |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-MakeStruct
    |       +-type=STRUCT<INT64, STRING>
    |       +-field_list=
    |         +-Literal(type=INT64, value=2)
    |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-collation_list=[[_,und:ci]]
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
==

# Struct comparison, = and !=, different but not conflicting collation in the multiple string fields.
select
  (1, Value, collate('abc', 'binary')) = (2, collate('def', 'und:ci'), Value),
  (1, collate('def', 'und:ci'), Value) = (2, Value, collate('abc', 'binary')),
from KeyValue
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS "$col1" [BOOL]
| +-$query.$col2#4 AS "$col2" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#3, $col2#4]
    +-expr_list=
    | +-$col1#3 :=
    | | +-FunctionCall(ZetaSQL:$equal(STRUCT<INT64, STRING, STRING>, STRUCT<INT64, STRING, STRING>) -> BOOL)
    | |   +-MakeStruct
    | |   | +-type=STRUCT<INT64, STRING, STRING>
    | |   | +-type_annotation_map=<_,_,{Collation:"binary"}>
    | |   | +-field_list=
    | |   |   +-Literal(type=INT64, value=1)
    | |   |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    | |   |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |   |     +-type_annotation_map={Collation:"binary"}
    | |   |     +-Literal(type=STRING, value='abc')
    | |   |     +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
    | |   +-MakeStruct
    | |     +-type=STRUCT<INT64, STRING, STRING>
    | |     +-type_annotation_map=<_,{Collation:"und:ci"},_>
    | |     +-field_list=
    | |       +-Literal(type=INT64, value=2)
    | |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |       | +-type_annotation_map={Collation:"und:ci"}
    | |       | +-Literal(type=STRING, value='def')
    | |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    | |   +-collation_list=[[_,und:ci,binary]]
    | +-$col2#4 :=
    |   +-FunctionCall(ZetaSQL:$equal(STRUCT<INT64, STRING, STRING>, STRUCT<INT64, STRING, STRING>) -> BOOL)
    |     +-MakeStruct
    |     | +-type=STRUCT<INT64, STRING, STRING>
    |     | +-type_annotation_map=<_,{Collation:"und:ci"},_>
    |     | +-field_list=
    |     |   +-Literal(type=INT64, value=1)
    |     |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |   | +-type_annotation_map={Collation:"und:ci"}
    |     |   | +-Literal(type=STRING, value='def')
    |     |   | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     +-MakeStruct
    |       +-type=STRUCT<INT64, STRING, STRING>
    |       +-type_annotation_map=<_,_,{Collation:"binary"}>
    |       +-field_list=
    |         +-Literal(type=INT64, value=2)
    |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |         +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |           +-type_annotation_map={Collation:"binary"}
    |           +-Literal(type=STRING, value='abc')
    |           +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
    |     +-collation_list=[[_,und:ci,binary]]
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
==

# Struct comparison, IN (), IN UNNEST, IN subquery, different but not conflicting collation in the multiple string fields.
select
  (1, 'abc', string_binary) in ((2, string_ci, 'def'), (3, 'hi', 'hello')),
  (1, 'abc', string_binary) in unnest ([(2, string_ci, 'def'), (3, 'hi', 'hello')]),
  (1, 'abc', string_binary) in (select (2, collate(Value, 'und:ci'), 'def') from KeyValue)
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS "$col1" [BOOL]
| +-$query.$col2#9 AS "$col2" [BOOL]
| +-$query.$col3#10 AS "$col3" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#8, $col2#9, $col3#10]
    +-expr_list=
    | +-$col1#8 :=
    | | +-FunctionCall(ZetaSQL:$in(STRUCT<INT64, STRING, STRING>, repeated(2) STRUCT<INT64, STRING, STRING>) -> BOOL)
    | |   +-MakeStruct
    | |   | +-type=STRUCT<INT64, STRING, STRING>
    | |   | +-type_annotation_map=<_,_,{Collation:"binary"}>
    | |   | +-field_list=
    | |   |   +-Literal(type=INT64, value=1)
    | |   |   +-Literal(type=STRING, value='abc')
    | |   |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    | |   +-MakeStruct
    | |   | +-type=STRUCT<INT64, STRING, STRING>
    | |   | +-type_annotation_map=<_,{Collation:"und:ci"},_>
    | |   | +-field_list=
    | |   |   +-Literal(type=INT64, value=2)
    | |   |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   |   +-Literal(type=STRING, value='def')
    | |   +-Literal(type=STRUCT<INT64, STRING, STRING>, value={3, 'hi', 'hello'})
    | |   +-collation_list=[[_,und:ci,binary]]
    | +-$col2#9 :=
    | | +-FunctionCall(ZetaSQL:$in_array(STRUCT<INT64, STRING, STRING>, ARRAY<STRUCT<INT64, STRING, STRING>>) -> BOOL)
    | |   +-MakeStruct
    | |   | +-type=STRUCT<INT64, STRING, STRING>
    | |   | +-type_annotation_map=<_,_,{Collation:"binary"}>
    | |   | +-field_list=
    | |   |   +-Literal(type=INT64, value=1)
    | |   |   +-Literal(type=STRING, value='abc')
    | |   |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    | |   +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRUCT<INT64, STRING, STRING>) -> ARRAY<STRUCT<INT64, STRING, STRING>>)
    | |     +-type_annotation_map=[<_,{Collation:"und:ci"},_>]
    | |     +-MakeStruct
    | |     | +-type=STRUCT<INT64, STRING, STRING>
    | |     | +-type_annotation_map=<_,{Collation:"und:ci"},_>
    | |     | +-field_list=
    | |     |   +-Literal(type=INT64, value=2)
    | |     |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |     |   +-Literal(type=STRING, value='def')
    | |     +-Literal(type=STRUCT<INT64, STRING, STRING>, value={3, 'hi', 'hello'})
    | |   +-collation_list=[[_,und:ci,binary]]
    | +-$col3#10 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-MakeStruct
    |     |   +-type=STRUCT<INT64, STRING, STRING>
    |     |   +-type_annotation_map=<_,_,{Collation:"binary"}>
    |     |   +-field_list=
    |     |     +-Literal(type=INT64, value=1)
    |     |     +-Literal(type=STRING, value='abc')
    |     |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    |     +-in_collation=[_,und:ci,binary]
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#7<_,{Collation:"und:ci"},_>]
    |         +-expr_list=
    |         | +-$col1#7 :=
    |         |   +-MakeStruct
    |         |     +-type=STRUCT<INT64, STRING, STRING>
    |         |     +-type_annotation_map=<_,{Collation:"und:ci"},_>
    |         |     +-field_list=
    |         |       +-Literal(type=INT64, value=2)
    |         |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |         |       | +-type_annotation_map={Collation:"und:ci"}
    |         |       | +-ColumnRef(type=STRING, column=KeyValue.Value#6)
    |         |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |         |       +-Literal(type=STRING, value='def')
    |         +-input_scan=
    |           +-TableScan(column_list=[KeyValue.Value#6], table=KeyValue, column_index_list=[1])
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
==

select
  # For function:
  # CASE (<T2>) WHEN (/*repeated*/ <T2>)
  #             THEN (/*repeated*/ <T1>)
  #             ELSE (<T1>) END
  # Verify that the operation collation is calculated from T2
  case string_ci when 'a' then 1 when 'b' then 2 else 3 end,

  # Verify that the propagation collation is calculated from T1
  case 'abc' when 'a' then string_ci when 'b' then 'a' else 'b' end,

  # Verify that the collation on T1 doesn't conflict with collation on T2
  case string_ci when 'a' then string_binary when 'b' then 'a' else 'b' end,
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [INT64]
| +-$query.$col2#6{Collation:"und:ci"} AS "$col2" [STRING]
| +-$query.$col3#7{Collation:"binary"} AS "$col3" [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:$case_with_value(STRING, repeated(2) STRING, repeated(2) INT64, INT64) -> INT64)
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='a')
    | |   +-Literal(type=INT64, value=1)
    | |   +-Literal(type=STRING, value='b')
    | |   +-Literal(type=INT64, value=2)
    | |   +-Literal(type=INT64, value=3)
    | |   +-collation_list=[und:ci]
    | +-$col2#6 :=
    | | +-FunctionCall(ZetaSQL:$case_with_value(STRING, repeated(2) STRING, repeated(2) STRING, STRING) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-Literal(type=STRING, value='abc')
    | |   +-Literal(type=STRING, value='a')
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-Literal(type=STRING, value='b')
    | |   +-Literal(type=STRING, value='a')
    | |   +-Literal(type=STRING, value='b')
    | +-$col3#7 :=
    |   +-FunctionCall(ZetaSQL:$case_with_value(STRING, repeated(2) STRING, repeated(2) STRING, STRING) -> STRING)
    |     +-type_annotation_map={Collation:"binary"}
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     +-Literal(type=STRING, value='a')
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    |     +-Literal(type=STRING, value='b')
    |     +-Literal(type=STRING, value='a')
    |     +-Literal(type=STRING, value='b')
    |     +-collation_list=[und:ci]
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
==

# Struct comparison, $case_with_value, different but not conflicting collation in the multiple string fields.
select
  case (1, 'abc', string_binary)
    when (2, string_ci, 'def') then 1
    when (3, 'hi', 'hello') then 2
    else 3 end
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:$case_with_value(STRUCT<INT64, STRING, STRING>, repeated(2) STRUCT<INT64, STRING, STRING>, repeated(2) INT64, INT64) -> INT64)
    |     +-MakeStruct
    |     | +-type=STRUCT<INT64, STRING, STRING>
    |     | +-type_annotation_map=<_,_,{Collation:"binary"}>
    |     | +-field_list=
    |     |   +-Literal(type=INT64, value=1)
    |     |   +-Literal(type=STRING, value='abc')
    |     |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    |     +-MakeStruct
    |     | +-type=STRUCT<INT64, STRING, STRING>
    |     | +-type_annotation_map=<_,{Collation:"und:ci"},_>
    |     | +-field_list=
    |     |   +-Literal(type=INT64, value=2)
    |     |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     |   +-Literal(type=STRING, value='def')
    |     +-Literal(type=INT64, value=1)
    |     +-Literal(type=STRUCT<INT64, STRING, STRING>, value={3, 'hi', 'hello'})
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=INT64, value=3)
    |     +-collation_list=[[_,und:ci,binary]]
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
==

[no_run_unparser]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# Result collation of $case_with_value, different but not conflicting collation in the multiple string fields.
select
  case Key
    when 1 then (1, 'abc', COLLATE(Value, 'binary'))
    when 2 then (2, COLLATE(Value, 'und:ci'), 'def')
    else (3, 'hi', 'hello') end
from KeyValue
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3<_,{Collation:"und:ci"},{Collation:"binary"}> AS "$col1" [STRUCT<INT64, STRING, STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3<_,{Collation:"und:ci"},{Collation:"binary"}>]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:$case_with_value(INT64, repeated(2) INT64, repeated(2) STRUCT<INT64, STRING, STRING>, STRUCT<INT64, STRING, STRING>) -> STRUCT<INT64, STRING, STRING>)
    |     +-type_annotation_map=<_,{Collation:"und:ci"},{Collation:"binary"}>
    |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-Literal(type=INT64, value=1)
    |     +-MakeStruct
    |     | +-type=STRUCT<INT64, STRING, STRING>
    |     | +-type_annotation_map=<_,_,{Collation:"binary"}>
    |     | +-field_list=
    |     |   +-Literal(type=INT64, value=1)
    |     |   +-Literal(type=STRING, value='abc')
    |     |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |     +-type_annotation_map={Collation:"binary"}
    |     |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     |     +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
    |     +-Literal(type=INT64, value=2)
    |     +-MakeStruct
    |     | +-type=STRUCT<INT64, STRING, STRING>
    |     | +-type_annotation_map=<_,{Collation:"und:ci"},_>
    |     | +-field_list=
    |     |   +-Literal(type=INT64, value=2)
    |     |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |   | +-type_annotation_map={Collation:"und:ci"}
    |     |   | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |     |   | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     |   +-Literal(type=STRING, value='def')
    |     +-Literal(type=STRUCT<INT64, STRING, STRING>, value={3, 'hi', 'hello'})
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
==

# Aggregate function call with distinct should resolve the collation for the
# 'distinct' operation.
select
  count(string_ci)              fn_count, # Shouldn't have resolved collation
  count(distinct string_ci)     fn_count_distinct,
  array_agg(distinct string_ci) fn_array_agg,
  array_concat_agg(distinct array_with_string_ci) fn_array_concat_agg,
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.fn_count#5 AS fn_count [INT64]
| +-$aggregate.fn_count_distinct#6 AS fn_count_distinct [INT64]
| +-$aggregate.fn_array_agg#7[{Collation:"und:ci"}] AS fn_array_agg [ARRAY<STRING>]
| +-$aggregate.fn_array_concat_agg#8[{Collation:"und:ci"}] AS fn_array_concat_agg [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[fn_count#5, fn_count_distinct#6, fn_array_agg#7, fn_array_concat_agg#8]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[fn_count#5, fn_count_distinct#6, fn_array_agg#7, fn_array_concat_agg#8]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 3])
        +-aggregate_list=
          +-fn_count#5 :=
          | +-AggregateFunctionCall(ZetaSQL:count(STRING) -> INT64)
          |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
          +-fn_count_distinct#6 :=
          | +-AggregateFunctionCall(ZetaSQL:count(STRING) -> INT64)
          |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
          |   +-collation_list=[und:ci]
          |   +-distinct=TRUE
          +-fn_array_agg#7 :=
          | +-AggregateFunctionCall(ZetaSQL:array_agg(STRING) -> ARRAY<STRING>)
          |   +-type_annotation_map=[{Collation:"und:ci"}]
          |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
          |   +-collation_list=[und:ci]
          |   +-distinct=TRUE
          +-fn_array_concat_agg#8 :=
            +-AggregateFunctionCall(ZetaSQL:array_concat_agg(ARRAY<STRING>) -> ARRAY<STRING>)
              +-type_annotation_map=[{Collation:"und:ci"}]
              +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
              +-collation_list=[[und:ci]]
              +-distinct=TRUE
==

# Analytic function call with distinct should resolve the collation for the
# 'distinct' operation.
select
  count(string_ci) over ()                  fn_analytic_count, # Shouldn't have resolved collation
  count(distinct length(string_ci)) over () fn_analytic_count_int, # Shouldn't have resolved collation
  count(distinct string_ci) over ()         fn_analytic_count_distinct
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$analytic.fn_analytic_count#8 AS fn_analytic_count [INT64]
| +-$analytic.fn_analytic_count_int#9 AS fn_analytic_count_int [INT64]
| +-$analytic.fn_analytic_count_distinct#10 AS fn_analytic_count_distinct [INT64]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[fn_analytic_count#8, fn_analytic_count_int#9, fn_analytic_count_distinct#10]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, $analytic.fn_analytic_count#8, $analytic.fn_analytic_count_int#9, $analytic.fn_analytic_count_distinct#10]
        +-input_scan=
        | +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-fn_analytic_count#8 :=
              | +-AnalyticFunctionCall(ZetaSQL:count(STRING) -> INT64)
              |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
              |   +-window_frame=
              |     +-WindowFrame(frame_unit=ROWS)
              |       +-start_expr=
              |       | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
              |       +-end_expr=
              |         +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
              +-fn_analytic_count_int#9 :=
              | +-AnalyticFunctionCall(ZetaSQL:count(INT64) -> INT64)
              |   +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
              |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
              |   +-distinct=TRUE
              |   +-window_frame=
              |     +-WindowFrame(frame_unit=ROWS)
              |       +-start_expr=
              |       | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
              |       +-end_expr=
              |         +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
              +-fn_analytic_count_distinct#10 :=
                +-AnalyticFunctionCall(ZetaSQL:count(STRING) -> INT64)
                  +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
                  +-collation_list=[und:ci]
                  +-distinct=TRUE
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

# Test all aggregate functions with operation collation that we have the
# <collation_list> set for each of the ResolvedAggregateFunctionCall.
# See (broken link).
# Cases are ordered alphabetically.

select
  approx_count_distinct(string_ci)                fn_approx_count_distinct,
  hll_count.init(string_ci)                       fn_hll_count_init,
  max(string_ci)                                  fn_max,
  min(string_ci)                                  fn_min,
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.fn_approx_count_distinct#5 AS fn_approx_count_distinct [INT64]
| +-$aggregate.fn_hll_count_init#6 AS fn_hll_count_init [BYTES]
| +-$aggregate.fn_max#7{Collation:"und:ci"} AS fn_max [STRING]
| +-$aggregate.fn_min#8{Collation:"und:ci"} AS fn_min [STRING]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[fn_approx_count_distinct#5, fn_hll_count_init#6, fn_max#7, fn_min#8]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[fn_approx_count_distinct#5, fn_hll_count_init#6, fn_max#7, fn_min#8]
        +-input_scan=
        | +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
        +-aggregate_list=
          +-fn_approx_count_distinct#5 :=
          | +-AggregateFunctionCall(ZetaSQL:approx_count_distinct(STRING) -> INT64)
          |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
          |   +-collation_list=[und:ci]
          +-fn_hll_count_init#6 :=
          | +-AggregateFunctionCall(ZetaSQL:hll_count.init(STRING, optional(0) INT64) -> BYTES)
          |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
          |   +-collation_list=[und:ci]
          +-fn_max#7 :=
          | +-AggregateFunctionCall(ZetaSQL:max(STRING) -> STRING)
          |   +-type_annotation_map={Collation:"und:ci"}
          |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
          |   +-collation_list=[und:ci]
          +-fn_min#8 :=
            +-AggregateFunctionCall(ZetaSQL:min(STRING) -> STRING)
              +-type_annotation_map={Collation:"und:ci"}
              +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
              +-collation_list=[und:ci]
==

# Throw an error when resolving operation collation, arguments have different
# collations
select string_ci != string_binary
from CollatedTable
--
ERROR: Collation conflict: "binary" vs. "und:ci". Collation on argument 2 ("binary") in function != is not compatible with other arguments [at 1:8]
select string_ci != string_binary
       ^
==

# Tests that other annotation doesn't affect the propagation and resolution of
# collation.
[enable_sample_annotation]
select
  concat(string, string),
  string = 'abc',
from AnnotatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS "$col1" [STRING]
| +-$query.$col2#8 AS "$col2" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#7, $col2#8]
    +-expr_list=
    | +-$col1#7 :=
    | | +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    | |   +-ColumnRef(type=STRING, type_annotation_map={SampleAnnotation:0}, column=AnnotatedTable.string#1{SampleAnnotation:0})
    | |   +-ColumnRef(type=STRING, type_annotation_map={SampleAnnotation:0}, column=AnnotatedTable.string#1{SampleAnnotation:0})
    | +-$col2#8 :=
    |   +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |     +-ColumnRef(type=STRING, type_annotation_map={SampleAnnotation:0}, column=AnnotatedTable.string#1{SampleAnnotation:0})
    |     +-Literal(type=STRING, value='abc')
    +-input_scan=
      +-TableScan(column_list=[AnnotatedTable.string#1{SampleAnnotation:0}], table=AnnotatedTable, column_index_list=[0])
==

# Order by list of columns
select string_ci, string_binary
from CollatedTable
order by string_ci, string_binary, array_with_string_ci
--
QueryStmt
+-output_column_list=
| +-CollatedTable.string_ci#1{Collation:"und:ci"} AS string_ci [STRING]
| +-CollatedTable.string_binary#2{Collation:"binary"} AS string_binary [STRING]
+-query=
  +-OrderByScan
    +-column_list=CollatedTable.[string_ci#1, string_binary#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 3])
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      | | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
      | +-collation=und:ci
      +-OrderByItem
      | +-column_ref=
      | | +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
      | +-collation=binary
      +-OrderByItem
        +-column_ref=
        | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
        +-collation=[und:ci]
==

# Order by list of expressions
select struct_with_string_ci
from CollatedTable
order by concat(string_ci, 'abc'), struct_with_string_ci.b
--
QueryStmt
+-output_column_list=
| +-CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}> AS struct_with_string_ci [STRUCT<a INT32, b STRING>]
+-query=
  +-OrderByScan
    +-column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>]
    +-is_ordered=TRUE
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>, $orderby.$orderbycol1#5{Collation:"und:ci"}, $orderby.$orderbycol2#6{Collation:"und:ci"}]
    |   +-expr_list=
    |   | +-$orderbycol1#5 :=
    |   | | +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |   | |   +-type_annotation_map={Collation:"und:ci"}
    |   | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |   | |   +-Literal(type=STRING, value='abc')
    |   | +-$orderbycol2#6 :=
    |   |   +-GetStructField
    |   |     +-type=STRING
    |   |     +-type_annotation_map={Collation:"und:ci"}
    |   |     +-expr=
    |   |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    |   |     +-field_idx=1
    |   +-input_scan=
    |     +-TableScan(column_list=CollatedTable.[string_ci#1, struct_with_string_ci#3], table=CollatedTable, column_index_list=[0, 2])
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      | | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$orderby.$orderbycol1#5{Collation:"und:ci"})
      | +-collation=und:ci
      +-OrderByItem
        +-column_ref=
        | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$orderby.$orderbycol2#6{Collation:"und:ci"})
        +-collation=und:ci
==

# COLLATE clause should override collation from the order by expression
select string_ci, string_binary
from CollatedTable
order by string_ci COLLATE 'binary',
         string_binary COLLATE @test_param_string
--
QueryStmt
+-output_column_list=
| +-CollatedTable.string_ci#1{Collation:"und:ci"} AS string_ci [STRING]
| +-CollatedTable.string_binary#2{Collation:"binary"} AS string_binary [STRING]
+-query=
  +-OrderByScan
    +-column_list=CollatedTable.[string_ci#1, string_binary#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
    +-order_by_item_list=
      +-OrderByItem
      | +-column_ref=
      | | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
      | +-collation_name=
      | | +-Literal(type=STRING, value='binary')
      | +-collation=binary
      +-OrderByItem
        +-column_ref=
        | +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        +-collation_name=
          +-Parameter(type=STRING, name='test_param_string')
==

# Order by within aggregate function call
select string_agg(string_ci order by string_ci),
       -- expression collation overridden by 'COLLATE' clause
       string_agg(string_ci order by string_ci COLLATE 'en_us'),
       string_agg(string_ci order by string_ci COLLATE @test_param_string),
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5{Collation:"und:ci"} AS "$col1" [STRING]
| +-$aggregate.$agg2#6{Collation:"und:ci"} AS "$col2" [STRING]
| +-$aggregate.$agg3#7{Collation:"und:ci"} AS "$col3" [STRING]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#5, $agg2#6, $agg3#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#5, $agg2#6, $agg3#7]
        +-input_scan=
        | +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#5 :=
          | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
          |   +-type_annotation_map={Collation:"und:ci"}
          |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
          |   +-order_by_item_list=
          |     +-OrderByItem
          |       +-column_ref=
          |       | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
          |       +-collation=und:ci
          +-$agg2#6 :=
          | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
          |   +-type_annotation_map={Collation:"und:ci"}
          |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
          |   +-order_by_item_list=
          |     +-OrderByItem
          |       +-column_ref=
          |       | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
          |       +-collation_name=
          |       | +-Literal(type=STRING, value='en_us')
          |       +-collation=en_us
          +-$agg3#7 :=
            +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
              +-type_annotation_map={Collation:"und:ci"}
              +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
              +-order_by_item_list=
                +-OrderByItem
                  +-column_ref=
                  | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
                  +-collation_name=
                    +-Parameter(type=STRING, name='test_param_string')
==

# Order by for analytic function
select afn_agg()
       over (order by string_ci, concat(string_binary, 'abc'))
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#6 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, CollatedTable.string_binary#2{Collation:"binary"}, $analytic.$analytic1#6]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, CollatedTable.string_binary#2{Collation:"binary"}, $orderby.$orderbycol2#7{Collation:"binary"}]
        |   +-expr_list=
        |   | +-$orderbycol2#7 :=
        |   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
        |   |     +-type_annotation_map={Collation:"binary"}
        |   |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        |   |     +-Literal(type=STRING, value='abc')
        |   +-input_scan=
        |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |     | +-column_ref=
            |     | | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
            |     | +-collation=und:ci
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=$orderby.$orderbycol2#7{Collation:"binary"})
            |       +-collation=binary
            +-analytic_function_list=
              +-$analytic1#6 :=
                +-AnalyticFunctionCall(sample_functions:afn_agg() -> INT64)
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

# Partition by for analytic function
select afn_agg()
       over (partition by string_ci, string_binary)
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#6 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, CollatedTable.string_binary#2{Collation:"binary"}, $analytic.$analytic1#6]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |   | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
            |   | +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
            |   +-collation_list=[und:ci,binary]
            +-analytic_function_list=
              +-$analytic1#6 :=
                +-AnalyticFunctionCall(sample_functions:afn_agg() -> INT64)
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

# Partition by and order by for analytic function
select afn_agg()
       over (partition by string_ci, string_binary
             order by string_ci, string_binary)
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#6 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, CollatedTable.string_binary#2{Collation:"binary"}, $analytic.$analytic1#6]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |   | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
            |   | +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
            |   +-collation_list=[und:ci,binary]
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |     | +-column_ref=
            |     | | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
            |     | +-collation=und:ci
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
            |       +-collation=binary
            +-analytic_function_list=
              +-$analytic1#6 :=
                +-AnalyticFunctionCall(sample_functions:afn_agg() -> INT64)
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

# Collation in partition key and sort key in analytic does not get propogated to
# the function result.
select min(collate(string_ci, ''))
       over (partition by string_ci, string_binary
             order by string_ci, string_binary)
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#6 AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, CollatedTable.string_binary#2{Collation:"binary"}, $analytic.$analytic1#6]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |   | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
            |   | +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
            |   +-collation_list=[und:ci,binary]
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |     | +-column_ref=
            |     | | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
            |     | +-collation=und:ci
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
            |       +-collation=binary
            +-analytic_function_list=
              +-$analytic1#6 :=
                +-AnalyticFunctionCall(ZetaSQL:min(STRING) -> STRING)
                  +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
                    +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
                    +-Literal(type=STRING, value='', preserve_in_literal_remover=TRUE)
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

# Partition by and order by for analytic function, partition keys and order
# keys have different collation
select afn_agg()
       over (partition by string_ci
             order by string_binary)
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#6 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, CollatedTable.string_binary#2{Collation:"binary"}, $analytic.$analytic1#6]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |   | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
            |   +-collation_list=[und:ci]
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
            |       +-collation=binary
            +-analytic_function_list=
              +-$analytic1#6 :=
                +-AnalyticFunctionCall(sample_functions:afn_agg() -> INT64)
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

# COLLATE clause should override collation from the order by expression
select afn_agg()
         over (order by string_ci COLLATE 'und:ci:ai',
               concat(string_binary, 'abc') COLLATE 'und:ci:ai'),
       afn_agg()
         over (order by string_ci COLLATE @test_param_string)
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#7 AS "$col1" [INT64]
| +-$analytic.$analytic2#8 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#7, $analytic2#8]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, CollatedTable.string_binary#2{Collation:"binary"}, $analytic.$analytic1#7, $analytic.$analytic2#8]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, CollatedTable.string_binary#2{Collation:"binary"}, $orderby.$orderbycol2#9{Collation:"binary"}]
        |   +-expr_list=
        |   | +-$orderbycol2#9 :=
        |   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
        |   |     +-type_annotation_map={Collation:"binary"}
        |   |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        |   |     +-Literal(type=STRING, value='abc')
        |   +-input_scan=
        |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |     | +-column_ref=
          | |     | | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
          | |     | +-collation_name=
          | |     | | +-Literal(type=STRING, value='und:ci:ai')
          | |     | +-collation=und:ci:ai
          | |     +-OrderByItem
          | |       +-column_ref=
          | |       | +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=$orderby.$orderbycol2#9{Collation:"binary"})
          | |       +-collation_name=
          | |       | +-Literal(type=STRING, value='und:ci:ai')
          | |       +-collation=und:ci:ai
          | +-analytic_function_list=
          |   +-$analytic1#7 :=
          |     +-AnalyticFunctionCall(sample_functions:afn_agg() -> INT64)
          |       +-window_frame=
          |         +-WindowFrame(frame_unit=RANGE)
          |           +-start_expr=
          |           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
          |           +-end_expr=
          |             +-WindowFrameExpr(boundary_type=CURRENT ROW)
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
            |       +-collation_name=
            |         +-Parameter(type=STRING, name='test_param_string')
            +-analytic_function_list=
              +-$analytic2#8 :=
                +-AnalyticFunctionCall(sample_functions:afn_agg() -> INT64)
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

select string_ci, string_binary, struct_with_string_ci
from CollatedTable
group by string_ci, string_binary, struct_with_string_ci
--
QueryStmt
+-output_column_list=
| +-$groupby.string_ci#5{Collation:"und:ci"} AS string_ci [STRING]
| +-$groupby.string_binary#6{Collation:"binary"} AS string_binary [STRING]
| +-$groupby.struct_with_string_ci#7<_,{Collation:"und:ci"}> AS struct_with_string_ci [STRUCT<a INT32, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[string_ci#5, string_binary#6, struct_with_string_ci#7]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[string_ci#5, string_binary#6, struct_with_string_ci#7]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3], table=CollatedTable, column_index_list=[0, 1, 2])
        +-group_by_list=
        | +-string_ci#5 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        | +-string_binary#6 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        | +-struct_with_string_ci#7 := ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
        +-collation_list=[und:ci,binary,[_,und:ci]]
==

select distinct 1, 'abc', string_ci, concat(string_binary, 'abc'), struct_with_string_ci
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$distinct.$col1#8 AS "$col1" [INT64]
| +-$distinct.$col2#9 AS "$col2" [STRING]
| +-$distinct.string_ci#10{Collation:"und:ci"} AS string_ci [STRING]
| +-$distinct.$col4#11{Collation:"binary"} AS "$col4" [STRING]
| +-$distinct.struct_with_string_ci#12<_,{Collation:"und:ci"}> AS struct_with_string_ci [STRUCT<a INT32, b STRING>]
+-query=
  +-AggregateScan
    +-column_list=$distinct.[$col1#8, $col2#9, string_ci#10, $col4#11, struct_with_string_ci#12]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, CollatedTable.string_binary#2{Collation:"binary"}, CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>, $query.$col1#5, $query.$col2#6, $query.$col4#7{Collation:"binary"}]
    |   +-expr_list=
    |   | +-$col1#5 := Literal(type=INT64, value=1)
    |   | +-$col2#6 := Literal(type=STRING, value='abc')
    |   | +-$col4#7 :=
    |   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |   |     +-type_annotation_map={Collation:"binary"}
    |   |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    |   |     +-Literal(type=STRING, value='abc')
    |   +-input_scan=
    |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3], table=CollatedTable, column_index_list=[0, 1, 2])
    +-group_by_list=
    | +-$col1#8 := ColumnRef(type=INT64, column=$query.$col1#5)
    | +-$col2#9 := ColumnRef(type=STRING, column=$query.$col2#6)
    | +-string_ci#10 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | +-$col4#11 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=$query.$col4#7{Collation:"binary"})
    | +-struct_with_string_ci#12 := ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    +-collation_list=[_,_,und:ci,binary,[_,und:ci]]
==

# Test distinct expression from equivalent group by computed column
SELECT distinct concat(string_ci)
from CollatedTable
group by concat(string_ci)
--
QueryStmt
+-output_column_list=
| +-$distinct.$groupbycol1#6{Collation:"und:ci"} AS "$col1" [STRING]
+-query=
  +-AggregateScan
    +-column_list=[$distinct.$groupbycol1#6{Collation:"und:ci"}]
    +-input_scan=
    | +-AggregateScan
    |   +-column_list=[$groupby.$groupbycol1#5{Collation:"und:ci"}]
    |   +-input_scan=
    |   | +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
    |   +-group_by_list=
    |   | +-$groupbycol1#5 :=
    |   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(0) STRING) -> STRING)
    |   |     +-type_annotation_map={Collation:"und:ci"}
    |   |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |   +-collation_list=[und:ci]
    +-group_by_list=
    | +-$groupbycol1#6 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$groupby.$groupbycol1#5{Collation:"und:ci"})
    +-collation_list=[und:ci]
==

SELECT distinct * from CollatedTable;
--
QueryStmt
+-output_column_list=
| +-$distinct.string_ci#5{Collation:"und:ci"} AS string_ci [STRING]
| +-$distinct.string_binary#6{Collation:"binary"} AS string_binary [STRING]
| +-$distinct.struct_with_string_ci#7<_,{Collation:"und:ci"}> AS struct_with_string_ci [STRUCT<a INT32, b STRING>]
| +-$distinct.array_with_string_ci#8[{Collation:"und:ci"}] AS array_with_string_ci [ARRAY<STRING>]
+-query=
  +-AggregateScan
    +-column_list=$distinct.[string_ci#5, string_binary#6, struct_with_string_ci#7, array_with_string_ci#8]
    +-input_scan=
    | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 2, 3])
    +-group_by_list=
    | +-string_ci#5 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | +-string_binary#6 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    | +-struct_with_string_ci#7 := ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    | +-array_with_string_ci#8 := ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    +-collation_list=[und:ci,binary,[_,und:ci],[und:ci]]
==

SELECT * from CollatedTable GROUP BY 1,2,3,4;
--
QueryStmt
+-output_column_list=
| +-$groupby.string_ci#5{Collation:"und:ci"} AS string_ci [STRING]
| +-$groupby.string_binary#6{Collation:"binary"} AS string_binary [STRING]
| +-$groupby.struct_with_string_ci#7<_,{Collation:"und:ci"}> AS struct_with_string_ci [STRUCT<a INT32, b STRING>]
| +-$groupby.array_with_string_ci#8[{Collation:"und:ci"}] AS array_with_string_ci [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[string_ci#5, string_binary#6, struct_with_string_ci#7, array_with_string_ci#8]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[string_ci#5, string_binary#6, struct_with_string_ci#7, array_with_string_ci#8]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 2, 3])
        +-group_by_list=
        | +-string_ci#5 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        | +-string_binary#6 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        | +-struct_with_string_ci#7 := ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
        | +-array_with_string_ci#8 := ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
        +-collation_list=[und:ci,binary,[_,und:ci],[und:ci]]
==

# AggregateScan.collation_list is empty when none of the group by element has
# collation.
select distinct 1, 'abc', key+1, key from KeyValue
--
QueryStmt
+-output_column_list=
| +-$distinct.$col1#6 AS "$col1" [INT64]
| +-$distinct.$col2#7 AS "$col2" [STRING]
| +-$distinct.$col3#8 AS "$col3" [INT64]
| +-$distinct.Key#9 AS key [INT64]
+-query=
  +-AggregateScan
    +-column_list=$distinct.[$col1#6, $col2#7, $col3#8, Key#9]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[KeyValue.Key#1, $query.$col1#3, $query.$col2#4, $query.$col3#5]
    |   +-expr_list=
    |   | +-$col1#3 := Literal(type=INT64, value=1)
    |   | +-$col2#4 := Literal(type=STRING, value='abc')
    |   | +-$col3#5 :=
    |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |     +-Literal(type=INT64, value=1)
    |   +-input_scan=
    |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-group_by_list=
      +-$col1#6 := ColumnRef(type=INT64, column=$query.$col1#3)
      +-$col2#7 := ColumnRef(type=STRING, column=$query.$col2#4)
      +-$col3#8 := ColumnRef(type=INT64, column=$query.$col3#5)
      +-Key#9 := ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# Test precomputed column before aggregation.
# See QueryResolutionInfo::select_list_columns_to_compute_before_aggregation_.
select struct_with_string_ci.b as foo
from CollatedTable
group by struct_with_string_ci.b
having sum(length(foo)) > 1 and concat(foo) > 'abc'
--
QueryStmt
+-output_column_list=
| +-$groupby.b#6{Collation:"und:ci"} AS foo [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.b#6{Collation:"und:ci"}]
    +-input_scan=
      +-FilterScan
        +-column_list=[$groupby.b#6{Collation:"und:ci"}, $aggregate.$agg1#7]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.b#6{Collation:"und:ci"}, $aggregate.$agg1#7]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>, $pre_groupby.foo#5{Collation:"und:ci"}]
        |   |   +-expr_list=
        |   |   | +-foo#5 :=
        |   |   |   +-GetStructField
        |   |   |     +-type=STRING
        |   |   |     +-type_annotation_map={Collation:"und:ci"}
        |   |   |     +-expr=
        |   |   |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
        |   |   |     +-field_idx=1
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>], table=CollatedTable, column_index_list=[2])
        |   +-group_by_list=
        |   | +-b#6 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$pre_groupby.foo#5{Collation:"und:ci"})
        |   +-collation_list=[und:ci]
        |   +-aggregate_list=
        |     +-$agg1#7 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
        |         +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
        |           +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$pre_groupby.foo#5{Collation:"und:ci"})
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
            +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
            | +-ColumnRef(type=INT64, column=$aggregate.$agg1#7)
            | +-Literal(type=INT64, value=1)
            +-FunctionCall(ZetaSQL:$greater(STRING, STRING) -> BOOL)
              +-FunctionCall(ZetaSQL:concat(STRING, repeated(0) STRING) -> STRING)
              | +-type_annotation_map={Collation:"und:ci"}
              | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$groupby.b#6{Collation:"und:ci"})
              +-Literal(type=STRING, value='abc')
              +-collation_list=[und:ci]
==

# Group by list of expressions
select concat(string_ci, 'abc'), struct_with_string_ci.b
from CollatedTable
group by 1, 2
--
QueryStmt
+-output_column_list=
| +-$groupby.$col1#5{Collation:"und:ci"} AS "$col1" [STRING]
| +-$groupby.b#6{Collation:"und:ci"} AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=$groupby.[$col1#5, b#6]
    +-input_scan=
      +-AggregateScan
        +-column_list=$groupby.[$col1#5, b#6]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, struct_with_string_ci#3], table=CollatedTable, column_index_list=[0, 2])
        +-group_by_list=
        | +-$col1#5 :=
        | | +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
        | |   +-type_annotation_map={Collation:"und:ci"}
        | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        | |   +-Literal(type=STRING, value='abc')
        | +-b#6 :=
        |   +-GetStructField
        |     +-type=STRING
        |     +-type_annotation_map={Collation:"und:ci"}
        |     +-expr=
        |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
        |     +-field_idx=1
        +-collation_list=[und:ci,und:ci]
==

# Group by collated function
[no_enable_literal_replacement]
SELECT REPLACE(string_ci, 'a', 'b'), count(*)
FROM CollatedTable GROUP BY REPLACE(string_ci, 'a', 'b')
--
QueryStmt
+-output_column_list=
| +-$groupby.$groupbycol1#6{Collation:"und:ci"} AS "$col1" [STRING]
| +-$aggregate.$agg1#5 AS "$col2" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.$groupbycol1#6{Collation:"und:ci"}, $aggregate.$agg1#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.$groupbycol1#6{Collation:"und:ci"}, $aggregate.$agg1#5]
        +-input_scan=
        | +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
        +-group_by_list=
        | +-$groupbycol1#6 :=
        |   +-FunctionCall(ZetaSQL:replace(STRING, STRING, STRING) -> STRING)
        |     +-type_annotation_map={Collation:"und:ci"}
        |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        |     +-Literal(type=STRING, value='a')
        |     +-Literal(type=STRING, value='b')
        |     +-collation_list=[und:ci]
        +-collation_list=[und:ci]
        +-aggregate_list=
          +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)

==

# Test full join with using clause. It returns a value column made from the
# expression COALESCE(lhs_value, rhs_value). Collation should be propagated
# through the value column.
with t1 as (select collate('abc', 'und:ci') col_a, 1 col_b),
     t2 as (select collate('abc', 'und:ci') col_a, 1 col_c)
select *
from t1 {{left|right|full}} join t2 using (col_a)
--
ALTERNATION GROUP: left
--
QueryStmt
+-output_column_list=
| +-t1.col_a#5{Collation:"und:ci"} AS col_a [STRING]
| +-t1.col_b#6 AS col_b [INT64]
| +-t2.col_c#8 AS col_c [INT64]
+-query=
  +-WithScan
    +-column_list=[t1.col_a#5{Collation:"und:ci"}, t1.col_b#6, t2.col_c#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=t1.[col_a#1, col_b#2]
    | |     +-expr_list=
    | |     | +-col_a#1 :=
    | |     | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |     | |   +-type_annotation_map={Collation:"und:ci"}
    | |     | |   +-Literal(type=STRING, value='abc')
    | |     | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |     | +-col_b#2 := Literal(type=INT64, value=1)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t2.[col_a#3, col_c#4]
    |       +-expr_list=
    |       | +-col_a#3 :=
    |       | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | |   +-type_annotation_map={Collation:"und:ci"}
    |       | |   +-Literal(type=STRING, value='abc')
    |       | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       | +-col_c#4 := Literal(type=INT64, value=1)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[t1.col_a#5{Collation:"und:ci"}, t1.col_b#6, t2.col_c#8]
        +-input_scan=
          +-JoinScan
            +-column_list=[t1.col_a#5{Collation:"und:ci"}, t1.col_b#6, t2.col_a#7{Collation:"und:ci"}, t2.col_c#8]
            +-join_type=LEFT
            +-left_scan=
            | +-WithRefScan(column_list=t1.[col_a#5, col_b#6], with_query_name='t1')
            +-right_scan=
            | +-WithRefScan(column_list=t2.[col_a#7, col_c#8], with_query_name='t2')
            +-join_expr=
              +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
                +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t1.col_a#5{Collation:"und:ci"})
                +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t2.col_a#7{Collation:"und:ci"})
                +-collation_list=[und:ci]
--
ALTERNATION GROUP: right
--
QueryStmt
+-output_column_list=
| +-t2.col_a#7{Collation:"und:ci"} AS col_a [STRING]
| +-t1.col_b#6 AS col_b [INT64]
| +-t2.col_c#8 AS col_c [INT64]
+-query=
  +-WithScan
    +-column_list=[t2.col_a#7{Collation:"und:ci"}, t1.col_b#6, t2.col_c#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=t1.[col_a#1, col_b#2]
    | |     +-expr_list=
    | |     | +-col_a#1 :=
    | |     | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |     | |   +-type_annotation_map={Collation:"und:ci"}
    | |     | |   +-Literal(type=STRING, value='abc')
    | |     | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |     | +-col_b#2 := Literal(type=INT64, value=1)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t2.[col_a#3, col_c#4]
    |       +-expr_list=
    |       | +-col_a#3 :=
    |       | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | |   +-type_annotation_map={Collation:"und:ci"}
    |       | |   +-Literal(type=STRING, value='abc')
    |       | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       | +-col_c#4 := Literal(type=INT64, value=1)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[t2.col_a#7{Collation:"und:ci"}, t1.col_b#6, t2.col_c#8]
        +-input_scan=
          +-JoinScan
            +-column_list=[t1.col_a#5{Collation:"und:ci"}, t1.col_b#6, t2.col_a#7{Collation:"und:ci"}, t2.col_c#8]
            +-join_type=RIGHT
            +-left_scan=
            | +-WithRefScan(column_list=t1.[col_a#5, col_b#6], with_query_name='t1')
            +-right_scan=
            | +-WithRefScan(column_list=t2.[col_a#7, col_c#8], with_query_name='t2')
            +-join_expr=
              +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
                +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t1.col_a#5{Collation:"und:ci"})
                +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t2.col_a#7{Collation:"und:ci"})
                +-collation_list=[und:ci]
--
ALTERNATION GROUP: full
--
QueryStmt
+-output_column_list=
| +-$full_join.col_a#9{Collation:"und:ci"} AS col_a [STRING]
| +-t1.col_b#6 AS col_b [INT64]
| +-t2.col_c#8 AS col_c [INT64]
+-query=
  +-WithScan
    +-column_list=[$full_join.col_a#9{Collation:"und:ci"}, t1.col_b#6, t2.col_c#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=t1.[col_a#1, col_b#2]
    | |     +-expr_list=
    | |     | +-col_a#1 :=
    | |     | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |     | |   +-type_annotation_map={Collation:"und:ci"}
    | |     | |   +-Literal(type=STRING, value='abc')
    | |     | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |     | +-col_b#2 := Literal(type=INT64, value=1)
    | |     +-input_scan=
    | |       +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t2.[col_a#3, col_c#4]
    |       +-expr_list=
    |       | +-col_a#3 :=
    |       | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | |   +-type_annotation_map={Collation:"und:ci"}
    |       | |   +-Literal(type=STRING, value='abc')
    |       | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       | +-col_c#4 := Literal(type=INT64, value=1)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$full_join.col_a#9{Collation:"und:ci"}, t1.col_b#6, t2.col_c#8]
        +-input_scan=
          +-ProjectScan
            +-column_list=[t1.col_a#5{Collation:"und:ci"}, t1.col_b#6, t2.col_a#7{Collation:"und:ci"}, t2.col_c#8, $full_join.col_a#9{Collation:"und:ci"}]
            +-expr_list=
            | +-col_a#9 :=
            |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) STRING) -> STRING)
            |     +-type_annotation_map={Collation:"und:ci"}
            |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t1.col_a#5{Collation:"und:ci"})
            |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t2.col_a#7{Collation:"und:ci"})
            +-input_scan=
              +-JoinScan
                +-column_list=[t1.col_a#5{Collation:"und:ci"}, t1.col_b#6, t2.col_a#7{Collation:"und:ci"}, t2.col_c#8]
                +-join_type=FULL
                +-left_scan=
                | +-WithRefScan(column_list=t1.[col_a#5, col_b#6], with_query_name='t1')
                +-right_scan=
                | +-WithRefScan(column_list=t2.[col_a#7, col_c#8], with_query_name='t2')
                +-join_expr=
                  +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
                    +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t1.col_a#5{Collation:"und:ci"})
                    +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t2.col_a#7{Collation:"und:ci"})
                    +-collation_list=[und:ci]
==

[no_run_unparser]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# Test join with 'using' on a value table field, collation should be propagated
with t1 as (select as struct collate('abc', 'und:ci') col_a, 1 col_b),
     t2 as (select as struct collate('abc', 'und:ci') col_a, 1 col_c)
select *
from t1 {{inner|left|right|full|outer}} join t2 using (col_a)
--
ALTERNATION GROUP: inner
--
QueryStmt
+-output_column_list=
| +-$join_left.col_a#9{Collation:"und:ci"} AS col_a [STRING]
| +-$query.col_b#11 AS col_b [INT64]
| +-$query.col_c#12 AS col_c [INT64]
+-query=
  +-WithScan
    +-column_list=[$join_left.col_a#9{Collation:"und:ci"}, $query.col_b#11, $query.col_c#12]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$make_struct.$struct#3<{Collation:"und:ci"},_>]
    | |     +-expr_list=
    | |     | +-$struct#3 :=
    | |     |   +-MakeStruct
    | |     |     +-type=STRUCT<col_a STRING, col_b INT64>
    | |     |     +-type_annotation_map=<{Collation:"und:ci"},_>
    | |     |     +-field_list=
    | |     |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t1.col_a#1{Collation:"und:ci"})
    | |     |       +-ColumnRef(type=INT64, column=t1.col_b#2)
    | |     +-input_scan=
    | |       +-ProjectScan
    | |         +-column_list=t1.[col_a#1, col_b#2]
    | |         +-expr_list=
    | |         | +-col_a#1 :=
    | |         | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |         | |   +-type_annotation_map={Collation:"und:ci"}
    | |         | |   +-Literal(type=STRING, value='abc')
    | |         | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |         | +-col_b#2 := Literal(type=INT64, value=1)
    | |         +-input_scan=
    | |           +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[$make_struct.$struct#6<{Collation:"und:ci"},_>]
    |       +-expr_list=
    |       | +-$struct#6 :=
    |       |   +-MakeStruct
    |       |     +-type=STRUCT<col_a STRING, col_c INT64>
    |       |     +-type_annotation_map=<{Collation:"und:ci"},_>
    |       |     +-field_list=
    |       |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t2.col_a#4{Collation:"und:ci"})
    |       |       +-ColumnRef(type=INT64, column=t2.col_c#5)
    |       +-input_scan=
    |         +-ProjectScan
    |           +-column_list=t2.[col_a#4, col_c#5]
    |           +-expr_list=
    |           | +-col_a#4 :=
    |           | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |           | |   +-type_annotation_map={Collation:"und:ci"}
    |           | |   +-Literal(type=STRING, value='abc')
    |           | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |           | +-col_c#5 := Literal(type=INT64, value=1)
    |           +-input_scan=
    |             +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$join_left.col_a#9{Collation:"und:ci"}, $query.col_b#11, $query.col_c#12]
        +-expr_list=
        | +-col_b#11 :=
        | | +-GetStructField
        | |   +-type=INT64
        | |   +-expr=
        | |   | +-ColumnRef(type=STRUCT<col_a STRING, col_b INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t1.$struct#7<{Collation:"und:ci"},_>)
        | |   +-field_idx=1
        | +-col_c#12 :=
        |   +-GetStructField
        |     +-type=INT64
        |     +-expr=
        |     | +-ColumnRef(type=STRUCT<col_a STRING, col_c INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t2.$struct#8<{Collation:"und:ci"},_>)
        |     +-field_idx=1
        +-input_scan=
          +-JoinScan
            +-column_list=[t1.$struct#7<{Collation:"und:ci"},_>, $join_left.col_a#9{Collation:"und:ci"}, t2.$struct#8<{Collation:"und:ci"},_>, $join_right.col_a#10{Collation:"und:ci"}]
            +-left_scan=
            | +-ProjectScan
            |   +-column_list=[t1.$struct#7<{Collation:"und:ci"},_>, $join_left.col_a#9{Collation:"und:ci"}]
            |   +-expr_list=
            |   | +-col_a#9 :=
            |   |   +-GetStructField
            |   |     +-type=STRING
            |   |     +-type_annotation_map={Collation:"und:ci"}
            |   |     +-expr=
            |   |     | +-ColumnRef(type=STRUCT<col_a STRING, col_b INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t1.$struct#7<{Collation:"und:ci"},_>)
            |   |     +-field_idx=0
            |   +-input_scan=
            |     +-WithRefScan(column_list=[t1.$struct#7<{Collation:"und:ci"},_>], with_query_name='t1')
            +-right_scan=
            | +-ProjectScan
            |   +-column_list=[t2.$struct#8<{Collation:"und:ci"},_>, $join_right.col_a#10{Collation:"und:ci"}]
            |   +-expr_list=
            |   | +-col_a#10 :=
            |   |   +-GetStructField
            |   |     +-type=STRING
            |   |     +-type_annotation_map={Collation:"und:ci"}
            |   |     +-expr=
            |   |     | +-ColumnRef(type=STRUCT<col_a STRING, col_c INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t2.$struct#8<{Collation:"und:ci"},_>)
            |   |     +-field_idx=0
            |   +-input_scan=
            |     +-WithRefScan(column_list=[t2.$struct#8<{Collation:"und:ci"},_>], with_query_name='t2')
            +-join_expr=
              +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
                +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$join_left.col_a#9{Collation:"und:ci"})
                +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$join_right.col_a#10{Collation:"und:ci"})
                +-collation_list=[und:ci]
--
ALTERNATION GROUP: left
--
QueryStmt
+-output_column_list=
| +-$join_left.col_a#9{Collation:"und:ci"} AS col_a [STRING]
| +-$query.col_b#11 AS col_b [INT64]
| +-$query.col_c#12 AS col_c [INT64]
+-query=
  +-WithScan
    +-column_list=[$join_left.col_a#9{Collation:"und:ci"}, $query.col_b#11, $query.col_c#12]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$make_struct.$struct#3<{Collation:"und:ci"},_>]
    | |     +-expr_list=
    | |     | +-$struct#3 :=
    | |     |   +-MakeStruct
    | |     |     +-type=STRUCT<col_a STRING, col_b INT64>
    | |     |     +-type_annotation_map=<{Collation:"und:ci"},_>
    | |     |     +-field_list=
    | |     |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t1.col_a#1{Collation:"und:ci"})
    | |     |       +-ColumnRef(type=INT64, column=t1.col_b#2)
    | |     +-input_scan=
    | |       +-ProjectScan
    | |         +-column_list=t1.[col_a#1, col_b#2]
    | |         +-expr_list=
    | |         | +-col_a#1 :=
    | |         | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |         | |   +-type_annotation_map={Collation:"und:ci"}
    | |         | |   +-Literal(type=STRING, value='abc')
    | |         | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |         | +-col_b#2 := Literal(type=INT64, value=1)
    | |         +-input_scan=
    | |           +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[$make_struct.$struct#6<{Collation:"und:ci"},_>]
    |       +-expr_list=
    |       | +-$struct#6 :=
    |       |   +-MakeStruct
    |       |     +-type=STRUCT<col_a STRING, col_c INT64>
    |       |     +-type_annotation_map=<{Collation:"und:ci"},_>
    |       |     +-field_list=
    |       |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t2.col_a#4{Collation:"und:ci"})
    |       |       +-ColumnRef(type=INT64, column=t2.col_c#5)
    |       +-input_scan=
    |         +-ProjectScan
    |           +-column_list=t2.[col_a#4, col_c#5]
    |           +-expr_list=
    |           | +-col_a#4 :=
    |           | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |           | |   +-type_annotation_map={Collation:"und:ci"}
    |           | |   +-Literal(type=STRING, value='abc')
    |           | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |           | +-col_c#5 := Literal(type=INT64, value=1)
    |           +-input_scan=
    |             +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$join_left.col_a#9{Collation:"und:ci"}, $query.col_b#11, $query.col_c#12]
        +-expr_list=
        | +-col_b#11 :=
        | | +-GetStructField
        | |   +-type=INT64
        | |   +-expr=
        | |   | +-ColumnRef(type=STRUCT<col_a STRING, col_b INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t1.$struct#7<{Collation:"und:ci"},_>)
        | |   +-field_idx=1
        | +-col_c#12 :=
        |   +-GetStructField
        |     +-type=INT64
        |     +-expr=
        |     | +-ColumnRef(type=STRUCT<col_a STRING, col_c INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t2.$struct#8<{Collation:"und:ci"},_>)
        |     +-field_idx=1
        +-input_scan=
          +-JoinScan
            +-column_list=[t1.$struct#7<{Collation:"und:ci"},_>, $join_left.col_a#9{Collation:"und:ci"}, t2.$struct#8<{Collation:"und:ci"},_>, $join_right.col_a#10{Collation:"und:ci"}]
            +-join_type=LEFT
            +-left_scan=
            | +-ProjectScan
            |   +-column_list=[t1.$struct#7<{Collation:"und:ci"},_>, $join_left.col_a#9{Collation:"und:ci"}]
            |   +-expr_list=
            |   | +-col_a#9 :=
            |   |   +-GetStructField
            |   |     +-type=STRING
            |   |     +-type_annotation_map={Collation:"und:ci"}
            |   |     +-expr=
            |   |     | +-ColumnRef(type=STRUCT<col_a STRING, col_b INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t1.$struct#7<{Collation:"und:ci"},_>)
            |   |     +-field_idx=0
            |   +-input_scan=
            |     +-WithRefScan(column_list=[t1.$struct#7<{Collation:"und:ci"},_>], with_query_name='t1')
            +-right_scan=
            | +-ProjectScan
            |   +-column_list=[t2.$struct#8<{Collation:"und:ci"},_>, $join_right.col_a#10{Collation:"und:ci"}]
            |   +-expr_list=
            |   | +-col_a#10 :=
            |   |   +-GetStructField
            |   |     +-type=STRING
            |   |     +-type_annotation_map={Collation:"und:ci"}
            |   |     +-expr=
            |   |     | +-ColumnRef(type=STRUCT<col_a STRING, col_c INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t2.$struct#8<{Collation:"und:ci"},_>)
            |   |     +-field_idx=0
            |   +-input_scan=
            |     +-WithRefScan(column_list=[t2.$struct#8<{Collation:"und:ci"},_>], with_query_name='t2')
            +-join_expr=
              +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
                +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$join_left.col_a#9{Collation:"und:ci"})
                +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$join_right.col_a#10{Collation:"und:ci"})
                +-collation_list=[und:ci]
--
ALTERNATION GROUP: right
--
QueryStmt
+-output_column_list=
| +-$join_right.col_a#10{Collation:"und:ci"} AS col_a [STRING]
| +-$query.col_b#11 AS col_b [INT64]
| +-$query.col_c#12 AS col_c [INT64]
+-query=
  +-WithScan
    +-column_list=[$join_right.col_a#10{Collation:"und:ci"}, $query.col_b#11, $query.col_c#12]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$make_struct.$struct#3<{Collation:"und:ci"},_>]
    | |     +-expr_list=
    | |     | +-$struct#3 :=
    | |     |   +-MakeStruct
    | |     |     +-type=STRUCT<col_a STRING, col_b INT64>
    | |     |     +-type_annotation_map=<{Collation:"und:ci"},_>
    | |     |     +-field_list=
    | |     |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t1.col_a#1{Collation:"und:ci"})
    | |     |       +-ColumnRef(type=INT64, column=t1.col_b#2)
    | |     +-input_scan=
    | |       +-ProjectScan
    | |         +-column_list=t1.[col_a#1, col_b#2]
    | |         +-expr_list=
    | |         | +-col_a#1 :=
    | |         | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |         | |   +-type_annotation_map={Collation:"und:ci"}
    | |         | |   +-Literal(type=STRING, value='abc')
    | |         | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |         | +-col_b#2 := Literal(type=INT64, value=1)
    | |         +-input_scan=
    | |           +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[$make_struct.$struct#6<{Collation:"und:ci"},_>]
    |       +-expr_list=
    |       | +-$struct#6 :=
    |       |   +-MakeStruct
    |       |     +-type=STRUCT<col_a STRING, col_c INT64>
    |       |     +-type_annotation_map=<{Collation:"und:ci"},_>
    |       |     +-field_list=
    |       |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t2.col_a#4{Collation:"und:ci"})
    |       |       +-ColumnRef(type=INT64, column=t2.col_c#5)
    |       +-input_scan=
    |         +-ProjectScan
    |           +-column_list=t2.[col_a#4, col_c#5]
    |           +-expr_list=
    |           | +-col_a#4 :=
    |           | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |           | |   +-type_annotation_map={Collation:"und:ci"}
    |           | |   +-Literal(type=STRING, value='abc')
    |           | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |           | +-col_c#5 := Literal(type=INT64, value=1)
    |           +-input_scan=
    |             +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$join_right.col_a#10{Collation:"und:ci"}, $query.col_b#11, $query.col_c#12]
        +-expr_list=
        | +-col_b#11 :=
        | | +-GetStructField
        | |   +-type=INT64
        | |   +-expr=
        | |   | +-ColumnRef(type=STRUCT<col_a STRING, col_b INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t1.$struct#7<{Collation:"und:ci"},_>)
        | |   +-field_idx=1
        | +-col_c#12 :=
        |   +-GetStructField
        |     +-type=INT64
        |     +-expr=
        |     | +-ColumnRef(type=STRUCT<col_a STRING, col_c INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t2.$struct#8<{Collation:"und:ci"},_>)
        |     +-field_idx=1
        +-input_scan=
          +-JoinScan
            +-column_list=[t1.$struct#7<{Collation:"und:ci"},_>, $join_left.col_a#9{Collation:"und:ci"}, t2.$struct#8<{Collation:"und:ci"},_>, $join_right.col_a#10{Collation:"und:ci"}]
            +-join_type=RIGHT
            +-left_scan=
            | +-ProjectScan
            |   +-column_list=[t1.$struct#7<{Collation:"und:ci"},_>, $join_left.col_a#9{Collation:"und:ci"}]
            |   +-expr_list=
            |   | +-col_a#9 :=
            |   |   +-GetStructField
            |   |     +-type=STRING
            |   |     +-type_annotation_map={Collation:"und:ci"}
            |   |     +-expr=
            |   |     | +-ColumnRef(type=STRUCT<col_a STRING, col_b INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t1.$struct#7<{Collation:"und:ci"},_>)
            |   |     +-field_idx=0
            |   +-input_scan=
            |     +-WithRefScan(column_list=[t1.$struct#7<{Collation:"und:ci"},_>], with_query_name='t1')
            +-right_scan=
            | +-ProjectScan
            |   +-column_list=[t2.$struct#8<{Collation:"und:ci"},_>, $join_right.col_a#10{Collation:"und:ci"}]
            |   +-expr_list=
            |   | +-col_a#10 :=
            |   |   +-GetStructField
            |   |     +-type=STRING
            |   |     +-type_annotation_map={Collation:"und:ci"}
            |   |     +-expr=
            |   |     | +-ColumnRef(type=STRUCT<col_a STRING, col_c INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t2.$struct#8<{Collation:"und:ci"},_>)
            |   |     +-field_idx=0
            |   +-input_scan=
            |     +-WithRefScan(column_list=[t2.$struct#8<{Collation:"und:ci"},_>], with_query_name='t2')
            +-join_expr=
              +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
                +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$join_left.col_a#9{Collation:"und:ci"})
                +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$join_right.col_a#10{Collation:"und:ci"})
                +-collation_list=[und:ci]
--
ALTERNATION GROUP: full
--
QueryStmt
+-output_column_list=
| +-$full_join.col_a#11{Collation:"und:ci"} AS col_a [STRING]
| +-$query.col_b#12 AS col_b [INT64]
| +-$query.col_c#13 AS col_c [INT64]
+-query=
  +-WithScan
    +-column_list=[$full_join.col_a#11{Collation:"und:ci"}, $query.col_b#12, $query.col_c#13]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name='t1'
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=[$make_struct.$struct#3<{Collation:"und:ci"},_>]
    | |     +-expr_list=
    | |     | +-$struct#3 :=
    | |     |   +-MakeStruct
    | |     |     +-type=STRUCT<col_a STRING, col_b INT64>
    | |     |     +-type_annotation_map=<{Collation:"und:ci"},_>
    | |     |     +-field_list=
    | |     |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t1.col_a#1{Collation:"und:ci"})
    | |     |       +-ColumnRef(type=INT64, column=t1.col_b#2)
    | |     +-input_scan=
    | |       +-ProjectScan
    | |         +-column_list=t1.[col_a#1, col_b#2]
    | |         +-expr_list=
    | |         | +-col_a#1 :=
    | |         | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |         | |   +-type_annotation_map={Collation:"und:ci"}
    | |         | |   +-Literal(type=STRING, value='abc')
    | |         | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |         | +-col_b#2 := Literal(type=INT64, value=1)
    | |         +-input_scan=
    | |           +-SingleRowScan
    | +-WithEntry
    |   +-with_query_name='t2'
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[$make_struct.$struct#6<{Collation:"und:ci"},_>]
    |       +-expr_list=
    |       | +-$struct#6 :=
    |       |   +-MakeStruct
    |       |     +-type=STRUCT<col_a STRING, col_c INT64>
    |       |     +-type_annotation_map=<{Collation:"und:ci"},_>
    |       |     +-field_list=
    |       |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=t2.col_a#4{Collation:"und:ci"})
    |       |       +-ColumnRef(type=INT64, column=t2.col_c#5)
    |       +-input_scan=
    |         +-ProjectScan
    |           +-column_list=t2.[col_a#4, col_c#5]
    |           +-expr_list=
    |           | +-col_a#4 :=
    |           | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |           | |   +-type_annotation_map={Collation:"und:ci"}
    |           | |   +-Literal(type=STRING, value='abc')
    |           | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |           | +-col_c#5 := Literal(type=INT64, value=1)
    |           +-input_scan=
    |             +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$full_join.col_a#11{Collation:"und:ci"}, $query.col_b#12, $query.col_c#13]
        +-expr_list=
        | +-col_b#12 :=
        | | +-GetStructField
        | |   +-type=INT64
        | |   +-expr=
        | |   | +-ColumnRef(type=STRUCT<col_a STRING, col_b INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t1.$struct#7<{Collation:"und:ci"},_>)
        | |   +-field_idx=1
        | +-col_c#13 :=
        |   +-GetStructField
        |     +-type=INT64
        |     +-expr=
        |     | +-ColumnRef(type=STRUCT<col_a STRING, col_c INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t2.$struct#8<{Collation:"und:ci"},_>)
        |     +-field_idx=1
        +-input_scan=
          +-ProjectScan
            +-column_list=[t1.$struct#7<{Collation:"und:ci"},_>, $join_left.col_a#9{Collation:"und:ci"}, t2.$struct#8<{Collation:"und:ci"},_>, $join_right.col_a#10{Collation:"und:ci"}, $full_join.col_a#11{Collation:"und:ci"}]
            +-expr_list=
            | +-col_a#11 :=
            |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) STRING) -> STRING)
            |     +-type_annotation_map={Collation:"und:ci"}
            |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$join_left.col_a#9{Collation:"und:ci"})
            |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$join_right.col_a#10{Collation:"und:ci"})
            +-input_scan=
              +-JoinScan
                +-column_list=[t1.$struct#7<{Collation:"und:ci"},_>, $join_left.col_a#9{Collation:"und:ci"}, t2.$struct#8<{Collation:"und:ci"},_>, $join_right.col_a#10{Collation:"und:ci"}]
                +-join_type=FULL
                +-left_scan=
                | +-ProjectScan
                |   +-column_list=[t1.$struct#7<{Collation:"und:ci"},_>, $join_left.col_a#9{Collation:"und:ci"}]
                |   +-expr_list=
                |   | +-col_a#9 :=
                |   |   +-GetStructField
                |   |     +-type=STRING
                |   |     +-type_annotation_map={Collation:"und:ci"}
                |   |     +-expr=
                |   |     | +-ColumnRef(type=STRUCT<col_a STRING, col_b INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t1.$struct#7<{Collation:"und:ci"},_>)
                |   |     +-field_idx=0
                |   +-input_scan=
                |     +-WithRefScan(column_list=[t1.$struct#7<{Collation:"und:ci"},_>], with_query_name='t1')
                +-right_scan=
                | +-ProjectScan
                |   +-column_list=[t2.$struct#8<{Collation:"und:ci"},_>, $join_right.col_a#10{Collation:"und:ci"}]
                |   +-expr_list=
                |   | +-col_a#10 :=
                |   |   +-GetStructField
                |   |     +-type=STRING
                |   |     +-type_annotation_map={Collation:"und:ci"}
                |   |     +-expr=
                |   |     | +-ColumnRef(type=STRUCT<col_a STRING, col_c INT64>, type_annotation_map=<{Collation:"und:ci"},_>, column=t2.$struct#8<{Collation:"und:ci"},_>)
                |   |     +-field_idx=0
                |   +-input_scan=
                |     +-WithRefScan(column_list=[t2.$struct#8<{Collation:"und:ci"},_>], with_query_name='t2')
                +-join_expr=
                  +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
                    +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$join_left.col_a#9{Collation:"und:ci"})
                    +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$join_right.col_a#10{Collation:"und:ci"})
                    +-collation_list=[und:ci]
--
ALTERNATION GROUP: outer
--
ERROR: Syntax error: Expected end of input but got keyword OUTER [at 7:9]
from t1 outer join t2 using (col_a)
        ^
==

[enabled_ast_rewrites=DEFAULTS]
[language_features=V_1_3_PIVOT,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT]
# PIVOT FOR expression with collation is not supported
select * FROM (select string_ci, string_binary from CollatedTable)
PIVOT(string_agg(distinct string_ci) FOR string_binary IN ('Value_1' AS v1, 'Value_2' AS v2));
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$pivot.v1#8{Collation:"und:ci"} AS v1 [STRING]
| +-$pivot.v2#9{Collation:"und:ci"} AS v2 [STRING]
+-query=
  +-ProjectScan
    +-column_list=$pivot.[v1#8, v2#9]
    +-input_scan=
      +-PivotScan
        +-column_list=$pivot.[v1#8, v2#9]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$subquery1.[string_ci#5, string_binary#6]
        |   +-expr_list=
        |   | +-string_ci#5 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        |   | +-string_binary#6 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        |   +-input_scan=
        |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-pivot_expr_list=
        | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
        |   +-parse_location=128-158
        |   +-type_annotation_map={Collation:"und:ci"}
        |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$subquery1.string_ci#5{Collation:"und:ci"})
        |   +-collation_list=[und:ci]
        |   +-distinct=TRUE
        +-for_expr=
        | +-ColumnRef(parse_location=163-176, type=STRING, type_annotation_map={Collation:"binary"}, column=$subquery1.string_binary#6{Collation:"binary"})
        +-pivot_value_list=
        | +-Literal(type=STRING, value='Value_1')
        | +-Literal(type=STRING, value='Value_2')
        +-pivot_column_list=
          +-PivotColumn(column=$pivot.v1#8{Collation:"und:ci"}, pivot_expr_index=0, pivot_value_index=0)
          +-PivotColumn(column=$pivot.v2#9{Collation:"und:ci"}, pivot_expr_index=0, pivot_value_index=1)

Rewrite ERROR: generic::unimplemented: Collation is not supported in a PIVOT clause yet [at 3:42]
PIVOT(string_agg(distinct string_ci) FOR string_binary IN ('Value_1' AS v1, '...
                                         ^
==

[enabled_ast_rewrites=DEFAULTS]
[language_features=V_1_3_PIVOT,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT]
# PIVOT aggregation with collation is not supported
select * FROM (select string_ci, string_binary, 'abc' value from CollatedTable)
PIVOT(string_agg(distinct string_ci) FOR value IN ('Value_1' AS v1, 'Value_2' AS v2));
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$groupby.string_binary#9{Collation:"binary"} AS string_binary [STRING]
| +-$pivot.v1#10{Collation:"und:ci"} AS v1 [STRING]
| +-$pivot.v2#11{Collation:"und:ci"} AS v2 [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.string_binary#9{Collation:"binary"}, $pivot.v1#10{Collation:"und:ci"}, $pivot.v2#11{Collation:"und:ci"}]
    +-input_scan=
      +-PivotScan
        +-column_list=[$groupby.string_binary#9{Collation:"binary"}, $pivot.v1#10{Collation:"und:ci"}, $pivot.v2#11{Collation:"und:ci"}]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$subquery1.[string_ci#5, string_binary#6, value#7]
        |   +-expr_list=
        |   | +-string_ci#5 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        |   | +-string_binary#6 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        |   | +-value#7 := Literal(type=STRING, value='abc')
        |   +-input_scan=
        |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-group_by_list=
        | +-string_binary#9 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=$subquery1.string_binary#6{Collation:"binary"})
        +-pivot_expr_list=
        | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
        |   +-parse_location=138-168
        |   +-type_annotation_map={Collation:"und:ci"}
        |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$subquery1.string_ci#5{Collation:"und:ci"})
        |   +-collation_list=[und:ci]
        |   +-distinct=TRUE
        +-for_expr=
        | +-ColumnRef(parse_location=173-178, type=STRING, column=$subquery1.value#7)
        +-pivot_value_list=
        | +-Literal(type=STRING, value='Value_1')
        | +-Literal(type=STRING, value='Value_2')
        +-pivot_column_list=
          +-PivotColumn(column=$pivot.v1#10{Collation:"und:ci"}, pivot_expr_index=0, pivot_value_index=0)
          +-PivotColumn(column=$pivot.v2#11{Collation:"und:ci"}, pivot_expr_index=0, pivot_value_index=1)

Rewrite ERROR: generic::unimplemented: Collation is not supported in a PIVOT clause yet [at 3:7]
PIVOT(string_agg(distinct string_ci) FOR value IN ('Value_1' AS v1, 'Value_2'...
      ^
==

# PIVOT aggregation with collated arguments is not supported
[enabled_ast_rewrites=DEFAULTS]
[language_features=V_1_3_PIVOT,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_IS_DISTINCT]
select * FROM (select string_ci, string_binary, 'abc' value from CollatedTable)
PIVOT(string_agg(string_ci) FOR value IN ('Value_1' AS v1, 'Value_2' AS v2));
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$groupby.string_binary#9{Collation:"binary"} AS string_binary [STRING]
| +-$pivot.v1#10{Collation:"und:ci"} AS v1 [STRING]
| +-$pivot.v2#11{Collation:"und:ci"} AS v2 [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.string_binary#9{Collation:"binary"}, $pivot.v1#10{Collation:"und:ci"}, $pivot.v2#11{Collation:"und:ci"}]
    +-input_scan=
      +-PivotScan
        +-column_list=[$groupby.string_binary#9{Collation:"binary"}, $pivot.v1#10{Collation:"und:ci"}, $pivot.v2#11{Collation:"und:ci"}]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$subquery1.[string_ci#5, string_binary#6, value#7]
        |   +-expr_list=
        |   | +-string_ci#5 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        |   | +-string_binary#6 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        |   | +-value#7 := Literal(type=STRING, value='abc')
        |   +-input_scan=
        |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-group_by_list=
        | +-string_binary#9 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=$subquery1.string_binary#6{Collation:"binary"})
        +-pivot_expr_list=
        | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
        |   +-parse_location=86-107
        |   +-type_annotation_map={Collation:"und:ci"}
        |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$subquery1.string_ci#5{Collation:"und:ci"})
        +-for_expr=
        | +-ColumnRef(parse_location=112-117, type=STRING, column=$subquery1.value#7)
        +-pivot_value_list=
        | +-Literal(type=STRING, value='Value_1')
        | +-Literal(type=STRING, value='Value_2')
        +-pivot_column_list=
          +-PivotColumn(column=$pivot.v1#10{Collation:"und:ci"}, pivot_expr_index=0, pivot_value_index=0)
          +-PivotColumn(column=$pivot.v2#11{Collation:"und:ci"}, pivot_expr_index=0, pivot_value_index=1)

Rewrite ERROR: generic::unimplemented: Collation "und:ci" is not supported on argument 1 of aggregate function in a PIVOT clause [at 2:7]
PIVOT(string_agg(string_ci) FOR value IN ('Value_1' AS v1, 'Value_2' AS v2));
      ^
==

# PIVOT - pivot value is collated
[enabled_ast_rewrites=DEFAULTS]
[language_features=V_1_3_PIVOT,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_IS_DISTINCT]
select * FROM (select string_ci, collate(string_binary, '') as col, 'foo' as value from CollatedTable)
PIVOT(string_agg(distinct col) FOR value IN (collate('Value_1', 'und:ci') AS v1, 'Value_2' AS v2));
--
QueryStmt
+-output_column_list=
| +-$groupby.string_ci#9{Collation:"und:ci"} AS string_ci [STRING]
| +-$pivot.v1#10 AS v1 [STRING]
| +-$pivot.v2#11 AS v2 [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.string_ci#9{Collation:"und:ci"}, $pivot.v1#10, $pivot.v2#11]
    +-input_scan=
      +-PivotScan
        +-column_list=[$groupby.string_ci#9{Collation:"und:ci"}, $pivot.v1#10, $pivot.v2#11]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$subquery1.[string_ci#5, col#6, value#7]
        |   +-expr_list=
        |   | +-string_ci#5 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        |   | +-col#6 :=
        |   | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |   | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        |   | |   +-Literal(type=STRING, value='', preserve_in_literal_remover=TRUE)
        |   | +-value#7 := Literal(type=STRING, value='foo')
        |   +-input_scan=
        |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-group_by_list=
        | +-string_ci#9 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$subquery1.string_ci#5{Collation:"und:ci"})
        +-pivot_expr_list=
        | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
        |   +-parse_location=109-133
        |   +-ColumnRef(type=STRING, column=$subquery1.col#6)
        |   +-distinct=TRUE
        +-for_expr=
        | +-ColumnRef(parse_location=138-143, type=STRING, column=$subquery1.value#7)
        +-pivot_value_list=
        | +-Cast(STRING -> STRING)
        | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        | |   +-type_annotation_map={Collation:"und:ci"}
        | |   +-Literal(type=STRING, value='Value_1')
        | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
        | +-Literal(type=STRING, value='Value_2')
        +-pivot_column_list=
          +-PivotColumn(column=$pivot.v1#10, pivot_expr_index=0, pivot_value_index=0)
          +-PivotColumn(column=$pivot.v2#11, pivot_expr_index=0, pivot_value_index=1)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.string_ci#9{Collation:"und:ci"} AS string_ci [STRING]
| +-$pivot.v1#10 AS v1 [STRING]
| +-$pivot.v2#11 AS v2 [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.string_ci#9{Collation:"und:ci"}, $pivot.v1#10, $pivot.v2#11]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.string_ci#9{Collation:"und:ci"}, $pivot.v1#10, $pivot.v2#11]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$subquery1.string_ci#5{Collation:"und:ci"}, $subquery1.col#6, $subquery1.value#7, $pivot.$pivot_value#12, $pivot.$pivot_expr_arg#13]
        |   +-expr_list=
        |   | +-$pivot_value#12 := ColumnRef(parse_location=138-143, type=STRING, column=$subquery1.value#7)
        |   | +-$pivot_expr_arg#13 := ColumnRef(type=STRING, column=$subquery1.col#6)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=$subquery1.[string_ci#5, col#6, value#7]
        |       +-expr_list=
        |       | +-string_ci#5 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        |       | +-col#6 :=
        |       | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |       | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        |       | |   +-Literal(type=STRING, value='', preserve_in_literal_remover=TRUE)
        |       | +-value#7 := Literal(type=STRING, value='foo')
        |       +-input_scan=
        |         +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-group_by_list=
        | +-string_ci#9 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$subquery1.string_ci#5{Collation:"und:ci"})
        +-aggregate_list=
          +-v1#10 :=
          | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
          |   +-SubqueryExpr
          |     +-type=STRING
          |     +-subquery_type=SCALAR
          |     +-parameter_list=
          |     | +-ColumnRef(type=STRING, column=$pivot.$pivot_value#12)
          |     | +-ColumnRef(type=STRING, column=$pivot.$pivot_expr_arg#13)
          |     +-subquery=
          |       +-ProjectScan
          |         +-column_list=[$expr_subquery.$col1#17]
          |         +-expr_list=
          |         | +-$col1#17 :=
          |         |   +-FunctionCall(ZetaSQL:if(BOOL, STRING, STRING) -> STRING)
          |         |     +-FunctionCall(ZetaSQL:$is_not_distinct_from(STRING, STRING) -> BOOL)
          |         |     | +-ColumnRef(type=STRING, column=$subquery1.pivot_column#15)
          |         |     | +-ColumnRef(type=STRING, column=$subquery1.pivot_value#16)
          |         |     +-ColumnRef(type=STRING, column=$subquery1.orig_arg#14)
          |         |     +-Literal(type=STRING, value=NULL)
          |         +-input_scan=
          |           +-ProjectScan
          |             +-column_list=$subquery1.[orig_arg#14, pivot_column#15, pivot_value#16]
          |             +-expr_list=
          |             | +-orig_arg#14 := ColumnRef(type=STRING, column=$pivot.$pivot_expr_arg#13, is_correlated=TRUE)
          |             | +-pivot_column#15 := ColumnRef(type=STRING, column=$pivot.$pivot_value#12, is_correlated=TRUE)
          |             | +-pivot_value#16 :=
          |             |   +-Cast(STRING -> STRING)
          |             |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
          |             |       +-type_annotation_map={Collation:"und:ci"}
          |             |       +-Literal(type=STRING, value='Value_1')
          |             |       +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
          |             +-input_scan=
          |               +-SingleRowScan
          |   +-distinct=TRUE
          +-v2#11 :=
            +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
              +-SubqueryExpr
                +-type=STRING
                +-subquery_type=SCALAR
                +-parameter_list=
                | +-ColumnRef(type=STRING, column=$pivot.$pivot_value#12)
                | +-ColumnRef(type=STRING, column=$pivot.$pivot_expr_arg#13)
                +-subquery=
                  +-ProjectScan
                    +-column_list=[$expr_subquery.$col1#21]
                    +-expr_list=
                    | +-$col1#21 :=
                    |   +-FunctionCall(ZetaSQL:if(BOOL, STRING, STRING) -> STRING)
                    |     +-FunctionCall(ZetaSQL:$is_not_distinct_from(STRING, STRING) -> BOOL)
                    |     | +-ColumnRef(type=STRING, column=$subquery1.pivot_column#19)
                    |     | +-ColumnRef(type=STRING, column=$subquery1.pivot_value#20)
                    |     +-ColumnRef(type=STRING, column=$subquery1.orig_arg#18)
                    |     +-Literal(type=STRING, value=NULL)
                    +-input_scan=
                      +-ProjectScan
                        +-column_list=$subquery1.[orig_arg#18, pivot_column#19, pivot_value#20]
                        +-expr_list=
                        | +-orig_arg#18 := ColumnRef(type=STRING, column=$pivot.$pivot_expr_arg#13, is_correlated=TRUE)
                        | +-pivot_column#19 := ColumnRef(type=STRING, column=$pivot.$pivot_value#12, is_correlated=TRUE)
                        | +-pivot_value#20 := Literal(type=STRING, value='Value_2')
                        +-input_scan=
                          +-SingleRowScan
              +-distinct=TRUE
==

[enabled_ast_rewrites=DEFAULTS]
[language_features=V_1_3_PIVOT,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT]
# PIVOT - group by collated columns
select * FROM (select string_ci, collate(string_binary, '') as col, 'foo' as value from CollatedTable)
PIVOT(string_agg(distinct col) FOR value IN ('Value_1' AS v1, 'Value_2' AS v2));
--
QueryStmt
+-output_column_list=
| +-$groupby.string_ci#9{Collation:"und:ci"} AS string_ci [STRING]
| +-$pivot.v1#10 AS v1 [STRING]
| +-$pivot.v2#11 AS v2 [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.string_ci#9{Collation:"und:ci"}, $pivot.v1#10, $pivot.v2#11]
    +-input_scan=
      +-PivotScan
        +-column_list=[$groupby.string_ci#9{Collation:"und:ci"}, $pivot.v1#10, $pivot.v2#11]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=$subquery1.[string_ci#5, col#6, value#7]
        |   +-expr_list=
        |   | +-string_ci#5 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        |   | +-col#6 :=
        |   | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |   | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        |   | |   +-Literal(type=STRING, value='', preserve_in_literal_remover=TRUE)
        |   | +-value#7 := Literal(type=STRING, value='foo')
        |   +-input_scan=
        |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-group_by_list=
        | +-string_ci#9 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$subquery1.string_ci#5{Collation:"und:ci"})
        +-pivot_expr_list=
        | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
        |   +-parse_location=145-169
        |   +-ColumnRef(type=STRING, column=$subquery1.col#6)
        |   +-distinct=TRUE
        +-for_expr=
        | +-ColumnRef(parse_location=174-179, type=STRING, column=$subquery1.value#7)
        +-pivot_value_list=
        | +-Literal(type=STRING, value='Value_1')
        | +-Literal(type=STRING, value='Value_2')
        +-pivot_column_list=
          +-PivotColumn(column=$pivot.v1#10, pivot_expr_index=0, pivot_value_index=0)
          +-PivotColumn(column=$pivot.v2#11, pivot_expr_index=0, pivot_value_index=1)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$groupby.string_ci#9{Collation:"und:ci"} AS string_ci [STRING]
| +-$pivot.v1#10 AS v1 [STRING]
| +-$pivot.v2#11 AS v2 [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.string_ci#9{Collation:"und:ci"}, $pivot.v1#10, $pivot.v2#11]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.string_ci#9{Collation:"und:ci"}, $pivot.v1#10, $pivot.v2#11]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$subquery1.string_ci#5{Collation:"und:ci"}, $subquery1.col#6, $subquery1.value#7, $pivot.$pivot_value#12, $pivot.$pivot_expr_arg#13]
        |   +-expr_list=
        |   | +-$pivot_value#12 := ColumnRef(parse_location=174-179, type=STRING, column=$subquery1.value#7)
        |   | +-$pivot_expr_arg#13 := ColumnRef(type=STRING, column=$subquery1.col#6)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=$subquery1.[string_ci#5, col#6, value#7]
        |       +-expr_list=
        |       | +-string_ci#5 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        |       | +-col#6 :=
        |       | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |       | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        |       | |   +-Literal(type=STRING, value='', preserve_in_literal_remover=TRUE)
        |       | +-value#7 := Literal(type=STRING, value='foo')
        |       +-input_scan=
        |         +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-group_by_list=
        | +-string_ci#9 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$subquery1.string_ci#5{Collation:"und:ci"})
        +-aggregate_list=
          +-v1#10 :=
          | +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
          |   +-SubqueryExpr
          |     +-type=STRING
          |     +-subquery_type=SCALAR
          |     +-parameter_list=
          |     | +-ColumnRef(type=STRING, column=$pivot.$pivot_value#12)
          |     | +-ColumnRef(type=STRING, column=$pivot.$pivot_expr_arg#13)
          |     +-subquery=
          |       +-ProjectScan
          |         +-column_list=[$expr_subquery.$col1#20]
          |         +-expr_list=
          |         | +-$col1#20 :=
          |         |   +-FunctionCall(ZetaSQL:if(BOOL, STRING, STRING) -> STRING)
          |         |     +-SubqueryExpr
          |         |     | +-type=BOOL
          |         |     | +-subquery_type=EXISTS
          |         |     | +-parameter_list=
          |         |     | | +-ColumnRef(type=STRING, column=$subquery1.pivot_column#15)
          |         |     | | +-ColumnRef(type=STRING, column=$subquery1.pivot_value#16)
          |         |     | +-subquery=
          |         |     |   +-SetOperationScan
          |         |     |     +-column_list=[$intersect_all.pivot_column#19]
          |         |     |     +-op_type=INTERSECT_ALL
          |         |     |     +-input_item_list=
          |         |     |       +-SetOperationItem
          |         |     |       | +-scan=
          |         |     |       | | +-ProjectScan
          |         |     |       | |   +-column_list=[$intersect_all1.pivot_column#17]
          |         |     |       | |   +-expr_list=
          |         |     |       | |   | +-pivot_column#17 := ColumnRef(type=STRING, column=$subquery1.pivot_column#15, is_correlated=TRUE)
          |         |     |       | |   +-input_scan=
          |         |     |       | |     +-SingleRowScan
          |         |     |       | +-output_column_list=[$intersect_all1.pivot_column#17]
          |         |     |       +-SetOperationItem
          |         |     |         +-scan=
          |         |     |         | +-ProjectScan
          |         |     |         |   +-column_list=[$intersect_all2.pivot_value#18]
          |         |     |         |   +-expr_list=
          |         |     |         |   | +-pivot_value#18 := ColumnRef(type=STRING, column=$subquery1.pivot_value#16, is_correlated=TRUE)
          |         |     |         |   +-input_scan=
          |         |     |         |     +-SingleRowScan
          |         |     |         +-output_column_list=[$intersect_all2.pivot_value#18]
          |         |     +-ColumnRef(type=STRING, column=$subquery1.orig_arg#14)
          |         |     +-Literal(type=STRING, value=NULL)
          |         +-input_scan=
          |           +-ProjectScan
          |             +-column_list=$subquery1.[orig_arg#14, pivot_column#15, pivot_value#16]
          |             +-expr_list=
          |             | +-orig_arg#14 := ColumnRef(type=STRING, column=$pivot.$pivot_expr_arg#13, is_correlated=TRUE)
          |             | +-pivot_column#15 := ColumnRef(type=STRING, column=$pivot.$pivot_value#12, is_correlated=TRUE)
          |             | +-pivot_value#16 := Literal(type=STRING, value='Value_1')
          |             +-input_scan=
          |               +-SingleRowScan
          |   +-distinct=TRUE
          +-v2#11 :=
            +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
              +-SubqueryExpr
                +-type=STRING
                +-subquery_type=SCALAR
                +-parameter_list=
                | +-ColumnRef(type=STRING, column=$pivot.$pivot_value#12)
                | +-ColumnRef(type=STRING, column=$pivot.$pivot_expr_arg#13)
                +-subquery=
                  +-ProjectScan
                    +-column_list=[$expr_subquery.$col1#27]
                    +-expr_list=
                    | +-$col1#27 :=
                    |   +-FunctionCall(ZetaSQL:if(BOOL, STRING, STRING) -> STRING)
                    |     +-SubqueryExpr
                    |     | +-type=BOOL
                    |     | +-subquery_type=EXISTS
                    |     | +-parameter_list=
                    |     | | +-ColumnRef(type=STRING, column=$subquery1.pivot_column#22)
                    |     | | +-ColumnRef(type=STRING, column=$subquery1.pivot_value#23)
                    |     | +-subquery=
                    |     |   +-SetOperationScan
                    |     |     +-column_list=[$intersect_all.pivot_column#26]
                    |     |     +-op_type=INTERSECT_ALL
                    |     |     +-input_item_list=
                    |     |       +-SetOperationItem
                    |     |       | +-scan=
                    |     |       | | +-ProjectScan
                    |     |       | |   +-column_list=[$intersect_all1.pivot_column#24]
                    |     |       | |   +-expr_list=
                    |     |       | |   | +-pivot_column#24 := ColumnRef(type=STRING, column=$subquery1.pivot_column#22, is_correlated=TRUE)
                    |     |       | |   +-input_scan=
                    |     |       | |     +-SingleRowScan
                    |     |       | +-output_column_list=[$intersect_all1.pivot_column#24]
                    |     |       +-SetOperationItem
                    |     |         +-scan=
                    |     |         | +-ProjectScan
                    |     |         |   +-column_list=[$intersect_all2.pivot_value#25]
                    |     |         |   +-expr_list=
                    |     |         |   | +-pivot_value#25 := ColumnRef(type=STRING, column=$subquery1.pivot_value#23, is_correlated=TRUE)
                    |     |         |   +-input_scan=
                    |     |         |     +-SingleRowScan
                    |     |         +-output_column_list=[$intersect_all2.pivot_value#25]
                    |     +-ColumnRef(type=STRING, column=$subquery1.orig_arg#21)
                    |     +-Literal(type=STRING, value=NULL)
                    +-input_scan=
                      +-ProjectScan
                        +-column_list=$subquery1.[orig_arg#21, pivot_column#22, pivot_value#23]
                        +-expr_list=
                        | +-orig_arg#21 := ColumnRef(type=STRING, column=$pivot.$pivot_expr_arg#13, is_correlated=TRUE)
                        | +-pivot_column#22 := ColumnRef(type=STRING, column=$pivot.$pivot_value#12, is_correlated=TRUE)
                        | +-pivot_value#23 := Literal(type=STRING, value='Value_2')
                        +-input_scan=
                          +-SingleRowScan
              +-distinct=TRUE
==


create table t (a int64) default collate 'und:ci';
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name='a', type=INT64, column=t.a#1)
+-collation_name=
  +-Literal(type=STRING, value='und:ci')

==

select string_ci, string_binary from CollatedTable
{{union|except|intersect}} distinct
select 'abc', 'xyz'
--
ALTERNATION GROUP: union
--
QueryStmt
+-output_column_list=
| +-$union_distinct.string_ci#7{Collation:"und:ci"} AS string_ci [STRING]
| +-$union_distinct.string_binary#8{Collation:"binary"} AS string_binary [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_distinct.[string_ci#7, string_binary#8]
    +-op_type=UNION_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=CollatedTable.[string_ci#1, string_binary#2]
      | |   +-input_scan=
      | |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
      | +-output_column_list=CollatedTable.[string_ci#1, string_binary#2]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=$union_distinct2.[$col1#5, $col2#6]
        |   +-expr_list=
        |   | +-$col1#5 := Literal(type=STRING, value='abc')
        |   | +-$col2#6 := Literal(type=STRING, value='xyz')
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=$union_distinct2.[$col1#5, $col2#6]
--
ALTERNATION GROUP: except
--
QueryStmt
+-output_column_list=
| +-$except_distinct.string_ci#7{Collation:"und:ci"} AS string_ci [STRING]
| +-$except_distinct.string_binary#8{Collation:"binary"} AS string_binary [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$except_distinct.[string_ci#7, string_binary#8]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=CollatedTable.[string_ci#1, string_binary#2]
      | |   +-input_scan=
      | |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
      | +-output_column_list=CollatedTable.[string_ci#1, string_binary#2]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=$except_distinct2.[$col1#5, $col2#6]
        |   +-expr_list=
        |   | +-$col1#5 := Literal(type=STRING, value='abc')
        |   | +-$col2#6 := Literal(type=STRING, value='xyz')
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=$except_distinct2.[$col1#5, $col2#6]
--
ALTERNATION GROUP: intersect
--
QueryStmt
+-output_column_list=
| +-$intersect_distinct.string_ci#7{Collation:"und:ci"} AS string_ci [STRING]
| +-$intersect_distinct.string_binary#8{Collation:"binary"} AS string_binary [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_distinct.[string_ci#7, string_binary#8]
    +-op_type=INTERSECT_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=CollatedTable.[string_ci#1, string_binary#2]
      | |   +-input_scan=
      | |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
      | +-output_column_list=CollatedTable.[string_ci#1, string_binary#2]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=$intersect_distinct2.[$col1#5, $col2#6]
        |   +-expr_list=
        |   | +-$col1#5 := Literal(type=STRING, value='abc')
        |   | +-$col2#6 := Literal(type=STRING, value='xyz')
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=$intersect_distinct2.[$col1#5, $col2#6]
==

select string_ci, string_binary from CollatedTable
{{union|except|intersect}} all
select 'abc', 'xyz'
--
ALTERNATION GROUP: union
--
QueryStmt
+-output_column_list=
| +-$union_all.string_ci#7{Collation:"und:ci"} AS string_ci [STRING]
| +-$union_all.string_binary#8{Collation:"binary"} AS string_binary [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[string_ci#7, string_binary#8]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=CollatedTable.[string_ci#1, string_binary#2]
      | |   +-input_scan=
      | |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
      | +-output_column_list=CollatedTable.[string_ci#1, string_binary#2]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=$union_all2.[$col1#5, $col2#6]
        |   +-expr_list=
        |   | +-$col1#5 := Literal(type=STRING, value='abc')
        |   | +-$col2#6 := Literal(type=STRING, value='xyz')
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=$union_all2.[$col1#5, $col2#6]
--
ALTERNATION GROUP: except
--
QueryStmt
+-output_column_list=
| +-$except_all.string_ci#7{Collation:"und:ci"} AS string_ci [STRING]
| +-$except_all.string_binary#8{Collation:"binary"} AS string_binary [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$except_all.[string_ci#7, string_binary#8]
    +-op_type=EXCEPT_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=CollatedTable.[string_ci#1, string_binary#2]
      | |   +-input_scan=
      | |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
      | +-output_column_list=CollatedTable.[string_ci#1, string_binary#2]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=$except_all2.[$col1#5, $col2#6]
        |   +-expr_list=
        |   | +-$col1#5 := Literal(type=STRING, value='abc')
        |   | +-$col2#6 := Literal(type=STRING, value='xyz')
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=$except_all2.[$col1#5, $col2#6]
--
ALTERNATION GROUP: intersect
--
QueryStmt
+-output_column_list=
| +-$intersect_all.string_ci#7{Collation:"und:ci"} AS string_ci [STRING]
| +-$intersect_all.string_binary#8{Collation:"binary"} AS string_binary [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[string_ci#7, string_binary#8]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=CollatedTable.[string_ci#1, string_binary#2]
      | |   +-input_scan=
      | |     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
      | +-output_column_list=CollatedTable.[string_ci#1, string_binary#2]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=$intersect_all2.[$col1#5, $col2#6]
        |   +-expr_list=
        |   | +-$col1#5 := Literal(type=STRING, value='abc')
        |   | +-$col2#6 := Literal(type=STRING, value='xyz')
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=$intersect_all2.[$col1#5, $col2#6]
==

select string_ci, string_binary from CollatedTable {{union|except|intersect}} all
select 'abc', COLLATE('abc', 'und:ci')
--
ALTERNATION GROUP: union
--
ERROR: Collation conflict: "und:ci" vs. "binary"; in column 2, item 2 of set operation scan [at 1:1]
select string_ci, string_binary from CollatedTable union all
^
--
ALTERNATION GROUP: except
--
ERROR: Collation conflict: "und:ci" vs. "binary"; in column 2, item 2 of set operation scan [at 1:1]
select string_ci, string_binary from CollatedTable except all
^
--
ALTERNATION GROUP: intersect
--
ERROR: Collation conflict: "und:ci" vs. "binary"; in column 2, item 2 of set operation scan [at 1:1]
select string_ci, string_binary from CollatedTable intersect all
^
==

select string_binary, [STRUCT(true as a, collate('a', 'binary') as b)] from CollatedTable
union all
select 'abc', array_of_struct_ci from ComplexCollatedTable
--
ERROR: Collation conflict: "und:ci" vs. "binary"; in column 2, item 2 of set operation scan [at 1:1]
select string_binary, [STRUCT(true as a, collate('a', 'binary') as b)] from C...
^
==

select string_ci, 'abc' from CollatedTable
union all
select 'abc', string_binary from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$union_all.string_ci#11{Collation:"und:ci"} AS string_ci [STRING]
| +-$union_all.$col2#12{Collation:"binary"} AS "$col2" [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[string_ci#11, $col2#12]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, $union_all1.$col2#5]
      | |   +-expr_list=
      | |   | +-$col2#5 := Literal(type=STRING, value='abc')
      | |   +-input_scan=
      | |     +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
      | +-output_column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, $union_all1.$col2#5]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2.$col1#10, CollatedTable.string_binary#7{Collation:"binary"}]
        |   +-expr_list=
        |   | +-$col1#10 := Literal(type=STRING, value='abc')
        |   +-input_scan=
        |     +-TableScan(column_list=[CollatedTable.string_binary#7{Collation:"binary"}], table=CollatedTable, column_index_list=[1])
        +-output_column_list=[$union_all2.$col1#10, CollatedTable.string_binary#7{Collation:"binary"}]
==

select string_binary, [STRUCT(true as a, collate('a', 'und:ci') as b)] from CollatedTable
union all
select 'abc', array_of_struct_ci from ComplexCollatedTable
--
QueryStmt
+-output_column_list=
| +-$union_all.string_binary#13{Collation:"binary"} AS string_binary [STRING]
| +-$union_all.$col2#14[<_,{Collation:"und:ci"}>] AS "$col2" [ARRAY<STRUCT<a BOOL, b STRING>>]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[string_binary#13, $col2#14]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[CollatedTable.string_binary#2{Collation:"binary"}, $union_all1.$col2#5[<_,{Collation:"und:ci"}>]]
      | |   +-expr_list=
      | |   | +-$col2#5 :=
      | |   |   +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<a BOOL, b STRING>) -> ARRAY<STRUCT<a BOOL, b STRING>>)
      | |   |     +-type_annotation_map=[<_,{Collation:"und:ci"}>]
      | |   |     +-MakeStruct
      | |   |       +-type=STRUCT<a BOOL, b STRING>
      | |   |       +-type_annotation_map=<_,{Collation:"und:ci"}>
      | |   |       +-field_list=
      | |   |         +-Literal(type=BOOL, value=true)
      | |   |         +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
      | |   |           +-type_annotation_map={Collation:"und:ci"}
      | |   |           +-Literal(type=STRING, value='a')
      | |   |           +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
      | |   +-input_scan=
      | |     +-TableScan(column_list=[CollatedTable.string_binary#2{Collation:"binary"}], table=CollatedTable, column_index_list=[1])
      | +-output_column_list=[CollatedTable.string_binary#2{Collation:"binary"}, $union_all1.$col2#5[<_,{Collation:"und:ci"}>]]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2.$col1#12, ComplexCollatedTable.array_of_struct_ci#7[<_,{Collation:"und:ci"}>]]
        |   +-expr_list=
        |   | +-$col1#12 := Literal(type=STRING, value='abc')
        |   +-input_scan=
        |     +-TableScan(column_list=[ComplexCollatedTable.array_of_struct_ci#7[<_,{Collation:"und:ci"}>]], table=ComplexCollatedTable, column_index_list=[1])
        +-output_column_list=[$union_all2.$col1#12, ComplexCollatedTable.array_of_struct_ci#7[<_,{Collation:"und:ci"}>]]
==

select string_ci, 'abc' from CollatedTable
union all
select 'abc', string_binary from CollatedTable
union all
select COLLATE('def', 'und:ci'), string_binary from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$union_all.string_ci#16{Collation:"und:ci"} AS string_ci [STRING]
| +-$union_all.$col2#17{Collation:"binary"} AS "$col2" [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[string_ci#16, $col2#17]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, $union_all1.$col2#5]
      | |   +-expr_list=
      | |   | +-$col2#5 := Literal(type=STRING, value='abc')
      | |   +-input_scan=
      | |     +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
      | +-output_column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, $union_all1.$col2#5]
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all2.$col1#10, CollatedTable.string_binary#7{Collation:"binary"}]
      | |   +-expr_list=
      | |   | +-$col1#10 := Literal(type=STRING, value='abc')
      | |   +-input_scan=
      | |     +-TableScan(column_list=[CollatedTable.string_binary#7{Collation:"binary"}], table=CollatedTable, column_index_list=[1])
      | +-output_column_list=[$union_all2.$col1#10, CollatedTable.string_binary#7{Collation:"binary"}]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all3.$col1#15{Collation:"und:ci"}, CollatedTable.string_binary#12{Collation:"binary"}]
        |   +-expr_list=
        |   | +-$col1#15 :=
        |   |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |   |     +-type_annotation_map={Collation:"und:ci"}
        |   |     +-Literal(type=STRING, value='def')
        |   |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
        |   +-input_scan=
        |     +-TableScan(column_list=[CollatedTable.string_binary#12{Collation:"binary"}], table=CollatedTable, column_index_list=[1])
        +-output_column_list=[$union_all3.$col1#15{Collation:"und:ci"}, CollatedTable.string_binary#12{Collation:"binary"}]
==

create table t (a int64 collate 'und:ci');
--
ERROR: COLLATE can only be applied to columns or expressions of type STRING, but was applied to INT64 [at 1:25]
create table t (a int64 collate 'und:ci');
                        ^
==

create table t (a int64 collate 'und:ci', b string);
--
ERROR: COLLATE can only be applied to columns or expressions of type STRING, but was applied to INT64 [at 1:25]
create table t (a int64 collate 'und:ci', b string);
                        ^
==

create table t (a bytes collate 'und:ci', b string);
--
ERROR: COLLATE can only be applied to columns or expressions of type STRING, but was applied to BYTES [at 1:25]
create table t (a bytes collate 'und:ci', b string);
                        ^
==

create table t (a int64, b string collate 'und:ci');
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition(name='a', type=INT64, column=t.a#1)
  +-ColumnDefinition
    +-name='b'
    +-type=STRING
    +-annotations=
    | +-ColumnAnnotations
    |   +-collation_name=
    |     +-Literal(type=STRING, value='und:ci')
    +-column=t.b#2
==

create table t (a int64, b string collate 'und:ci')
as select 1, 'abc'
--
CreateTableAsSelectStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name='a', type=INT64, column=t.a#1)
| +-ColumnDefinition
|   +-name='b'
|   +-type=STRING
|   +-annotations=
|   | +-ColumnAnnotations
|   |   +-collation_name=
|   |     +-Literal(type=STRING, value='und:ci')
|   +-column=t.b#2
+-output_column_list=
| +-$create_as.$col1#3 AS a [INT64]
| +-$create_as.$col2#4 AS b [STRING]
+-query=
  +-ProjectScan
    +-column_list=$create_as.[$col1#3, $col2#4]
    +-expr_list=
    | +-$col1#3 := Literal(type=INT64, value=1)
    | +-$col2#4 := Literal(type=STRING, value='abc')
    +-input_scan=
      +-SingleRowScan
==

[no_run_unparser]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# CTAS should propagate collation from query to column_definition_list.
create table t
as select 1 a,
   collate('abc', 'und:ci') b,
   [collate('abc', 'und:ci')] c,
   (collate('abc', 'und:ci'), collate('def', 'binary'), 'ghi') d
--
CreateTableAsSelectStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name='a', type=INT64, column=t.a#5)
| +-ColumnDefinition
| | +-name='b'
| | +-type=STRING
| | +-annotations=
| | | +-ColumnAnnotations
| | |   +-collation_name=
| | |     +-Literal(type=STRING, value='und:ci')
| | +-column=t.b#6{Collation:"und:ci"}
| +-ColumnDefinition
| | +-name='c'
| | +-type=ARRAY<STRING>
| | +-annotations=
| | | +-ColumnAnnotations
| | |   +-child_list=
| | |     +-ColumnAnnotations
| | |       +-collation_name=
| | |         +-Literal(type=STRING, value='und:ci')
| | +-column=t.c#7[{Collation:"und:ci"}]
| +-ColumnDefinition
|   +-name='d'
|   +-type=STRUCT<STRING, STRING, STRING>
|   +-annotations=
|   | +-ColumnAnnotations
|   |   +-child_list=
|   |     +-ColumnAnnotations
|   |     | +-collation_name=
|   |     |   +-Literal(type=STRING, value='und:ci')
|   |     +-ColumnAnnotations
|   |       +-collation_name=
|   |         +-Literal(type=STRING, value='binary')
|   +-column=t.d#8<{Collation:"und:ci"},{Collation:"binary"},_>
+-output_column_list=
| +-$create_as.a#1 AS a [INT64]
| +-$create_as.b#2{Collation:"und:ci"} AS b [STRING]
| +-$create_as.c#3[{Collation:"und:ci"}] AS c [ARRAY<STRING>]
| +-$create_as.d#4<{Collation:"und:ci"},{Collation:"binary"},_> AS d [STRUCT<STRING, STRING, STRING>]
+-query=
  +-ProjectScan
    +-column_list=$create_as.[a#1, b#2, c#3, d#4]
    +-expr_list=
    | +-a#1 := Literal(type=INT64, value=1)
    | +-b#2 :=
    | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-Literal(type=STRING, value='abc')
    | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | +-c#3 :=
    | | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
    | |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |     +-type_annotation_map={Collation:"und:ci"}
    | |     +-Literal(type=STRING, value='abc')
    | |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | +-d#4 :=
    |   +-MakeStruct
    |     +-type=STRUCT<STRING, STRING, STRING>
    |     +-type_annotation_map=<{Collation:"und:ci"},{Collation:"binary"},_>
    |     +-field_list=
    |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | +-type_annotation_map={Collation:"und:ci"}
    |       | +-Literal(type=STRING, value='abc')
    |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | +-type_annotation_map={Collation:"binary"}
    |       | +-Literal(type=STRING, value='def')
    |       | +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
    |       +-Literal(type=STRING, value='ghi')
    +-input_scan=
      +-SingleRowScan
==

[no_run_unparser]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# CREATE VIEW should propagate collation from query to column_definition_list.
create view t
as select 1 a,
   collate('abc', 'und:ci') b,
   [collate('abc', 'und:ci')] c,
   (collate('abc', 'und:ci'), collate('def', 'binary'), 'ghi') d
--
CreateViewStmt
+-name_path=t
+-output_column_list=
| +-$view.a#1 AS a [INT64]
| +-$view.b#2{Collation:"und:ci"} AS b [STRING]
| +-$view.c#3[{Collation:"und:ci"}] AS c [ARRAY<STRING>]
| +-$view.d#4<{Collation:"und:ci"},{Collation:"binary"},_> AS d [STRUCT<STRING, STRING, STRING>]
+-query=
| +-ProjectScan
|   +-column_list=$view.[a#1, b#2, c#3, d#4]
|   +-expr_list=
|   | +-a#1 := Literal(type=INT64, value=1)
|   | +-b#2 :=
|   | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   | |   +-type_annotation_map={Collation:"und:ci"}
|   | |   +-Literal(type=STRING, value='abc')
|   | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   | +-c#3 :=
|   | | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
|   | |   +-type_annotation_map=[{Collation:"und:ci"}]
|   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   | |     +-type_annotation_map={Collation:"und:ci"}
|   | |     +-Literal(type=STRING, value='abc')
|   | |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   | +-d#4 :=
|   |   +-MakeStruct
|   |     +-type=STRUCT<STRING, STRING, STRING>
|   |     +-type_annotation_map=<{Collation:"und:ci"},{Collation:"binary"},_>
|   |     +-field_list=
|   |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   |       | +-type_annotation_map={Collation:"und:ci"}
|   |       | +-Literal(type=STRING, value='abc')
|   |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   |       | +-type_annotation_map={Collation:"binary"}
|   |       | +-Literal(type=STRING, value='def')
|   |       | +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
|   |       +-Literal(type=STRING, value='ghi')
|   +-input_scan=
|     +-SingleRowScan
+-sql='select 1 a,\n   collate(\'abc\', \'und:ci\') b,\n   [collate(\'abc\', \'und:ci\')] c,\n   (collate(\'abc\', \'und:ci\'), collate(\'def\', \'binary\'), \'ghi\') d'
+-column_definition_list=
  +-ColumnDefinition(name='a', type=INT64, column=t.a#5)
  +-ColumnDefinition
  | +-name='b'
  | +-type=STRING
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-collation_name=
  | |     +-Literal(type=STRING, value='und:ci')
  | +-column=t.b#6{Collation:"und:ci"}
  +-ColumnDefinition
  | +-name='c'
  | +-type=ARRAY<STRING>
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-child_list=
  | |     +-ColumnAnnotations
  | |       +-collation_name=
  | |         +-Literal(type=STRING, value='und:ci')
  | +-column=t.c#7[{Collation:"und:ci"}]
  +-ColumnDefinition
    +-name='d'
    +-type=STRUCT<STRING, STRING, STRING>
    +-annotations=
    | +-ColumnAnnotations
    |   +-child_list=
    |     +-ColumnAnnotations
    |     | +-collation_name=
    |     |   +-Literal(type=STRING, value='und:ci')
    |     +-ColumnAnnotations
    |       +-collation_name=
    |         +-Literal(type=STRING, value='binary')
    +-column=t.d#8<{Collation:"und:ci"},{Collation:"binary"},_>
==

[no_run_unparser]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# For CTAS, user specified column_definition_list should override the collation
# from the query.
create table t(x INT64,
               y STRING COLLATE 'binary',
               z ARRAY<STRING>,
               xx STRUCT<STRING, STRING, STRING COLLATE 'binary'>)
as select 1 a,
   collate('abc', 'und:ci') b,
   [collate('abc', 'und:ci')] c,
   (collate('abc', 'und:ci'), collate('def', 'binary'), 'ghi') d
--
CreateTableAsSelectStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name='x', type=INT64, column=t.x#1)
| +-ColumnDefinition
| | +-name='y'
| | +-type=STRING
| | +-annotations=
| | | +-ColumnAnnotations
| | |   +-collation_name=
| | |     +-Literal(type=STRING, value='binary')
| | +-column=t.y#2
| +-ColumnDefinition(name='z', type=ARRAY<STRING>, column=t.z#3)
| +-ColumnDefinition
|   +-name='xx'
|   +-type=STRUCT<STRING, STRING, STRING>
|   +-annotations=
|   | +-ColumnAnnotations
|   |   +-child_list=
|   |     +-ColumnAnnotations
|   |     +-ColumnAnnotations
|   |     +-ColumnAnnotations
|   |       +-collation_name=
|   |         +-Literal(type=STRING, value='binary')
|   +-column=t.xx#4
+-output_column_list=
| +-$create_as.a#5 AS x [INT64]
| +-$create_as.b#6{Collation:"und:ci"} AS y [STRING]
| +-$create_as.c#7[{Collation:"und:ci"}] AS z [ARRAY<STRING>]
| +-$create_as.d#8<{Collation:"und:ci"},{Collation:"binary"},_> AS xx [STRUCT<STRING, STRING, STRING>]
+-query=
  +-ProjectScan
    +-column_list=$create_as.[a#5, b#6, c#7, d#8]
    +-expr_list=
    | +-a#5 := Literal(type=INT64, value=1)
    | +-b#6 :=
    | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-Literal(type=STRING, value='abc')
    | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | +-c#7 :=
    | | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
    | |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |     +-type_annotation_map={Collation:"und:ci"}
    | |     +-Literal(type=STRING, value='abc')
    | |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | +-d#8 :=
    |   +-MakeStruct
    |     +-type=STRUCT<STRING, STRING, STRING>
    |     +-type_annotation_map=<{Collation:"und:ci"},{Collation:"binary"},_>
    |     +-field_list=
    |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | +-type_annotation_map={Collation:"und:ci"}
    |       | +-Literal(type=STRING, value='abc')
    |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | +-type_annotation_map={Collation:"binary"}
    |       | +-Literal(type=STRING, value='def')
    |       | +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
    |       +-Literal(type=STRING, value='ghi')
    +-input_scan=
      +-SingleRowScan
==

# CREATE VIEW should propagate collation from query to output_column_list.
create view t
as select * from CollatedTable
--
CreateViewStmt
+-name_path=t
+-output_column_list=
| +-CollatedTable.string_ci#1{Collation:"und:ci"} AS string_ci [STRING]
| +-CollatedTable.string_binary#2{Collation:"binary"} AS string_binary [STRING]
| +-CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}> AS struct_with_string_ci [STRUCT<a INT32, b STRING>]
| +-CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}] AS array_with_string_ci [ARRAY<STRING>]
+-query=
| +-ProjectScan
|   +-column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4]
|   +-input_scan=
|     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 2, 3])
+-sql='select * from CollatedTable'
+-column_definition_list=
  +-ColumnDefinition
  | +-name='string_ci'
  | +-type=STRING
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-collation_name=
  | |     +-Literal(type=STRING, value='und:ci')
  | +-column=t.string_ci#5{Collation:"und:ci"}
  +-ColumnDefinition
  | +-name='string_binary'
  | +-type=STRING
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-collation_name=
  | |     +-Literal(type=STRING, value='binary')
  | +-column=t.string_binary#6{Collation:"binary"}
  +-ColumnDefinition
  | +-name='struct_with_string_ci'
  | +-type=STRUCT<a INT32, b STRING>
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-child_list=
  | |     +-ColumnAnnotations
  | |     +-ColumnAnnotations
  | |       +-collation_name=
  | |         +-Literal(type=STRING, value='und:ci')
  | +-column=t.struct_with_string_ci#7<_,{Collation:"und:ci"}>
  +-ColumnDefinition
    +-name='array_with_string_ci'
    +-type=ARRAY<STRING>
    +-annotations=
    | +-ColumnAnnotations
    |   +-child_list=
    |     +-ColumnAnnotations
    |       +-collation_name=
    |         +-Literal(type=STRING, value='und:ci')
    +-column=t.array_with_string_ci#8[{Collation:"und:ci"}]
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE]
# CREATE RECURSIVE VIEW with collation in output columns is not supported.
create {{materialized|}} recursive view t
AS (
  select 1 as ind, COLLATE('a', 'und:ci') as string_ci union {{all|distinct}}
  (select ind + 1 as ind, 'a' as string_ci from t where ind < 3)
)
--
ALTERNATION GROUPS:
    materialized,all
    all
--
ERROR: Collation is not supported in recursive queries [at 4:3]
  select 1 as ind, COLLATE('a', 'und:ci') as string_ci union all
  ^
--
ALTERNATION GROUPS:
    materialized,distinct
    distinct
--
ERROR: Collation is not supported in recursive queries [at 4:3]
  select 1 as ind, COLLATE('a', 'und:ci') as string_ci union distinct
  ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE]
# CREATE RECURSIVE VIEW with collation in output columns is not supported.
create {{materialized|}} recursive view t
AS (
  select 1 as ind, 'a' as string_ci union {{all|distinct}}
  (select ind + 1 as ind, COLLATE('a', 'und:ci') as string_ci from t where ind < 3)
)
--
ALTERNATION GROUPS:
    materialized,all
    all
--
ERROR: Collation is not supported in recursive queries [at 4:3]
  select 1 as ind, 'a' as string_ci union all
  ^
--
ALTERNATION GROUPS:
    materialized,distinct
    distinct
--
ERROR: Collation is not supported in recursive queries [at 4:3]
  select 1 as ind, 'a' as string_ci union distinct
  ^
==

create table t (a int64, b string(50) collate 'und:ci');
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition(name='a', type=INT64, column=t.a#1)
  +-ColumnDefinition
    +-name='b'
    +-type=STRING
    +-annotations=
    | +-ColumnAnnotations
    |   +-collation_name=
    |   | +-Literal(type=STRING, value='und:ci')
    |   +-type_parameters=(max_length=50)
    +-column=t.b#2
==

CREATE MATERIALIZED VIEW mv
AS SELECT COLLATE('foo', 'und:ci') AS col1, STRUCT(COLLATE('bar', 'binary') AS col2_1, 1 AS col2_2) AS col2;
--
CreateMaterializedViewStmt
+-name_path=mv
+-output_column_list=
| +-$view.col1#1{Collation:"und:ci"} AS col1 [STRING]
| +-$view.col2#2<{Collation:"binary"},_> AS col2 [STRUCT<col2_1 STRING, col2_2 INT64>]
+-query=
| +-ProjectScan
|   +-column_list=$view.[col1#1, col2#2]
|   +-expr_list=
|   | +-col1#1 :=
|   | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   | |   +-type_annotation_map={Collation:"und:ci"}
|   | |   +-Literal(type=STRING, value='foo')
|   | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   | +-col2#2 :=
|   |   +-MakeStruct
|   |     +-type=STRUCT<col2_1 STRING, col2_2 INT64>
|   |     +-type_annotation_map=<{Collation:"binary"},_>
|   |     +-field_list=
|   |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   |       | +-type_annotation_map={Collation:"binary"}
|   |       | +-Literal(type=STRING, value='bar')
|   |       | +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
|   |       +-Literal(type=INT64, value=1)
|   +-input_scan=
|     +-SingleRowScan
+-sql='SELECT COLLATE(\'foo\', \'und:ci\') AS col1, STRUCT(COLLATE(\'bar\', \'binary\') AS col2_1, 1 AS col2_2) AS col2'
+-column_definition_list=
  +-ColumnDefinition
  | +-name='col1'
  | +-type=STRING
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-collation_name=
  | |     +-Literal(type=STRING, value='und:ci')
  | +-column=mv.col1#3{Collation:"und:ci"}
  +-ColumnDefinition
    +-name='col2'
    +-type=STRUCT<col2_1 STRING, col2_2 INT64>
    +-annotations=
    | +-ColumnAnnotations
    |   +-child_list=
    |     +-ColumnAnnotations
    |       +-collation_name=
    |         +-Literal(type=STRING, value='binary')
    +-column=mv.col2#4<{Collation:"binary"},_>
==

CREATE MATERIALIZED VIEW mv
AS SELECT * FROM CollatedTable
--
CreateMaterializedViewStmt
+-name_path=mv
+-output_column_list=
| +-CollatedTable.string_ci#1{Collation:"und:ci"} AS string_ci [STRING]
| +-CollatedTable.string_binary#2{Collation:"binary"} AS string_binary [STRING]
| +-CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}> AS struct_with_string_ci [STRUCT<a INT32, b STRING>]
| +-CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}] AS array_with_string_ci [ARRAY<STRING>]
+-query=
| +-ProjectScan
|   +-column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4]
|   +-input_scan=
|     +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 2, 3])
+-sql='SELECT * FROM CollatedTable'
+-column_definition_list=
  +-ColumnDefinition
  | +-name='string_ci'
  | +-type=STRING
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-collation_name=
  | |     +-Literal(type=STRING, value='und:ci')
  | +-column=mv.string_ci#5{Collation:"und:ci"}
  +-ColumnDefinition
  | +-name='string_binary'
  | +-type=STRING
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-collation_name=
  | |     +-Literal(type=STRING, value='binary')
  | +-column=mv.string_binary#6{Collation:"binary"}
  +-ColumnDefinition
  | +-name='struct_with_string_ci'
  | +-type=STRUCT<a INT32, b STRING>
  | +-annotations=
  | | +-ColumnAnnotations
  | |   +-child_list=
  | |     +-ColumnAnnotations
  | |     +-ColumnAnnotations
  | |       +-collation_name=
  | |         +-Literal(type=STRING, value='und:ci')
  | +-column=mv.struct_with_string_ci#7<_,{Collation:"und:ci"}>
  +-ColumnDefinition
    +-name='array_with_string_ci'
    +-type=ARRAY<STRING>
    +-annotations=
    | +-ColumnAnnotations
    |   +-child_list=
    |     +-ColumnAnnotations
    |       +-collation_name=
    |         +-Literal(type=STRING, value='und:ci')
    +-column=mv.array_with_string_ci#8[{Collation:"und:ci"}]
==

create table t (a int64, b numeric(20,5) collate 'und:ci');
--
ERROR: COLLATE can only be applied to columns or expressions of type STRING, but was applied to NUMERIC [at 1:42]
create table t (a int64, b numeric(20,5) collate 'und:ci');
                                         ^
==

create table t (a int64, b string collate 'und:cs') default collate 'und:ci';
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition(name='a', type=INT64, column=t.a#1)
| +-ColumnDefinition
|   +-name='b'
|   +-type=STRING
|   +-annotations=
|   | +-ColumnAnnotations
|   |   +-collation_name=
|   |     +-Literal(type=STRING, value='und:cs')
|   +-column=t.b#2
+-collation_name=
  +-Literal(type=STRING, value='und:ci')
==

create table t (a int64, b array<string> collate 'und:ci');
--
ERROR: COLLATE can only be applied to columns or expressions of type STRING, but was applied to ARRAY<STRING> [at 1:42]
create table t (a int64, b array<string> collate 'und:ci');
                                         ^
==

create table t (a int64, b struct<string> collate 'und:ci');
--
ERROR: COLLATE can only be applied to columns or expressions of type STRING, but was applied to STRUCT<STRING> [at 1:43]
create table t (a int64, b struct<string> collate 'und:ci');
                                          ^
==

create table t (a int64, b zetasql_test__.SimpleProto3Message collate 'und:ci');
--
ERROR: COLLATE can only be applied to columns or expressions of type STRING, but was applied to zetasql_test__.SimpleProto3Message [at 1:63]
create table t (a int64, b zetasql_test__.SimpleProto3Message collate 'und:ci');
                                                              ^
==

create table t (a int64, b array<string collate 'und:ci'>);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition(name='a', type=INT64, column=t.a#1)
  +-ColumnDefinition
    +-name='b'
    +-type=ARRAY<STRING>
    +-annotations=
    | +-ColumnAnnotations
    |   +-child_list=
    |     +-ColumnAnnotations
    |       +-collation_name=
    |         +-Literal(type=STRING, value='und:ci')
    +-column=t.b#2
==

create table t (a int64, b struct<int64, string collate 'und:ci', float64>);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition(name='a', type=INT64, column=t.a#1)
  +-ColumnDefinition
    +-name='b'
    +-type=STRUCT<INT64, STRING, DOUBLE>
    +-annotations=
    | +-ColumnAnnotations
    |   +-child_list=
    |     +-ColumnAnnotations
    |     +-ColumnAnnotations
    |       +-collation_name=
    |         +-Literal(type=STRING, value='und:ci')
    +-column=t.b#2
==

create table t (a int64, b array<string collate 'und:ci'>);
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition(name='a', type=INT64, column=t.a#1)
  +-ColumnDefinition
    +-name='b'
    +-type=ARRAY<STRING>
    +-annotations=
    | +-ColumnAnnotations
    |   +-child_list=
    |     +-ColumnAnnotations
    |       +-collation_name=
    |         +-Literal(type=STRING, value='und:ci')
    +-column=t.b#2
==

create table t (a int64, b string collate @test_param_string);
--
ERROR: COLLATE must be followed by a string literal [at 1:43]
create table t (a int64, b string collate @test_param_string);
                                          ^
==

[language_features=CREATE_TABLE_LIKE,CREATE_TABLE_PARTITION_BY,CREATE_TABLE_CLUSTER_BY,V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK]
[create_table_like_not_scanned]
create table t1 like KeyValue DEFAULT COLLATE 'und:ci' partition by Key cluster by Key options(table_option=1) ;
--
CreateTableStmt
+-name_path=t1
+-option_list=
| +-table_option := Literal(type=INT64, value=1)
+-column_definition_list=
| +-ColumnDefinition(name='Key', type=INT64, column=t1.Key#1)
| +-ColumnDefinition(name='Value', type=STRING, column=t1.Value#2)
+-pseudo_column_list=t1.[pseudo_column_int32#3, pseudo_column_kitchensink#4, pseudo_column_timestamp#5]
+-like_table=KeyValue
+-collation_name=
| +-Literal(type=STRING, value='und:ci')
+-partition_by_list=
| +-ColumnRef(type=INT64, column=t1.Key#1)
+-cluster_by_list=
  +-ColumnRef(type=INT64, column=t1.Key#1)
==

CREATE SCHEMA COLLATE 'und:ci' myProject.mySchema;
--
ERROR: Syntax error: Unexpected keyword COLLATE [at 1:15]
CREATE SCHEMA COLLATE 'und:ci' myProject.mySchema;
              ^
==

CREATE SCHEMA myProject.mySchema DEFAULT COLLATE 'und:ci';
--
CreateSchemaStmt
+-name_path=myProject.mySchema
+-collation_name=
  +-Literal(type=STRING, value='und:ci')
==

CREATE SCHEMA myProject.mySchema DEFAULT COLLATE 'und:ci' OPTIONS(a='b', c='d');
--
CreateSchemaStmt
+-name_path=myProject.mySchema
+-collation_name=
| +-Literal(type=STRING, value='und:ci')
+-option_list=
  +-a := Literal(type=STRING, value='b')
  +-c := Literal(type=STRING, value='d')
==

create table t (a int64, b string collate 'und:cs') default collate cast(null as string);
--
ERROR: Syntax error: Expected "@" or "@@" or string literal but got keyword CAST [at 1:69]
...a int64, b string collate 'und:cs') default collate cast(null as string);
                                                       ^
==

create table t (a int64, b string collate 'und:cs') default collate TestConstantString;
--
ERROR: Syntax error: Expected "@" or "@@" or string literal but got identifier "TestConstantString" [at 1:69]
...a int64, b string collate 'und:cs') default collate TestConstantString;
                                                       ^
==

create table t (a int64, b string) default collate concat('und', '-', 'ci');
--
ERROR: Syntax error: Expected "@" or "@@" or string literal but got identifier "concat" [at 1:52]
create table t (a int64, b string) default collate concat('und', '-', 'ci');
                                                   ^
==

create table t (a int64, b string) default collate @test_param_string;
--
ERROR: COLLATE must be followed by a string literal [at 1:52]
create table t (a int64, b string) default collate @test_param_string;
                                                   ^
==

CREATE SCHEMA myProject.mySchema DEFAULT COLLATE cast(null as string);
--
ERROR: Syntax error: Expected "@" or "@@" or string literal but got keyword CAST [at 1:50]
CREATE SCHEMA myProject.mySchema DEFAULT COLLATE cast(null as string);
                                                 ^
==

CREATE SCHEMA myProject.mySchema DEFAULT COLLATE TestConstantString;
--
ERROR: Syntax error: Expected "@" or "@@" or string literal but got identifier "TestConstantString" [at 1:50]
CREATE SCHEMA myProject.mySchema DEFAULT COLLATE TestConstantString;
                                                 ^
==

CREATE SCHEMA myProject.mySchema DEFAULT COLLATE concat('und', '-', 'ci');
--
ERROR: Syntax error: Expected "@" or "@@" or string literal but got identifier "concat" [at 1:50]
CREATE SCHEMA myProject.mySchema DEFAULT COLLATE concat('und', '-', 'ci');
                                                 ^
==

CREATE SCHEMA myProject.mySchema DEFAULT COLLATE @test_param_string;
--
ERROR: COLLATE must be followed by a string literal [at 1:50]
CREATE SCHEMA myProject.mySchema DEFAULT COLLATE @test_param_string;
                                                 ^
==

alter {{database|schema|table|view|materialized view}} if exists entity set default collate 'und:ci';
--
ALTERNATION GROUP: database
--
ERROR: ALTER DATABASE does not support SET DEFAULT COLLATE [at 1:33]
alter database if exists entity set default collate 'und:ci';
                                ^
--
ALTERNATION GROUP: schema
--
AlterSchemaStmt
+-name_path=entity
+-alter_action_list=
| +-SetCollateClause
|   +-collation_name=
|     +-Literal(type=STRING, value='und:ci')
+-is_if_exists=TRUE
--
ALTERNATION GROUP: table
--
AlterTableStmt
+-name_path=entity
+-alter_action_list=
| +-SetCollateClause
|   +-collation_name=
|     +-Literal(type=STRING, value='und:ci')
+-is_if_exists=TRUE
--
ALTERNATION GROUP: view
--
ERROR: ALTER VIEW does not support SET DEFAULT COLLATE [at 1:29]
alter view if exists entity set default collate 'und:ci';
                            ^
--
ALTERNATION GROUP: materialized view
--
ERROR: ALTER MATERIALIZED VIEW does not support SET DEFAULT COLLATE [at 1:42]
alter materialized view if exists entity set default collate 'und:ci';
                                         ^
==

ALTER TABLE t SET DEFAULT COLLATE 'und:ci';
--
AlterTableStmt
+-name_path=t
+-alter_action_list=
  +-SetCollateClause
    +-collation_name=
      +-Literal(type=STRING, value='und:ci')
==

ALTER TABLE t SET DEFAULT COLLATE '';
--
AlterTableStmt
+-name_path=t
+-alter_action_list=
  +-SetCollateClause
    +-collation_name=
      +-Literal(type=STRING, value='')
==

ALTER TABLE t SET DEFAULT COLLATE NULL;
--
ERROR: Syntax error: Expected "@" or "@@" or string literal but got keyword NULL [at 1:35]
ALTER TABLE t SET DEFAULT COLLATE NULL;
                                  ^
==

ALTER TABLE t SET DEFAULT COLLATE CAST(NULL AS STRING);
--
ERROR: Syntax error: Expected "@" or "@@" or string literal but got keyword CAST [at 1:35]
ALTER TABLE t SET DEFAULT COLLATE CAST(NULL AS STRING);
                                  ^
==

ALTER TABLE t SET DEFAULT COLLATE @test_param_string;
--
ERROR: COLLATE must be followed by a string literal [at 1:35]
ALTER TABLE t SET DEFAULT COLLATE @test_param_string;
                                  ^
==

INSERT CollatedTable (string_binary)
VALUES(collate('b', 'binary')),
      (collate('a', 'und:ci')),
      ('c')
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[CollatedTable.string_binary#2{Collation:"binary"}], table=CollatedTable, column_index_list=[1])
+-insert_column_list=[CollatedTable.string_binary#2{Collation:"binary"}]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |     +-value=
| |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
| |         +-type_annotation_map={Collation:"binary"}
| |         +-Literal(type=STRING, value='b')
| |         +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |     +-value=
| |       +-Cast(STRING -> STRING)
| |         +-type_annotation_map={Collation:"binary"}
| |         +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
| |           +-type_annotation_map={Collation:"und:ci"}
| |           +-Literal(type=STRING, value='a')
| |           +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
| |         +-type_modifiers=collation:binary
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Cast(STRING -> STRING)
|           +-type_annotation_map={Collation:"binary"}
|           +-Literal(type=STRING, value='c')
|           +-type_modifiers=collation:binary
+-column_access_list=WRITE
==

INSERT CollatedTable (struct_with_string_ci)
VALUES((1, collate('a', 'und:ci'))),
      ((2, collate('b', 'binary'))),
      ((3, 'c'))
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>], table=CollatedTable, column_index_list=[2])
+-insert_column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |     +-value=
| |       +-MakeStruct
| |         +-type=STRUCT<a INT32, b STRING>
| |         +-type_annotation_map=<_,{Collation:"und:ci"}>
| |         +-field_list=
| |           +-Literal(type=INT32, value=1)
| |           +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
| |             +-type_annotation_map={Collation:"und:ci"}
| |             +-Literal(type=STRING, value='a')
| |             +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |     +-value=
| |       +-MakeStruct
| |         +-type=STRUCT<a INT32, b STRING>
| |         +-type_annotation_map=<_,{Collation:"und:ci"}>
| |         +-field_list=
| |           +-Literal(type=INT32, value=2)
| |           +-Cast(STRING -> STRING)
| |             +-type_annotation_map={Collation:"und:ci"}
| |             +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
| |               +-type_annotation_map={Collation:"binary"}
| |               +-Literal(type=STRING, value='b')
| |               +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
| |             +-type_modifiers=collation:und:ci
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Cast(STRUCT<a INT32, b STRING> -> STRUCT<a INT32, b STRING>)
|           +-type_annotation_map=<_,{Collation:"und:ci"}>
|           +-Literal(type=STRUCT<a INT32, b STRING>, value={a:3, b:'c'})
|           +-type_modifiers=collation:[_,und:ci]
+-column_access_list=WRITE
==

INSERT ComplexCollatedTable (struct_with_string_ci_binary)
VALUES((collate('a', 'binary'), collate('b', 'und:ci'))),
      (('c', collate('d', 'und:ci')))
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[ComplexCollatedTable.struct_with_string_ci_binary#5<{Collation:"und:ci"},{Collation:"binary"}>], table=ComplexCollatedTable, column_index_list=[4])
+-insert_column_list=[ComplexCollatedTable.struct_with_string_ci_binary#5<{Collation:"und:ci"},{Collation:"binary"}>]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |     +-value=
| |       +-MakeStruct
| |         +-type=STRUCT<a STRING, b STRING>
| |         +-type_annotation_map=<{Collation:"und:ci"},{Collation:"binary"}>
| |         +-field_list=
| |           +-Cast(STRING -> STRING)
| |           | +-type_annotation_map={Collation:"und:ci"}
| |           | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
| |           |   +-type_annotation_map={Collation:"binary"}
| |           |   +-Literal(type=STRING, value='a')
| |           |   +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
| |           | +-type_modifiers=collation:und:ci
| |           +-Cast(STRING -> STRING)
| |             +-type_annotation_map={Collation:"binary"}
| |             +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
| |               +-type_annotation_map={Collation:"und:ci"}
| |               +-Literal(type=STRING, value='b')
| |               +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
| |             +-type_modifiers=collation:binary
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-MakeStruct
|           +-type=STRUCT<a STRING, b STRING>
|           +-type_annotation_map=<{Collation:"und:ci"},{Collation:"binary"}>
|           +-field_list=
|             +-Cast(STRING -> STRING)
|             | +-type_annotation_map={Collation:"und:ci"}
|             | +-Literal(type=STRING, value='c')
|             | +-type_modifiers=collation:und:ci
|             +-Cast(STRING -> STRING)
|               +-type_annotation_map={Collation:"binary"}
|               +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|                 +-type_annotation_map={Collation:"und:ci"}
|                 +-Literal(type=STRING, value='d')
|                 +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|               +-type_modifiers=collation:binary
+-column_access_list=WRITE
==

INSERT ComplexCollatedTable (struct_of_struct_ci)
VALUES((1, (1, 'a'))),
      ((2, (2, collate('b', 'binary'))))
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[ComplexCollatedTable.struct_of_struct_ci#4<_,<_,{Collation:"und:ci"}>>], table=ComplexCollatedTable, column_index_list=[3])
+-insert_column_list=[ComplexCollatedTable.struct_of_struct_ci#4<_,<_,{Collation:"und:ci"}>>]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |     +-value=
| |       +-Cast(STRUCT<c INT32, d STRUCT<a INT32, b STRING>> -> STRUCT<c INT32, d STRUCT<a INT32, b STRING>>)
| |         +-type_annotation_map=<_,<_,{Collation:"und:ci"}>>
| |         +-Literal(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, value={c:1, d:{a:1, b:'a'}})
| |         +-type_modifiers=collation:[_,[_,und:ci]]
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-MakeStruct
|           +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
|           +-type_annotation_map=<_,<_,{Collation:"und:ci"}>>
|           +-field_list=
|             +-Literal(type=INT32, value=2)
|             +-MakeStruct
|               +-type=STRUCT<a INT32, b STRING>
|               +-type_annotation_map=<_,{Collation:"und:ci"}>
|               +-field_list=
|                 +-Literal(type=INT32, value=2)
|                 +-Cast(STRING -> STRING)
|                   +-type_annotation_map={Collation:"und:ci"}
|                   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|                     +-type_annotation_map={Collation:"binary"}
|                     +-Literal(type=STRING, value='b')
|                     +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
|                   +-type_modifiers=collation:und:ci
+-column_access_list=WRITE
==

INSERT CollatedTable (array_with_string_ci)
VALUES([collate('a', 'und:ci')]),
      ([collate('b', 'binary')]),
      (['c'])
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}]], table=CollatedTable, column_index_list=[3])
+-insert_column_list=[CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}]]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |     +-value=
| |       +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
| |         +-type_annotation_map=[{Collation:"und:ci"}]
| |         +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
| |           +-type_annotation_map={Collation:"und:ci"}
| |           +-Literal(type=STRING, value='a')
| |           +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |     +-value=
| |       +-Cast(ARRAY<STRING> -> ARRAY<STRING>)
| |         +-type_annotation_map=[{Collation:"und:ci"}]
| |         +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
| |           +-type_annotation_map=[{Collation:"binary"}]
| |           +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
| |             +-type_annotation_map={Collation:"binary"}
| |             +-Literal(type=STRING, value='b')
| |             +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
| |         +-type_modifiers=collation:[und:ci]
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Cast(ARRAY<STRING> -> ARRAY<STRING>)
|           +-type_annotation_map=[{Collation:"und:ci"}]
|           +-Literal(type=ARRAY<STRING>, value=['c'])
|           +-type_modifiers=collation:[und:ci]
+-column_access_list=WRITE
==

INSERT ComplexCollatedTable (struct_with_array_of_struct_ci)
VALUES((1, [STRUCT(true as a, collate('a', 'binary') as b)])),
      ((2, [STRUCT(false as a, 'b' as b)]))
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[ComplexCollatedTable.struct_with_array_of_struct_ci#3<_,[<_,{Collation:"und:ci"}>]>], table=ComplexCollatedTable, column_index_list=[2])
+-insert_column_list=[ComplexCollatedTable.struct_with_array_of_struct_ci#3<_,[<_,{Collation:"und:ci"}>]>]
+-row_list=
| +-InsertRow
| | +-value_list=
| |   +-DMLValue
| |     +-value=
| |       +-MakeStruct
| |         +-type=STRUCT<a INT32, b ARRAY<STRUCT<a BOOL, b STRING>>>
| |         +-type_annotation_map=<_,[<_,{Collation:"und:ci"}>]>
| |         +-field_list=
| |           +-Literal(type=INT32, value=1)
| |           +-Cast(ARRAY<STRUCT<a BOOL, b STRING>> -> ARRAY<STRUCT<a BOOL, b STRING>>)
| |             +-type_annotation_map=[<_,{Collation:"und:ci"}>]
| |             +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<a BOOL, b STRING>) -> ARRAY<STRUCT<a BOOL, b STRING>>)
| |               +-type_annotation_map=[<_,{Collation:"binary"}>]
| |               +-MakeStruct
| |                 +-type=STRUCT<a BOOL, b STRING>
| |                 +-type_annotation_map=<_,{Collation:"binary"}>
| |                 +-field_list=
| |                   +-Literal(type=BOOL, value=true)
| |                   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
| |                     +-type_annotation_map={Collation:"binary"}
| |                     +-Literal(type=STRING, value='a')
| |                     +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
| |             +-type_modifiers=collation:[[_,und:ci]]
| +-InsertRow
|   +-value_list=
|     +-DMLValue
|       +-value=
|         +-Cast(STRUCT<a INT32, b ARRAY<STRUCT<a BOOL, b STRING>>> -> STRUCT<a INT32, b ARRAY<STRUCT<a BOOL, b STRING>>>)
|           +-type_annotation_map=<_,[<_,{Collation:"und:ci"}>]>
|           +-Literal(type=STRUCT<a INT32, b ARRAY<STRUCT<a BOOL, b STRING>>>, value={a:2, b:[{a:false, b:'b'}]})
|           +-type_modifiers=collation:[_,[[_,und:ci]]]
+-column_access_list=WRITE
==

UPDATE CollatedTable
SET string_ci = COLLATE('a', 'binary'),
    string_binary = 'b',
    struct_with_string_ci = (1, collate('c', 'binary')),
    array_with_string_ci = [collate('e', 'binary')]
WHERE string_ci = 'f'
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 2, 3])
+-column_access_list=READ_WRITE,WRITE,WRITE,WRITE
+-where_expr=
| +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
|   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
|   +-Literal(type=STRING, value='f')
|   +-collation_list=[und:ci]
+-update_item_list=
  +-UpdateItem
  | +-target=
  | | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
  | +-set_value=
  |   +-DMLValue
  |     +-value=
  |       +-Cast(STRING -> STRING)
  |         +-type_annotation_map={Collation:"und:ci"}
  |         +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
  |           +-type_annotation_map={Collation:"binary"}
  |           +-Literal(type=STRING, value='a')
  |           +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
  |         +-type_modifiers=collation:und:ci
  +-UpdateItem
  | +-target=
  | | +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
  | +-set_value=
  |   +-DMLValue
  |     +-value=
  |       +-Cast(STRING -> STRING)
  |         +-type_annotation_map={Collation:"binary"}
  |         +-Literal(type=STRING, value='b')
  |         +-type_modifiers=collation:binary
  +-UpdateItem
  | +-target=
  | | +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
  | +-set_value=
  |   +-DMLValue
  |     +-value=
  |       +-MakeStruct
  |         +-type=STRUCT<a INT32, b STRING>
  |         +-type_annotation_map=<_,{Collation:"und:ci"}>
  |         +-field_list=
  |           +-Literal(type=INT32, value=1)
  |           +-Cast(STRING -> STRING)
  |             +-type_annotation_map={Collation:"und:ci"}
  |             +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
  |               +-type_annotation_map={Collation:"binary"}
  |               +-Literal(type=STRING, value='c')
  |               +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
  |             +-type_modifiers=collation:und:ci
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    +-set_value=
      +-DMLValue
        +-value=
          +-Cast(ARRAY<STRING> -> ARRAY<STRING>)
            +-type_annotation_map=[{Collation:"und:ci"}]
            +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
              +-type_annotation_map=[{Collation:"binary"}]
              +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
                +-type_annotation_map={Collation:"binary"}
                +-Literal(type=STRING, value='e')
                +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
            +-type_modifiers=collation:[und:ci]
==

UPDATE ComplexCollatedTable
SET string_no_collation = COLLATE('a', 'binary')
WHERE string_no_collation = 'f'
--
UpdateStmt
+-table_scan=
| +-TableScan(column_list=[ComplexCollatedTable.string_no_collation#1], table=ComplexCollatedTable, column_index_list=[0])
+-column_access_list=READ_WRITE
+-where_expr=
| +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
|   +-ColumnRef(type=STRING, column=ComplexCollatedTable.string_no_collation#1)
|   +-Literal(type=STRING, value='f')
+-update_item_list=
  +-UpdateItem
    +-target=
    | +-ColumnRef(type=STRING, column=ComplexCollatedTable.string_no_collation#1)
    +-set_value=
      +-DMLValue
        +-value=
          +-Cast(STRING -> STRING)
            +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
              +-type_annotation_map={Collation:"binary"}
              +-Literal(type=STRING, value='a')
              +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
==

CREATE {{TEMP|}} FUNCTION f(x STRING) AS (x);
--
ALTERNATION GROUP: TEMP
--
CreateFunctionStmt
+-name_path=f
+-create_scope=CREATE_TEMP
+-return_type=STRING
+-argument_name_list=[x]
+-signature=(STRING x) -> STRING rejects_collation=TRUE
+-language='SQL'
+-code='x'
+-function_expression=
  +-ArgumentRef(type=STRING, name='x')
--
ALTERNATION GROUP: <empty>
--
CreateFunctionStmt
+-name_path=f
+-return_type=STRING
+-argument_name_list=[x]
+-signature=(STRING x) -> STRING rejects_collation=TRUE
+-language='SQL'
+-code='x'
+-function_expression=
  +-ArgumentRef(type=STRING, name='x')
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_UNNEST_AND_FLATTEN_ARRAYS]
SELECT FLATTEN([STRUCT(COLLATE('a', 'und:ci') as x, 1 as y)].x);
--
ERROR: Collation is not allowed on input array to FLATTEN ([<"und:ci",_>]) [at 1:8]
SELECT FLATTEN([STRUCT(COLLATE('a', 'und:ci') as x, 1 as y)].x);
       ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_UNNEST_AND_FLATTEN_ARRAYS]
# The path expression is effectively a single array.
SELECT FLATTEN([COLLATE('a', 'und:ci'), COLLATE('b', 'und:ci')]);
--
ERROR: Collation is not allowed on input array to FLATTEN (["und:ci"]) [at 2:8]
SELECT FLATTEN([COLLATE('a', 'und:ci'), COLLATE('b', 'und:ci')]);
       ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_UNNEST_AND_FLATTEN_ARRAYS]
# The path expression is effectively a single array.
SELECT FLATTEN(STRUCT([COLLATE('a', 'und:ci'), COLLATE('b', 'und:ci')] as x, 1 as y).x);
--
ERROR: Collation is not allowed on input array to FLATTEN (["und:ci"]) [at 2:8]
SELECT FLATTEN(STRUCT([COLLATE('a', 'und:ci'), COLLATE('b', 'und:ci')] as x, ...
       ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT]
# Collation in explicit CAST is not supported when flag
# FEATURE_V_1_4_COLLATION_IN_EXPLICIT_CAST is off.
SELECT
  CAST('a' AS STRING COLLATE 'und:ci')
FROM CollatedTable
--
ERROR: Type with collation name is not supported in cast [at 4:22]
  CAST('a' AS STRING COLLATE 'und:ci')
                     ^
==

SELECT
  CAST('a' AS STRING COLLATE 'und:ci'),
  CAST(string_ci AS STRING COLLATE 'binary'),
  CAST(string_binary AS STRING COLLATE 'und:ci')
FROM CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5{Collation:"und:ci"} AS "$col1" [STRING]
| +-$query.$col2#6{Collation:"binary"} AS "$col2" [STRING]
| +-$query.$col3#7{Collation:"und:ci"} AS "$col3" [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7]
    +-expr_list=
    | +-$col1#5 :=
    | | +-Cast(STRING -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-Literal(type=STRING, value='a', has_explicit_type=TRUE)
    | |   +-type_modifiers=collation:und:ci
    | +-$col2#6 :=
    | | +-Cast(STRING -> STRING)
    | |   +-type_annotation_map={Collation:"binary"}
    | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    | |   +-type_modifiers=collation:binary
    | +-$col3#7 :=
    |   +-Cast(STRING -> STRING)
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
    |     +-type_modifiers=collation:und:ci
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
==

[language_features=V_1_1_CAST_DIFFERENT_ARRAY_TYPES,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_4_COLLATION_IN_EXPLICIT_CAST]
SELECT
  CAST(['a', 'b'] AS ARRAY<STRING COLLATE 'und:ci'>),
  CAST(array_with_string_ci AS ARRAY<STRING COLLATE 'binary'>),
  CAST([COLLATE('a', 'binary'), 'B'] AS ARRAY<STRING COLLATE 'und:ci'>)
FROM CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5[{Collation:"und:ci"}] AS "$col1" [ARRAY<STRING>]
| +-$query.$col2#6[{Collation:"binary"}] AS "$col2" [ARRAY<STRING>]
| +-$query.$col3#7[{Collation:"und:ci"}] AS "$col3" [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7]
    +-expr_list=
    | +-$col1#5 :=
    | | +-Cast(ARRAY<STRING> -> ARRAY<STRING>)
    | |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |   +-Literal(type=ARRAY<STRING>, value=['a', 'b'], has_explicit_type=TRUE)
    | |   +-type_modifiers=collation:[und:ci]
    | +-$col2#6 :=
    | | +-Cast(ARRAY<STRING> -> ARRAY<STRING>)
    | |   +-type_annotation_map=[{Collation:"binary"}]
    | |   +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    | |   +-type_modifiers=collation:[binary]
    | +-$col3#7 :=
    |   +-Cast(ARRAY<STRING> -> ARRAY<STRING>)
    |     +-type_annotation_map=[{Collation:"und:ci"}]
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |       +-type_annotation_map=[{Collation:"binary"}]
    |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | +-type_annotation_map={Collation:"binary"}
    |       | +-Literal(type=STRING, value='a')
    |       | +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
    |       +-Literal(type=STRING, value='B')
    |     +-type_modifiers=collation:[und:ci]
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}]], table=CollatedTable, column_index_list=[3])
==

SELECT CAST(['a'] AS ARRAY<STRING> COLLATE 'und:ci')
--
ERROR: ARRAY<STRING> type cannot have collation by itself, it can only have collation on its element type [at 1:36]
SELECT CAST(['a'] AS ARRAY<STRING> COLLATE 'und:ci')
                                   ^
==

[no_run_unparser]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
SELECT
  CAST(('a', 1) AS STRUCT<STRING COLLATE 'und:ci', INT32>),
  CAST((COLLATE('a', 'binary'), 1) AS STRUCT<STRING COLLATE 'und:ci', INT32>),
  CAST((COLLATE('a', 'und:ci'), 1) AS STRUCT<STRING COLLATE 'binary', INT32>),
  # Cast is pushed down to the STRING field which is a literal.
  CAST(('a', LENGTH('A')) AS STRUCT<STRING COLLATE 'und:ci', INT64>),
  # Struct type with field names.
  CAST(struct_with_string_ci AS STRUCT<a INT32, b STRING COLLATE 'binary'>),
FROM CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5<{Collation:"und:ci"},_> AS "$col1" [STRUCT<STRING, INT32>]
| +-$query.$col2#6<{Collation:"und:ci"},_> AS "$col2" [STRUCT<STRING, INT32>]
| +-$query.$col3#7<{Collation:"binary"},_> AS "$col3" [STRUCT<STRING, INT32>]
| +-$query.$col4#8<{Collation:"und:ci"},_> AS "$col4" [STRUCT<STRING, INT64>]
| +-$query.$col5#9<_,{Collation:"binary"}> AS "$col5" [STRUCT<a INT32, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7, $col4#8, $col5#9]
    +-expr_list=
    | +-$col1#5 :=
    | | +-Cast(STRUCT<STRING, INT32> -> STRUCT<STRING, INT32>)
    | |   +-type_annotation_map=<{Collation:"und:ci"},_>
    | |   +-Literal(type=STRUCT<STRING, INT32>, value={'a', 1}, has_explicit_type=TRUE)
    | |   +-type_modifiers=collation:[und:ci,_]
    | +-$col2#6 :=
    | | +-MakeStruct
    | |   +-type=STRUCT<STRING, INT32>
    | |   +-type_annotation_map=<{Collation:"und:ci"},_>
    | |   +-field_list=
    | |     +-Cast(STRING -> STRING)
    | |     | +-type_annotation_map={Collation:"und:ci"}
    | |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |     |   +-type_annotation_map={Collation:"binary"}
    | |     |   +-Literal(type=STRING, value='a')
    | |     |   +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
    | |     | +-type_modifiers=collation:und:ci
    | |     +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
    | +-$col3#7 :=
    | | +-MakeStruct
    | |   +-type=STRUCT<STRING, INT32>
    | |   +-type_annotation_map=<{Collation:"binary"},_>
    | |   +-field_list=
    | |     +-Cast(STRING -> STRING)
    | |     | +-type_annotation_map={Collation:"binary"}
    | |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |     |   +-type_annotation_map={Collation:"und:ci"}
    | |     |   +-Literal(type=STRING, value='a')
    | |     |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | |     | +-type_modifiers=collation:binary
    | |     +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
    | +-$col4#8 :=
    | | +-MakeStruct
    | |   +-type=STRUCT<STRING, INT64>
    | |   +-type_annotation_map=<{Collation:"und:ci"},_>
    | |   +-field_list=
    | |     +-Cast(STRING -> STRING)
    | |     | +-type_annotation_map={Collation:"und:ci"}
    | |     | +-Literal(type=STRING, value='a', has_explicit_type=TRUE)
    | |     | +-type_modifiers=collation:und:ci
    | |     +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
    | |       +-Literal(type=STRING, value='A')
    | +-$col5#9 :=
    |   +-Cast(STRUCT<a INT32, b STRING> -> STRUCT<a INT32, b STRING>)
    |     +-type_annotation_map=<_,{Collation:"binary"}>
    |     +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    |     +-type_modifiers=collation:[_,binary]
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>], table=CollatedTable, column_index_list=[2])
==

SELECT CAST(('a', 1) AS STRUCT<STRING, INT32> COLLATE 'und:ci')
--
ERROR: STRUCT<STRING, INT32> type cannot have collation by itself, it can only have collation on its field type [at 1:47]
SELECT CAST(('a', 1) AS STRUCT<STRING, INT32> COLLATE 'und:ci')
                                              ^
==

# CAST to more complex collated types.
SELECT
  CAST(struct_with_string_ci_binary AS STRUCT<STRING COLLATE 'binary', STRING>),
  CAST(struct_with_string_ci_binary AS STRUCT<STRING COLLATE 'binary', STRING COLLATE 'und:ci'>),
  CAST(struct_of_struct_ci AS STRUCT<c INT32, d STRUCT<a INT32, b STRING COLLATE 'binary'>>),
  CAST(struct_with_array_of_struct_ci AS STRUCT<a INT32, b ARRAY<STRUCT<a BOOL, b STRING COLLATE 'binary'>>>)
FROM ComplexCollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7<{Collation:"binary"},_> AS "$col1" [STRUCT<STRING, STRING>]
| +-$query.$col2#8<{Collation:"binary"},{Collation:"und:ci"}> AS "$col2" [STRUCT<STRING, STRING>]
| +-$query.$col3#9<_,<_,{Collation:"binary"}>> AS "$col3" [STRUCT<c INT32, d STRUCT<a INT32, b STRING>>]
| +-$query.$col4#10<_,[<_,{Collation:"binary"}>]> AS "$col4" [STRUCT<a INT32, b ARRAY<STRUCT<a BOOL, b STRING>>>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#7, $col2#8, $col3#9, $col4#10]
    +-expr_list=
    | +-$col1#7 :=
    | | +-Cast(STRUCT<a STRING, b STRING> -> STRUCT<STRING, STRING>)
    | |   +-type_annotation_map=<{Collation:"binary"},_>
    | |   +-ColumnRef(type=STRUCT<a STRING, b STRING>, type_annotation_map=<{Collation:"und:ci"},{Collation:"binary"}>, column=ComplexCollatedTable.struct_with_string_ci_binary#5<{Collation:"und:ci"},{Collation:"binary"}>)
    | |   +-type_modifiers=collation:[binary,_]
    | +-$col2#8 :=
    | | +-Cast(STRUCT<a STRING, b STRING> -> STRUCT<STRING, STRING>)
    | |   +-type_annotation_map=<{Collation:"binary"},{Collation:"und:ci"}>
    | |   +-ColumnRef(type=STRUCT<a STRING, b STRING>, type_annotation_map=<{Collation:"und:ci"},{Collation:"binary"}>, column=ComplexCollatedTable.struct_with_string_ci_binary#5<{Collation:"und:ci"},{Collation:"binary"}>)
    | |   +-type_modifiers=collation:[binary,und:ci]
    | +-$col3#9 :=
    | | +-Cast(STRUCT<c INT32, d STRUCT<a INT32, b STRING>> -> STRUCT<c INT32, d STRUCT<a INT32, b STRING>>)
    | |   +-type_annotation_map=<_,<_,{Collation:"binary"}>>
    | |   +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, type_annotation_map=<_,<_,{Collation:"und:ci"}>>, column=ComplexCollatedTable.struct_of_struct_ci#4<_,<_,{Collation:"und:ci"}>>)
    | |   +-type_modifiers=collation:[_,[_,binary]]
    | +-$col4#10 :=
    |   +-Cast(STRUCT<a INT32, b ARRAY<STRUCT<a BOOL, b STRING>>> -> STRUCT<a INT32, b ARRAY<STRUCT<a BOOL, b STRING>>>)
    |     +-type_annotation_map=<_,[<_,{Collation:"binary"}>]>
    |     +-ColumnRef(type=STRUCT<a INT32, b ARRAY<STRUCT<a BOOL, b STRING>>>, type_annotation_map=<_,[<_,{Collation:"und:ci"}>]>, column=ComplexCollatedTable.struct_with_array_of_struct_ci#3<_,[<_,{Collation:"und:ci"}>]>)
    |     +-type_modifiers=collation:[_,[[_,binary]]]
    +-input_scan=
      +-TableScan(column_list=ComplexCollatedTable.[struct_with_array_of_struct_ci#3, struct_of_struct_ci#4, struct_with_string_ci_binary#5], table=ComplexCollatedTable, column_index_list=[2, 3, 4])
==

# Cast NULL to collated types.
SELECT
  CAST(NULL AS STRING COLLATE 'und:ci'),
  CAST(NULL AS STRUCT<ARRAY<STRING COLLATE 'und:ci'>, STRING COLLATE 'und:ci'>)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1{Collation:"und:ci"} AS "$col1" [STRING]
| +-$query.$col2#2<[{Collation:"und:ci"}],{Collation:"und:ci"}> AS "$col2" [STRUCT<ARRAY<STRING>, STRING>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRING, type_annotation_map={Collation:"und:ci"}, value=NULL, has_explicit_type=TRUE)
    | +-$col2#2 := Literal(type=STRUCT<ARRAY<STRING>, STRING>, type_annotation_map=<[{Collation:"und:ci"}],{Collation:"und:ci"}>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# TODO: enable the unparser once ARRAY<STRING COLLATE '...'> syntax
# is supported.
[no_run_unparser]
# Cast empty array to collated types.
SELECT CAST([] AS ARRAY<STRING COLLATE 'und:ci'>)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1[{Collation:"und:ci"}] AS "$col1" [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1[{Collation:"und:ci"}]]
    +-expr_list=
    | +-$col1#1 := Literal(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_3_FORMAT_IN_CAST,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_4_COLLATION_IN_EXPLICIT_CAST]
# CAST with <format> and <time_zone> arguments.
SELECT
  CAST(b'abcd' AS STRING COLLATE 'und:ci' FORMAT 'HEX'),
  CAST(TIMESTAMP '2008-12-25' AS STRING COLLATE 'und:ci' FORMAT 'YYYY' AT TIME ZONE 'Asia/Kolkata')
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1{Collation:"und:ci"} AS "$col1" [STRING]
| +-$query.$col2#2{Collation:"und:ci"} AS "$col2" [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2]
    +-expr_list=
    | +-$col1#1 :=
    | | +-Cast(BYTES -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-Literal(type=BYTES, value=b"abcd")
    | |   +-format=
    | |   | +-Literal(type=STRING, value='HEX')
    | |   +-type_modifiers=collation:und:ci
    | +-$col2#2 :=
    |   +-Cast(TIMESTAMP -> STRING)
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-Literal(type=TIMESTAMP, value=2008-12-25 08:00:00+00, has_explicit_type=TRUE)
    |     +-format=
    |     | +-Literal(type=STRING, value='YYYY')
    |     +-time_zone=
    |     | +-Literal(type=STRING, value='Asia/Kolkata')
    |     +-type_modifiers=collation:und:ci
    +-input_scan=
      +-SingleRowScan
==

# The annotated_target_type is the same as that of the argument to CAST, so
# actually no CAST is produced.
SELECT
  CAST(COLLATE('a', 'und:ci') AS STRING COLLATE 'und:ci'),
  CAST([COLLATE('a', 'und:ci')] AS ARRAY<STRING COLLATE 'und:ci'>),
  CAST(struct_with_string_ci AS STRUCT<a INT32, b STRING COLLATE 'und:ci'>)
FROM CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5{Collation:"und:ci"} AS "$col1" [STRING]
| +-$query.$col2#6[{Collation:"und:ci"}] AS "$col2" [ARRAY<STRING>]
| +-CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}> AS "$col3" [STRUCT<a INT32, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5{Collation:"und:ci"}, $query.$col2#6[{Collation:"und:ci"}], CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>]
    +-expr_list=
    | +-$col1#5 :=
    | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-Literal(type=STRING, value='a')
    | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | +-$col2#6 :=
    |   +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
    |     +-type_annotation_map=[{Collation:"und:ci"}]
    |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       +-type_annotation_map={Collation:"und:ci"}
    |       +-Literal(type=STRING, value='a')
    |       +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>], table=CollatedTable, column_index_list=[2])
==

# TODO: Move to cast.test once Java implementation of Collation and
# AnnotationMap is completed.
# Test format with type parameters and collation on format string
[language_features=V_1_3_FORMAT_IN_CAST,PARAMETERIZED_TYPES,NUMERIC_TYPE,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_4_COLLATION_IN_EXPLICIT_CAST]
select cast("string" as bytes format CAST(123 as STRING(MAX) COLLATE 'und:ci')) from SimpleTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19 AS "$col1" [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19]
    +-expr_list=
    | +-$col1#19 :=
    |   +-Cast(STRING -> BYTES)
    |     +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
    |     +-format=
    |       +-Cast(STRING -> STRING)
    |         +-type_annotation_map={Collation:"und:ci"}
    |         +-Literal(type=STRING, value='123', has_explicit_type=TRUE)
    |         +-type_modifiers=type_parameters:(max_length=MAX), collation:und:ci
    +-input_scan=
      +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
==

# TODO: Move to cast.test once Java implementation of Collation and
# AnnotationMap is completed.
# Test format with type parameters and collation
[language_features=V_1_3_FORMAT_IN_CAST,V_1_3_COLLATION_SUPPORT,V_1_3_ANNOTATION_FRAMEWORK,PARAMETERIZED_TYPES,NUMERIC_TYPE,V_1_4_COLLATION_IN_EXPLICIT_CAST]
select cast(b'string' as STRING(10) COLLATE 'und:ci' format 'hex') from SimpleTypes;
--
QueryStmt
+-output_column_list=
| +-$query.$col1#19{Collation:"und:ci"} AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#19{Collation:"und:ci"}]
    +-expr_list=
    | +-$col1#19 :=
    |   +-Cast(BYTES -> STRING)
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-Literal(type=BYTES, value=b"string")
    |     +-format=
    |     | +-Literal(type=STRING, value='hex')
    |     +-type_modifiers=type_parameters:(max_length=10), collation:und:ci
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

# TODO: Move to cast.test once Java implementation of Collation and
# AnnotationMap is completed.
# CAST with type parameters and collation
select
  cast('string' as STRING(10) COLLATE 'und:ci'),
  cast(string_ci AS STRING(5) COLLATE 'binary')
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5{Collation:"und:ci"} AS "$col1" [STRING]
| +-$query.$col2#6{Collation:"binary"} AS "$col2" [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6]
    +-expr_list=
    | +-$col1#5 :=
    | | +-Cast(STRING -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-Literal(type=STRING, value='string', has_explicit_type=TRUE)
    | |   +-type_modifiers=type_parameters:(max_length=10), collation:und:ci
    | +-$col2#6 :=
    |   +-Cast(STRING -> STRING)
    |     +-type_annotation_map={Collation:"binary"}
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     +-type_modifiers=type_parameters:(max_length=5), collation:binary
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
==

# TODO: Move to cast.test once Java implementation of Collation and
# AnnotationMap is completed.
# CAST with type parameters and collation
select
  cast(['string'] as ARRAY<STRING(10) COLLATE 'und:ci'>),
  cast(array_with_string_ci AS ARRAY<STRING(5) COLLATE 'binary'>)
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5[{Collation:"und:ci"}] AS "$col1" [ARRAY<STRING>]
| +-$query.$col2#6[{Collation:"binary"}] AS "$col2" [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6]
    +-expr_list=
    | +-$col1#5 :=
    | | +-Cast(ARRAY<STRING> -> ARRAY<STRING>)
    | |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |   +-Literal(type=ARRAY<STRING>, value=['string'], has_explicit_type=TRUE)
    | |   +-type_modifiers=type_parameters:[(max_length=10)], collation:[und:ci]
    | +-$col2#6 :=
    |   +-Cast(ARRAY<STRING> -> ARRAY<STRING>)
    |     +-type_annotation_map=[{Collation:"binary"}]
    |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
    |     +-type_modifiers=type_parameters:[(max_length=5)], collation:[binary]
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}]], table=CollatedTable, column_index_list=[3])
==

# TODO: Move to cast.test once Java implementation of Collation and
# AnnotationMap is completed. Enable the unparser once
# STRUCT<STRING COLLATE '...'> syntax is supported.
[no_run_unparser]
# CAST with type parameters and collation
select
  cast(struct_with_string_ci AS STRUCT<a INT32, b STRING(6) COLLATE 'binary'>),
  cast(STRUCT<a STRING, b STRING>('c', 'd') AS STRUCT<a NUMERIC(5), b STRING COLLATE 'und:ci'>),
  cast(STRUCT<a INT64, b STRING>(LENGTH('A'), 'd') AS STRUCT<a NUMERIC(5), b STRING COLLATE 'und:ci'>)
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5<_,{Collation:"binary"}> AS "$col1" [STRUCT<a INT32, b STRING>]
| +-$query.$col2#6<_,{Collation:"und:ci"}> AS "$col2" [STRUCT<a NUMERIC, b STRING>]
| +-$query.$col3#7<_,{Collation:"und:ci"}> AS "$col3" [STRUCT<a NUMERIC, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#5, $col2#6, $col3#7]
    +-expr_list=
    | +-$col1#5 :=
    | | +-Cast(STRUCT<a INT32, b STRING> -> STRUCT<a INT32, b STRING>)
    | |   +-type_annotation_map=<_,{Collation:"binary"}>
    | |   +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    | |   +-type_modifiers=type_parameters:[null,(max_length=6)], collation:[_,binary]
    | +-$col2#6 :=
    | | +-Cast(STRUCT<a STRING, b STRING> -> STRUCT<a NUMERIC, b STRING>)
    | |   +-type_annotation_map=<_,{Collation:"und:ci"}>
    | |   +-Literal(type=STRUCT<a STRING, b STRING>, value={a:'c', b:'d'}, has_explicit_type=TRUE)
    | |   +-type_modifiers=type_parameters:[(precision=5,scale=0),null], collation:[_,und:ci]
    | +-$col3#7 :=
    |   +-MakeStruct
    |     +-type=STRUCT<a NUMERIC, b STRING>
    |     +-type_annotation_map=<_,{Collation:"und:ci"}>
    |     +-field_list=
    |       +-Cast(INT64 -> NUMERIC)
    |       | +-FunctionCall(ZetaSQL:length(STRING) -> INT64)
    |       |   +-Literal(type=STRING, value='A')
    |       | +-type_modifiers=type_parameters:(precision=5,scale=0)
    |       +-Cast(STRING -> STRING)
    |         +-type_annotation_map={Collation:"und:ci"}
    |         +-Literal(type=STRING, value='d', has_explicit_type=TRUE)
    |         +-type_modifiers=collation:und:ci
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>], table=CollatedTable, column_index_list=[2])
==

# The collated column exist in the ResolvedFlatten node. The corresponding
# ResolvedColumnRef nodes still have the right annotations after rewriting.
[enabled_ast_rewrites=DEFAULTS]
[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_UNNEST_AND_FLATTEN_ARRAYS]
SELECT FLATTEN(ARRAY(
  SELECT y
  FROM CollatedTable as x, TestStructValueTable as y
  WHERE x.string_ci = 'abcd'
).a)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS "$col1" [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-Flatten
    |     +-type=ARRAY<INT32>
    |     +-expr=
    |     | +-SubqueryExpr
    |     |   +-type=ARRAY<STRUCT<a INT32, b STRING>>
    |     |   +-subquery_type=ARRAY
    |     |   +-subquery=
    |     |     +-ProjectScan
    |     |       +-column_list=[TestStructValueTable.value#5]
    |     |       +-input_scan=
    |     |         +-FilterScan
    |     |           +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, TestStructValueTable.value#5]
    |     |           +-input_scan=
    |     |           | +-JoinScan
    |     |           |   +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, TestStructValueTable.value#5]
    |     |           |   +-left_scan=
    |     |           |   | +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0], alias='x')
    |     |           |   +-right_scan=
    |     |           |     +-TableScan(column_list=[TestStructValueTable.value#5], table=TestStructValueTable, column_index_list=[0], alias='y')
    |     |           +-filter_expr=
    |     |             +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |     |               +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     |               +-Literal(type=STRING, value='abcd')
    |     |               +-collation_list=[und:ci]
    |     +-get_field_list=
    |       +-GetStructField
    |         +-type=INT32
    |         +-expr=
    |         | +-FlattenedArg(type=STRUCT<a INT32, b STRING>)
    |         +-field_idx=0
    +-input_scan=
      +-SingleRowScan

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS "$col1" [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<INT32>
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$with_expr.injected#11]
    |         +-expr_list=
    |         | +-injected#11 :=
    |         |   +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<INT32>, ARRAY<INT32>) -> ARRAY<INT32>)
    |         |     +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRUCT<a INT32, b STRING>>) -> BOOL)
    |         |     | +-ColumnRef(type=ARRAY<STRUCT<a INT32, b STRING>>, column=$flatten_input.injected#7)
    |         |     +-Literal(type=ARRAY<INT32>, value=NULL)
    |         |     +-SubqueryExpr
    |         |       +-type=ARRAY<INT32>
    |         |       +-subquery_type=ARRAY
    |         |       +-parameter_list=
    |         |       | +-ColumnRef(type=ARRAY<STRUCT<a INT32, b STRING>>, column=$flatten_input.injected#7)
    |         |       +-subquery=
    |         |         +-OrderByScan
    |         |           +-column_list=[$flatten.injected#10]
    |         |           +-is_ordered=TRUE
    |         |           +-input_scan=
    |         |           | +-ProjectScan
    |         |           |   +-column_list=[$flatten.injected#8, $offset.injected#9, $flatten.injected#10]
    |         |           |   +-expr_list=
    |         |           |   | +-injected#10 :=
    |         |           |   |   +-GetStructField
    |         |           |   |     +-type=INT32
    |         |           |   |     +-expr=
    |         |           |   |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$flatten.injected#8)
    |         |           |   |     +-field_idx=0
    |         |           |   +-input_scan=
    |         |           |     +-ArrayScan
    |         |           |       +-column_list=[$flatten.injected#8, $offset.injected#9]
    |         |           |       +-array_expr=
    |         |           |       | +-ColumnRef(type=ARRAY<STRUCT<a INT32, b STRING>>, column=$flatten_input.injected#7, is_correlated=TRUE)
    |         |           |       +-element_column=$flatten.injected#8
    |         |           |       +-array_offset_column=
    |         |           |         +-ColumnHolder(column=$offset.injected#9)
    |         |           +-order_by_item_list=
    |         |             +-OrderByItem
    |         |               +-column_ref=
    |         |                 +-ColumnRef(type=INT64, column=$offset.injected#9)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$flatten_input.injected#7]
    |             +-expr_list=
    |             | +-injected#7 :=
    |             |   +-SubqueryExpr
    |             |     +-type=ARRAY<STRUCT<a INT32, b STRING>>
    |             |     +-subquery_type=ARRAY
    |             |     +-subquery=
    |             |       +-ProjectScan
    |             |         +-column_list=[TestStructValueTable.value#5]
    |             |         +-input_scan=
    |             |           +-FilterScan
    |             |             +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, TestStructValueTable.value#5]
    |             |             +-input_scan=
    |             |             | +-JoinScan
    |             |             |   +-column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}, TestStructValueTable.value#5]
    |             |             |   +-left_scan=
    |             |             |   | +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0], alias='x')
    |             |             |   +-right_scan=
    |             |             |     +-TableScan(column_list=[TestStructValueTable.value#5], table=TestStructValueTable, column_index_list=[0], alias='y')
    |             |             +-filter_expr=
    |             |               +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |             |                 +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |             |                 +-Literal(type=STRING, value='abcd')
    |             |                 +-collation_list=[und:ci]
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# The collated column is correlated inside Flatten function.
[enabled_ast_rewrites=DEFAULTS]
[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_UNNEST_AND_FLATTEN_ARRAYS]
SELECT FLATTEN(ARRAY(
  SELECT y
  FROM TestStructValueTable y
  WHERE x.string_ci = 'abcd'
).a)
FROM CollatedTable as x
--
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS "$col1" [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-Flatten
    |     +-type=ARRAY<INT32>
    |     +-expr=
    |     | +-SubqueryExpr
    |     |   +-type=ARRAY<STRUCT<a INT32, b STRING>>
    |     |   +-subquery_type=ARRAY
    |     |   +-parameter_list=
    |     |   | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     |   +-subquery=
    |     |     +-ProjectScan
    |     |       +-column_list=[TestStructValueTable.value#5]
    |     |       +-input_scan=
    |     |         +-FilterScan
    |     |           +-column_list=[TestStructValueTable.value#5]
    |     |           +-input_scan=
    |     |           | +-TableScan(column_list=[TestStructValueTable.value#5], table=TestStructValueTable, column_index_list=[0], alias='y')
    |     |           +-filter_expr=
    |     |             +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |     |               +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"}, is_correlated=TRUE)
    |     |               +-Literal(type=STRING, value='abcd')
    |     |               +-collation_list=[und:ci]
    |     +-get_field_list=
    |       +-GetStructField
    |         +-type=INT32
    |         +-expr=
    |         | +-FlattenedArg(type=STRUCT<a INT32, b STRING>)
    |         +-field_idx=0
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0], alias='x')

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#6 AS "$col1" [ARRAY<INT32>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<INT32>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$with_expr.injected#11]
    |         +-expr_list=
    |         | +-injected#11 :=
    |         |   +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<INT32>, ARRAY<INT32>) -> ARRAY<INT32>)
    |         |     +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRUCT<a INT32, b STRING>>) -> BOOL)
    |         |     | +-ColumnRef(type=ARRAY<STRUCT<a INT32, b STRING>>, column=$flatten_input.injected#7)
    |         |     +-Literal(type=ARRAY<INT32>, value=NULL)
    |         |     +-SubqueryExpr
    |         |       +-type=ARRAY<INT32>
    |         |       +-subquery_type=ARRAY
    |         |       +-parameter_list=
    |         |       | +-ColumnRef(type=ARRAY<STRUCT<a INT32, b STRING>>, column=$flatten_input.injected#7)
    |         |       +-subquery=
    |         |         +-OrderByScan
    |         |           +-column_list=[$flatten.injected#10]
    |         |           +-is_ordered=TRUE
    |         |           +-input_scan=
    |         |           | +-ProjectScan
    |         |           |   +-column_list=[$flatten.injected#8, $offset.injected#9, $flatten.injected#10]
    |         |           |   +-expr_list=
    |         |           |   | +-injected#10 :=
    |         |           |   |   +-GetStructField
    |         |           |   |     +-type=INT32
    |         |           |   |     +-expr=
    |         |           |   |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$flatten.injected#8)
    |         |           |   |     +-field_idx=0
    |         |           |   +-input_scan=
    |         |           |     +-ArrayScan
    |         |           |       +-column_list=[$flatten.injected#8, $offset.injected#9]
    |         |           |       +-array_expr=
    |         |           |       | +-ColumnRef(type=ARRAY<STRUCT<a INT32, b STRING>>, column=$flatten_input.injected#7, is_correlated=TRUE)
    |         |           |       +-element_column=$flatten.injected#8
    |         |           |       +-array_offset_column=
    |         |           |         +-ColumnHolder(column=$offset.injected#9)
    |         |           +-order_by_item_list=
    |         |             +-OrderByItem
    |         |               +-column_ref=
    |         |                 +-ColumnRef(type=INT64, column=$offset.injected#9)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$flatten_input.injected#7]
    |             +-expr_list=
    |             | +-injected#7 :=
    |             |   +-SubqueryExpr
    |             |     +-type=ARRAY<STRUCT<a INT32, b STRING>>
    |             |     +-subquery_type=ARRAY
    |             |     +-parameter_list=
    |             |     | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"}, is_correlated=TRUE)
    |             |     +-subquery=
    |             |       +-ProjectScan
    |             |         +-column_list=[TestStructValueTable.value#5]
    |             |         +-input_scan=
    |             |           +-FilterScan
    |             |             +-column_list=[TestStructValueTable.value#5]
    |             |             +-input_scan=
    |             |             | +-TableScan(column_list=[TestStructValueTable.value#5], table=TestStructValueTable, column_index_list=[0], alias='y')
    |             |             +-filter_expr=
    |             |               +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |             |                 +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"}, is_correlated=TRUE)
    |             |                 +-Literal(type=STRING, value='abcd')
    |             |                 +-collation_list=[und:ci]
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0], alias='x')
==

# The collated column is part of the arguments of NULLIFERROR(), which gets
# rewriteen into another function, IFERROR().
[enabled_ast_rewrites=DEFAULTS]
SELECT NULLIFERROR(string_ci) FROM CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5{Collation:"und:ci"} AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5{Collation:"und:ci"}]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:nulliferror(STRING) -> STRING)
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#5{Collation:"und:ci"} AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5{Collation:"und:ci"}]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:iferror(STRING, STRING) -> STRING)
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    |     +-Literal(type=STRING, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.string_ci#1{Collation:"und:ci"}], table=CollatedTable, column_index_list=[0])
==

# TODO: Add more ARRAY built-in functions
[enabled_ast_rewrites=DEFAULTS]
SELECT ARRAY_FIRST([collate('hello', 'und:ci'), collate('zetasql', 'und:ci')])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1{Collation:"und:ci"} AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1{Collation:"und:ci"}]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:array_first(ARRAY<STRING> input_array) -> STRING)
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |       +-type_annotation_map=[{Collation:"und:ci"}]
    |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | +-type_annotation_map={Collation:"und:ci"}
    |       | +-Literal(type=STRING, value='hello')
    |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |         +-type_annotation_map={Collation:"und:ci"}
    |         +-Literal(type=STRING, value='zetasql')
    |         +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    +-input_scan=
      +-SingleRowScan

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#1{Collation:"und:ci"} AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1{Collation:"und:ci"}]
    +-expr_list=
    | +-$col1#1 :=
    |   +-SubqueryExpr
    |     +-type=STRING
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#3{Collation:"und:ci"}]
    |         +-expr_list=
    |         | +-$col1#3 :=
    |         |   +-FunctionCall(ZetaSQL:$case_no_value(repeated(2) BOOL, repeated(2) STRING, STRING) -> STRING)
    |         |     +-type_annotation_map={Collation:"und:ci"}
    |         |     +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
    |         |     | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=$subquery1.input_array#2[{Collation:"und:ci"}])
    |         |     +-Literal(type=STRING, value=NULL)
    |         |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |         |     | +-FunctionCall(ZetaSQL:array_length(ARRAY<STRING>) -> INT64)
    |         |     | | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=$subquery1.input_array#2[{Collation:"und:ci"}])
    |         |     | +-Literal(type=INT64, value=0)
    |         |     +-Cast(STRING -> STRING)
    |         |     | +-FunctionCall(ZetaSQL:error(STRING) -> STRING)
    |         |     |   +-Literal(type=STRING, value='ARRAY_FIRST cannot get the first element of an empty array')
    |         |     +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<STRING>, INT64) -> STRING)
    |         |       +-type_annotation_map={Collation:"und:ci"}
    |         |       +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=$subquery1.input_array#2[{Collation:"und:ci"}])
    |         |       +-Literal(type=INT64, value=0)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$subquery1.input_array#2[{Collation:"und:ci"}]]
    |             +-expr_list=
    |             | +-input_array#2 :=
    |             |   +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |             |     +-type_annotation_map=[{Collation:"und:ci"}]
    |             |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |             |     | +-type_annotation_map={Collation:"und:ci"}
    |             |     | +-Literal(type=STRING, value='hello')
    |             |     | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |             |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |             |       +-type_annotation_map={Collation:"und:ci"}
    |             |       +-Literal(type=STRING, value='zetasql')
    |             |       +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

[enabled_ast_rewrites=DEFAULTS]
SELECT ARRAY_SLICE([collate('hello', 'und:ci'), collate('zetasql', 'und:ci')], 0, 0)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1[{Collation:"und:ci"}] AS "$col1" [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1[{Collation:"und:ci"}]]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:array_slice(ARRAY<STRING> array_to_slice, INT64 start_offset, INT64 end_offset) -> ARRAY<STRING>)
    |     +-type_annotation_map=[{Collation:"und:ci"}]
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |     | +-type_annotation_map=[{Collation:"und:ci"}]
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     | | +-type_annotation_map={Collation:"und:ci"}
    |     | | +-Literal(type=STRING, value='hello')
    |     | | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |   +-type_annotation_map={Collation:"und:ci"}
    |     |   +-Literal(type=STRING, value='zetasql')
    |     |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-Literal(type=INT64, value=0)
    |     +-Literal(type=INT64, value=0)
    +-input_scan=
      +-SingleRowScan

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#1[{Collation:"und:ci"}] AS "$col1" [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1[{Collation:"und:ci"}]]
    +-expr_list=
    | +-$col1#1 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<STRING>
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#9]
    |         +-expr_list=
    |         | +-$col1#9 :=
    |         |   +-FunctionCall(ZetaSQL:$case_no_value(repeated(2) BOOL, repeated(2) ARRAY<STRING>, ARRAY<STRING>) -> ARRAY<STRING>)
    |         |     +-FunctionCall(ZetaSQL:$or(BOOL, repeated(2) BOOL) -> BOOL)
    |         |     | +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
    |         |     | | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=$subquery1.array_to_slice#2[{Collation:"und:ci"}])
    |         |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
    |         |     | | +-ColumnRef(type=INT64, column=$subquery1.start_offset#4)
    |         |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
    |         |     |   +-ColumnRef(type=INT64, column=$subquery1.end_offset#3)
    |         |     +-Literal(type=ARRAY<STRING>, value=NULL)
    |         |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |         |     | +-FunctionCall(ZetaSQL:array_length(ARRAY<STRING>) -> INT64)
    |         |     | | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=$subquery1.array_to_slice#2[{Collation:"und:ci"}])
    |         |     | +-Literal(type=INT64, value=0)
    |         |     +-Literal(type=ARRAY<STRING>, value=[])
    |         |     +-SubqueryExpr
    |         |       +-type=ARRAY<STRING>
    |         |       +-subquery_type=SCALAR
    |         |       +-parameter_list=
    |         |       | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=$subquery1.array_to_slice#2[{Collation:"und:ci"}])
    |         |       | +-ColumnRef(type=INT64, column=$subquery1.end_offset#3)
    |         |       | +-ColumnRef(type=INT64, column=$subquery1.start_offset#4)
    |         |       +-subquery=
    |         |         +-ProjectScan
    |         |           +-column_list=[$with_expr.injected#10]
    |         |           +-expr_list=
    |         |           | +-injected#10 :=
    |         |           |   +-SubqueryExpr
    |         |           |     +-type=ARRAY<STRING>
    |         |           |     +-type_annotation_map=[{Collation:"und:ci"}]
    |         |           |     +-subquery_type=ARRAY
    |         |           |     +-parameter_list=
    |         |           |     | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=$subquery1.array_to_slice#2[{Collation:"und:ci"}], is_correlated=TRUE)
    |         |           |     | +-ColumnRef(type=INT64, column=$with_expr.start_offset#5)
    |         |           |     | +-ColumnRef(type=INT64, column=$with_expr.end_offset#6)
    |         |           |     +-subquery=
    |         |           |       +-OrderByScan
    |         |           |         +-column_list=[$array.e#7{Collation:"und:ci"}]
    |         |           |         +-is_ordered=TRUE
    |         |           |         +-input_scan=
    |         |           |         | +-FilterScan
    |         |           |         |   +-column_list=[$array.e#7{Collation:"und:ci"}, $array_offset.idx#8]
    |         |           |         |   +-input_scan=
    |         |           |         |   | +-ArrayScan
    |         |           |         |   |   +-column_list=[$array.e#7{Collation:"und:ci"}, $array_offset.idx#8]
    |         |           |         |   |   +-array_expr=
    |         |           |         |   |   | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=$subquery1.array_to_slice#2[{Collation:"und:ci"}], is_correlated=TRUE)
    |         |           |         |   |   +-element_column=$array.e#7{Collation:"und:ci"}
    |         |           |         |   |   +-array_offset_column=
    |         |           |         |   |     +-ColumnHolder(column=$array_offset.idx#8)
    |         |           |         |   +-filter_expr=
    |         |           |         |     +-FunctionCall(ZetaSQL:$between(INT64, INT64, INT64) -> BOOL)
    |         |           |         |       +-ColumnRef(type=INT64, column=$array_offset.idx#8)
    |         |           |         |       +-ColumnRef(type=INT64, column=$with_expr.start_offset#5, is_correlated=TRUE)
    |         |           |         |       +-ColumnRef(type=INT64, column=$with_expr.end_offset#6, is_correlated=TRUE)
    |         |           |         +-order_by_item_list=
    |         |           |           +-OrderByItem
    |         |           |             +-column_ref=
    |         |           |               +-ColumnRef(type=INT64, column=$array_offset.idx#8)
    |         |           +-input_scan=
    |         |             +-ProjectScan
    |         |               +-column_list=$with_expr.[start_offset#5, end_offset#6]
    |         |               +-expr_list=
    |         |               | +-end_offset#6 :=
    |         |               |   +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
    |         |               |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |         |               |     | +-ColumnRef(type=INT64, column=$subquery1.end_offset#3, is_correlated=TRUE)
    |         |               |     | +-Literal(type=INT64, value=0)
    |         |               |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |         |               |     | +-ColumnRef(type=INT64, column=$subquery1.end_offset#3, is_correlated=TRUE)
    |         |               |     | +-FunctionCall(ZetaSQL:array_length(ARRAY<STRING>) -> INT64)
    |         |               |     |   +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=$subquery1.array_to_slice#2[{Collation:"und:ci"}], is_correlated=TRUE)
    |         |               |     +-ColumnRef(type=INT64, column=$subquery1.end_offset#3, is_correlated=TRUE)
    |         |               +-input_scan=
    |         |                 +-ProjectScan
    |         |                   +-column_list=[$with_expr.start_offset#5]
    |         |                   +-expr_list=
    |         |                   | +-start_offset#5 :=
    |         |                   |   +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
    |         |                   |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |         |                   |     | +-ColumnRef(type=INT64, column=$subquery1.start_offset#4, is_correlated=TRUE)
    |         |                   |     | +-Literal(type=INT64, value=0)
    |         |                   |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |         |                   |     | +-ColumnRef(type=INT64, column=$subquery1.start_offset#4, is_correlated=TRUE)
    |         |                   |     | +-FunctionCall(ZetaSQL:array_length(ARRAY<STRING>) -> INT64)
    |         |                   |     |   +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=$subquery1.array_to_slice#2[{Collation:"und:ci"}], is_correlated=TRUE)
    |         |                   |     +-ColumnRef(type=INT64, column=$subquery1.start_offset#4, is_correlated=TRUE)
    |         |                   +-input_scan=
    |         |                     +-SingleRowScan
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=$subquery1.[array_to_slice#2, end_offset#3, start_offset#4]
    |             +-expr_list=
    |             | +-array_to_slice#2 :=
    |             | | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |             | |   +-type_annotation_map=[{Collation:"und:ci"}]
    |             | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |             | |   | +-type_annotation_map={Collation:"und:ci"}
    |             | |   | +-Literal(type=STRING, value='hello')
    |             | |   | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |             | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |             | |     +-type_annotation_map={Collation:"und:ci"}
    |             | |     +-Literal(type=STRING, value='zetasql')
    |             | |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |             | +-end_offset#3 := Literal(type=INT64, value=0)
    |             | +-start_offset#4 := Literal(type=INT64, value=0)
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Repro for RQG found error: "random_query:iteration_6:query_387"
# TODO: Remove [no_run_unparser] when unparser generated CAST
# with collation is addressed.
[enabled_ast_rewrites=DEFAULTS]
[no_run_unparser]
SELECT
    IFERROR(
      ARRAY_SLICE(
        ARRAY_CONCAT(
          ARRAY<STRUCT<int32_val INT32, string_val STRING>>[
            STRUCT<int32_val INT32, string_val STRING> (CAST(123 AS INT32), '67MXcza829l0r4Vhravi4Mg5S7uc2P9SJ58ShEg0b35h4lC')
          ],
          ARRAY(
            SELECT
                table_collated_types.c3 AS struct_with_string_ci
            FROM (
              SELECT
                string_ci AS c1,
                string_binary AS c2,
                struct_with_string_ci AS c3,
                array_with_string_ci AS c4
              FROM
                CollatedTable
            ) AS table_collated_types
          )
        ), 0, 2
      ),
      [STRUCT<int32_val INT32, string_val STRING>(1, 'foo')]
    )
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5[<_,{Collation:"und:ci"}>] AS "$col1" [ARRAY<STRUCT<int32_val INT32, string_val STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5[<_,{Collation:"und:ci"}>]]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:iferror(ARRAY<STRUCT<int32_val INT32, string_val STRING>>, ARRAY<STRUCT<int32_val INT32, string_val STRING>>) -> ARRAY<STRUCT<int32_val INT32, string_val STRING>>)
    |     +-type_annotation_map=[<_,{Collation:"und:ci"}>]
    |     +-FunctionCall(ZetaSQL:array_slice(ARRAY<STRUCT<int32_val INT32, string_val STRING>> array_to_slice, INT64 start_offset, INT64 end_offset) -> ARRAY<STRUCT<int32_val INT32, string_val STRING>>)
    |     | +-type_annotation_map=[<_,{Collation:"und:ci"}>]
    |     | +-FunctionCall(ZetaSQL:array_concat(ARRAY<STRUCT<int32_val INT32, string_val STRING>>, repeated(1) ARRAY<STRUCT<int32_val INT32, string_val STRING>>) -> ARRAY<STRUCT<int32_val INT32, string_val STRING>>)
    |     | | +-type_annotation_map=[<_,{Collation:"und:ci"}>]
    |     | | +-Literal(type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>, value=[{int32_val:123, string_val:'67MXcza829l0r4Vhravi4Mg5S7uc2P9SJ58ShEg0b35h4lC'}], has_explicit_type=TRUE)
    |     | | +-Cast(ARRAY<STRUCT<a INT32, b STRING>> -> ARRAY<STRUCT<int32_val INT32, string_val STRING>>)
    |     | |   +-type_annotation_map=[<_,{Collation:"und:ci"}>]
    |     | |   +-SubqueryExpr
    |     | |     +-type=ARRAY<STRUCT<a INT32, b STRING>>
    |     | |     +-type_annotation_map=[<_,{Collation:"und:ci"}>]
    |     | |     +-subquery_type=ARRAY
    |     | |     +-subquery=
    |     | |       +-ProjectScan
    |     | |         +-column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>]
    |     | |         +-input_scan=
    |     | |           +-ProjectScan
    |     | |             +-column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4]
    |     | |             +-input_scan=
    |     | |               +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 2, 3])
    |     | |   +-type_modifiers=collation:[[_,und:ci]]
    |     | +-Literal(type=INT64, value=0)
    |     | +-Literal(type=INT64, value=2)
    |     +-Literal(type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>, value=[{int32_val:1, string_val:'foo'}], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#5[<_,{Collation:"und:ci"}>] AS "$col1" [ARRAY<STRUCT<int32_val INT32, string_val STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5[<_,{Collation:"und:ci"}>]]
    +-expr_list=
    | +-$col1#5 :=
    |   +-FunctionCall(ZetaSQL:iferror(ARRAY<STRUCT<int32_val INT32, string_val STRING>>, ARRAY<STRUCT<int32_val INT32, string_val STRING>>) -> ARRAY<STRUCT<int32_val INT32, string_val STRING>>)
    |     +-type_annotation_map=[<_,{Collation:"und:ci"}>]
    |     +-SubqueryExpr
    |     | +-type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>
    |     | +-subquery_type=SCALAR
    |     | +-subquery=
    |     |   +-ProjectScan
    |     |     +-column_list=[$expr_subquery.$col1#13]
    |     |     +-expr_list=
    |     |     | +-$col1#13 :=
    |     |     |   +-FunctionCall(ZetaSQL:$case_no_value(repeated(2) BOOL, repeated(2) ARRAY<STRUCT<int32_val INT32, string_val STRING>>, ARRAY<STRUCT<int32_val INT32, string_val STRING>>) -> ARRAY<STRUCT<int32_val INT32, string_val STRING>>)
    |     |     |     +-FunctionCall(ZetaSQL:$or(BOOL, repeated(2) BOOL) -> BOOL)
    |     |     |     | +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRUCT<int32_val INT32, string_val STRING>>) -> BOOL)
    |     |     |     | | +-ColumnRef(type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>, type_annotation_map=[<_,{Collation:"und:ci"}>], column=$subquery1.array_to_slice#6[<_,{Collation:"und:ci"}>])
    |     |     |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
    |     |     |     | | +-ColumnRef(type=INT64, column=$subquery1.start_offset#8)
    |     |     |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
    |     |     |     |   +-ColumnRef(type=INT64, column=$subquery1.end_offset#7)
    |     |     |     +-Literal(type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>, value=NULL)
    |     |     |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |     |     |     | +-FunctionCall(ZetaSQL:array_length(ARRAY<STRUCT<int32_val INT32, string_val STRING>>) -> INT64)
    |     |     |     | | +-ColumnRef(type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>, type_annotation_map=[<_,{Collation:"und:ci"}>], column=$subquery1.array_to_slice#6[<_,{Collation:"und:ci"}>])
    |     |     |     | +-Literal(type=INT64, value=0)
    |     |     |     +-Literal(type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>, value=[])
    |     |     |     +-SubqueryExpr
    |     |     |       +-type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>
    |     |     |       +-subquery_type=SCALAR
    |     |     |       +-parameter_list=
    |     |     |       | +-ColumnRef(type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>, type_annotation_map=[<_,{Collation:"und:ci"}>], column=$subquery1.array_to_slice#6[<_,{Collation:"und:ci"}>])
    |     |     |       | +-ColumnRef(type=INT64, column=$subquery1.end_offset#7)
    |     |     |       | +-ColumnRef(type=INT64, column=$subquery1.start_offset#8)
    |     |     |       +-subquery=
    |     |     |         +-ProjectScan
    |     |     |           +-column_list=[$with_expr.injected#14]
    |     |     |           +-expr_list=
    |     |     |           | +-injected#14 :=
    |     |     |           |   +-SubqueryExpr
    |     |     |           |     +-type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>
    |     |     |           |     +-type_annotation_map=[<_,{Collation:"und:ci"}>]
    |     |     |           |     +-subquery_type=ARRAY
    |     |     |           |     +-parameter_list=
    |     |     |           |     | +-ColumnRef(type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>, type_annotation_map=[<_,{Collation:"und:ci"}>], column=$subquery1.array_to_slice#6[<_,{Collation:"und:ci"}>], is_correlated=TRUE)
    |     |     |           |     | +-ColumnRef(type=INT64, column=$with_expr.start_offset#9)
    |     |     |           |     | +-ColumnRef(type=INT64, column=$with_expr.end_offset#10)
    |     |     |           |     +-subquery=
    |     |     |           |       +-OrderByScan
    |     |     |           |         +-column_list=[$array.e#11<_,{Collation:"und:ci"}>]
    |     |     |           |         +-is_ordered=TRUE
    |     |     |           |         +-input_scan=
    |     |     |           |         | +-FilterScan
    |     |     |           |         |   +-column_list=[$array.e#11<_,{Collation:"und:ci"}>, $array_offset.idx#12]
    |     |     |           |         |   +-input_scan=
    |     |     |           |         |   | +-ArrayScan
    |     |     |           |         |   |   +-column_list=[$array.e#11<_,{Collation:"und:ci"}>, $array_offset.idx#12]
    |     |     |           |         |   |   +-array_expr=
    |     |     |           |         |   |   | +-ColumnRef(type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>, type_annotation_map=[<_,{Collation:"und:ci"}>], column=$subquery1.array_to_slice#6[<_,{Collation:"und:ci"}>], is_correlated=TRUE)
    |     |     |           |         |   |   +-element_column=$array.e#11<_,{Collation:"und:ci"}>
    |     |     |           |         |   |   +-array_offset_column=
    |     |     |           |         |   |     +-ColumnHolder(column=$array_offset.idx#12)
    |     |     |           |         |   +-filter_expr=
    |     |     |           |         |     +-FunctionCall(ZetaSQL:$between(INT64, INT64, INT64) -> BOOL)
    |     |     |           |         |       +-ColumnRef(type=INT64, column=$array_offset.idx#12)
    |     |     |           |         |       +-ColumnRef(type=INT64, column=$with_expr.start_offset#9, is_correlated=TRUE)
    |     |     |           |         |       +-ColumnRef(type=INT64, column=$with_expr.end_offset#10, is_correlated=TRUE)
    |     |     |           |         +-order_by_item_list=
    |     |     |           |           +-OrderByItem
    |     |     |           |             +-column_ref=
    |     |     |           |               +-ColumnRef(type=INT64, column=$array_offset.idx#12)
    |     |     |           +-input_scan=
    |     |     |             +-ProjectScan
    |     |     |               +-column_list=$with_expr.[start_offset#9, end_offset#10]
    |     |     |               +-expr_list=
    |     |     |               | +-end_offset#10 :=
    |     |     |               |   +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
    |     |     |               |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |     |     |               |     | +-ColumnRef(type=INT64, column=$subquery1.end_offset#7, is_correlated=TRUE)
    |     |     |               |     | +-Literal(type=INT64, value=0)
    |     |     |               |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     |     |               |     | +-ColumnRef(type=INT64, column=$subquery1.end_offset#7, is_correlated=TRUE)
    |     |     |               |     | +-FunctionCall(ZetaSQL:array_length(ARRAY<STRUCT<int32_val INT32, string_val STRING>>) -> INT64)
    |     |     |               |     |   +-ColumnRef(type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>, type_annotation_map=[<_,{Collation:"und:ci"}>], column=$subquery1.array_to_slice#6[<_,{Collation:"und:ci"}>], is_correlated=TRUE)
    |     |     |               |     +-ColumnRef(type=INT64, column=$subquery1.end_offset#7, is_correlated=TRUE)
    |     |     |               +-input_scan=
    |     |     |                 +-ProjectScan
    |     |     |                   +-column_list=[$with_expr.start_offset#9]
    |     |     |                   +-expr_list=
    |     |     |                   | +-start_offset#9 :=
    |     |     |                   |   +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
    |     |     |                   |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |     |     |                   |     | +-ColumnRef(type=INT64, column=$subquery1.start_offset#8, is_correlated=TRUE)
    |     |     |                   |     | +-Literal(type=INT64, value=0)
    |     |     |                   |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |     |     |                   |     | +-ColumnRef(type=INT64, column=$subquery1.start_offset#8, is_correlated=TRUE)
    |     |     |                   |     | +-FunctionCall(ZetaSQL:array_length(ARRAY<STRUCT<int32_val INT32, string_val STRING>>) -> INT64)
    |     |     |                   |     |   +-ColumnRef(type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>, type_annotation_map=[<_,{Collation:"und:ci"}>], column=$subquery1.array_to_slice#6[<_,{Collation:"und:ci"}>], is_correlated=TRUE)
    |     |     |                   |     +-ColumnRef(type=INT64, column=$subquery1.start_offset#8, is_correlated=TRUE)
    |     |     |                   +-input_scan=
    |     |     |                     +-SingleRowScan
    |     |     +-input_scan=
    |     |       +-ProjectScan
    |     |         +-column_list=$subquery1.[array_to_slice#6, end_offset#7, start_offset#8]
    |     |         +-expr_list=
    |     |         | +-array_to_slice#6 :=
    |     |         | | +-FunctionCall(ZetaSQL:array_concat(ARRAY<STRUCT<int32_val INT32, string_val STRING>>, repeated(1) ARRAY<STRUCT<int32_val INT32, string_val STRING>>) -> ARRAY<STRUCT<int32_val INT32, string_val STRING>>)
    |     |         | |   +-type_annotation_map=[<_,{Collation:"und:ci"}>]
    |     |         | |   +-Literal(type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>, value=[{int32_val:123, string_val:'67MXcza829l0r4Vhravi4Mg5S7uc2P9SJ58ShEg0b35h4lC'}], has_explicit_type=TRUE)
    |     |         | |   +-Cast(ARRAY<STRUCT<a INT32, b STRING>> -> ARRAY<STRUCT<int32_val INT32, string_val STRING>>)
    |     |         | |     +-type_annotation_map=[<_,{Collation:"und:ci"}>]
    |     |         | |     +-SubqueryExpr
    |     |         | |       +-type=ARRAY<STRUCT<a INT32, b STRING>>
    |     |         | |       +-type_annotation_map=[<_,{Collation:"und:ci"}>]
    |     |         | |       +-subquery_type=ARRAY
    |     |         | |       +-subquery=
    |     |         | |         +-ProjectScan
    |     |         | |           +-column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>]
    |     |         | |           +-input_scan=
    |     |         | |             +-ProjectScan
    |     |         | |               +-column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4]
    |     |         | |               +-input_scan=
    |     |         | |                 +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 2, 3])
    |     |         | |     +-type_modifiers=collation:[[_,und:ci]]
    |     |         | +-end_offset#7 := Literal(type=INT64, value=2)
    |     |         | +-start_offset#8 := Literal(type=INT64, value=0)
    |     |         +-input_scan=
    |     |           +-SingleRowScan
    |     +-Literal(type=ARRAY<STRUCT<int32_val INT32, string_val STRING>>, value=[{int32_val:1, string_val:'foo'}], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# When both ARRAY<STRING> argument and STRING argument have collation attached,
# verify that the element collation of the first argument and the collation on
# the second argument are the same, then mark that in collation_list.
[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_4_ARRAY_FIND_FUNCTIONS]
SELECT ARRAY_OFFSET([collate('hello', 'und:ci'), collate('zetasql', 'und:ci')], {{'hello'|collate('hello', 'und:ci')}})
--
ALTERNATION GROUP: 'hello'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:array_offset(ARRAY<STRING> input_array, STRING target_element, optional(1) ENUM<ARRAY_FIND_MODE> find_mode) -> INT64)
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |     | +-type_annotation_map=[{Collation:"und:ci"}]
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     | | +-type_annotation_map={Collation:"und:ci"}
    |     | | +-Literal(type=STRING, value='hello')
    |     | | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |   +-type_annotation_map={Collation:"und:ci"}
    |     |   +-Literal(type=STRING, value='zetasql')
    |     |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-Literal(type=STRING, value='hello')
    |     +-Literal(type=ENUM<ARRAY_FIND_MODE>, value=FIRST)
    |     +-collation_list=[und:ci]
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: collate('hello', 'und:ci')
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:array_offset(ARRAY<STRING> input_array, STRING target_element, optional(1) ENUM<ARRAY_FIND_MODE> find_mode) -> INT64)
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |     | +-type_annotation_map=[{Collation:"und:ci"}]
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     | | +-type_annotation_map={Collation:"und:ci"}
    |     | | +-Literal(type=STRING, value='hello')
    |     | | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |   +-type_annotation_map={Collation:"und:ci"}
    |     |   +-Literal(type=STRING, value='zetasql')
    |     |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     | +-type_annotation_map={Collation:"und:ci"}
    |     | +-Literal(type=STRING, value='hello')
    |     | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-Literal(type=ENUM<ARRAY_FIND_MODE>, value=FIRST)
    |     +-collation_list=[und:ci]
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_4_ARRAY_FIND_FUNCTIONS]
SELECT ARRAY_OFFSETS([collate('hello', 'und:ci'), collate('zetasql', 'und:ci')], 'hello')
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS "$col1" [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:array_offsets(ARRAY<STRING> input_array, STRING target_element) -> ARRAY<INT64>)
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |     | +-type_annotation_map=[{Collation:"und:ci"}]
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     | | +-type_annotation_map={Collation:"und:ci"}
    |     | | +-Literal(type=STRING, value='hello')
    |     | | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |   +-type_annotation_map={Collation:"und:ci"}
    |     |   +-Literal(type=STRING, value='zetasql')
    |     |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-Literal(type=STRING, value='hello')
    |     +-collation_list=[und:ci]
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_4_ARRAY_FIND_FUNCTIONS]
SELECT ARRAY_FIND([collate('hello', 'und:ci'), collate('zetasql', 'und:ci')], 'hello')
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1{Collation:"und:ci"} AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1{Collation:"und:ci"}]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:array_find(ARRAY<STRING> input_array, STRING target_element, optional(1) ENUM<ARRAY_FIND_MODE> find_mode) -> STRING)
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |     | +-type_annotation_map=[{Collation:"und:ci"}]
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     | | +-type_annotation_map={Collation:"und:ci"}
    |     | | +-Literal(type=STRING, value='hello')
    |     | | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |   +-type_annotation_map={Collation:"und:ci"}
    |     |   +-Literal(type=STRING, value='zetasql')
    |     |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-Literal(type=STRING, value='hello')
    |     +-Literal(type=ENUM<ARRAY_FIND_MODE>, value=FIRST)
    |     +-collation_list=[und:ci]
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_4_ARRAY_FIND_FUNCTIONS]
SELECT ARRAY_FIND_ALL([collate('hello', 'und:ci'), collate('zetasql', 'und:ci')], 'hello')
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1[{Collation:"und:ci"}] AS "$col1" [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1[{Collation:"und:ci"}]]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:array_find_all(ARRAY<STRING> input_array, STRING target_element) -> ARRAY<STRING>)
    |     +-type_annotation_map=[{Collation:"und:ci"}]
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |     | +-type_annotation_map=[{Collation:"und:ci"}]
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     | | +-type_annotation_map={Collation:"und:ci"}
    |     | | +-Literal(type=STRING, value='hello')
    |     | | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |   +-type_annotation_map={Collation:"und:ci"}
    |     |   +-Literal(type=STRING, value='zetasql')
    |     |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-Literal(type=STRING, value='hello')
    |     +-collation_list=[und:ci]
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_4_ARRAY_AGGREGATION_FUNCTIONS]
SELECT ARRAY_MIN([collate('hello', 'und:ci')])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1{Collation:"und:ci"} AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1{Collation:"und:ci"}]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:array_min(ARRAY<STRING> input_array) -> STRING)
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
    |       +-type_annotation_map=[{Collation:"und:ci"}]
    |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |         +-type_annotation_map={Collation:"und:ci"}
    |         +-Literal(type=STRING, value='hello')
    |         +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-collation_list=[und:ci]
    +-input_scan=
      +-SingleRowScan
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_4_ARRAY_AGGREGATION_FUNCTIONS]
SELECT ARRAY_MAX([collate('hello', 'und:ci')])
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1{Collation:"und:ci"} AS "$col1" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1{Collation:"und:ci"}]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:array_max(ARRAY<STRING> input_array) -> STRING)
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
    |       +-type_annotation_map=[{Collation:"und:ci"}]
    |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |         +-type_annotation_map={Collation:"und:ci"}
    |         +-Literal(type=STRING, value='hello')
    |         +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-collation_list=[und:ci]
    +-input_scan=
      +-SingleRowScan
==

select * from tvf_templated_select_collated_output_columns_with_collate_function('abc', 2)
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_collated_output_columns_with_collate_function.col_ci#1{Collation:"und:ci"} AS col_ci [STRING]
| +-tvf_templated_select_collated_output_columns_with_collate_function.col_array_ci#2[{Collation:"und:ci"}] AS col_array_ci [ARRAY<STRING>]
| +-tvf_templated_select_collated_output_columns_with_collate_function.col_struct_ci#3<{Collation:"und:ci"},_> AS col_struct_ci [STRUCT<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_select_collated_output_columns_with_collate_function.[col_ci#1, col_array_ci#2, col_struct_ci#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_templated_select_collated_output_columns_with_collate_function.[col_ci#1, col_array_ci#2, col_struct_ci#3]
        +-tvf=tvf_templated_select_collated_output_columns_with_collate_function((ANY TYPE, ANY TYPE) -> ANY TABLE)
        +-signature=(literal STRING, literal INT64) -> TABLE<col_ci STRING COLLATE 'und:ci', col_array_ci ARRAY<STRING COLLATE 'und:ci'>, col_struct_ci STRUCT<STRING COLLATE 'und:ci', INT64>>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value='abc')
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=2)
        +-column_index_list=[0, 1, 2]

With Templated SQL TVF signature:
  tvf_templated_select_collated_output_columns_with_collate_function(literal STRING, literal INT64) -> TABLE<col_ci STRING COLLATE 'und:ci', col_array_ci ARRAY<STRING COLLATE 'und:ci'>, col_struct_ci STRUCT<STRING COLLATE 'und:ci', INT64>>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.col_ci#1{Collation:"und:ci"} AS col_ci [STRING]
| +-$query.col_array_ci#2[{Collation:"und:ci"}] AS col_array_ci [ARRAY<STRING>]
| +-$query.col_struct_ci#3<{Collation:"und:ci"},_> AS col_struct_ci [STRUCT<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=$query.[col_ci#1, col_array_ci#2, col_struct_ci#3]
    +-expr_list=
    | +-col_ci#1 :=
    | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-ArgumentRef(type=STRING, name='x')
    | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | +-col_array_ci#2 :=
    | | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
    | |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |     +-type_annotation_map={Collation:"und:ci"}
    | |     +-ArgumentRef(type=STRING, name='x')
    | |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | +-col_struct_ci#3 :=
    |   +-MakeStruct
    |     +-type=STRUCT<STRING, INT64>
    |     +-type_annotation_map=<{Collation:"und:ci"},_>
    |     +-field_list=
    |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | +-type_annotation_map={Collation:"und:ci"}
    |       | +-ArgumentRef(type=STRING, name='x')
    |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       +-ArgumentRef(type=INT64, name='y')
    +-input_scan=
      +-SingleRowScan
==

select * from tvf_templated_select_collated_output_columns_with_collated_column_ref('abc')
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_collated_output_columns_with_collated_column_ref.concat_ci#1{Collation:"und:ci"} AS concat_ci [STRING]
| +-tvf_templated_select_collated_output_columns_with_collated_column_ref.array_with_string_ci#2[{Collation:"und:ci"}] AS array_with_string_ci [ARRAY<STRING>]
| +-tvf_templated_select_collated_output_columns_with_collated_column_ref.struct_with_string_ci#3<_,{Collation:"und:ci"}> AS struct_with_string_ci [STRUCT<a INT32, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_select_collated_output_columns_with_collated_column_ref.[concat_ci#1, array_with_string_ci#2, struct_with_string_ci#3]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_templated_select_collated_output_columns_with_collated_column_ref.[concat_ci#1, array_with_string_ci#2, struct_with_string_ci#3]
        +-tvf=tvf_templated_select_collated_output_columns_with_collated_column_ref((ANY TYPE) -> ANY TABLE)
        +-signature=(literal STRING) -> TABLE<concat_ci STRING COLLATE 'und:ci', array_with_string_ci ARRAY<STRING COLLATE 'und:ci'>, struct_with_string_ci STRUCT<a INT32, b STRING COLLATE 'und:ci'>>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value='abc')
        +-column_index_list=[0, 1, 2]

With Templated SQL TVF signature:
  tvf_templated_select_collated_output_columns_with_collated_column_ref(literal STRING) -> TABLE<concat_ci STRING COLLATE 'und:ci', array_with_string_ci ARRAY<STRING COLLATE 'und:ci'>, struct_with_string_ci STRUCT<a INT32, b STRING COLLATE 'und:ci'>>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.concat_ci#5{Collation:"und:ci"} AS concat_ci [STRING]
| +-CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}] AS array_with_string_ci [ARRAY<STRING>]
| +-CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}> AS struct_with_string_ci [STRUCT<a INT32, b STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.concat_ci#5{Collation:"und:ci"}, CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}], CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>]
    +-expr_list=
    | +-concat_ci#5 :=
    |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-ArgumentRef(type=STRING, name='x')
    |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
    +-input_scan=
      +-TableScan(column_list=CollatedTable.[string_ci#1, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 2, 3])
==

select * from tvf_templated_select_collated_output_columns_with_relation_arg(
  (select 'abc' as col_str), 2
)
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_collated_output_columns_with_relation_arg.col_ci#2{Collation:"und:ci"} AS col_ci [STRING]
| +-tvf_templated_select_collated_output_columns_with_relation_arg.col_array_ci#3[{Collation:"und:ci"}] AS col_array_ci [ARRAY<STRING>]
| +-tvf_templated_select_collated_output_columns_with_relation_arg.col_struct_ci#4<{Collation:"und:ci"},_> AS col_struct_ci [STRUCT<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=tvf_templated_select_collated_output_columns_with_relation_arg.[col_ci#2, col_array_ci#3, col_struct_ci#4]
    +-input_scan=
      +-TVFScan
        +-column_list=tvf_templated_select_collated_output_columns_with_relation_arg.[col_ci#2, col_array_ci#3, col_struct_ci#4]
        +-tvf=tvf_templated_select_collated_output_columns_with_relation_arg((ANY TABLE, INT64) -> ANY TABLE)
        +-signature=(TABLE<col_str STRING>, literal INT64) -> TABLE<col_ci STRING COLLATE 'und:ci', col_array_ci ARRAY<STRING COLLATE 'und:ci'>, col_struct_ci STRUCT<STRING COLLATE 'und:ci', INT64>>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$subquery1.col_str#1]
        | | |   +-expr_list=
        | | |   | +-col_str#1 := Literal(type=STRING, value='abc')
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-argument_column_list=[$subquery1.col_str#1]
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=INT64, value=2)
        +-column_index_list=[0, 1, 2]

With Templated SQL TVF signature:
  tvf_templated_select_collated_output_columns_with_relation_arg(TABLE<col_str STRING>, literal INT64) -> TABLE<col_ci STRING COLLATE 'und:ci', col_array_ci ARRAY<STRING COLLATE 'und:ci'>, col_struct_ci STRUCT<STRING COLLATE 'und:ci', INT64>>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.col_ci#2{Collation:"und:ci"} AS col_ci [STRING]
| +-$query.col_array_ci#3[{Collation:"und:ci"}] AS col_array_ci [ARRAY<STRING>]
| +-$query.col_struct_ci#4<{Collation:"und:ci"},_> AS col_struct_ci [STRUCT<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=$query.[col_ci#2, col_array_ci#3, col_struct_ci#4]
    +-expr_list=
    | +-col_ci#2 :=
    | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |   +-type_annotation_map={Collation:"und:ci"}
    | |   +-ColumnRef(type=STRING, column=x.col_str#1)
    | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | +-col_array_ci#3 :=
    | | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
    | |   +-type_annotation_map=[{Collation:"und:ci"}]
    | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    | |     +-type_annotation_map={Collation:"und:ci"}
    | |     +-ColumnRef(type=STRING, column=x.col_str#1)
    | |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    | +-col_struct_ci#4 :=
    |   +-MakeStruct
    |     +-type=STRUCT<STRING, INT64>
    |     +-type_annotation_map=<{Collation:"und:ci"},_>
    |     +-field_list=
    |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | +-type_annotation_map={Collation:"und:ci"}
    |       | +-ColumnRef(type=STRING, column=x.col_str#1)
    |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       +-ArgumentRef(type=INT64, name='y')
    +-input_scan=
      +-RelationArgumentScan(column_list=[x.col_str#1], name='x')
==

select * from tvf_templated_select_collated_output_column_as_value_table('a', 'b')
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_collated_output_column_as_value_table.$col0#1{Collation:"und:ci"} AS "$col0" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_collated_output_column_as_value_table.$col0#1{Collation:"und:ci"}]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_collated_output_column_as_value_table.$col0#1{Collation:"und:ci"}]
        +-tvf=tvf_templated_select_collated_output_column_as_value_table((ANY TYPE, ANY TYPE) -> ANY TABLE)
        +-signature=(literal STRING, literal STRING) -> TABLE<STRING COLLATE 'und:ci'>
        +-argument_list=
        | +-FunctionArgument
        | | +-expr=
        | |   +-Literal(type=STRING, value='a')
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value='b')
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_collated_output_column_as_value_table(literal STRING, literal STRING) -> TABLE<STRING COLLATE 'und:ci'>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.$col1#1{Collation:"und:ci"} AS "$value_column" [STRING]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1{Collation:"und:ci"}]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    |     +-type_annotation_map={Collation:"und:ci"}
    |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     | +-type_annotation_map={Collation:"und:ci"}
    |     | +-ArgumentRef(type=STRING, name='x')
    |     | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |     +-ArgumentRef(type=STRING, name='y')
    +-input_scan=
      +-SingleRowScan
==

# TVF query with collated output column is not allowed when an explicit result schema is present.
select * from tvf_templated_select_collated_output_column_returns_int64_string_col(1, 'a')
--
ERROR: Invalid table-valued function tvf_templated_select_collated_output_column_returns_int64_string_col [at 1:15]
select * from tvf_templated_select_collated_output_column_returns_int64_strin...
              ^
Analysis of table-valued function tvf_templated_select_collated_output_column_returns_int64_string_col failed [at 1:1]
select x as key, COLLATE(y, 'und:ci') as value
^
Collation "und:ci" on output column value is not allowed when an explicit result schema is present
==

# TVF query with collated output column is not allowed when an explicit value table result schema is present.
select * from tvf_templated_select_collated_output_column_returns_value_table_string_col('x')
--
ERROR: Invalid table-valued function tvf_templated_select_collated_output_column_returns_value_table_string_col [at 1:15]
select * from tvf_templated_select_collated_output_column_returns_value_table...
              ^
Analysis of table-valued function tvf_templated_select_collated_output_column_returns_value_table_string_col failed [at 1:1]
select as value COLLATE(x, 'und:ci')
^
Collation "und:ci" on value-table column is not allowed when an explicit result schema is present
==

# Create a TVF which returns columns of collated types with COLLATE function inside TVF body.
create table function tvf(x STRING, y INT64) as (
  select
    COLLATE(x, 'und:ci') as col_ci,
    [COLLATE(x, 'und:ci')] as col_array_ci,
    (COLLATE(x, 'und:ci'), y) as col_struct_ci
)
--
CreateTableFunctionStmt
+-name_path=tvf
+-argument_name_list=[x, y]
+-signature=(STRING x, INT64 y) -> TABLE<col_ci STRING COLLATE 'und:ci', col_array_ci ARRAY<STRING COLLATE 'und:ci'>, col_struct_ci STRUCT<STRING COLLATE 'und:ci', INT64>>
+-language='SQL'
+-code='select\n    COLLATE(x, \'und:ci\') as col_ci,\n    [COLLATE(x, \'und:ci\')] as col_array_ci,\n    (COLLATE(x, \'und:ci\'), y) as col_struct_ci'
+-query=
| +-ProjectScan
|   +-column_list=$query.[col_ci#1, col_array_ci#2, col_struct_ci#3]
|   +-expr_list=
|   | +-col_ci#1 :=
|   | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   | |   +-type_annotation_map={Collation:"und:ci"}
|   | |   +-ArgumentRef(type=STRING, name='x')
|   | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   | +-col_array_ci#2 :=
|   | | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
|   | |   +-type_annotation_map=[{Collation:"und:ci"}]
|   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   | |     +-type_annotation_map={Collation:"und:ci"}
|   | |     +-ArgumentRef(type=STRING, name='x')
|   | |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   | +-col_struct_ci#3 :=
|   |   +-MakeStruct
|   |     +-type=STRUCT<STRING, INT64>
|   |     +-type_annotation_map=<{Collation:"und:ci"},_>
|   |     +-field_list=
|   |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   |       | +-type_annotation_map={Collation:"und:ci"}
|   |       | +-ArgumentRef(type=STRING, name='x')
|   |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   |       +-ArgumentRef(type=INT64, name='y')
|   +-input_scan=
|     +-SingleRowScan
+-output_column_list=
  +-$query.col_ci#1{Collation:"und:ci"} AS col_ci [STRING]
  +-$query.col_array_ci#2[{Collation:"und:ci"}] AS col_array_ci [ARRAY<STRING>]
  +-$query.col_struct_ci#3<{Collation:"und:ci"},_> AS col_struct_ci [STRUCT<STRING, INT64>]
==

# Create a TVF which returns columns of collated types with reference to collated columns inside TVF body.
create table function tvf(x STRING, y INT64) as (
  select
    CONCAT(x, string_ci) as concat_ci,
    array_with_string_ci,
    struct_with_string_ci
  from CollatedTable
)
--
CreateTableFunctionStmt
+-name_path=tvf
+-argument_name_list=[x, y]
+-signature=(STRING x, INT64 y) -> TABLE<concat_ci STRING COLLATE 'und:ci', array_with_string_ci ARRAY<STRING COLLATE 'und:ci'>, struct_with_string_ci STRUCT<a INT32, b STRING COLLATE 'und:ci'>>
+-language='SQL'
+-code='select\n    CONCAT(x, string_ci) as concat_ci,\n    array_with_string_ci,\n    struct_with_string_ci\n  from CollatedTable'
+-query=
| +-ProjectScan
|   +-column_list=[$query.concat_ci#5{Collation:"und:ci"}, CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}], CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>]
|   +-expr_list=
|   | +-concat_ci#5 :=
|   |   +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
|   |     +-type_annotation_map={Collation:"und:ci"}
|   |     +-ArgumentRef(type=STRING, name='x')
|   |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
|   +-input_scan=
|     +-TableScan(column_list=CollatedTable.[string_ci#1, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 2, 3])
+-output_column_list=
  +-$query.concat_ci#5{Collation:"und:ci"} AS concat_ci [STRING]
  +-CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}] AS array_with_string_ci [ARRAY<STRING>]
  +-CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}> AS struct_with_string_ci [STRUCT<a INT32, b STRING>]
==

# Create a TVF which returns columns of collated types with input table argument.
create table function tvf(x TABLE<col_str STRING>, y INT64) as (
  select
    COLLATE(col_str, 'und:ci') as col_ci,
    [COLLATE(col_str, 'und:ci')] as col_array_ci,
    (COLLATE(col_str, 'und:ci'), y) as col_struct_ci
  from x
)
--
CreateTableFunctionStmt
+-name_path=tvf
+-argument_name_list=[x, y]
+-signature=(TABLE<col_str STRING> x, INT64 y) -> TABLE<col_ci STRING COLLATE 'und:ci', col_array_ci ARRAY<STRING COLLATE 'und:ci'>, col_struct_ci STRUCT<STRING COLLATE 'und:ci', INT64>>
+-language='SQL'
+-code='select\n    COLLATE(col_str, \'und:ci\') as col_ci,\n    [COLLATE(col_str, \'und:ci\')] as col_array_ci,\n    (COLLATE(col_str, \'und:ci\'), y) as col_struct_ci\n  from x'
+-query=
| +-ProjectScan
|   +-column_list=$query.[col_ci#2, col_array_ci#3, col_struct_ci#4]
|   +-expr_list=
|   | +-col_ci#2 :=
|   | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   | |   +-type_annotation_map={Collation:"und:ci"}
|   | |   +-ColumnRef(type=STRING, column=x.col_str#1)
|   | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   | +-col_array_ci#3 :=
|   | | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
|   | |   +-type_annotation_map=[{Collation:"und:ci"}]
|   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   | |     +-type_annotation_map={Collation:"und:ci"}
|   | |     +-ColumnRef(type=STRING, column=x.col_str#1)
|   | |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   | +-col_struct_ci#4 :=
|   |   +-MakeStruct
|   |     +-type=STRUCT<STRING, INT64>
|   |     +-type_annotation_map=<{Collation:"und:ci"},_>
|   |     +-field_list=
|   |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   |       | +-type_annotation_map={Collation:"und:ci"}
|   |       | +-ColumnRef(type=STRING, column=x.col_str#1)
|   |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   |       +-ArgumentRef(type=INT64, name='y')
|   +-input_scan=
|     +-RelationArgumentScan(column_list=[x.col_str#1], name='x')
+-output_column_list=
  +-$query.col_ci#2{Collation:"und:ci"} AS col_ci [STRING]
  +-$query.col_array_ci#3[{Collation:"und:ci"}] AS col_array_ci [ARRAY<STRING>]
  +-$query.col_struct_ci#4<{Collation:"und:ci"},_> AS col_struct_ci [STRUCT<STRING, INT64>]
==

# Create a TVF which returns columns of collated types with input value table argument.
create table function tvf(x TABLE<STRUCT<str_field STRING>>) as (
  select
    COLLATE(str_field, 'und:ci') as col_ci,
    [COLLATE(str_field, 'und:ci')] as col_array_ci,
    (COLLATE(str_field, 'und:ci'), 1) as col_struct_ci
  from x
)
--
CreateTableFunctionStmt
+-name_path=tvf
+-argument_name_list=[x]
+-signature=(TABLE<STRUCT<str_field STRING>> x) -> TABLE<col_ci STRING COLLATE 'und:ci', col_array_ci ARRAY<STRING COLLATE 'und:ci'>, col_struct_ci STRUCT<STRING COLLATE 'und:ci', INT64>>
+-language='SQL'
+-code='select\n    COLLATE(str_field, \'und:ci\') as col_ci,\n    [COLLATE(str_field, \'und:ci\')] as col_array_ci,\n    (COLLATE(str_field, \'und:ci\'), 1) as col_struct_ci\n  from x'
+-query=
| +-ProjectScan
|   +-column_list=$query.[col_ci#2, col_array_ci#3, col_struct_ci#4]
|   +-expr_list=
|   | +-col_ci#2 :=
|   | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   | |   +-type_annotation_map={Collation:"und:ci"}
|   | |   +-GetStructField
|   | |   | +-type=STRING
|   | |   | +-expr=
|   | |   | | +-ColumnRef(type=STRUCT<str_field STRING>, column=x.$value_column#1)
|   | |   | +-field_idx=0
|   | |   +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   | +-col_array_ci#3 :=
|   | | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
|   | |   +-type_annotation_map=[{Collation:"und:ci"}]
|   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   | |     +-type_annotation_map={Collation:"und:ci"}
|   | |     +-GetStructField
|   | |     | +-type=STRING
|   | |     | +-expr=
|   | |     | | +-ColumnRef(type=STRUCT<str_field STRING>, column=x.$value_column#1)
|   | |     | +-field_idx=0
|   | |     +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   | +-col_struct_ci#4 :=
|   |   +-MakeStruct
|   |     +-type=STRUCT<STRING, INT64>
|   |     +-type_annotation_map=<{Collation:"und:ci"},_>
|   |     +-field_list=
|   |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   |       | +-type_annotation_map={Collation:"und:ci"}
|   |       | +-GetStructField
|   |       | | +-type=STRING
|   |       | | +-expr=
|   |       | | | +-ColumnRef(type=STRUCT<str_field STRING>, column=x.$value_column#1)
|   |       | | +-field_idx=0
|   |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   |       +-Literal(type=INT64, value=1)
|   +-input_scan=
|     +-RelationArgumentScan(column_list=[x.$value_column#1], name='x', is_value_table=TRUE)
+-output_column_list=
  +-$query.col_ci#2{Collation:"und:ci"} AS col_ci [STRING]
  +-$query.col_array_ci#3[{Collation:"und:ci"}] AS col_array_ci [ARRAY<STRING>]
  +-$query.col_struct_ci#4<{Collation:"und:ci"},_> AS col_struct_ci [STRUCT<STRING, INT64>]
==

# Create a TVF which returns value table column of collated types.
create table function tvf(x STRING) as (
  select as value struct(COLLATE(x, 'und:ci') as col_ci, COLLATE(x, 'binary') as col_binary)
)
--
CreateTableFunctionStmt
+-name_path=tvf
+-argument_name_list=[x]
+-signature=(STRING x) -> TABLE<STRUCT<col_ci STRING COLLATE 'und:ci', col_binary STRING COLLATE 'binary'>>
+-language='SQL'
+-code='select as value struct(COLLATE(x, \'und:ci\') as col_ci, COLLATE(x, \'binary\') as col_binary)'
+-query=
| +-ProjectScan
|   +-column_list=[$query.$col1#1<{Collation:"und:ci"},{Collation:"binary"}>]
|   +-expr_list=
|   | +-$col1#1 :=
|   |   +-MakeStruct
|   |     +-type=STRUCT<col_ci STRING, col_binary STRING>
|   |     +-type_annotation_map=<{Collation:"und:ci"},{Collation:"binary"}>
|   |     +-field_list=
|   |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   |       | +-type_annotation_map={Collation:"und:ci"}
|   |       | +-ArgumentRef(type=STRING, name='x')
|   |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
|   |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|   |         +-type_annotation_map={Collation:"binary"}
|   |         +-ArgumentRef(type=STRING, name='x')
|   |         +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
|   +-input_scan=
|     +-SingleRowScan
+-output_column_list=
| +-$query.$col1#1<{Collation:"und:ci"},{Collation:"binary"}> AS "$value_column" [STRUCT<col_ci STRING, col_binary STRING>]
+-is_value_table=TRUE
==

# TVF query with collated output column is not allowed when an explicit result schema is present.
create table function tvf(x STRING)
returns TABLE<output_str STRING>
as (select COLLATE(x, 'und:ci') as output_str)
--
ERROR: Collation "und:ci" on output column output_str is not allowed when an explicit result schema is present [at 1:1]
create table function tvf(x STRING)
^
==

# TVF query with collated output column is not allowed when an explicit value table result schema is present.
create table function tvf(x STRING)
returns TABLE<STRING>
as (select as value COLLATE(x, 'und:ci'))
--
ERROR: Collation "und:ci" on value-table column is not allowed when an explicit result schema is present [at 1:1]
create table function tvf(x STRING)
^
==

select * from ScalarArgWithCollatedOutputCols('abc')
--
QueryStmt
+-output_column_list=
| +-ScalarArgWithCollatedOutputCols.col_ci#1{Collation:"und:ci"} AS col_ci [STRING]
| +-ScalarArgWithCollatedOutputCols.col_array_ci#2[{Collation:"und:ci"}] AS col_array_ci [ARRAY<STRING>]
| +-ScalarArgWithCollatedOutputCols.col_struct_ci#3<[{Collation:"und:ci"}],_> AS col_struct_ci [STRUCT<ARRAY<STRING>, INT64>]
+-query=
  +-ProjectScan
    +-column_list=ScalarArgWithCollatedOutputCols.[col_ci#1, col_array_ci#2, col_struct_ci#3]
    +-input_scan=
      +-TVFScan
        +-column_list=ScalarArgWithCollatedOutputCols.[col_ci#1, col_array_ci#2, col_struct_ci#3]
        +-tvf=ScalarArgWithCollatedOutputCols((STRING arg0) -> TABLE<col_ci STRING COLLATE 'und:ci', col_array_ci ARRAY<STRING COLLATE 'und:ci'>, col_struct_ci STRUCT<ARRAY<STRING COLLATE 'und:ci'>, INT64>>)
        +-signature=(literal STRING) -> TABLE<col_ci STRING COLLATE 'und:ci', col_array_ci ARRAY<STRING COLLATE 'und:ci'>, col_struct_ci STRUCT<ARRAY<STRING COLLATE 'und:ci'>, INT64>>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value='abc')
        +-column_index_list=[0, 1, 2]
==

select * from TableArgWithCollatedOutputCols((select 'abc' as a))
--
QueryStmt
+-output_column_list=
| +-TableArgWithCollatedOutputCols.col_ci#2{Collation:"und:ci"} AS col_ci [STRING]
| +-TableArgWithCollatedOutputCols.col_array_ci#3[{Collation:"und:ci"}] AS col_array_ci [ARRAY<STRING>]
| +-TableArgWithCollatedOutputCols.col_struct_ci#4<[{Collation:"und:ci"}],_> AS col_struct_ci [STRUCT<ARRAY<STRING>, INT64>]
+-query=
  +-ProjectScan
    +-column_list=TableArgWithCollatedOutputCols.[col_ci#2, col_array_ci#3, col_struct_ci#4]
    +-input_scan=
      +-TVFScan
        +-column_list=TableArgWithCollatedOutputCols.[col_ci#2, col_array_ci#3, col_struct_ci#4]
        +-tvf=TableArgWithCollatedOutputCols((TABLE<a STRING> arg0) -> TABLE<col_ci STRING COLLATE 'und:ci', col_array_ci ARRAY<STRING COLLATE 'und:ci'>, col_struct_ci STRUCT<ARRAY<STRING COLLATE 'und:ci'>, INT64>>)
        +-signature=(TABLE<a STRING>) -> TABLE<col_ci STRING COLLATE 'und:ci', col_array_ci ARRAY<STRING COLLATE 'und:ci'>, col_struct_ci STRUCT<ARRAY<STRING COLLATE 'und:ci'>, INT64>>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$subquery1.a#1]
        |   |   +-expr_list=
        |   |   | +-a#1 := Literal(type=STRING, value='abc')
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-argument_column_list=[$subquery1.a#1]
        +-column_index_list=[0, 1, 2]
==

select * from ValueTableArgWithCollatedOutputCols((select as struct 'abc' str_field))
--
QueryStmt
+-output_column_list=
| +-ValueTableArgWithCollatedOutputCols.col_ci#3{Collation:"und:ci"} AS col_ci [STRING]
| +-ValueTableArgWithCollatedOutputCols.col_array_ci#4[{Collation:"und:ci"}] AS col_array_ci [ARRAY<STRING>]
| +-ValueTableArgWithCollatedOutputCols.col_struct_ci#5<[{Collation:"und:ci"}],_> AS col_struct_ci [STRUCT<ARRAY<STRING>, INT64>]
+-query=
  +-ProjectScan
    +-column_list=ValueTableArgWithCollatedOutputCols.[col_ci#3, col_array_ci#4, col_struct_ci#5]
    +-input_scan=
      +-TVFScan
        +-column_list=ValueTableArgWithCollatedOutputCols.[col_ci#3, col_array_ci#4, col_struct_ci#5]
        +-tvf=ValueTableArgWithCollatedOutputCols((TABLE<STRUCT<str_field STRING>> arg0) -> TABLE<col_ci STRING COLLATE 'und:ci', col_array_ci ARRAY<STRING COLLATE 'und:ci'>, col_struct_ci STRUCT<ARRAY<STRING COLLATE 'und:ci'>, INT64>>)
        +-signature=(TABLE<STRUCT<str_field STRING>>) -> TABLE<col_ci STRING COLLATE 'und:ci', col_array_ci ARRAY<STRING COLLATE 'und:ci'>, col_struct_ci STRUCT<ARRAY<STRING COLLATE 'und:ci'>, INT64>>
        +-argument_list=
        | +-FunctionArgument
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$make_struct.$struct#2]
        |   |   +-expr_list=
        |   |   | +-$struct#2 :=
        |   |   |   +-MakeStruct
        |   |   |     +-type=STRUCT<str_field STRING>
        |   |   |     +-field_list=
        |   |   |       +-ColumnRef(type=STRING, column=$subquery1.str_field#1)
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=[$subquery1.str_field#1]
        |   |       +-expr_list=
        |   |       | +-str_field#1 := Literal(type=STRING, value='abc')
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-argument_column_list=[$make_struct.$struct#2]
        +-column_index_list=[0, 1, 2]
==

select * from ScalarArgWithCollatedOutputValueTableCol('abc')
--
QueryStmt
+-output_column_list=
| +-ScalarArgWithCollatedOutputValueTableCol.$col0#1{Collation:"und:ci"} AS "$col0" [STRING]
+-query=
  +-ProjectScan
    +-column_list=[ScalarArgWithCollatedOutputValueTableCol.$col0#1{Collation:"und:ci"}]
    +-input_scan=
      +-TVFScan
        +-column_list=[ScalarArgWithCollatedOutputValueTableCol.$col0#1{Collation:"und:ci"}]
        +-tvf=ScalarArgWithCollatedOutputValueTableCol((STRING arg0) -> TABLE<STRING COLLATE 'und:ci'>)
        +-signature=(literal STRING) -> TABLE<STRING COLLATE 'und:ci'>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-Literal(type=STRING, value='abc')
        +-column_index_list=[0]
==

select * from tvf_templated_select_any_scalar_arg(COLLATE('abc', 'und:ci'))
--
ERROR: Collation "und:ci" on argument of TVF call is not allowed [at 1:51]
select * from tvf_templated_select_any_scalar_arg(COLLATE('abc', 'und:ci'))
                                                  ^
==

# Argument is accepted after removing the collation of the collated expression.
select * from tvf_templated_select_any_scalar_arg(COLLATE(COLLATE('abc', 'und:ci'), ''))
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_any_scalar_arg.x#1 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[tvf_templated_select_any_scalar_arg.x#1]
    +-input_scan=
      +-TVFScan
        +-column_list=[tvf_templated_select_any_scalar_arg.x#1]
        +-tvf=tvf_templated_select_any_scalar_arg((ANY TYPE) -> ANY TABLE)
        +-signature=(STRING) -> TABLE<x STRING>
        +-argument_list=
        | +-FunctionArgument
        |   +-expr=
        |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |       | +-type_annotation_map={Collation:"und:ci"}
        |       | +-Literal(type=STRING, value='abc')
        |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
        |       +-Literal(type=STRING, value='', preserve_in_literal_remover=TRUE)
        +-column_index_list=[0]

With Templated SQL TVF signature:
  tvf_templated_select_any_scalar_arg(STRING) -> TABLE<x STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1]
    +-expr_list=
    | +-x#1 := ArgumentRef(type=STRING, name='x')
    +-input_scan=
      +-SingleRowScan
==

select * from tvf_templated_select_any_scalar_arg([COLLATE('abc', 'und:ci')])
--
ERROR: Collation ["und:ci"] on argument of TVF call is not allowed [at 1:51]
select * from tvf_templated_select_any_scalar_arg([COLLATE('abc', 'und:ci')])
                                                  ^
==

select * from tvf_templated_select_any_scalar_arg(STRUCT(COLLATE('abc', 'und:ci') as x, 1 as y))
--
ERROR: Collation <"und:ci",_> on argument of TVF call is not allowed [at 1:51]
select * from tvf_templated_select_any_scalar_arg(STRUCT(COLLATE('abc', 'und:...
                                                  ^
==

select * from tvf_templated_select_relation_arg_using_select_star((select [COLLATE('abc', 'und:ci')] as col_array_ci))
--
ERROR: Collation ["und:ci"] on column col_array_ci of argument of TVF call is not allowed [at 1:67]
...tvf_templated_select_relation_arg_using_select_star((select [COLLATE('abc'...
                                                       ^
==

select * from tvf_templated_select_relation_arg_using_select_star((select as struct COLLATE('abc', 'und:ci') x, 123 y))
--
ERROR: Collation <"und:ci",_> on value-table column of argument of TVF call is not allowed [at 1:67]
...tvf_templated_select_relation_arg_using_select_star((select as struct COLL...
                                                       ^
==

select * from ScalarArgsOfCollatableTypes(COLLATE('abc', 'und:ci'), ['abc'], ('abc', 1))
--
ERROR: Collation "und:ci" on argument of TVF call is not allowed [at 1:43]
select * from ScalarArgsOfCollatableTypes(COLLATE('abc', 'und:ci'), ['abc'], ...
                                          ^
==

select * from ScalarArgsOfCollatableTypes(arg1=>[COLLATE('abc', 'und:ci')], arg0=>'abc', arg2=>('abc', 1))
--
ERROR: Collation ["und:ci"] on argument of TVF call is not allowed [at 1:43]
select * from ScalarArgsOfCollatableTypes(arg1=>[COLLATE('abc', 'und:ci')], a...
                                          ^
==

select * from ScalarArgsOfCollatableTypes('abc', ['abc'], (COLLATE('abc', 'und:ci'), 1))
--
ERROR: Collation <"und:ci",_> on argument of TVF call is not allowed [at 1:59]
...from ScalarArgsOfCollatableTypes('abc', ['abc'], (COLLATE('abc', 'und:ci')...
                                                    ^
==

select * from TableArgWithCollatedOutputCols((select COLLATE('abc', 'und:ci') as a))
--
ERROR: Collation "und:ci" on column a of argument of TVF call is not allowed [at 1:46]
select * from TableArgWithCollatedOutputCols((select COLLATE('abc', 'und:ci')...
                                             ^
==

select * from ValueTableArgWithCollatedOutputCols((select as struct COLLATE('abc', 'und:ci') str_field))
--
ERROR: Collation <"und:ci"> on value-table column of argument of TVF call is not allowed [at 1:51]
select * from ValueTableArgWithCollatedOutputCols((select as struct COLLATE('...
                                                  ^
==

# Collation in return type of SQL function body is not allowed.
create function myfunc(x STRING) as (COLLATE(x, 'und:ci'));
--
ERROR: Collation "und:ci" in return type of user-defined function body is not allowed [at 1:37]
create function myfunc(x STRING) as (COLLATE(x, 'und:ci'));
                                    ^
==

# Collation in return type of SQL function body is not allowed.
create function myfunc(x STRING) as ([COLLATE(x, 'und:ci')]);
--
ERROR: Collation ["und:ci"] in return type of user-defined function body is not allowed [at 1:37]
create function myfunc(x STRING) as ([COLLATE(x, 'und:ci')]);
                                    ^
==

# Collation in return type of SQL function body is not allowed.
create function myfunc(x STRING) as ((COLLATE(x, 'und:ci'), 1));
--
ERROR: Collation <"und:ci",_> in return type of user-defined function body is not allowed [at 1:37]
create function myfunc(x STRING) as ((COLLATE(x, 'und:ci'), 1));
                                    ^
==

# Collation in return type of SQL function body is not allowed.
create function myfunc(x STRING) as (COLLATE(x, 'binary'));
--
ERROR: Collation "binary" in return type of user-defined function body is not allowed [at 1:37]
create function myfunc(x STRING) as (COLLATE(x, 'binary'));
                                    ^
==

# If the second argument of COLLATE function is empty string, the return type
# of function body has no collation and hence the query is not blocked.
create function myfunc(x STRING) as (COLLATE(x, ''));
--
CreateFunctionStmt
+-name_path=myfunc
+-return_type=STRING
+-argument_name_list=[x]
+-signature=(STRING x) -> STRING rejects_collation=TRUE
+-language='SQL'
+-code='COLLATE(x, \'\')'
+-function_expression=
  +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    +-ArgumentRef(type=STRING, name='x')
    +-Literal(type=STRING, value='', preserve_in_literal_remover=TRUE)
==

# Collation in return type of SQL function body is not allowed.
# Returns an error even if the function has an explicit return type without
# collation.
create function myfunc(x STRING) returns string
as (COLLATE(x, 'und:ci'));
--
ERROR: Collation "und:ci" in return type of user-defined function body is not allowed [at 2:4]
as (COLLATE(x, 'und:ci'));
   ^
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,CREATE_AGGREGATE_FUNCTION]
# Collation in return type of SQL function body is not allowed. The function
# is a SQL aggregate function.
create aggregate function myfunc(x STRING)
as (MIN(COLLATE(x, 'und:ci')));
--
ERROR: Collation "und:ci" in return type of user-defined function body is not allowed [at 4:4]
as (MIN(COLLATE(x, 'und:ci')));
   ^
==

# Collation in return type of templated SQL function body is not allowed.
select udf_templated_collate_function('abc');
--
ERROR: Invalid function udf_templated_collate_function [at 1:8]
select udf_templated_collate_function('abc');
       ^
Collation "und:ci" in return type of user-defined function body is not allowed
==

# Collation in return type of templated SQL function body is not allowed.
select udf_templated_collate_function_in_array('abc');
--
ERROR: Invalid function udf_templated_collate_function_in_array [at 1:8]
select udf_templated_collate_function_in_array('abc');
       ^
Collation ["und:ci"] in return type of user-defined function body is not allowed
==

# Collation in return type of templated SQL function body is not allowed.
select udf_templated_collate_function_in_struct('abc');
--
ERROR: Invalid function udf_templated_collate_function_in_struct [at 1:8]
select udf_templated_collate_function_in_struct('abc');
       ^
Collation <"und:ci",_> in return type of user-defined function body is not allowed
==

# Collation in return type of templated SQL function body is not allowed, even
# if the function has an explicit return type without collation.
select udf_templated_collate_function_return_string('abc');
--
ERROR: Invalid function udf_templated_collate_function_return_string [at 1:8]
select udf_templated_collate_function_return_string('abc');
       ^
Collation "und:ci" in return type of user-defined function body is not allowed
==

# Collation in return type of templated SQL function body is not allowed. The
# function is a SQL aggregate function.
select uda_templated_aggregate_with_min_collate_function(x)
from unnest(['a', 'b', 'c']) x;
--
ERROR: Invalid function uda_templated_aggregate_with_min_collate_function [at 1:8]
select uda_templated_aggregate_with_min_collate_function(x)
       ^
Collation "und:ci" in return type of user-defined function body is not allowed
==

# Coercing struct in scan through internal CAST - IN subquery.
# Left struct type has collation and the right struct type has no collation.
SELECT struct_with_string_ci IN
(SELECT STRUCT<x INT32, y STRING>(1, Value) FROM KeyValue)
from CollatedTable
--
QueryStmt
+-output_column_list=
| +-$query.$col1#10 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    |     +-in_collation=[_,und:ci]
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$in_subquery_cast.$col1#9]
    |         +-expr_list=
    |         | +-$col1#9 :=
    |         |   +-Cast(STRUCT<x INT32, y STRING> -> STRUCT<a INT32, b STRING>)
    |         |     +-ColumnRef(type=STRUCT<x INT32, y STRING>, column=$expr_subquery.$col1#7)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$expr_subquery.$col1#7]
    |             +-expr_list=
    |             | +-$col1#7 :=
    |             |   +-MakeStruct
    |             |     +-type=STRUCT<x INT32, y STRING>
    |             |     +-field_list=
    |             |       +-Literal(type=INT32, value=1, has_explicit_type=TRUE)
    |             |       +-ColumnRef(type=STRING, column=KeyValue.Value#6)
    |             +-input_scan=
    |               +-TableScan(column_list=[KeyValue.Value#6], table=KeyValue, column_index_list=[1])
    +-input_scan=
      +-TableScan(column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>], table=CollatedTable, column_index_list=[2])
==

[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE]
# Coercing struct in scan through internal CAST - IN subquery.
# Left struct type has no collation and the right struct type has collation but
# the feture FEATURE_V_1_4_PRESERVE_ANNOTATION_IN_IMPLICIT_CAST_IN_SCAN is
# off. The collation in the right struct type will be dropped in the CAST.
SELECT STRUCT<x INT32, y STRING>(1, 'a') IN (SELECT struct_with_string_ci FROM CollatedTable)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=STRUCT<x INT32, y STRING>, value={x:1, y:'a'}, has_explicit_type=TRUE)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$in_subquery_cast.struct_with_string_ci#6]
    |         +-expr_list=
    |         | +-struct_with_string_ci#6 :=
    |         |   +-Cast(STRUCT<a INT32, b STRING> -> STRUCT<x INT32, y STRING>)
    |         |     +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>]
    |             +-input_scan=
    |               +-TableScan(column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>], table=CollatedTable, column_index_list=[2])
    +-input_scan=
      +-SingleRowScan
==

# Coercing struct in scan through internal CAST - IN subquery.
# Left struct type has no collation and the right struct type has collation.
SELECT STRUCT<x INT32, y STRING>(1, 'a') IN (SELECT struct_with_string_ci FROM CollatedTable)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#7 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#7]
    +-expr_list=
    | +-$col1#7 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=STRUCT<x INT32, y STRING>, value={x:1, y:'a'}, has_explicit_type=TRUE)
    |     +-in_collation=[_,und:ci]
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$in_subquery_cast.struct_with_string_ci#6<_,{Collation:"und:ci"}>]
    |         +-expr_list=
    |         | +-struct_with_string_ci#6 :=
    |         |   +-Cast(STRUCT<a INT32, b STRING> -> STRUCT<x INT32, y STRING>)
    |         |     +-type_annotation_map=<_,{Collation:"und:ci"}>
    |         |     +-ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
    |         |     +-type_modifiers=collation:[_,und:ci]
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>]
    |             +-input_scan=
    |               +-TableScan(column_list=[CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>], table=CollatedTable, column_index_list=[2])
    +-input_scan=
      +-SingleRowScan
==

# Coercing struct in scan through internal CAST - IN subquery.
# Both left struct type and right struct type have collation.
SELECT STRUCT('abc' AS x, COLLATE('abc', 'binary') AS y) IN
(SELECT (COLLATE('def', 'und:ci'), 'def'))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-MakeStruct
    |     |   +-type=STRUCT<x STRING, y STRING>
    |     |   +-type_annotation_map=<_,{Collation:"binary"}>
    |     |   +-field_list=
    |     |     +-Literal(type=STRING, value='abc')
    |     |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |     |       +-type_annotation_map={Collation:"binary"}
    |     |       +-Literal(type=STRING, value='abc')
    |     |       +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
    |     +-in_collation=[und:ci,binary]
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$in_subquery_cast.$col1#3<{Collation:"und:ci"},_>]
    |         +-expr_list=
    |         | +-$col1#3 :=
    |         |   +-Cast(STRUCT<STRING, STRING> -> STRUCT<x STRING, y STRING>)
    |         |     +-type_annotation_map=<{Collation:"und:ci"},_>
    |         |     +-ColumnRef(type=STRUCT<STRING, STRING>, type_annotation_map=<{Collation:"und:ci"},_>, column=$expr_subquery.$col1#1<{Collation:"und:ci"},_>)
    |         |     +-type_modifiers=collation:[und:ci,_]
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$expr_subquery.$col1#1<{Collation:"und:ci"},_>]
    |             +-expr_list=
    |             | +-$col1#1 :=
    |             |   +-MakeStruct
    |             |     +-type=STRUCT<STRING, STRING>
    |             |     +-type_annotation_map=<{Collation:"und:ci"},_>
    |             |     +-field_list=
    |             |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |             |       | +-type_annotation_map={Collation:"und:ci"}
    |             |       | +-Literal(type=STRING, value='def')
    |             |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |             |       +-Literal(type=STRING, value='def')
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

# Coercing struct in scan through internal CAST - IN subquery.
# The struct being casted has ARRAY field with collation.
[language_features=V_1_1_ARRAY_EQUALITY,V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_4_COLLATION_IN_EXPLICIT_CAST,V_1_4_PRESERVE_ANNOTATION_IN_IMPLICIT_CAST_IN_SCAN]
SELECT STRUCT<x INT64, y ARRAY<STRING>>(1, ['a']) IN
(SELECT (1, [COLLATE('abc', 'und:ci')]))
--
QueryStmt
+-output_column_list=
| +-$query.$col1#4 AS "$col1" [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#4]
    +-expr_list=
    | +-$col1#4 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=IN
    |     +-in_expr=
    |     | +-Literal(type=STRUCT<x INT64, y ARRAY<STRING>>, value={x:1, y:['a']}, has_explicit_type=TRUE)
    |     +-in_collation=[_,[und:ci]]
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$in_subquery_cast.$col1#3<_,[{Collation:"und:ci"}]>]
    |         +-expr_list=
    |         | +-$col1#3 :=
    |         |   +-Cast(STRUCT<INT64, ARRAY<STRING>> -> STRUCT<x INT64, y ARRAY<STRING>>)
    |         |     +-type_annotation_map=<_,[{Collation:"und:ci"}]>
    |         |     +-ColumnRef(type=STRUCT<INT64, ARRAY<STRING>>, type_annotation_map=<_,[{Collation:"und:ci"}]>, column=$expr_subquery.$col1#1<_,[{Collation:"und:ci"}]>)
    |         |     +-type_modifiers=collation:[_,[und:ci]]
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$expr_subquery.$col1#1<_,[{Collation:"und:ci"}]>]
    |             +-expr_list=
    |             | +-$col1#1 :=
    |             |   +-MakeStruct
    |             |     +-type=STRUCT<INT64, ARRAY<STRING>>
    |             |     +-type_annotation_map=<_,[{Collation:"und:ci"}]>
    |             |     +-field_list=
    |             |       +-Literal(type=INT64, value=1)
    |             |       +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
    |             |         +-type_annotation_map=[{Collation:"und:ci"}]
    |             |         +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |             |           +-type_annotation_map={Collation:"und:ci"}
    |             |           +-Literal(type=STRING, value='abc')
    |             |           +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
==

[no_run_unparser]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# Coercing struct in scan through internal CAST - set operation.
# The column that is NOT casted has collation.
(SELECT (0.1, COLLATE('abc', 'binary')))
UNION ALL
(SELECT (1, 'abc'))
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#3<_,{Collation:"binary"}> AS "$col1" [STRUCT<DOUBLE, STRING>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#3<_,{Collation:"binary"}>]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1.$col1#1<_,{Collation:"binary"}>]
      | |   +-expr_list=
      | |   | +-$col1#1 :=
      | |   |   +-MakeStruct
      | |   |     +-type=STRUCT<DOUBLE, STRING>
      | |   |     +-type_annotation_map=<_,{Collation:"binary"}>
      | |   |     +-field_list=
      | |   |       +-Literal(type=DOUBLE, value=0.1, float_literal_id=1)
      | |   |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
      | |   |         +-type_annotation_map={Collation:"binary"}
      | |   |         +-Literal(type=STRING, value='abc')
      | |   |         +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=[$union_all1.$col1#1<_,{Collation:"binary"}>]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2_cast.$col1#4]
        |   +-expr_list=
        |   | +-$col1#4 := Literal(type=STRUCT<DOUBLE, STRING>, value={1, 'abc'})
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$union_all2.$col1#2]
        |       +-expr_list=
        |       | +-$col1#2 := Literal(type=STRUCT<INT64, STRING>, value={1, 'abc'})
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$union_all2_cast.$col1#4]
==

[no_run_unparser]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# Coercing struct in scan through internal CAST - set operation.
# The column that is casted has collation.
(SELECT (0.1, 'abc'))
UNION ALL
(SELECT (1, COLLATE('abc', 'und:ci')))
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#3<_,{Collation:"und:ci"}> AS "$col1" [STRUCT<DOUBLE, STRING>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#3<_,{Collation:"und:ci"}>]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1.$col1#1]
      | |   +-expr_list=
      | |   | +-$col1#1 := Literal(type=STRUCT<DOUBLE, STRING>, value={0.1, 'abc'})
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=[$union_all1.$col1#1]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2_cast.$col1#4<_,{Collation:"und:ci"}>]
        |   +-expr_list=
        |   | +-$col1#4 :=
        |   |   +-Cast(STRUCT<INT64, STRING> -> STRUCT<DOUBLE, STRING>)
        |   |     +-type_annotation_map=<_,{Collation:"und:ci"}>
        |   |     +-ColumnRef(type=STRUCT<INT64, STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=$union_all2.$col1#2<_,{Collation:"und:ci"}>)
        |   |     +-type_modifiers=collation:[_,und:ci]
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$union_all2.$col1#2<_,{Collation:"und:ci"}>]
        |       +-expr_list=
        |       | +-$col1#2 :=
        |       |   +-MakeStruct
        |       |     +-type=STRUCT<INT64, STRING>
        |       |     +-type_annotation_map=<_,{Collation:"und:ci"}>
        |       |     +-field_list=
        |       |       +-Literal(type=INT64, value=1)
        |       |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |       |         +-type_annotation_map={Collation:"und:ci"}
        |       |         +-Literal(type=STRING, value='abc')
        |       |         +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$union_all2_cast.$col1#4<_,{Collation:"und:ci"}>]
==

[no_run_unparser]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# Coercing struct in scan through internal CAST - set operation.
# Columns from different queries are casted and they have collation in different
# fields.
(SELECT STRUCT(1 as x, 'abc' AS y, COLLATE('abc', 'binary') AS z))
UNION ALL
(SELECT (0.1, COLLATE('def', 'und:ci'), 'def'))
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#3<_,{Collation:"und:ci"},{Collation:"binary"}> AS "$col1" [STRUCT<x DOUBLE, y STRING, z STRING>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#3<_,{Collation:"und:ci"},{Collation:"binary"}>]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.$col1#4<_,_,{Collation:"binary"}>]
      | |   +-expr_list=
      | |   | +-$col1#4 :=
      | |   |   +-Cast(STRUCT<x INT64, y STRING, z STRING> -> STRUCT<x DOUBLE, y STRING, z STRING>)
      | |   |     +-type_annotation_map=<_,_,{Collation:"binary"}>
      | |   |     +-ColumnRef(type=STRUCT<x INT64, y STRING, z STRING>, type_annotation_map=<_,_,{Collation:"binary"}>, column=$union_all1.$col1#1<_,_,{Collation:"binary"}>)
      | |   |     +-type_modifiers=collation:[_,_,binary]
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$union_all1.$col1#1<_,_,{Collation:"binary"}>]
      | |       +-expr_list=
      | |       | +-$col1#1 :=
      | |       |   +-MakeStruct
      | |       |     +-type=STRUCT<x INT64, y STRING, z STRING>
      | |       |     +-type_annotation_map=<_,_,{Collation:"binary"}>
      | |       |     +-field_list=
      | |       |       +-Literal(type=INT64, value=1)
      | |       |       +-Literal(type=STRING, value='abc')
      | |       |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
      | |       |         +-type_annotation_map={Collation:"binary"}
      | |       |         +-Literal(type=STRING, value='abc')
      | |       |         +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$union_all1_cast.$col1#4<_,_,{Collation:"binary"}>]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all2_cast.$col1#5<_,{Collation:"und:ci"},_>]
        |   +-expr_list=
        |   | +-$col1#5 :=
        |   |   +-Cast(STRUCT<DOUBLE, STRING, STRING> -> STRUCT<x DOUBLE, y STRING, z STRING>)
        |   |     +-type_annotation_map=<_,{Collation:"und:ci"},_>
        |   |     +-ColumnRef(type=STRUCT<DOUBLE, STRING, STRING>, type_annotation_map=<_,{Collation:"und:ci"},_>, column=$union_all2.$col1#2<_,{Collation:"und:ci"},_>)
        |   |     +-type_modifiers=collation:[_,und:ci,_]
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$union_all2.$col1#2<_,{Collation:"und:ci"},_>]
        |       +-expr_list=
        |       | +-$col1#2 :=
        |       |   +-MakeStruct
        |       |     +-type=STRUCT<DOUBLE, STRING, STRING>
        |       |     +-type_annotation_map=<_,{Collation:"und:ci"},_>
        |       |     +-field_list=
        |       |       +-Literal(type=DOUBLE, value=0.1, float_literal_id=1)
        |       |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |       |       | +-type_annotation_map={Collation:"und:ci"}
        |       |       | +-Literal(type=STRING, value='def')
        |       |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
        |       |       +-Literal(type=STRING, value='def')
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$union_all2_cast.$col1#5<_,{Collation:"und:ci"},_>]
==

[no_run_unparser]
[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE,V_1_4_PRESERVE_ANNOTATION_IN_IMPLICIT_CAST_IN_SCAN]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# Coercing struct in scan through internal CAST - with recursive.
# Column in non-recursive term is casted and has collation.
WITH RECURSIVE t AS (
  SELECT (0.1, 'abc') AS col_struct, 1 AS n UNION ALL
  SELECT (1, COLLATE('def', 'und:ci')), 1 UNION ALL
  SELECT (0.1, COLLATE('hi', 'und:ci')), n + 1 FROM t WHERE n < 2
) SELECT * FROM t
--
QueryStmt
+-output_column_list=
| +-t.col_struct#14<_,{Collation:"und:ci"}> AS col_struct [STRUCT<DOUBLE, STRING>]
| +-t.n#15 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=t.[col_struct#14, n#15]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=$union_all.[col_struct#5, n#6]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-SetOperationScan
    |       |   |   +-column_list=$union_all.[col_struct#8, n#9]
    |       |   |   +-op_type=UNION_ALL
    |       |   |   +-input_item_list=
    |       |   |     +-SetOperationItem
    |       |   |     | +-scan=
    |       |   |     | | +-ProjectScan
    |       |   |     | |   +-column_list=$union_all1.[col_struct#1, n#2]
    |       |   |     | |   +-expr_list=
    |       |   |     | |   | +-col_struct#1 := Literal(type=STRUCT<DOUBLE, STRING>, value={0.1, 'abc'})
    |       |   |     | |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |     | |   +-input_scan=
    |       |   |     | |     +-SingleRowScan
    |       |   |     | +-output_column_list=$union_all1.[col_struct#1, n#2]
    |       |   |     +-SetOperationItem
    |       |   |       +-scan=
    |       |   |       | +-ProjectScan
    |       |   |       |   +-column_list=[$union_all2_cast.$col1#7<_,{Collation:"und:ci"}>, $union_all2.$col2#4]
    |       |   |       |   +-expr_list=
    |       |   |       |   | +-$col1#7 :=
    |       |   |       |   |   +-Cast(STRUCT<INT64, STRING> -> STRUCT<DOUBLE, STRING>)
    |       |   |       |   |     +-type_annotation_map=<_,{Collation:"und:ci"}>
    |       |   |       |   |     +-ColumnRef(type=STRUCT<INT64, STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=$union_all2.$col1#3<_,{Collation:"und:ci"}>)
    |       |   |       |   |     +-type_modifiers=collation:[_,und:ci]
    |       |   |       |   +-input_scan=
    |       |   |       |     +-ProjectScan
    |       |   |       |       +-column_list=$union_all2.[$col1#3, $col2#4]
    |       |   |       |       +-expr_list=
    |       |   |       |       | +-$col1#3 :=
    |       |   |       |       | | +-MakeStruct
    |       |   |       |       | |   +-type=STRUCT<INT64, STRING>
    |       |   |       |       | |   +-type_annotation_map=<_,{Collation:"und:ci"}>
    |       |   |       |       | |   +-field_list=
    |       |   |       |       | |     +-Literal(type=INT64, value=1)
    |       |   |       |       | |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |   |       |       | |       +-type_annotation_map={Collation:"und:ci"}
    |       |   |       |       | |       +-Literal(type=STRING, value='def')
    |       |   |       |       | |       +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       |   |       |       | +-$col2#4 := Literal(type=INT64, value=1)
    |       |   |       |       +-input_scan=
    |       |   |       |         +-SingleRowScan
    |       |   |       +-output_column_list=[$union_all2_cast.$col1#7<_,{Collation:"und:ci"}>, $union_all2.$col2#4]
    |       |   +-output_column_list=$union_all.[col_struct#8, n#9]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=$union_all3.[$col1#12, $col2#13]
    |           |   +-expr_list=
    |           |   | +-$col1#12 :=
    |           |   | | +-MakeStruct
    |           |   | |   +-type=STRUCT<DOUBLE, STRING>
    |           |   | |   +-type_annotation_map=<_,{Collation:"und:ci"}>
    |           |   | |   +-field_list=
    |           |   | |     +-Literal(type=DOUBLE, value=0.1)
    |           |   | |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |           |   | |       +-type_annotation_map={Collation:"und:ci"}
    |           |   | |       +-Literal(type=STRING, value='hi')
    |           |   | |       +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |           |   | +-$col2#13 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=t.n#11)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=t.[col_struct#10, n#11]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=t.[col_struct#10, n#11])
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=t.n#11)
    |           |           +-Literal(type=INT64, value=2)
    |           +-output_column_list=$union_all3.[$col1#12, $col2#13]
    +-query=
    | +-ProjectScan
    |   +-column_list=t.[col_struct#14, n#15]
    |   +-input_scan=
    |     +-WithRefScan(column_list=t.[col_struct#14, n#15], with_query_name='t')
    +-recursive=TRUE
==

[no_run_unparser]
[language_features=V_1_3_ANNOTATION_FRAMEWORK,V_1_3_COLLATION_SUPPORT,V_1_3_WITH_RECURSIVE,V_1_4_COLLATION_IN_WITH_RECURSIVE,V_1_4_PRESERVE_ANNOTATION_IN_IMPLICIT_CAST_IN_SCAN]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# Coercing struct in scan through internal CAST - with recursive.
# Column in recursive term is casted and has collation.
WITH RECURSIVE t AS (
  SELECT (0.1, 'abc') AS col_struct, 1 AS n UNION ALL
  SELECT (0.1, COLLATE('def', 'und:ci')), 1 UNION ALL
  SELECT (1, COLLATE('hi', 'und:ci')), n + 1 FROM t WHERE n < 2
) SELECT * FROM t
--
QueryStmt
+-output_column_list=
| +-t.col_struct#14<_,{Collation:"und:ci"}> AS col_struct [STRUCT<DOUBLE, STRING>]
| +-t.n#15 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=t.[col_struct#14, n#15]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name='t'
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=$union_all.[col_struct#5, n#6]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-SetOperationScan
    |       |   |   +-column_list=$union_all.[col_struct#7, n#8]
    |       |   |   +-op_type=UNION_ALL
    |       |   |   +-input_item_list=
    |       |   |     +-SetOperationItem
    |       |   |     | +-scan=
    |       |   |     | | +-ProjectScan
    |       |   |     | |   +-column_list=$union_all1.[col_struct#1, n#2]
    |       |   |     | |   +-expr_list=
    |       |   |     | |   | +-col_struct#1 := Literal(type=STRUCT<DOUBLE, STRING>, value={0.1, 'abc'})
    |       |   |     | |   | +-n#2 := Literal(type=INT64, value=1)
    |       |   |     | |   +-input_scan=
    |       |   |     | |     +-SingleRowScan
    |       |   |     | +-output_column_list=$union_all1.[col_struct#1, n#2]
    |       |   |     +-SetOperationItem
    |       |   |       +-scan=
    |       |   |       | +-ProjectScan
    |       |   |       |   +-column_list=$union_all2.[$col1#3, $col2#4]
    |       |   |       |   +-expr_list=
    |       |   |       |   | +-$col1#3 :=
    |       |   |       |   | | +-MakeStruct
    |       |   |       |   | |   +-type=STRUCT<DOUBLE, STRING>
    |       |   |       |   | |   +-type_annotation_map=<_,{Collation:"und:ci"}>
    |       |   |       |   | |   +-field_list=
    |       |   |       |   | |     +-Literal(type=DOUBLE, value=0.1)
    |       |   |       |   | |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |   |       |   | |       +-type_annotation_map={Collation:"und:ci"}
    |       |   |       |   | |       +-Literal(type=STRING, value='def')
    |       |   |       |   | |       +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |       |   |       |   | +-$col2#4 := Literal(type=INT64, value=1)
    |       |   |       |   +-input_scan=
    |       |   |       |     +-SingleRowScan
    |       |   |       +-output_column_list=$union_all2.[$col1#3, $col2#4]
    |       |   +-output_column_list=$union_all.[col_struct#7, n#8]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all1_cast.$col1#13<_,{Collation:"und:ci"}>, $union_all3.$col2#12]
    |           |   +-expr_list=
    |           |   | +-$col1#13 :=
    |           |   |   +-Cast(STRUCT<INT64, STRING> -> STRUCT<DOUBLE, STRING>)
    |           |   |     +-type_annotation_map=<_,{Collation:"und:ci"}>
    |           |   |     +-ColumnRef(type=STRUCT<INT64, STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=$union_all3.$col1#11<_,{Collation:"und:ci"}>)
    |           |   |     +-type_modifiers=collation:[_,und:ci]
    |           |   +-input_scan=
    |           |     +-ProjectScan
    |           |       +-column_list=$union_all3.[$col1#11, $col2#12]
    |           |       +-expr_list=
    |           |       | +-$col1#11 :=
    |           |       | | +-MakeStruct
    |           |       | |   +-type=STRUCT<INT64, STRING>
    |           |       | |   +-type_annotation_map=<_,{Collation:"und:ci"}>
    |           |       | |   +-field_list=
    |           |       | |     +-Literal(type=INT64, value=1)
    |           |       | |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |           |       | |       +-type_annotation_map={Collation:"und:ci"}
    |           |       | |       +-Literal(type=STRING, value='hi')
    |           |       | |       +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
    |           |       | +-$col2#12 :=
    |           |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |       |     +-ColumnRef(type=INT64, column=t.n#10)
    |           |       |     +-Literal(type=INT64, value=1)
    |           |       +-input_scan=
    |           |         +-FilterScan
    |           |           +-column_list=t.[col_struct#9, n#10]
    |           |           +-input_scan=
    |           |           | +-RecursiveRefScan(column_list=t.[col_struct#9, n#10])
    |           |           +-filter_expr=
    |           |             +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |               +-ColumnRef(type=INT64, column=t.n#10)
    |           |               +-Literal(type=INT64, value=2)
    |           +-output_column_list=[$union_all1_cast.$col1#13<_,{Collation:"und:ci"}>, $union_all3.$col2#12]
    +-query=
    | +-ProjectScan
    |   +-column_list=t.[col_struct#14, n#15]
    |   +-input_scan=
    |     +-WithRefScan(column_list=t.[col_struct#14, n#15], with_query_name='t')
    +-recursive=TRUE
==

[no_run_unparser]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# Coercing struct in scan through internal CAST - CTAS.
# For CTAS, user specified column_definition_list should override the collation
# from the query.
CREATE TABLE t(
  col_struct STRUCT<DOUBLE, STRING COLLATE 'binary', ARRAY<STRING COLLATE 'binary'>>
) AS
SELECT (1, COLLATE('abc', 'und:ci'), [COLLATE('def', 'und:ci')])
--
CreateTableAsSelectStmt
+-name_path=t
+-column_definition_list=
| +-ColumnDefinition
|   +-name='col_struct'
|   +-type=STRUCT<DOUBLE, STRING, ARRAY<STRING>>
|   +-annotations=
|   | +-ColumnAnnotations
|   |   +-child_list=
|   |     +-ColumnAnnotations
|   |     +-ColumnAnnotations
|   |     | +-collation_name=
|   |     |   +-Literal(type=STRING, value='binary')
|   |     +-ColumnAnnotations
|   |       +-child_list=
|   |         +-ColumnAnnotations
|   |           +-collation_name=
|   |             +-Literal(type=STRING, value='binary')
|   +-column=t.col_struct#1
+-output_column_list=
| +-$create_as_cast.$col1#3<_,{Collation:"und:ci"},[{Collation:"und:ci"}]> AS col_struct [STRUCT<DOUBLE, STRING, ARRAY<STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$create_as_cast.$col1#3<_,{Collation:"und:ci"},[{Collation:"und:ci"}]>]
    +-expr_list=
    | +-$col1#3 :=
    |   +-Cast(STRUCT<INT64, STRING, ARRAY<STRING>> -> STRUCT<DOUBLE, STRING, ARRAY<STRING>>)
    |     +-type_annotation_map=<_,{Collation:"und:ci"},[{Collation:"und:ci"}]>
    |     +-ColumnRef(type=STRUCT<INT64, STRING, ARRAY<STRING>>, type_annotation_map=<_,{Collation:"und:ci"},[{Collation:"und:ci"}]>, column=$create_as.$col1#2<_,{Collation:"und:ci"},[{Collation:"und:ci"}]>)
    |     +-type_modifiers=collation:[_,und:ci,[und:ci]]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$create_as.$col1#2<_,{Collation:"und:ci"},[{Collation:"und:ci"}]>]
        +-expr_list=
        | +-$col1#2 :=
        |   +-MakeStruct
        |     +-type=STRUCT<INT64, STRING, ARRAY<STRING>>
        |     +-type_annotation_map=<_,{Collation:"und:ci"},[{Collation:"und:ci"}]>
        |     +-field_list=
        |       +-Literal(type=INT64, value=1)
        |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |       | +-type_annotation_map={Collation:"und:ci"}
        |       | +-Literal(type=STRING, value='abc')
        |       | +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
        |       +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
        |         +-type_annotation_map=[{Collation:"und:ci"}]
        |         +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |           +-type_annotation_map={Collation:"und:ci"}
        |           +-Literal(type=STRING, value='def')
        |           +-Literal(type=STRING, value='und:ci', preserve_in_literal_remover=TRUE)
        +-input_scan=
          +-SingleRowScan
==

[no_run_unparser]
# TODO: enable the unparser once STRUCT<STRING COLLATE '...'> syntax
# is supported.
# Coercing struct in scan through internal CAST - INSERT query.
# The struct in the query output will be casted and has collation different
# from the target table column.
INSERT ComplexCollatedTable (struct_of_double_and_string_ci_and_array_ci)
SELECT (2, COLLATE('def', 'binary'), [COLLATE('def', 'binary')])
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=[ComplexCollatedTable.struct_of_double_and_string_ci_and_array_ci#6<_,{Collation:"und:ci"},[{Collation:"und:ci"}]>], table=ComplexCollatedTable, column_index_list=[5])
+-insert_column_list=[ComplexCollatedTable.struct_of_double_and_string_ci_and_array_ci#6<_,{Collation:"und:ci"},[{Collation:"und:ci"}]>]
+-query=
| +-ProjectScan
|   +-column_list=[$insert_cast.$col1#8<_,{Collation:"binary"},[{Collation:"binary"}]>]
|   +-expr_list=
|   | +-$col1#8 :=
|   |   +-Cast(STRUCT<INT64, STRING, ARRAY<STRING>> -> STRUCT<a DOUBLE, b STRING, c ARRAY<STRING>>)
|   |     +-type_annotation_map=<_,{Collation:"binary"},[{Collation:"binary"}]>
|   |     +-ColumnRef(type=STRUCT<INT64, STRING, ARRAY<STRING>>, type_annotation_map=<_,{Collation:"binary"},[{Collation:"binary"}]>, column=$insert.$col1#7<_,{Collation:"binary"},[{Collation:"binary"}]>)
|   |     +-type_modifiers=collation:[_,binary,[binary]]
|   +-input_scan=
|     +-ProjectScan
|       +-column_list=[$insert.$col1#7<_,{Collation:"binary"},[{Collation:"binary"}]>]
|       +-expr_list=
|       | +-$col1#7 :=
|       |   +-MakeStruct
|       |     +-type=STRUCT<INT64, STRING, ARRAY<STRING>>
|       |     +-type_annotation_map=<_,{Collation:"binary"},[{Collation:"binary"}]>
|       |     +-field_list=
|       |       +-Literal(type=INT64, value=2)
|       |       +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|       |       | +-type_annotation_map={Collation:"binary"}
|       |       | +-Literal(type=STRING, value='def')
|       |       | +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
|       |       +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRING) -> ARRAY<STRING>)
|       |         +-type_annotation_map=[{Collation:"binary"}]
|       |         +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
|       |           +-type_annotation_map={Collation:"binary"}
|       |           +-Literal(type=STRING, value='def')
|       |           +-Literal(type=STRING, value='binary', preserve_in_literal_remover=TRUE)
|       +-input_scan=
|         +-SingleRowScan
+-query_output_column_list=[$insert_cast.$col1#8<_,{Collation:"binary"},[{Collation:"binary"}]>]
+-column_access_list=WRITE
==

[enabled_ast_rewrites=DEFAULTS,+GROUPING_SET]
SELECT COUNT(*), string_ci, string_binary, GROUPING(string_ci)
FROM CollatedTable
GROUP BY GROUPING SETS(UPPER(string_ci), (string_ci, string_binary), ROLLUP(string_ci), CUBE(LOWER(string_binary), string_ci))
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS "$col1" [INT64]
| +-$groupby.string_ci#8{Collation:"und:ci"} AS string_ci [STRING]
| +-$groupby.string_binary#9{Collation:"binary"} AS string_binary [STRING]
| +-$grouping_call.$grouping_call1#11 AS "$col4" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5, $groupby.string_ci#8{Collation:"und:ci"}, $groupby.string_binary#9{Collation:"binary"}, $grouping_call.$grouping_call1#11]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.string_ci#8{Collation:"und:ci"}, $groupby.string_binary#9{Collation:"binary"}, $aggregate.$agg1#5, $grouping_call.$grouping_call1#11]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-group_by_list=
        | +-$groupbycol1#7 :=
        | | +-FunctionCall(ZetaSQL:upper(STRING) -> STRING)
        | |   +-type_annotation_map={Collation:"und:ci"}
        | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        | +-string_ci#8 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        | +-string_binary#9 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        | +-$groupbycol4#10 :=
        |   +-FunctionCall(ZetaSQL:lower(STRING) -> STRING)
        |     +-type_annotation_map={Collation:"binary"}
        |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        +-collation_list=[und:ci,und:ci,binary,binary]
        +-aggregate_list=
        | +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-grouping_set_list=
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=STRING, column=$groupby.$groupbycol1#7{Collation:"und:ci"})
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=STRING, column=$groupby.string_ci#8{Collation:"und:ci"})
        | |   +-ColumnRef(type=STRING, column=$groupby.string_binary#9{Collation:"binary"})
        | +-Rollup
        | | +-rollup_column_list=
        | |   +-GroupingSetMultiColumn
        | |     +-column_list=
        | |       +-ColumnRef(type=STRING, column=$groupby.string_ci#8{Collation:"und:ci"})
        | +-Cube
        |   +-cube_column_list=
        |     +-GroupingSetMultiColumn
        |     | +-column_list=
        |     |   +-ColumnRef(type=STRING, column=$groupby.$groupbycol4#10{Collation:"binary"})
        |     +-GroupingSetMultiColumn
        |       +-column_list=
        |         +-ColumnRef(type=STRING, column=$groupby.string_ci#8{Collation:"und:ci"})
        +-grouping_call_list=
          +-GroupingCall
            +-group_by_column=
            | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$groupby.string_ci#8{Collation:"und:ci"})
            +-output_column=$grouping_call.$grouping_call1#11

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS "$col1" [INT64]
| +-$groupby.string_ci#8{Collation:"und:ci"} AS string_ci [STRING]
| +-$groupby.string_binary#9{Collation:"binary"} AS string_binary [STRING]
| +-$grouping_call.$grouping_call1#11 AS "$col4" [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5, $groupby.string_ci#8{Collation:"und:ci"}, $groupby.string_binary#9{Collation:"binary"}, $grouping_call.$grouping_call1#11]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.string_ci#8{Collation:"und:ci"}, $groupby.string_binary#9{Collation:"binary"}, $aggregate.$agg1#5, $grouping_call.$grouping_call1#11]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-group_by_list=
        | +-$groupbycol1#7 :=
        | | +-FunctionCall(ZetaSQL:upper(STRING) -> STRING)
        | |   +-type_annotation_map={Collation:"und:ci"}
        | |   +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        | +-string_ci#8 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        | +-string_binary#9 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        | +-$groupbycol4#10 :=
        |   +-FunctionCall(ZetaSQL:lower(STRING) -> STRING)
        |     +-type_annotation_map={Collation:"binary"}
        |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        +-collation_list=[und:ci,und:ci,binary,binary]
        +-aggregate_list=
        | +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-grouping_set_list=
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=STRING, column=$groupby.$groupbycol1#7{Collation:"und:ci"})
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=STRING, column=$groupby.string_ci#8{Collation:"und:ci"})
        | |   +-ColumnRef(type=STRING, column=$groupby.string_binary#9{Collation:"binary"})
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=STRING, column=$groupby.string_ci#8{Collation:"und:ci"})
        | +-GroupingSet
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=STRING, column=$groupby.$groupbycol4#10{Collation:"binary"})
        | |   +-ColumnRef(type=STRING, column=$groupby.string_ci#8{Collation:"und:ci"})
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=STRING, column=$groupby.string_ci#8{Collation:"und:ci"})
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=STRING, column=$groupby.$groupbycol4#10{Collation:"binary"})
        | +-GroupingSet
        +-grouping_call_list=
          +-GroupingCall
            +-group_by_column=
            | +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$groupby.string_ci#8{Collation:"und:ci"})
            +-output_column=$grouping_call.$grouping_call1#11
==

# Disable GROUPING_SETS, in which case rollup won't go through rewriters, this is the current code path.
[language_features=V_1_3_COLLATION_SUPPORT,GROUP_BY_ROLLUP,V_1_3_ANNOTATION_FRAMEWORK]
SELECT COUNT(*), string_ci, string_binary
FROM CollatedTable
GROUP BY ROLLUP(string_ci, string_binary, UPPER(string_ci))
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS "$col1" [INT64]
| +-$groupby.string_ci#6{Collation:"und:ci"} AS string_ci [STRING]
| +-$groupby.string_binary#7{Collation:"binary"} AS string_binary [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5, $groupby.string_ci#6{Collation:"und:ci"}, $groupby.string_binary#7{Collation:"binary"}]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.string_ci#6{Collation:"und:ci"}, $groupby.string_binary#7{Collation:"binary"}, $aggregate.$agg1#5]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2], table=CollatedTable, column_index_list=[0, 1])
        +-group_by_list=
        | +-string_ci#6 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        | +-string_binary#7 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        | +-$groupbycol3#8 :=
        |   +-FunctionCall(ZetaSQL:upper(STRING) -> STRING)
        |     +-type_annotation_map={Collation:"und:ci"}
        |     +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        +-collation_list=[und:ci,binary,und:ci]
        +-aggregate_list=
        | +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-grouping_set_list=
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=STRING, column=$groupby.string_ci#6{Collation:"und:ci"})
        | |   +-ColumnRef(type=STRING, column=$groupby.string_binary#7{Collation:"binary"})
        | |   +-ColumnRef(type=STRING, column=$groupby.$groupbycol3#8{Collation:"und:ci"})
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=STRING, column=$groupby.string_ci#6{Collation:"und:ci"})
        | |   +-ColumnRef(type=STRING, column=$groupby.string_binary#7{Collation:"binary"})
        | +-GroupingSet
        | | +-group_by_column_list=
        | |   +-ColumnRef(type=STRING, column=$groupby.string_ci#6{Collation:"und:ci"})
        | +-GroupingSet
        +-rollup_column_list=
          +-ColumnRef(type=STRING, column=$groupby.string_ci#6{Collation:"und:ci"})
          +-ColumnRef(type=STRING, column=$groupby.string_binary#7{Collation:"binary"})
          +-ColumnRef(type=STRING, column=$groupby.$groupbycol3#8{Collation:"und:ci"})
==

# grouping sets with collated struct and array type
[no_run_unparser]
[enabled_ast_rewrites=DEFAULTS,+GROUPING_SET]
SELECT COUNT(*), struct_with_string_ci, array_with_string_ci
FROM CollatedTable
GROUP BY GROUPING SETS(
  struct_with_string_ci,
  ROLLUP(struct_with_string_ci, string_ci),
  CUBE(array_with_string_ci, string_binary)
)
--

QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS "$col1" [INT64]
| +-$groupby.struct_with_string_ci#6<_,{Collation:"und:ci"}> AS struct_with_string_ci [STRUCT<a INT32, b STRING>]
| +-$groupby.array_with_string_ci#8[{Collation:"und:ci"}] AS array_with_string_ci [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5, $groupby.struct_with_string_ci#6<_,{Collation:"und:ci"}>, $groupby.array_with_string_ci#8[{Collation:"und:ci"}]]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.struct_with_string_ci#6<_,{Collation:"und:ci"}>, $groupby.array_with_string_ci#8[{Collation:"und:ci"}], $aggregate.$agg1#5]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 2, 3])
        +-group_by_list=
        | +-struct_with_string_ci#6 := ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
        | +-string_ci#7 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        | +-array_with_string_ci#8 := ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
        | +-string_binary#9 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        +-collation_list=[[_,und:ci],und:ci,[und:ci],binary]
        +-aggregate_list=
        | +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-grouping_set_list=
          +-GroupingSet
          | +-group_by_column_list=
          |   +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$groupby.struct_with_string_ci#6<_,{Collation:"und:ci"}>)
          +-Rollup
          | +-rollup_column_list=
          |   +-GroupingSetMultiColumn
          |   | +-column_list=
          |   |   +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$groupby.struct_with_string_ci#6<_,{Collation:"und:ci"}>)
          |   +-GroupingSetMultiColumn
          |     +-column_list=
          |       +-ColumnRef(type=STRING, column=$groupby.string_ci#7{Collation:"und:ci"})
          +-Cube
            +-cube_column_list=
              +-GroupingSetMultiColumn
              | +-column_list=
              |   +-ColumnRef(type=ARRAY<STRING>, column=$groupby.array_with_string_ci#8[{Collation:"und:ci"}])
              +-GroupingSetMultiColumn
                +-column_list=
                  +-ColumnRef(type=STRING, column=$groupby.string_binary#9{Collation:"binary"})


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#5 AS "$col1" [INT64]
| +-$groupby.struct_with_string_ci#6<_,{Collation:"und:ci"}> AS struct_with_string_ci [STRUCT<a INT32, b STRING>]
| +-$groupby.array_with_string_ci#8[{Collation:"und:ci"}] AS array_with_string_ci [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#5, $groupby.struct_with_string_ci#6<_,{Collation:"und:ci"}>, $groupby.array_with_string_ci#8[{Collation:"und:ci"}]]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$groupby.struct_with_string_ci#6<_,{Collation:"und:ci"}>, $groupby.array_with_string_ci#8[{Collation:"und:ci"}], $aggregate.$agg1#5]
        +-input_scan=
        | +-TableScan(column_list=CollatedTable.[string_ci#1, string_binary#2, struct_with_string_ci#3, array_with_string_ci#4], table=CollatedTable, column_index_list=[0, 1, 2, 3])
        +-group_by_list=
        | +-struct_with_string_ci#6 := ColumnRef(type=STRUCT<a INT32, b STRING>, type_annotation_map=<_,{Collation:"und:ci"}>, column=CollatedTable.struct_with_string_ci#3<_,{Collation:"und:ci"}>)
        | +-string_ci#7 := ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=CollatedTable.string_ci#1{Collation:"und:ci"})
        | +-array_with_string_ci#8 := ColumnRef(type=ARRAY<STRING>, type_annotation_map=[{Collation:"und:ci"}], column=CollatedTable.array_with_string_ci#4[{Collation:"und:ci"}])
        | +-string_binary#9 := ColumnRef(type=STRING, type_annotation_map={Collation:"binary"}, column=CollatedTable.string_binary#2{Collation:"binary"})
        +-collation_list=[[_,und:ci],und:ci,[und:ci],binary]
        +-aggregate_list=
        | +-$agg1#5 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-grouping_set_list=
          +-GroupingSet
          | +-group_by_column_list=
          |   +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$groupby.struct_with_string_ci#6<_,{Collation:"und:ci"}>)
          +-GroupingSet
          | +-group_by_column_list=
          |   +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$groupby.struct_with_string_ci#6<_,{Collation:"und:ci"}>)
          |   +-ColumnRef(type=STRING, column=$groupby.string_ci#7{Collation:"und:ci"})
          +-GroupingSet
          | +-group_by_column_list=
          |   +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$groupby.struct_with_string_ci#6<_,{Collation:"und:ci"}>)
          +-GroupingSet
          +-GroupingSet
          | +-group_by_column_list=
          |   +-ColumnRef(type=ARRAY<STRING>, column=$groupby.array_with_string_ci#8[{Collation:"und:ci"}])
          |   +-ColumnRef(type=STRING, column=$groupby.string_binary#9{Collation:"binary"})
          +-GroupingSet
          | +-group_by_column_list=
          |   +-ColumnRef(type=STRING, column=$groupby.string_binary#9{Collation:"binary"})
          +-GroupingSet
          | +-group_by_column_list=
          |   +-ColumnRef(type=ARRAY<STRING>, column=$groupby.array_with_string_ci#8[{Collation:"und:ci"}])
          +-GroupingSet
